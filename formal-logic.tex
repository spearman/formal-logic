%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{article}
\usepackage{amssymb}
\usepackage{amsmath}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

% --------------------------------------------------------------------

\title{Survey of Mathematical Logic}
\date{draft 2014}
\author{Shane Pearman}
\maketitle

% --------------------------------------------------------------------

\tableofcontents

% --------------------------------------------------------------------



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Formal Language}\label{sec:formal_language}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A \emph{Formal Language}, $L$, is a possibly infinite Subset of an
infinite \emph{Vocabulary}, $\Sigma^*$, that is the Set of all
possible finite \emph{Expressions} (strings) over a possibly infinite
\emph{Alphabet} of \emph{Symbols}, $\Sigma$. This Set $\Sigma^*$ is
the \emph{Kleene star} or \emph{Free Monoid} (\S\ref{subsec:monoid})
of $\Sigma$; the smallest superset of $\Sigma$ that is closed under
string concatenation.

The \emph{Syntax} is that part of the Language that refers only to the
literal strings of Symbols of the Language with no regard to their
meaning or interpretation; only the condition that they can be
identified and differentiated from one-another is required.

The entire content of a Language is uniquely determined by the Set of
all \emph{Terminal Expressions} generated by the \emph{Production} or
rewrite rules of a \emph{Formal Grammer}. This possibly infinite Set
of Terminals will be a Subset of the Vocabulary over the Alphabet.



% ====================================================================
\section{Metalanguage}\label{sec:metalanguage}
% ====================================================================

A \emph{Metalanguage} is a Language used to describe another Language,
the \emph{Object Language}. A \emph{Metavariable} is a variable
written in a Metalanguage that stands in for an element in the Object
Language. Metavariables may be referred to as \emph{Schematic
  Variables} in the context of \emph{Axiom Schemata} and \emph{Rule
  Schemata} (\S \ref{subsec:deductive_apparatus}).

The use of an Object Language to describe itself is an \emph{Embedded
  Metalanguage} (eg the English words \emph{noun} and \emph{verb} are
used to describe English itself).



% ====================================================================
\section{Abstract Reduction Systems}\label{sec:abstract_rewrite}
% ====================================================================

\emph{Holism}

\emph{Reductionism}

The following descriptions of Formal Grammars and \emph{Automata} may
be abstracted as \emph{Reduction} or \emph{rewrite} systems. This is
simply
    \[(A,\rightarrow)\]
where $A$ is a set of objects and $\rightarrow \subseteq A \times
A$. This is equivalent to an \emph{Unlabeled State Transition System}
(\S\ref{sec:state_transition_system}).

An \emph{Indexed Abstract Reduction System} differentiates Reductions
into classes so that $\rightarrow$ is the indexed union of these
relations
    \[(A, \rightarrow_1, \rightarrow_2, \cdots)\]
This is identical to a \emph{Labeled Transition System}.



% ====================================================================
\section{Syntactic Elements}
% ====================================================================

Within a Formal Language defined by a Formal Grammar over a given
Alphabet and Vocabulary, the Symbols will be divided into two disjoint
subsets according to whether they are \emph{Terminal} or
\emph{Non-terminal Symbols}.

The definition of a Non-terminal Symbol is one for which a Production
rule exists with that Symbol appearing in the input and replaced in
the output. Thus a Grammar is specified by a finite set of
Productions, $P$, a finite set of Non-terminal Symbols, $N$, and a
finite set of Terminal Symbols, $T$. Additionally, in certain Grammars
it is allowed for multiple Non-terminals to appear in an Expression.

\begin{description}

    \item[Symbol] \hfill \\
    an atomic unit of a Language

    \item[Alphabet ($\Sigma$)] \hfill \\
    a possibly infinite set of Symbols

    \item[Expression] \hfill \\
    a finite string of Symbols

    \item[Vocabulary ($\Sigma^{*}$)] \hfill \\
    set of all Expressions over an Alphabet of Symbols

    \item[Production] \hfill \\
    a rewrite rule specifying a Non-terminal Symbol substitution

    \item[Grammar] \hfill \\
    a finite set of Productions over the Expressions of a Vocabulary

\end{description}

% --------------------------------------------------------------------
\subsection{Special Symbols}
% --------------------------------------------------------------------

Two special Symbols are recognized:

    \begin{description}

    \item[Empty Symbol ($\varepsilon$)] \hfill \\
    the Symbol of zero length and a Terminal Symbol

    \item[Start Symbol ($S$)] \hfill \\
    a unique Non-terminal Symbol

    \end{description}

% --------------------------------------------------------------------
\subsection{Generative Grammar}
% --------------------------------------------------------------------

A Grammar \emph{generates} a Language by the repeated application of
its Production Rules beginning with the Start Symbol. A sequence of
rule applications is a \emph{Derivation}. Formal definition of a
Grammar as a 4-tuple:
\[
    G(N,T,P,S)
\]
The unrestricted form of a Production:
\[
    (N \cup T)^*N(N \cup T)^* \rightarrow (N \cup T)^*
\]
That is, a Production is a function from one Expression to
another, where the left Expression must contain at least one
Non-terminal Symbol. By convention, Non-terminal Symbols
will be denoted by capitals ($A,B,C,\cdots$), and Terminals by
lowercase ($a,b,c,\cdots$), and expressions by Greek letters
($\alpha,\beta,\gamma$). Let:

\[
    \mathcal{A} = \{ Alphabets \},\: \mathcal{V} = \{ Vocabularies \}
\] \[
    \mathcal{G} = \{ Grammars \},\: \mathcal{L} = \{ Languages \}
\]

    \begin{description}

    \item Definition of the Kleene star over an
      Alphabet where $\circ$ is the operation to \emph{Concatenate} two
      Expressions:
    \[
        \forall \: \Sigma \in \mathcal{A} \:
        \exists \: \Sigma^* \in \mathcal{V}
        : \Sigma^* = \bigcup_{i=0}^{|\Sigma|} \Sigma_i
        = (\Sigma,\circ)
    \]

    \item Definition of a Language in terms of a Vocabulary:
    \[
        \forall \: L \in \mathcal{L} \:
        \exists \: \Sigma^* \in \mathcal{V}
        : L \subseteq \Sigma^*
    \]

    \item Existence of the Empty Symbol, $\varepsilon$:
    \[
        \forall \: \Sigma^* \in \mathcal{V} \:
        \exists ! \: \varepsilon \in \Sigma^*
        : |\varepsilon|=0
    \]

    \end{description}



% ====================================================================
\section{Formal Grammars}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Chomsky Hierarchy}
% --------------------------------------------------------------------

Grammars are classified by how restrictive the Production Rules
are. By convention, they may be organized into a hierarchy of sets
under proper inclusion, where \emph{Type-0} is an unrestricted grammar,
covering all possible formal grammars.

\[
    Type-0 \supset Type-1 \supset Type-2 \supset Type-3
\]

These different levels in the hierarchy are \emph{Recognizable} by
different kinds of Automata (\S \ref{subsec:automata})

\subsubsection{Type-0: Unrestricted}

\paragraph{Semi-decidable}\label{subsec:semidecidable}
Production Rules of an \emph{Unrestricted} Grammar have the form
\[
    \alpha \rightarrow \beta
\]
where $\alpha$ and $\beta$ are Expressions of $N \cup T$ and $\alpha
\neq \varepsilon$.

A completely unrestricted Grammar is called \emph{recursively
  enumerable} or \emph{Semi-decidable}. This means membership of the
Language can be decided by an algorithm, but non-membership cannot,
and the class of Languages having this property is called
$\mathsf{RE}$. Members of this class are also \emph{Diophantine} sets
and the Lattice of $\mathsf{RE}$ sets under inclusion is written
$\mathcal{E}$. % FIXME add a reference when sections describing these terms
               % are added

The complement of $\mathsf{RE}$ is the class of Languages for which
an algorithm may decide non-membership only and is termed
$\mathsf{coRE}$. The class of Automata capable of implementing these
algorithms are \emph{Turing Machines}(\S\ref{subsec:turing_machine}).

\paragraph{Decidable}\label{subsec:decidability}
A \emph{Decidable} or \emph{recursive} Language (as opposed to
recursively enumerable) is defined as the intersection of
$\mathsf{RE}$ and $\mathsf{coRE}$:
\[
    \mathsf{R} = \mathsf{RE} \cap \mathsf{coRE}
\]
That is, it can be decided whether a Symbol is a member or not by a
\emph{total computable function} (one which returns \emph{True} or
\emph{False} depending on membership). Decidable Languages are
recognizable by a \emph{decider} or \emph{Total Turing
  Machine}\cite{kozen97} (however determining whether an arbitrary
Turing Machine gives an answer for every input is an undecidable
decision problem).

\subsubsection{Type-1: Context-sensitive}

\paragraph{Context-sensitive}\label{subsec:context_sensitive}
\emph{Context-sensitive Grammars} have the restriction that the result
of a Production is not shorter than the input. Formally stated
Productions are of the form
\[
    \alpha \Gamma \beta \rightarrow \alpha \gamma \beta
\]
where $|\Gamma| \leq |\gamma|$. In this formulation $\alpha$ and $\beta$ form
the \emph{Context} of $\Gamma$.

Requiring that $S$ does not appear on the right of any Production
and allowing the rule
\[
    S \rightarrow \varepsilon
\]
makes the Context-sensitive Languages a proper superset of the
\emph{Context-free Languages}.

Context-sensitive Languages are equivalent to \emph{Linear
Bounded Automata} (\S\ref{subsec:linear_bounded_automata}).

\paragraph{Indexed}
An \emph{Indexed Grammar} has an extra set of \emph{Index Symbols},
$F$, with Productions of three possible forms,
\[
    A[\sigma] \rightarrow \alpha[\sigma]
\]\[
    A[\sigma] \rightarrow B[f\sigma]
\]\[
    A[f\sigma] \rightarrow \alpha[\sigma]
\]
where $f \in F$ and $\sigma$ is a string of Index Symbols. The Index
Symbols are used to form a \emph{stack} by the Production Rules where
Index Symbols are either pushed or popped from the stack.

An Indexed Language can be recognized by a \emph{Nested Stack
  Automaton}\cite{aho69}.

\paragraph{Generalized Contex-free}
A \emph{Generalized Context-free Grammar} adds to the rewrite rules of
a Context-free Grammar a set of non-context-free \emph{composition
  functions} that combine tuples of symbols:
\[
    f(\langle x_1,\cdots,x_m\rangle,\cdots,\langle
    y_1,\cdots,y_n\rangle)=\gamma
\]
where $\gamma$ is a single tuple or another composition function that
reduces to a single tuple.

Rules are of the form:
\[
    A \rightarrow f(X,Y,\cdots)
\]
where $X$,$Y$,$\cdots$ are string tuples or Non-terminal Symbols.

There are several weakly equivalent Grammars to the composition
formulation:

\begin{description}
\item[Linear context-free rewriting system] \hfill \\
    Weakly equivalent to \emph{multi-component Tree-adjoining
      Grammars} where composition functions are both \emph{linear} and
    \emph{regular}. Can be recognized by \emph{Thread
      Automata}\cite{villemonte02}.

\item[Tree-adjoining] \hfill \\
    Elementary rewriting unit is a tree rather than a Symbol. Can be
    recognized by \emph{Embedded Pushdown
      Automata}\cite{vijayashanker88}.

\item[Linear indexed grammar] \hfill \\
    A modified Indexed Grammar where only one symbol receives the
    stack.

\item[Combinatory Categorical Grammar] \hfill \\
    A type of \emph{phrase Structure Grammar} using \emph{Combinatory
      Logic}(\S\ref{subsec:combinatory_logic}).

\item[Head grammar] \hfill \\
    A subset of the Linear context-free rewriting system and a Phrase
    Structure Grammar.

\end{description}

\subsubsection{Type-2: Context-free}\label{subsec:context_free_language}

\paragraph{Context-free}
\emph{Context-free Grammars} (\emph{CFG}s) have Production Rules of the form
\[
    V \rightarrow \alpha
\]
where $V$ is a single Non-terminal and $\alpha$ is a string of Terminals
and/or Non-terminals (or empty). Because $V$ is required to be a
single Non-terminal, the Production Rules can be applied regardless of
Context. Each Non-terminal in a Context-free Grammar, $G$, is said to
form a \emph{Sub-Language} of the language defined by $G$.

Multiple Context-free Grammars may generate the same Language, so
properties of CFGs may be termed \emph{extrinsic} while Language properties
are \emph{intrinsic}. The question of equality between CFGs is
undecidable.

A popular notation for Context-free Grammars (especially in Computer
Science) is \emph{Backus-Naur form} (\emph{BNF}).

In Linguistics, the term used for Context-free Grammar is \emph{Phrase
  Structure Grammar} which is also called \emph{constituency grammar}
due to the one-to-one-or-many correspondence between the Productions
(ultimately rooted in the \emph{subject-predicate} clause derived from
\emph{Term Logic}).

An alternative formulation to Phrase Structure Grammar is \emph{Dependency
  Grammar} in which the Verb is the root and there is a one-to-one
correspondence between Symbols and nodes in the syntax structure.

The Context-free Grammar is equivalent to \emph{Non-deterministic
Pushdown Automata}(\S\ref{subsec:pushdown_automata}).

\paragraph{Deterministic}\label{subsec:deterministic_cfg}
\emph{Deterministic Context-free Grammars} are derived from
\emph{Deterministic Pushdown Automata}(\S\ref{subsec:deterministic_pda})
and are always \emph{unambiguous}. They can be parsed in linear time
and a \emph{Parser} can be automatically generated from the Grammar by a
\emph{Parser Generator}(\S\ref{subsec:parser_generator}).

\paragraph{Visibly Pushdown}
\emph{Visibly Pushdown Grammars} are described by the 4-tuple
\[
    G = (V=V^0 \cup V^1,T,P,S)
\]
where $V^0$ and $V^1$ are disjoint sets of Non-terminals and there
are three kinds of Production Rules:
\[
    X \rightarrow \varepsilon
\]\[
    X \rightarrow aY
\]\[
    X \rightarrow \langle aZb \rangle Y
\]
where $Z \in V^0$ and if $X \in V^0$ then $Y \in V^0$

The resulting Language is a \emph{Regular Language} with \emph{nested
  words}, described by a \emph{Monadic Second-order Logic}. % FIXME ref

\subsubsection{Type-3: Regular} \label{subsec:regular_language}

\emph{Regular Languages} are more restricted than Context-free
Languages and satisfy a number of closure properties. For two Regular
Languages, $K$ and $L$, the following operations result in a Language
that is also Regular:
\[
    K \cup L, \quad
    K \cap L, \quad
    \overline{L}, \quad
    K - L, \quad
    K \circ L, \quad
    L^*, \quad
    K / L, \quad
    L^R
\]
A common formulation of Regular Languages is the \emph{Regular
  Expression} and conversely it is sometimes said that a Regular
Language is one that can be defined by a Regular Expression.

An algebraic description is as follows:
\[
    L = \{ w \in \Sigma^* | f(w) \in N \}
\]
where $f : \Sigma^* \rightarrow M$ is a \emph{Monoid homomorphism} of
\emph{Finite Monoid}, $M$, and $N \subseteq M$.
% FIXME ref monoids

\paragraph{Extended Regular}
\emph{Extended Regular Grammars} have Productions of either \emph{right
Regular} or \emph{left Regular} form.

Right:
\[
    B \rightarrow a
\]\[
    A \rightarrow B \nu
\]\[
    A \rightarrow \varepsilon
\]

Left:
\[
    A \rightarrow a
\]\[
    A \rightarrow B \nu
\]\[
    A \rightarrow \varepsilon
\]
where $a$ is a single Non-terminal and $\nu$ is an expression of only
Non-terminal characters.

\paragraph{Strictly Regular}
\emph{Strictly Regular Grammars} also have Productions of either right
Regular or left Regular form.

Right:
\[
    B \rightarrow a
\]\[
    B \rightarrow aC
\]\[
    B \rightarrow \varepsilon
\]

Left:
\[
    A \rightarrow a
\]\[
    A \rightarrow Ba
\]\[
    A \rightarrow \varepsilon
\]
where $a$ is a single Non-terminal.

There is a one-to-one correspondence between the rules of a
\emph{Strictly Left Regular Grammar} and those of a
\emph{Non-deterministic Finite Automaton}(\S\ref{subsec:ndfa}).

The \emph{pumping lemma} states that the middle section of an
Expression within a Regular Language may be repeated an arbitrary
number of times to produce another Expression in that same Language.

\paragraph{k-Testable}\label{subsec:k_testable}
A \emph{k-Testable Language} is one where membership of an Expression
depends on the first and last symbol and a set of factors of length
$k$. An example is a \emph{Local Language} which is a \emph{2-Testable
  Language} described by the \emph{regular expression}:
\[
    (Q\Sigma^* \cap \Sigma^*R)\setminus\Sigma^*F\Sigma^*
\]
where $Q,R \subseteq \Sigma$ and $F \subseteq \Sigma \times
\Sigma$. This requires for a \emph{Word} (Expression), $w$, that is a
member of a Local Language to have its first Symbol in $Q$, and its
second Symbol in $R$, and no factor of $w$ of length 2 is in $F$. A
Local Language is recognized by a \emph{Local
  Automaton}(\S\ref{subsec:dfa}).

\paragraph{Star-free}
A \emph{Star-free Language} is one having a \emph{Generalized Star
  Height} equal to zero, that is, the minimal \emph{Star Height} of
all Expressions in the Language with the Star Height of an
Expression's \emph{Complement} being equal.

Star-free Languages are characterized as those with \emph{Aperiodic
  Syntactic Monoids}\cite{schutzenberger65} and also as the
\emph{Counter-free Langauges}\cite{mcnaughton-papert71} by the
\emph{Aperiodic Finite-state Automaton}, and \emph{Linear Temporal
  Logic}. % FIXME ref

% --------------------------------------------------------------------
\subsection{Affix Grammars}
% --------------------------------------------------------------------

\emph{Affix Grammars} are those of a Context-free Grammar with a
subset of the Non-terminals used as \emph{affix arguments}. If the
same affix appears multiple places in a Production, the value must be
the same.

% --------------------------------------------------------------------
\subsection{Two-Level Grammars}
% --------------------------------------------------------------------

\emph{Two-Level Grammars} are \emph{Grammar generators} that may
generate Grammars with infinite rules. Allowing the values for affixes
to be described by a Context-free Grammar results in a Two-Level
Grammar.


\begin{description}
\item[W-grammar] \emph{Van Wijngaarden Grammar} consists of a finite
  set of \emph{meta-rules} used to derive a possibly infinite set of
  Production Rules from a finite set of \emph{hyper-rules}.
\item[Extended Affix Grammar] is a restricted W-grammar.
\end{description}

% --------------------------------------------------------------------
\subsection{Attribute Grammars}
% --------------------------------------------------------------------

\emph{Attribute Grammars} allows affixes from arbitrary domains and
allows functions calculate values of affixes.

% --------------------------------------------------------------------
\subsection{Analytic Grammars}
% --------------------------------------------------------------------

\emph{Analytic Grammars} are used in \emph{Parsing} (\S
\ref{sec:parsers}). A few examples:

\begin{description}
\item[Top-Down Parsing Language] \hfill \\
Formal representation of \emph{Recursive Descent Parser}. Production
rules of the form
\[
    A \leftarrow \varepsilon
\]\[
    A \leftarrow f
\]\[
    A \leftarrow a
\]\[
    A \leftarrow BC/D
\]
\item[Parsing Expression Generator] \hfill \\
A more generalized Top-Down Parsing Language.
\item[Link Grammar] \hfill \\
Dependency Grammar with directionality between Symbols.
\end{description}

% --------------------------------------------------------------------
\subsection{Adaptive Grammars}
% --------------------------------------------------------------------

\emph{Adaptive Grammars} allow for Production Rules to be manipulated
within the Grammar, including addition, deletion, and modification of
Rules.

\subsubsection{Imperative Adaptive Grammar}

Global

Rule changes are based on global state changing over time.

\begin{itemize}
\item Extensible Context-Free Grammars
\item Top-down Modifiable Grammars
\item Bottom-up Modifiable Grammars
\end{itemize}

\subsubsection{Declarative Adaptive Grammar}

Local

Rule changes only affect the position in the syntax tree of the
generation of a string.

\begin{itemize}
\item Christiansen Grammars
\item Recursive Adaptive Grammars
\end{itemize}

\subsubsection{Time-space (Hybrid) Adaptive Grammar}

\begin{itemize}
\item \S-Calculus
\end{itemize}

\subsubsection{Dynamic Grammars}

Boullier\cite{boullier94}


% ====================================================================
\section{Parsers} \label{sec:parsers}
% ====================================================================

A \emph{Parser} analyzes an Expression according to the rules of a Formal
Grammar, generating a \emph{Data Structure} describing the Syntax of
the input. An outline of the process follows.

% --------------------------------------------------------------------
\subsection{Lexical Analysis}
% --------------------------------------------------------------------

A Parser may be preceded by a \emph{Lexical Analyzer} which creates
\emph{Tokens} (Symbols) from an input Expression. Strings of Tokens
are referred to as Phrases. A Lexical Analyzer is a Parser itself and
usually the \emph{Lexical Grammar} is a Regular Language (other
methods are \emph{flags}, \emph{delimiters}, or \emph{dictionaries})
and the Tokens are parsed as a Context-free or \emph{Attribute Phrase
  Syntax}.

Prior to \emph{Scanning}, a \emph{Lexer} may perform its own
Tokenization.  The Scanning stage first recognizes the Token
strings as \emph{Lexemes}, usually achieved by a Finite State
Machine.

Lexemes are resolved into Tokens by an \emph{Evaluator} which assigns
values where needed-- this results in Tokens that are either a
\emph{Type-Value} pair, or just a \emph{Type}.

% --------------------------------------------------------------------
\subsection{Syntactic Analysis}
% --------------------------------------------------------------------

The Parser determines if and how the input can be derived from the
Start Symbol of the Grammar. Parsing can proceed in two directions:

\begin{description}
    \item[Top-down Parsing]
    starts with the highest level of the \emph{Parse Tree}. Proceeds greedily
    and may be \emph{Exponential} with \emph{Backtracking}.
    \item[Bottom-up Parsing]
    starts with the lowest level of the Parse Tree.
\end{description}

Further \emph{Semantic} Parsing may be performed after these steps. An
example of this would be the in the \emph{Compiler} of a
\emph{Programming Language}.

% --------------------------------------------------------------------
\subsection{Top-down Parsers}
% --------------------------------------------------------------------

\subsubsection{Recursive Descent Parser}

\subsubsection{LL Parser}

\subsubsection{Early Parser}

% --------------------------------------------------------------------
\subsection{Bottom-up Parsers}
% --------------------------------------------------------------------

\subsubsection{Precedence Parser}

\subsubsection{LR Parser}

\emph{Canonical LR} LR(1)

\paragraph{SLR Parser}

\paragraph{LALR Parser}

\paragraph{GLR Parser}

\subsubsection{CYK Parser}

\subsubsection{Recursive Ascent Parser}

% --------------------------------------------------------------------
\subsection{Parser Generators}\label{subsec:parser_generator}
% --------------------------------------------------------------------

A \emph{Parser Generator} takes as a Grammar (for example a BNF
Grammar) and outputs the source code of a Parser for the Language
specified by the Grammar.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Automata Theory}\label{sec:automata_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ====================================================================
\section{State Transition Systems} \label{sec:state_transition_system}
% ====================================================================

A \emph{State Transition System} can have an infinite number of
\emph{States} and \emph{Transitions}, represented as the pair
\[
    (S,\rightarrow)
\]
where $S$ is a set of States and $\rightarrow \subseteq S \times
S$. This is identical to an \emph{un-indexed Abstract Rewriting
  System}(\S \ref{sec:abstract_rewrite}).

\emph{Finite Automata} may be seen as State Transition Systems with an
initial State and a number of final \emph{Accept} states indicating
\emph{Word} (Expression) membership for a Language.

\emph{Labeled State Transition Systems} have an additional set of
\emph{Labels}, $\Lambda$
\[(S,\Lambda,\rightarrow)\]
and $\rightarrow \subseteq S \times \Lambda \times S$.

\emph{Action Programming Languages} add a set of \emph{Fluents}, $F$, and
\emph{Values}, $V$, and a function mapping $F \times S$ to $V$.

% ====================================================================
\section{Semiautomata}
% ====================================================================

A State Transition System may be formulated as a \emph{Semiautomata}
\[
    (Q,\Sigma,T)
\]
where $\Sigma$ is a non-empty \emph{input Symbols}, $Q$ is the set of
States, and $T$ is a \emph{transition function} $T:Q \times \Sigma
\rightarrow Q$.

A Semiautomaton induces a Monoid called the \emph{input Monoid}:
\[
    M(Q,\Sigma,T) = \{T_w | w \in \Sigma^*\}
\]



% ====================================================================
\section{Automata} \label{subsec:automata}
% ====================================================================

An \emph{Automaton} reads input strings, \emph{Words} (Expressions),
and either accepts or rejects depending on whether a Word is a member
of the Language recognized by that Automaton. By convention the
Vocabulary of Expressions will be re-cast as an Alphabet of Words,
$\Sigma$.

Automata may be arranged in a hierarchy according to increasing power:
\[
    DFA = NFA \subset DPDA-I \subset NPDA-I \subset LBA \subset DPDA-II =
\]\[
    = NPDA-II = DTM = NTM = PTM = MDTM
\]
where
\begin{itemize}
\item DFA = Deterministic Finite Automata
\item NFA = Non-deterministic Finite Automata
\item DPDA = Deterministic Push Down Automata with 1
  or 2 push-down stores
\item NPDA = Non-deterministic Push Down Automata
  with 1 or 2 push-down stores
\item LBA = Linear Bounded Automata
\item DTM = Deterministic Turing Machine
\item NTM = Non-deterministic Turing Machine
\item PTM = Probabilistic Turing Machine
\item MDTM = Multidimensional Turing Machine
\end{itemize}

% --------------------------------------------------------------------
\subsection{Finite Automata}
% --------------------------------------------------------------------

\emph{Finite Automata} are \emph{Finite State Machines} and take a
finite input string of Symbols and either accepts or rejects the
input depending on the final State of the computation. Finite
Automata are able to recognize Regular Languages(\S\ref{subsec:regular_language}).

\subsubsection{Deterministic Finite Automata}\label{subsec:dfa}
\emph{Deterministic Finite Automata} have the restriction that an
input Symbol has a transition function to a single State.
Deterministic Finite Automata recognize Regular
Languages(\S\ref{subsec:regular_language}).

Representation of a Deterministic Finite Automaton as a 5-tuple:
\[
    (Q,\Sigma,\delta,q_0,F)
\]
where
\begin{itemize}
\item $Q$ is a finite set of States
\item $\Sigma$ is the Alphabet
\item $\delta$ is the transition function $\delta: Q \times
  \Sigma \rightarrow Q$
\item $q_0 \in Q$ is the initial State
\item $F \subseteq Q$ is the set of final Accept States.
\end{itemize}

Running for a given input $w = a_1,a_2, \cdots , a_n \in \Sigma^*$
produces a sequence of States $q_0,q_1,q_2,\cdots , q_n$ where $q_i
\in Q$ such that $q_i = \delta (q_{i-1},a_i)$ and $w$ is accepted if
$q_n \in F$.

A recursive definition using \emph{composition} of transition
functions
\[
    \widehat{\delta}(q,\varepsilon) = q
\]\[
    \widehat{\delta}(q,wa) = \delta_a(\widehat{\delta}(q,w))
\]
where $w \in \Sigma^*$, $a \in \Sigma$ and $q \in Q$. Repeated
application describes the \emph{Transition Monoid} or
\emph{Transformation Semigroup}.

A kind of Deterministic Finite Automata that recognizes Local
Languages(\S\ref{subsec:k_testable}) is called a \emph{Local Automaton}.

\subsubsection{Nondeterministic Finite Automata}\label{subsec:ndfa}
\emph{Nondeterministic Finite Automata} are Finite State Machines that
may transition from one State to a number of different states, given
as an element of the powerset of $Q$, $\mathcal{P}(Q)$.

Representation of a Nondeterministic Finite Automaton as a
5-tuple:
\[
    (Q,\Sigma,\Delta,q_0,F)
\]
where
\begin{itemize}
\item $Q$ is a finite set of States
\item $\Sigma$ is the Alphabet
\item $\Delta$ is a \emph{transition relation} $\Delta: Q \times
  \Sigma \rightarrow \mathcal{P}(Q)$
\item $q_0 \in Q$ is the initial State
\item $F \subseteq Q$ is the set of final Accept States.
\end{itemize}

A Word, $w=a_1,a_2,\cdots,a_n$, is accepted when there exists a
sequence of States, $r_0,r_1,\cdots,r_n$ such that
\begin{enumerate}
\item $r_0 = q_0$
\item $r_{i+1} \in \Delta(r_i, a_{i+1})$, for $i = 0, \cdots, n-1$
\item $r_n \in F$
\end{enumerate}

A DFA may be seen as a NFA which restricts transitions to allow only
one State, and can be constructed from a NFA with $n$ States using
\emph{powerset construction}, requiring up to $2^n$ States. Both types
recognize the same Regular Languages(\S\ref{subsec:regular_language}).

\paragraph{NFA-$\varepsilon$} is a NFA that allows transitions
without consuming input Symbols. A transition that changes state
without consuming input is an $\varepsilon$ $move$. Each State $q$
defines an $\varepsilon$-\emph{closure}, $E(q)$, which is the set of
States that are reachable by $\varepsilon$ moves.

The Languages recognized by NFA-$\varepsilon$ are the same as NFA/DFA.

% --------------------------------------------------------------------
\subsection{Pushdown Automata}\label{subsec:pushdown_automata}
% --------------------------------------------------------------------

\emph{Pushdown Automata} add to Finite Automata a \emph{Stack} as a
parameter for choice of States and can recognize Context-free
Languages(\S\ref{subsec:context_free_language}).

Adding a second Stack makes a Pushdown Automata equal in power to a
Turing Machine.

Unlike Finite Automata, Deterministic PDA are not equivalent to
Nondeterministic PDA. The general representation for a PDA is
\[
    M = (Q, \Sigma, \Gamma, q_0, Z_0, F, \delta)
\]
where
\begin{itemize}
\item $Q$ is a finite set of States
\item $\Sigma$ is a finite set of input Symbols
\item $\Gamma$ is a finite set of Stack Symbols
\item $q_0 \in Q$ is the initial State
\item $Z_0 \in \Gamma$ is the initial Stack Symbol
\item $F \subseteq Q$ is the set of final Accept States
\item $\delta$ is the transition function $\delta: (Q \times (\Sigma
  \cup \{\varepsilon\}) \times \Gamma) \rightarrow \mathcal{P}(Q \times
  \Gamma^*)$
\end{itemize}

An element $(p,a,Z,q,\alpha)\in\delta$, with $M$ in State $p \in Q$,
input $a \in \Sigma \cup \{\varepsilon\}$, and top stack Symbol $Z \in
\Gamma$ results in the following:
\begin{enumerate}
\item read $a$
\item change state to $q$
\item pop $Z$
\item push $\alpha \in \Gamma^*$
\end{enumerate}

\subsubsection{Deterministic Pushdown Automata}\label{subsec:deterministic_pda}
\emph{Deterministic Pushdown Automata} have the restriction of only
one derivation per accepted input Word. This allows recognition of a
subset of Context-free Languages termed
Deterministic(\S\ref{subsec:deterministic_cfg}). Such Languages can be
parsed in linear time and Parsers for such Languages can be generated
automatically(\S\ref{subsec:parser_generator}).

A Pushdown Automata is Deterministic iff both
\begin{enumerate}
\item $\forall q \in Q, a \in \Sigma \cup {\varepsilon}, x \in
  \Gamma \vdash |\delta(q,a,x)| \leq 1$
\item $\forall q \in Q, x \in \Gamma \vdash |\delta(q,\varepsilon,x)|
  \neq 0 \Rightarrow \forall a \in \Sigma \vdash |\delta(q,a,x)|=0$
\end{enumerate}

% --------------------------------------------------------------------
\subsection{Linear Bounded Automata} \label{subsec:linear_bounded_automata}
% --------------------------------------------------------------------

\emph{Linear Bounded Automata} are Turing Machines restricted to an
input of finite length and are acceptors for Context-sensitive
Languages(\S\ref{subsec:context_sensitive}) which require that
Production Rules do not increase the size of the Expression as a
result; therefore the size of the input is sufficient for calculation.

% --------------------------------------------------------------------
\subsection{Turing Machines}\label{subsec:turing_machine}
% --------------------------------------------------------------------

A Turing Machine operates on an infinite \emph{storage tape}, which
acts as the read input as well as write storage. Pushdown Automata
with 2 Stacks are equivalent to Turing Machines.

\subsubsection{Nondeterministic Turing Machines}
\emph{Nondeterministic Turing Machines} (\emph{NTM}s) can be defined
as
    \[
        M = (Q, \Sigma, q_0, \sqcup, A, \delta)
    \]
where
\begin{itemize}
\item $Q$ is a finite set of States
\item $\Sigma$ is the finite Alphabet
\item $q_0 \in Q$ is the initial State
\item $\sqcup \in \Sigma$ is the blank Symbol
\item $F \subseteq Q$ is the set of final Accept States
\item $\delta \subseteq (Q \setminus F \times \Sigma) \times (Q \times
  \Sigma \times \{L,R\})$ and $L$ and $R$ are left and right shift.
\end{itemize}

The operation of $M$ in State $q_i$ and current read input $a_j$ is a
transition function, $q_i a_j \rightarrow q_{i1} a_{j1} d_k$. Note
that for an NTM, $\delta$ is a relation and more than one function can
exist for each possible input/State combination. The result is to
write the new Symbol $a_{j1}$ in the current position and shift the
storage left or right as specified by $d_k$, afterwards assuming State
$q_{i1}$.

\subsubsection{Deterministic Turing Machines}
\emph{Deterministic Turing Machines} (\emph{DTM}s) have one possible
output transition per unique input/State combination, thus $\delta$ is
a \emph{partial function} rather than a \emph{relation}:
\[
    \delta : Q \setminus F \times \Sigma \rightarrow Q \times
    \Sigma \times {L,R}
\]
The computational power of DTMs and NTMs is equivalent (they can solve
the same problems) as NTMs include DTMs as a special case. An
equivalent accepting computation in a DTM is generally exponential to
the length of the shortest accepting computation of an NTM.

\subsubsection{Probabilistic Turing Machines}
A \emph{Probabilistic Turing Machine} adds to transitions a
probability distribution (or a tape with random Symbols). It is an
open question whether this is more powerful than a DTM
($\mathsf{BPP}=\mathsf{P}$ ?)  but it is useful in the definition of
\emph{interactive proof systems}. %FIXME ref

\subsubsection{Multidimensional Turing Machines}
\emph{Multidimensional Turing Machines} allow for tapes of varying
topologies. This requires additional shift directions (i.e. $\{L, R, U,
D\}$ for a 2-dimensional tape) but does not increase the computing
power; even an $\infty$-\emph{dimensional} Turing Machine can be
simulated by a DTM.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Symbolic Logic}\label{sec:formal_logic}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Formal Logic} applies Formal Language (Part
\ref{sec:formal_language}) to \emph{Formal Arguments} by means of
\emph{Inference Rules} (\S\ref{subsec:inference_rules}). A Formal
Argument is an Ordered Set of \emph{Formulas}.



% ====================================================================
\section{Terminology}\label{sec:logic_terminology}
% ====================================================================

\begin{description}
\item[Universe] class containing elements of \emph{objects} considered
  in a particular Logical discourse, also called \emph{Domain of
    Discourse}
\item[Constant] a named object from the Domain
\item[Variable] a placeholder that ranges over the objects in the
  Domain
\item[Function] $n$-ary functions maps $n$-tuples of objects in the
  Domain to objects
\item[Term] an object of the Domain (Variables, Constants and Compound
  Statements)
\item[Formula] a mathematical Fact
\end{description}
\hfill \\ Inductive definition of \emph{Terms} from \emph{Constants},
\emph{Variables}, and \emph{Functions}:

Given Terms, $T$, Variables, $V$, n-ary Functions, $F = F_0 \cup F_1
\cup F_2 \cup \cdots \cup F_n$, Constants, $C = F_0$:
\[
    V \subseteq T
\]\[
    C \subseteq T
\]\[
    \forall \tau_n=\{t_1,\cdots,t_n\} \in \mathcal{P}(T), \forall f \in F_n
    \exists f(t_1,\cdots,t_n) \in T
\]
Inductive definition of \emph{Formulas} from Terms and
\emph{Relations}:

Given Terms, $T = \{t_0,\ldots,t_n\}$, and Relations, $R = \{r_0,\ldots,r_m\}$:
\begin{itemize}
\item $t_i = t_j$ is a Formula
\item $r_k(t_0,\ldots,t_n)$ is a Formula and $r_k$ is an n-ary Relation
\end{itemize}
A Formula is \emph{Valid} if and only if it is True under every
\emph{Interpretation} (\S\ref{subsec:interpretation}).

\emph{Mapping} % Functions, Morphisms



% ====================================================================
\section{Formal Systems}\label{sec:formal_systems}
% ====================================================================

Symbols may be divided into \emph{Logical} and \emph{Non-Logical
  Symbols}: Logical Symbols ($\forall$, $\vee$, $\rightarrow$, $\neg$,
etc., and \emph{Variables} $x_0$, $x_1$, etc.) always have the same
meaning while Non-Logical Symbols (\emph{Predicates} (Relations),
\emph{Functions}, and individual \emph{Constants}) only have meaning
under \emph{Interpretation} (\S\ref{subsec:interpretation}). The set of
Non-Logical Symbols used in a particular discourse is called the
\emph{Signature} of the discourse. The Signature may be defined as a
triple:
\[
    \sigma = (S_{func},S_{rel},ar)
\]
where
\[
    ar: S_{func} \cup S_{rel} \rightarrow \mathbb{N}_0
\]
\emph{Extra-logical Symbols} are those of a Metalanguage, such as the
symbol for \emph{Logical Consequence} (\emph{Entailment}), $\vdash$,
(read \emph{yields} or \emph{proves}) or Metavariables, $\varphi,
\psi, \ldots$.

A particular \emph{Formal System} is required to be \emph{Consistent}; that
is the ability to derive only the affirmation or denial of a
particular statement, not both. Another way of stating Consistency is
that Falsity is not provable from no Assumptions.

\emph{Stratification}

% --------------------------------------------------------------------
\subsection{Deductive Apparatus} \label{subsec:deductive_apparatus}
% --------------------------------------------------------------------

A Formal Language (described by a Formal Grammar) in combination with
a \emph{Deductive Apparatus} gives rise to a \emph{System of
  Logic}. Here, Expressions of Symbols are usually referred to as
\emph{Forumulas}, and Expressions that belong to the Language are
called ``\emph{Well-formed Formulas}'' (\emph{WFF}).

The Deductive Apparatus is a set of zero or more \emph{Axioms} and one
or more \emph{Inference Rules}. A System of Logic is termed
\emph{Effective} (i.e. Recursively Definable) if the set of Axioms and
the set of Inference Rules are Decidable or Semi-decidable. The notion
of \emph{Theorems}, however, is not in general Effective
(\S\ref{subsec:formal_proof}).

\subsubsection{Axioms}\label{subsec:axiomatization}

\emph{Axioms} are given as WFFs, the truth value of which are assumed
for the purpose of performing \emph{analysis} within a System of
Logic. An Axiom is properly an \emph{Inference Rule} with no
\emph{Premises}, only a given \emph{Conclusion}; that is a
\emph{Logical Assertion}(\S\ref{subsec:sequent_notation}).

Axioms may be divided into two kinds: \emph{Logical Axioms} of a
tautological sort, and \emph{Non-logical Axioms}, hereafter referred
to as \emph{Postulates}, that play the role of assumptions: defining
properties of the domain of the theory in question.

An \emph{Axiom Schema} is properly a template for Axioms in which one
or more \emph{Schematic Variables} (Metavariables, \S
\ref{sec:metalanguage}) appear, standing for a subformula in the
Object Language of the system. For a Language with infinitely many
WFF, an Axiom Schema describes a countably infinite number of
Axioms. A system without Schema is termed \emph{Finitely Axiomatized}.

\subsubsection{Inference Rules} \label{subsec:inference_rules}

An \emph{Inference Rule} is a \emph{transformation rule}: it is the
\emph{Logical Form} of the \emph{Deduction} of a \emph{Conclusion}
(also called an \emph{Idiomatic}) based on \emph{Premises}-- Premises
and Conclusions being WFF in the Formal Language of the system. Axioms
are special cases of Inference Rules which have no Premises, only a
universally held Conclusion. Axioms may be further differentiated from
Rules by saying that Rules are statements \emph{about} the system,
Axioms are statements \emph{in} the system.

Inference Rules may be viewed as functions that take Premises and
return a Conclusion. An alternative formulation for Inference Rules is
as a \emph{Deducibility Relation}, $\vdash$, that holds between zero
or more Premises and a Conclusion. A Formal Argument is \emph{Valid}
if and only if the Conclusion is Entailed by the Premises. Inference
Rules, like Axioms, may be Schematic if they contain Metavariables,
and such an Argument is called an \emph{Argument Form}. Argument Forms
are Valid if and only if every Argument is Valid.

Taken individually, both Premises and Conclusions are
\emph{Propositions}. The Conclusion relies on the truth of the
Premises; if the Premises are left unsatisfied, then the derivation is
\emph{Hypothetical} and the Premises \emph{Hypotheses}. It can be said
that the Conclusion of a Deducibility Relation is reached by
\emph{Syntactic Consequence}, a form of \emph{Logical
  Consequence}. For more information, see section on \emph{Formal
  Proof} (\S\ref{subsec:formal_proof}).

Inference Rules may be identified as reduntant in two senses. An
\emph{Admissible Rule} is one which does not change the set of
\emph{Theorems} in a Formal System when it is added. A \emph{Derivable
  Rule} is a case of an Admissible Rule that has been \emph{Derived}
from existing rules.



% --------------------------------------------------------------------
\subsection{Quantification}\label{subsec:firstorder_quantification}
% --------------------------------------------------------------------

A \emph{Quantifier} limits (\emph{Binds}) a Variable to a certain
quantity of members of the Domain, the two fundamental Quantifiers
being \emph{Universal} ($\forall$) and \emph{Existential} ($\exists$).

A \emph{Bound Quantifier} is one with a restricted Range, e.g.
$\exists x > 0$ or $\forall x \in \mathbb{R}$.



\subsubsection{Bound \& Free Variables}\label{subsec:bound_free}

Variables are \emph{Free Variables} if they are not Quantified in any
Formula, and \emph{Bound Variables} when they are Quantified.
Inductive definition of \emph{Free} and \emph{Bound Variables}:
\begin{enumerate}
\item A Variable $x$ is Free in Atomic Formula $\varphi$ if $x$ occurs
  in $\varphi$ (there are no Bound Variables in Atomic Formulas)
\item A Variable is Free or Bound in $\varphi \bullet \psi$ if $x$ is
  Free or Bound in either $\varphi$ or $\psi$, where $\bullet$ is a
  Binary Connective
\item A Variable $x$ is Free in $\forall y \varphi$ iff $x$ is Free in
  $\varphi$ and $x$ is not $y$. Conversely $x$ is Bound in $\forall y
  \varphi$ if $x$ is $y$ or $x$ is Bound in $\varphi$.
\end{enumerate}

A Term with no Free Variables is a \emph{Ground Term} and a Formula
with no Free Variables in First-order Logic is a \emph{First-order
  Sentence} (also called a \emph{Closed Formula}). First-order
Sentences have well-defined Truth values. Free Variables are
implicitly Universally Quantified.

\subsubsection{Uniqueness Quantification}\hfill

\emph{Unique Existential Quantification}, denoted by $\exists !$,
is expressed in natural language as ``there is one and only one.'' A
First-Order System requires the \emph{Equality Relation}
(\S\ref{subsec:firstorder_equality}) in order to be able to express
Uniqueness Quantification.



\subsubsection{Quantifier Rank}

Inductive definition of \emph{Quantifier Rank} function $qr$:
\begin{itemize}
\item $qr(\varphi) = 0$ if $\varphi$ is Atomic
\item $qr(\varphi_1 \wedge \varphi_2) = qr(\varphi_1 \vee \varphi_2) = max(qr(\varphi_1),qr(\varphi_2))$
\item $qr(\neg \varphi) = qr(\varphi)$
\item $qr(\exists_x \varphi) = qr(\varphi) + 1$
\end{itemize}



\subsubsection{Quantifier Nesting}

% FIXME



\subsubsection{Prenex Normal Form}\label{subsec:prenex_normal}



% --------------------------------------------------------------------
\subsection{Zeroth-order - Propositional}\label{subsec:propositional}
% --------------------------------------------------------------------

\emph{Propositional Logic} (also called \emph{Sentential} or
\emph{Statement Logic}) is represented by a Formal Language with WFF
consisting only of \emph{Operators} (\emph{Logical Connectives}) and
\emph{Primitive Symbols} representing \emph{Propositions}.

Propositions are WFF that are assigned a truth value. An \emph{Atomic
  Proposition} contains no Operators. A \emph{Composite Proposition}
is composed by recursive application of Operators to Propositions by a
corresponding \emph{Concatenation Rule} that assigns a new truth value
to the Composite string.

Primitive Symbols are usually divided into three different categories:
\begin{description}
\item[Propositional Constants] \hfill \\
Represent particular Propositions: $A$, $B$, $C$, $\ldots$
\item[Propositional Variables] \hfill \\
Range over set of all Atomic Propositions: $p$, $q$, $r$, $\ldots$
\item[Schematic Variables] \hfill \\
Metavariables; range over set of all propositions: $\varphi$, $\psi$,
$\chi$, $\ldots$
\end{description}

The Domain of a Propositional Calculus is \emph{Truth} and
\emph{Falsity}, so Variables are not necessarily \emph{Bound} or
\emph{Free} as in \emph{Predicate Logic}. In fact, a Propositional
Variable is equivalent to a \emph{Nullary Predicate} in \emph{First
  Order Logic}.

Formal definition of a \emph{Propositional Calculus}:
\[
    \mathcal{S} = (\mathbf{A},\mathbf{\Omega},\mathbf{Z},\mathbf{I})
\]
where
\begin{itemize}
\item $\mathbf{A}$ is a finite set of Proposition symbols ($p$, $q$,
  $r$, $\ldots$)
\item $\mathbf{\Omega}$ is a finite set of Operator symbols ($\neg$,
  $\wedge$, $\vee$, $\ldots$)
\item $\mathbf{Z}$ is a finite set of Inference Rules
\item $\mathbf{I}$ is a finite set of Axioms
\end{itemize}
$\mathcal{S}$ is then inductively defined as follows, where
$\mathbf{\Omega_j}$ is the partition of $\mathbf{\Omega}$ containing
Operators of arity $\mathbf{j}$:
\begin{enumerate}
\item Any element of $\mathbf{A}$ is a Formula of $\mathcal{S}$
\item For Formulas $p_1, p_2, \cdots, p_j$ and $f \in
  \mathbf{\Omega_j}$ then $f(p_1, p_2, \cdots, p_j)$ is a formula
\end{enumerate}
Propositional Logic is closed under Truth-Functional Connectives, so
the above is sufficient to define all WFF: nothing else is a formula
of $\mathcal{S}$.

Formulas derived by the Axioms and Inference Rules of a Propositional
Logic are termed \emph{Theorems}. Allowing for Axiom Schema (an
infinite number of axioms) extends Propositional Logic; an example of
such a system is \emph{Skolem Arithmetic}\cite{skolem23}.

The set of WFF of a System, $\mathcal{S}$, may be defined inductively:
\begin{itemize}
\item Propositional Variables are WFF
\item If $\varphi$ is a WFF, then $\neg\varphi$ is a WFF
\item If $\varphi$ and $\psi$ are WFF and $\bullet$ is a binary Operator,
  then $\varphi \bullet \psi$ is a WFF.
\end{itemize}

\subsubsection{Argument Forms}

Inference Rules of a Propositional Logic define Valid \emph{Argument
  Forms} (\S\ref{subsec:inference_rules}). The simplest Argument Form
that is both necessary (and given a complete set of Axioms is
sufficient to define all other Argument Forms) is \emph{Modus Ponens},
shown here Schematicized:

$\textrm{1. }\varphi \rightarrow \psi$

$\textrm{2. }\varphi$

$\therefore\textrm{ }\psi$
\\
where lines one and two are Premises and line three is the Conclusion
(the symbol $\therefore$ is read as \emph{therefore}). This is written in
\emph{Sequent Notation}(\S\ref{subsec:sequent_notation}) as
\[(\varphi \rightarrow \psi), \varphi \vdash \psi\]
The Schematic representation of \emph{Modus Tollens}:

$\textrm{1. }\varphi \rightarrow \psi$

$\textrm{2. }\neg\psi$

$\therefore\textrm{ }\neg\varphi$

\subsubsection{Operators}

The minimal set of primitive Operators is the \emph{negation} symbol
($\neg$) plus a \emph{sole sufficient} Operator of either $\land$,
$\lor$ or $\rightarrow$. Choosing one of these Operators, the other
two, and any other Operator, can be defined in terms of it and
negation. It is also possible to construct functionally complete sets
of one element: $\mathbf{\Omega} = \{\uparrow\}$ or $\mathbf{\Omega} =
\{\downarrow\}$ ($\uparrow$ and $\downarrow$ being \emph{NAND} and
\emph{NOR}, respectively).
\\
Example simple Axiom system:

$\mathbf{\Omega} = \mathbf{\Omega_1} \cup \mathbf{\Omega_2}$

$\mathbf{\Omega_1} = \{\neg\}$

$\mathbf{\Omega_2} = \{\rightarrow\}$

$\mathbf{I} = \{ (p \rightarrow (q \rightarrow p)),$

$\qquad((p \rightarrow (q \rightarrow r)) \rightarrow
(( p \rightarrow q) \rightarrow (p \rightarrow r))),$

$\qquad(( \neg p \rightarrow \neg q ) \rightarrow (q \rightarrow p ))
\}$\\ with Modus Ponens as the sole inference rule (see Hilbert
Systems, \S\ref{subsec:hilbert_systems}).

In Propositional Logic, the Extra-logical Symbol for Entailment,
$\vdash$, and the Logical \emph{Implication Symbol}, $\rightarrow$,
coincide in that
\[(A \vdash B) \leftrightarrow (\vdash A \rightarrow B)\]
but the difference is that $\vdash$ describes a Deduction, that is a
relation between Sentences, and $\rightarrow$ is a Logical Connective
within a Formula.

Another possible system is a \emph{Natural Deduction
  System}\cite{jaskowski34} (\S \ref{subsec:natural_deduction})
which has no Axioms ($\mathbf{I}=\varnothing$) and ten Inference
Rules.

% --------------------------------------------------------------------
\subsection{First-order - Predicate}\label{subsec:predicate_logic}
% --------------------------------------------------------------------

Systems of \emph{First-order Predicate Logic} add \emph{Extensional
  Quantifiers} that may be applied to Variables, which may be Objects
of the Universe of discussion, or Relations or Functions. A
\emph{First-Order Theory} may be formed by a system of First-order
Logic together with a Domain of Discourse over which Variables may
range, plus finitely many Functions and \emph{Predicates} defined on
that Domain, and a recursive set of Axioms.

A Predicate in First-order Logic takes one or more Objects from the
Domain and returns either True or False, that is a Relation on the
Domain. A Predicate taking no Objects (a Nullary Predicate) is
equivalent to a Proposition in Zeroth-order Logic.

\emph{Higher-order Logic}(\S\ref{subsec:higher_order}) allows Predicates
to be applied to other Predicates or Functions, or Quantifiers may be
applied to Predicates or Functions. In First-order Logic, Predicates
are associated with Sets, in Higher-order Logic, with Sets of
Sets.
\\
The traditional Signature used in First-order Logic:
\begin{enumerate}
\item For $n \geq 0$, $n$-ary Predicate (also called Relation)
  Symbols: $p^{n}_0, p^{n}_1, p^{n}_2, p^{n}_2, p^{n}_3, \ldots$
\item For $n \geq 0$, $n$-ary Function Symbols: $f^{n}_0, f^{n}_1,
  f^{n}_2, f^{n}_2, f^{n}_3, \ldots$
\end{enumerate}
The contemporary Signature used:
\begin{enumerate}
\item Predicate Symbols denoted by uppercase letters $P$, $Q$, $R$,
  $\ldots$ with arity ($\geq 0$) specified by the \emph{Valence} of the
  parenthetical arguments, eg P(x), Q(x,y).
\item Function Symbols denoted by lowercase letters $f$, $g$, $h$,
  $\ldots$ with arity specified in the usual way.
\end{enumerate}
Here, Functions of Valence 0 are \emph{Constant Symbols} denoted by
letters $a$, $b$, $c$, $\ldots$.

\subsubsection{Properties}\label{subsec:firstorder_properties}

First-order Logic may be used to devise Deductive Systems with finite
Domains that are \emph{Sound} (\S\ref{sec:soundness}) and
\emph{Complete}, but for infinite Domains a system of Higher-order
Logic is required. First-order Logic is
Semi-decidable(\S\ref{subsec:semidecidable}).

%FIXME ref Lowenheim-skolem thoerem
The \emph{L\"owenheim-Skolem theorem} implies that First-order Logic
is unable to characterize the concept of Countability (or
Uncountability).

%FIXME def/ref compactness theorem
The \emph{Compactness theorem} implies that if a Formula is derived
from a System of First-order Logic with an infinite set of Axioms,
then it can be derived from a finite number of those Axioms. This has
implications for the determination of \emph{Connected Components} of a
\emph{Directed Graph} (\S\ref{subsec:directed_graph}).

\subsubsection{Formation Rules}\label{subsec:formation_rules}

The \emph{Formation Rules} for WFF in a System of First-order Logic
generally describe a Context-free Grammar with a infinite Alphabet and
many Start Symbols.

Terms are limited to those derived from Variables and a finite number
of $n$-ary Function applications, but not Expressions involving a
Predicate Symbol. See Section \ref{sec:logic_terminology} for a recursive
definition of Terms.

Definition of \emph{Atomic Formulas} (no Logical Connectives or Quantifiers):
\begin{enumerate}
\item If $t_1$ and $t_2$ are Terms, then $t_1 = t_2$ is an Atomic Formula.
\item If $R$ is an $n$-ary Relation (Predicate), and $t_1,\ldots,t_n$
  are terms, then $R(t_1,\ldots,t_n)$ is an Atomic Formula.
\end{enumerate}
Atomic Formulas or their negations are also called \emph{Literals}. A
\emph{Clause} is a finite Disjunction of Literals.

Definition of WFF as a finite number of applications of the following rules:
\begin{enumerate}
\item $\neg \phi$ is a WFF when $\phi$ is a WFF
\item $(\phi \bullet \psi)$ is a WFF when $\phi$ and $\psi$ are WFF
  and $\bullet$ is a Binary Connective
\item $\exists x \phi$ is a WFF when $x$ is a Variable and $\phi$ is a WFF
\item $\forall x \phi$ is a WFF when $x$ is a Variable and $\phi$ is a WFF
\end{enumerate}




\subsubsection{Inference Rules}

\paragraph{Universal Generalization}\label{subsec:universal_generalization} \hfill
\\
\[P(x) \vdash \forall x P(x)\]

\subsubsection{Equality Conventions}\label{subsec:firstorder_equality}

\paragraph{First-order Logic with Equality}\hfill
\\ Including a primitive Logical Symbol for equality, $=$, interpreted
as the real equality relation between members of the Domain such that
``two'' given members are the same member. This adds the following
Axioms:

\begin{enumerate}
\item \textbf{Reflexivity}: $\forall x, x=x$
\item \textbf{Substitution for functions}: given a function, $f$,
  $\forall x \forall y, x = y \rightarrow f(\ldots,x,\ldots) =
  f(\ldots,y,\ldots)$
\item \textbf{Substitution for formulas (Leibniz's Law)}: given a
  formula $\varphi$ with Free occurrences of $x$, and $\varphi '$ with
  Free occurrences of $y$, $\forall x \forall y, x = y \rightarrow
  (\varphi \rightarrow \varphi ')$
\end{enumerate}

Defining a theory with a Binary Relation $A(x,y)$ that satisfies
Reflexivity and Leibniz's law is sufficient to derive any other
equality Theorems.

\paragraph{First-order Logic without Equality} \hfill
\\ An alternative convention is to consider the Equality Relation to
be a Non-logical Symbol, included as a part of the Signiature of a
particular Theory instead of as a Rule of Logic. This allows two
distinct individuals to be considered equal by an arbitraray
Equivalence Relation. If this convention is used, but no distinct
individuals, $a$ and $b$ satisfy $a=b$ then the interpretation is
termed a \emph{Normal Model} (that is equivalent to a First-order
Logic with Equality).


\subsubsection{Monadic First-order Logic}

\emph{Monadic First-order Logic}, also called \emph{Monadic Predicate
  Calculus} restricts First-order Logic to unary Relations and no
Function symbols. This weaker form of First-order Logic is fully
Decidable.

\subsubsection{Many-sorted First-order Logic}\label{subsec:manysorted_logic}

\emph{Many-sorted First-order Logic} allows Variables to be Quantified
over different Domains, thus giving Variables different
\emph{Sorts}. With finitely many Sorts, Many-sorted First-order Logic
can be reduced to Single-sorted First-order Logic. This can be
accomplished by adding unary Predicates to a First-order Logic that
partition the Domain.

\subsubsection{Infinitary First-order Logic}

\emph{Infinitary Logic} allows Formulas of infinite length, through
either Conjunctons and Disjunctions, infinite-arity Relations and
Functions, or Quantification over infinitely many Variables.

\paragraph{$\Omega$-logic}\label{subsec:omega_logic}

% --------------------------------------------------------------------
\subsection{Higher-order - Plural}\label{subsec:higher_order}
% --------------------------------------------------------------------

\subsubsection{Second-order}\label{subsec:second_order}

\emph{Second-order Logic} allows for Quantifiers to range over
Relations and Functions and thus \emph{Sorts} of Variables that range
over $k$-ary Relations and Functions. It is possible to leave out a
definition of Quantifiers for Functions since $k$-ary Functions can be
represented by $k+1$-ary Relations.\cite{shapiro00} Quantification
over Functions allows the creation of the \emph{Analytic Hierarchy}
(\S\ref{subsec:analytic_hierarchy}).

\subsubsection{Plural, Monadic Second-order Logic}

An alternative formulation of Second-order Logic is to allow Variables
to take on \emph{Plural} Values. It is equi-interpretable with
\emph{Monadic Second-order Logic}, which restricts Quantification to
Unary Relations (sets).

\subsubsection{Independence-friendly Logic}\label{subsec:independence_logic}

\emph{Independence-friendly Logic} has \emph{Branching Quantifiers}.

% --------------------------------------------------------------------
\subsection{Classical Logic}\label{subsec:classical_logic}
% --------------------------------------------------------------------

\emph{Classical Logic} is the class of Propositional and
First-order Systems of Logic characterized by the following Inference
Rules:

\begin{description}

\item [Tertium non datur] (\emph{Law of excluded middle})
    \[\vdash(p \vee \neg p)\]

\item [Double Negation]
    \[p \vdash \neg\neg p\]

\item [Law of Non-contradiction]
    \[\vdash \neg(p \wedge \neg p)\]

\item [Ex falso quodlibet] (\emph{Principle of explosion},
  \emph{Principle of Psuedo-Scotus})
    \[\vdash 0 \rightarrow p\]

%FIXME finish properties and rules

\end{description}

The intended Semantic Interpretation (\S\ref{subsec:interpretation})
of Classical Logic is subject to the \emph{Principle of Bivalence}
which says that every Proposition has one Truth-value: True or False.
Non-classical Logics such as \emph{Intuitionistic Logic}
(\S\ref{subsec:intuitionistic_logic}) does not have this Property.

% --------------------------------------------------------------------
\subsection{Modal (Intensional) Logic} \label{subsec:modal_logic}
% --------------------------------------------------------------------

\emph{Intensional Logic} adds to First-order Logic \emph{Sentential
  Functors} (\emph{Intensions}) that range over Terms. An Intension is
the \emph{Sense} in which a Logical Assertion is made, as opposed to
the \emph{Reference} to which the Assertion applies (\emph{i.e.
  Extensional Quantification}).

\emph{Modal Logic} extends Propositional and Predicate Logic to
include Operators expressing \emph{Modality}. Various meanings for
these Modal Operators include \emph{Alethic Modality}
(\emph{Necessity} and \emph{Possibility}), \emph{Temporal Modality}
(qualification in terms of time, eg \emph{always}, \emph{eventually},
\emph{until}), \emph{Deontic Modality} (\emph{Obligation} and
\emph{Permission}), and \emph{Doxastic Modality} (Modalities with
regards to \emph{Belief}).

An unary \emph{Primitive Modal Operator}, $\square$, defines a Dual
Operator, $\Diamond$, such that the following analogues of de Morgan's
Laws (\S\ref{subsec:de_morgan}) hold:
    \[\Diamond P \leftrightarrow \neg \square \neg P\]
    \[\square P \leftrightarrow \neg \Diamond \neg P\]
Modal Logic with more than one Primitive Modal Operator, $\square _i,
i \in \{1, \ldots, n\}$ is \emph{Multimodal Logic}.

\subsubsection{Alethic Logic}\label{subsec:alethic_logic}

Most Systems of Alethic Logic are based on an extension of
Propositional Logic called $\mathbf{K}$ which has:

\begin{enumerate}
\item $\square$, unary operator for \emph{Necessity}.
\item $\mathbf{N}$, \emph{Necessitation Rule}: stating if $p$ is a
  Theorem, then $\square p$ is a Theorem.
\item $\mathbf{K}$, \emph{Distribution Axiom}: $\square(p \rightarrow
  q) \rightarrow (\square p \rightarrow \square q)$ (also called the
  \emph{Kripke schema} (\S\ref{sec:frame_semantics}).
\end{enumerate}

Adding further Axioms gives rise to a nested hierarchy of Systems of
\emph{Normal Modal Logic}:

\begin{itemize}
\item $K := \mathbf{K} + \mathbf{N}$
\item $T := K + \mathbf{T}$
\item $S4 := T + \mathbf{4}$
\item $S5 := S4 + \mathbf{5}$
\item $D := K + \mathbf{D}$
\end{itemize} \hfill \\
where

\begin{itemize}
\item $\Diamond$, unary operator for \emph{Possibly}
\item $\mathbf{T}$, \emph{Reflexivity Axiom}: $\square p \rightarrow p$
\item $\mathbf{4}$: $\square p \rightarrow \square \square p$
\item $\mathbf{B}$: $p \rightarrow \square \Diamond p$
\item $\mathbf{D}$: $\square p \rightarrow \Diamond p$
\item $\mathbf{5}$: $\Diamond p \rightarrow \square \Diamond p$
\end{itemize}

\subsubsection{Doxastic Logic}

\emph{Doxastic Logic} uses the unary Modal Operator, $\mathcal{B}$, to
denote \emph{Belief}. Example:
\[
    \mathcal{B} x
\]
has the meaning ``It is Believed that x is the case''. A set of
Beliefs is usually denoted
\[
    \mathbb{B}: \{ b_1, b_2, \ldots, b_n \}
\]

\subsubsection{Deontic Logic}

\emph{Standard Deontic Logic} ($\mathbf{SDL}$) adds the following
Axioms to Propositional Logic (\S\ref{subsec:propositional}):
    \[O(A \rightarrow B) \rightarrow (OA \rightarrow OB)\]
    \[PA \rightarrow \neg O \neg A\]
with Primitive Operators $O$ (\emph{Obligatory}) and $P$
(\emph{Permissible}). \emph{Forbidden} is defined as
    \[FA = O \neg A\]
or
    \[FA = \neg P A\]
Deontic Logic may be extended by Alethic Operators with the Axiom:
    \[OA \rightarrow \Diamond A\]
which has the meaning ``ought implies can''.

\subsubsection{Temporal Logic}

\paragraph{Tense Logic} \hfill \\

\emph{Tense Logic} is a 2-modal Logic that adds operators $[F]$ for
\emph{Future} and $[P]$ for \emph{Past} Modalities.

\paragraph{Linear Temporal Logic}

\paragraph{Computation Tree Logic}

\paragraph{Interval Temporal Logc}

\paragraph{Modal $\mu$-calculus}

\subsubsection{Dynamic Logic}

\emph{Dynamic Logic} adds Terms denoting \emph{Actions}:
\[[a]p\]
where after performing Action $a$ is necessitated that $p$ holds and
\[\langle a \rangle p\]
where after performing Action $a$ it is possible that $p$ holds.

% --------------------------------------------------------------------
\subsection{Intuitionistic Logic}\label{subsec:intuitionistic_logic}
% --------------------------------------------------------------------

\emph{Intuitionistic Logic} (or \emph{Constructive Logic}) replaces
Truth with the concept of \emph{Constructive Provability}. This is to
say that Operations in Intuitionistic Logic preserve
\emph{Justification} rather than Truth-value. Such systems are
restrictions of Classical Logic without the Law of the Excluded Middle
or Double Negation Elimination (\S\ref{subsec:classical_logic}).

Whereas First-order Logic (\S\ref{subsec:predicate_logic}) is a
foundation for Set Theory (Part \ref{sec:set_theory}), Intuitionistic
Logic is used as a foundation for \emph{Type Theory} (Part
\ref{sec:type_theory}) and \emph{Constructive Set Theory}
(\S\ref{sec:constructive_set_theory}).

A Formula in Intuitionistic Logic does not necessarily have a Prenex
Normal Form (\S\ref{subsec:prenex_normal}).

Intuitionistic Logic is \emph{Modelled} by \emph{Heyting Algebra}
(\S\ref{subsec:heyting_semantics}) or \emph{Kripke Semantics}
(\S\ref{subsec:kripke_semantics}) and lacks the Principle of Bivalence
(\S\ref{subsec:classical_logic}); thus there is no sole-sufficient
Operator in Intuitionistic Logic. A Formula is Valid if and only if it
receives the Value of the Top Element for any Valuation on any Heyting
Algebra.

Complete bases are:
\[
    \{ \vee, \leftrightarrow, \bot \}
\]
and
\[
    \{ \vee, \leftrightarrow, \neg \}
\]

Proofs (Part \ref{sec:proof_theory}) in a Theory
(\S\ref{subsec:formal_theory}), $\mathcal{T}$, based on Intuitionistic
Logic have the \emph{Existence Property}:
\[
    (\exists x)A(x) \in \mathcal{T} \rightarrow (\exists t)A(t)
\]
where $A(x)$ has $x$ as the only Free Variable and $t$ is a Term.

\emph{Disjunction Property}:
\[
    A \vee B \in \mathcal{T} \rightarrow A \in \mathcal{T} \vee B \in \mathcal{T}
\]

\subsubsection{Minimal Logic}

\subsubsection{Combinatory Logic}\label{subsec:combinatory_logic}

\emph{Combinator}

\subsubsection{Intermediate Logic}

\emph{Intermediate Logic} is an extended Intuitionistic Logic
(\emph{Superintuitionistic Logic}) that is Consistent and still weaker
than the strongest Consistent Superintuitionistic Logic: Classical
Logic.

% --------------------------------------------------------------------
\subsection{Substructural Logic}\label{subsec:substructural_logic}
% --------------------------------------------------------------------

\subsubsection{Relevance Logic}\label{subsec:relevance_logic}

\subsubsection{Linear Logic}\label{subsec:linear_logic}

\paragraph{Non-commutative Logic}\label{subsec:noncommutative_logic}

% --------------------------------------------------------------------
\subsection{Ordinal Logic}
% --------------------------------------------------------------------

Alan Turing's PhD Thesis \cite{turing38}

% --------------------------------------------------------------------
\subsection{Hoare Logic}
% --------------------------------------------------------------------

\emph{Concurrency}

% --------------------------------------------------------------------
\subsection{Categorical Logic}
% --------------------------------------------------------------------



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Proof Theory}\label{sec:proof_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ====================================================================
\section{Metatheory} \label{sec:metatheory}
% ====================================================================

\emph{Proof Theory} is itself \emph{Metamathematical} in that it
studies the form of Logical Consequence within Logical Systems, and
therefore is expressed as \emph{Metatheory}.

A \emph{Judgement} is an inductively definable assertion in the
Metatheory of a Logical System. That is, one that includes
Extra-logical Symbols, namely that of Logical Consequence, $\vdash$,
and commas used in \emph{Sequents}
(\S\ref{subsec:sequent_notation}). In this way, Axioms are Judgements,
and a \emph{Formal Proof} expresses a Judgement with the Premises
being a sequence of Judgements and the Conclusion also a Judgement.

% --------------------------------------------------------------------
\subsection{Formal Theory}\label{subsec:formal_theory}
% --------------------------------------------------------------------

A \emph{Formal Theory} is a Set of Sentences in some Formal Language
(Part \ref{sec:formal_language}). In a Deductive System, a Theory has
certain Sentences which are Axioms, and any Sentences which are a
Logical Consequence are also Sentences of that Theory. That is, a
Theory $\mathcal{T}$ which is an \emph{Inductive Class}. The Sentences
which are considered for a particular Theory are drawn from a
\emph{Conceptual Class} of \emph{Elementary Statements}. A Formal
Theory is said to be \emph{Complete} if for every Sentence in the
Language of that Theory, the Theory contains either that Sentence or
its Negation. Such a Set of Sentences is a \emph{Maximal Consistent
  Set}.

A Formal Theory is \emph{Categorical} if it has just one \emph{Model}
(Part \ref{sec:model_theory}) up to Isomorphism.

%FIXME connections with stability theory



\subsubsection{Duality Principle}\label{subsec:duality_principle}



% --------------------------------------------------------------------
\subsection{Formal Proof} \label{subsec:formal_proof}
% --------------------------------------------------------------------

A Formal Proof is a \emph{Logical Derivation}: a finite sequence of
Well-formed Formulas of a Formal System that are either Axioms of a
Logical System or follow from the preceding Formulas by an Inference
Rule. The concluding Formula in the sequence is a \emph{Theorem}. A
Theorem used in the course of Deriving a further Theorem is called a
\emph{Lemma}.

For a Formal System, $\mathcal{S}$, of a set of Formulas, $\Gamma$,
there is a \emph{Syntactic Consequence}, $A$, if there is a
Formal Proof of $A$ from the set $\Gamma$:
\[
    \Gamma \vdash_{\mathcal{S}} A
\]
It will suffice for now to say that Syntactic Consequence as
differentiated from \emph{Material Consequence} ($\rightarrow$)
should:

\begin{enumerate}
\item Rely on the Logical Form (\S\ref{subsec:inference_rules}) of the
  Expressions
\item Be completely \emph{a priori}
\item Be \emph{Modal} (\S\ref{subsec:modal_logic}) (i.e. Necessary)
\end{enumerate}
Another form of Logical Consequence, \emph{Semantic Consequence}
(\S\ref{subsec:semantic_consequence}) will be described under
\emph{Model Theory} (Part \ref{sec:model_theory}).

Proof by Syntactic Consequence is a \emph{Deduction}; that is, the
production of a Theorem is said to be a \emph{Derivation}. Deduction
proper is the top-down, \emph{Reductive} process that starts with
general Axioms and Reduces to the specific Theorem that is being
proved. \emph{Mathematical Induction} is the bottom-up,
\emph{Implicative} process where a \emph{Base Case} is shown to extend
to the more general by means of Implication (the Inductive step). Note
that Mathematical Induction is not \emph{Inductive Reasoning} which is
an empirical or probabilistic Inference and not a form of Deduction.
The \emph{Principle of Mathematical Induction}
(\S\ref{subsec:induction_principle}) is an application of Mathematical
Induction to the \emph{Natural Numbers}
(\S\ref{sec:natural_number}).

An \emph{Theoretic Analytic Proof} begins with an assumption and
proceeds to an accepted truth (an Axiom, or contradiction as in
Analytic Tableau (\S\ref{subsec:tableau_calculus}). A \emph{Synthetic
  Proof} is the reverse of this process; beginning with known truths
and reasoning up to the desired Proof. A \emph{Problematic Analytic
  Proof} is constructed from given conditions that are to be
satisfied.

\subsubsection{Sequent Notation}\label{subsec:sequent_notation}

A \emph{Sequent} is a specific kind of Judgement of the form
\[\Gamma \vdash \Sigma \]
where the \emph{Antecedent}, $\Gamma$, is a Conjunctive sequence of
Formula, and the \emph{Succedent}, $\Sigma$, is a Disjunctive sequence
of Formulas. Together, Antecedents and Succedents are
\emph{Cedents}. The Extra-logical Operators, $\vdash$, and $,$
(comma), are called \emph{Structural Operators} and Rules which change
only Structural Operators are \emph{Structural Rules} (as opposed to
\emph{Logical Rules}. A sequence of Cedents may be called a
\emph{Context}, but \emph{the} Context for a specific Judgement is
usually meant to be the Antecedent.

\emph{Weakening} refers to a Rule that introduces arbitrary elements
to a Sequent. \emph{Contraction} refers to a Rule that removes
multiple occurences of some element and \emph{Permutation} refers to
the re-ordering of elements. Logics lacking Structural Rules are
\emph{Substructural Logics} (\S\ref{subsec:substructural_logic}). If
Sequents are defined as Sets or Multisets instead of Sequences (that
is, unordered Sets), then the Permutation rule is obsolete, likewise
the Contraction Rule would be obsolete for Sets instead of Sequences.

In a general \emph{Sequent Calculus} there may be any
number of Formulas on either side
\[
    A_1, \ldots, A_n \vdash B_1, \ldots, B_k
\]
is equivalent to
\[
    \vdash(A_1 \wedge \cdots \wedge A_n) \rightarrow (B_1 \vee \cdots \vee B_k)
\]
and the dual nature of Judgements and negation can be expressed by the
dual forms
\[
    \vdash \neg A_1 \vee \cdots \vee \neg A_n \vee B_1 \vee \cdots
    \vee B_k
\]
and
\[
    \vdash \neg(A_1 \wedge \cdots \wedge A_n \wedge \neg B_1 \wedge
    \cdots \wedge \neg B_k)
\]

A Sequent with no Succedent ($\Gamma \vdash$) is a
\emph{Contradiction} meaning it proves falsity which is
Inconsistent. A Sequent with no Antecedent ($\vdash \Sigma$) is a
\emph{Logical Assertion} and the Succedent is a
\emph{Tautology}. Theorems are those of the form $\vdash B$ which are
the Conclusion of a Valid Proof.



% ====================================================================
\section{Proof Calculi}
% ====================================================================

\emph{Proof Calculi} are families of Formal (Deductive) Systems
(\S\ref{sec:formal_systems}), specifying templates for forms of
\emph{Formal Inference} (Axioms and Inference Rules).

% --------------------------------------------------------------------
\subsection{Axiomatic Systems}
% --------------------------------------------------------------------

\subsubsection{Hilbert Systems} \label{subsec:hilbert_systems}

\emph{Hilbert Systems} are characterized by having a large number of
Axiom Schema and few Inference Rules-- just Modus Ponens for
Propositional Logics and Universal Generalization for Predicate
Logic. In a Hilbert System, Judgements and Formulas are not
differentiated. A Theorem in a Hilbert System is the Concluding
Judgement in a Derivation.

A Hilbert System is differentiated from Systems of \emph{Natural
 Deduction} by not having any Rules that change the Context of a
Formula.

% --------------------------------------------------------------------
\subsection{Structural Proof Theory}
% --------------------------------------------------------------------

\emph{Structural Proof Theory} studies Proof Calculi that support
\emph{Analytic Proof}; that is Proofs that are \emph{Cut-free} (they
do not use the \emph{Cut Rule}) or in \emph{Normal Form}.

\subsubsection{Natural Deduction}\label{subsec:natural_deduction} \hfill
\\
Systems of \emph{Natural Deduction}\cite{prawitz65}, contrasted with
Hilbert Systems, include many Inference Rules but few or no Axioms. A
Natural Deduction System allows Judgements with multiple Antecedents
and a single Succedent
\[
    A_1,\ldots,A_n \vdash B
\]
Inference Rules in Natural Deduction have the general notation
\[
    {
        \frac{J_1 \quad J_2 \quad \cdots \quad J_n}
        {J}
    } name
\]
where the Rule with name $name$ has Premises of zero or more
Judgements $J_i$ and the Judgement $J$ is the Conclusion.

Inference Rules that introduce a Logical Connective in the Conclusion
are called \emph{Introduction Rules}. Example
\[
    {
        \frac{A\;\mathrm{true} \quad B\;\mathrm{true}}
        {(A \wedge B)\;\mathrm{true}}
    } \wedge_I
\]
where $A$ and $B$ are Propositions.

Conversely, Inference Rules that remove Logical Connectives are
\emph{Elimination Rules}.
\[
    {
        \frac{A \wedge B\;\mathrm{true}}
        {A\;\mathrm{true}}
    } \wedge_E
\]

\emph{Hypothetical Derivations} (reasoning from \emph{Assumptions})
are required for Implication Introduction or Disjunction
Elimination. The general form of a Hypothetical Derivation with
Antecedents $D_i$ and Succedent $J$:
\[
    D_1 \quad D_2 \cdots D_n
\]\[
    \vdots
\]\[
    J
\]
Introduction Rules for Implication:
\[
    {
        \frac{}
        {A\;\mathrm{true}}
    } u
\]\[
    \vdots
\]\[
    {
        \frac{B\;\mathrm{true}}
        {A \rightarrow B\;\mathrm{true}}
    } \rightarrow_{I^u}
\]
The Premise $u$ here is considered \emph{discharged} by the Rule
$I^u$; that is the scope of $u$ does not extend past $I^u$.
Elimination Rule for Implication (Modus Ponens):
\[
    {
        \frac{A \rightarrow B\;\mathrm{true} \quad A\;\mathrm{true}}
        {B\;\mathrm{true}}
    } \rightarrow_{E}
\]
Disjunctive Elimination:
\[
    \frac{
    A \vee B\;\mathrm{true} \quad
    \begin{matrix}
        {
            \frac{}
            {A\;\mathrm{true}}
        }u \\
        \vdots \\
        C\;\mathrm{true}
    \end{matrix}
    \quad
    \begin{matrix}
        {
            \frac{}
            {B\;\mathrm{true}}
        }w \\
        \vdots \\
        C\;\mathrm{true}
    \end{matrix}
    }{ C\;\mathrm{true}}\wedge_{E^{u,w}}
\]
A Theory is \emph{Locally Consistent} (or \emph{Locally Reducible}) if
an Introduction of a Connective followed by its Elimination can be
equivalently Derived without these steps.  The dual to Local
Consistency is \emph{Local Completeness} which states that Elimination
rules can decompose a Connective into the forms of its Introduction
Rule. These correspond to $\beta$-reduction and $\eta$-conversion in
$\lambda$-Calculus (\S\ref{subsec:lambda_calculus}) where Propositions
are \emph{Types} and Proofs are \emph{Programs}. If an entire
Derivation has only Eliminations followed by Introductions, it is said
to be in \emph{Normal Form}.

In a Formal Proof, the Judgements representing Antecedents are
presented as Rules with no Premises, named by a \emph{Proof Variable}
(from a countable set $V$ of variables):
\[
    \frac{}{J_1}u_1 \; \frac{}{J_2}u_2 \; \cdots \frac{}{J_n}u_n
\]\[
    \vdots
\]\[
    J
\]
where $u_i \in V$. Written in Sequent Notation:
\[
    u_1:J_1, u_2:J_2, \ldots, u_n:J_n \vdash J
\]
This convention is sometimes called \emph{Localized Hypotheses}. In
general, $\pi : A$ may be read ``$\pi$ is a proof of $A$''.

\subsubsection{Sequent Calculus}

In \emph{Sequent Calculus} a Formal Proof is a Sequence of Sequents
(\S\ref{subsec:sequent_notation}) where each successive Sequent is
Derivable from prior Sequents by Inference Rules.

The Rule for \emph{Cut} is as follows:
\[
    \frac{
        \Gamma \vdash \Delta, A \quad A, \Sigma \vdash \Pi
    }{
        \Gamma, \Sigma \vdash \Delta, \Pi
    }(Cut)
\]
It states that when a Formula $A$ that can be Concluded can also be
used as a Premise, it can be \emph{cut} out and the Derivations joined
together. That is, wherever the Lemma $A$ occurs, it can be
substituted for the Proof of $A$. This means that the Cut Rule is an
Admissible Rule (\S\ref{subsec:inference_rules}).

The \emph{Cut-elimination Theorem} states that any Judgement with a
Proof in Sequent Calculus that uses the Cut Rule may be expressed as a
\emph{Cut-free} Proof without using the Cut Rule. Usually,
demonstrating the existence of the Cut-elmination Theorem implies that
the System is Consistent since that would rule-out the possibility of
Proof of Contradiction.

\paragraph{$\mathbf{LK}$} \hfill \\

Formalization of Classical Logic (\S\ref{subsec:classical_logic})
(sound and complete in First-Order) with Sequents having zero or more
RHS Formulas. Allowing multiple RHS Formulas with a \emph{Right
  Contraction Rule} is equivalent to the admissibility of the
\emph{Law of the Excluded Middle}.

\paragraph{$\mathbf{LJ}$} \hfill \\

Formalization of Intuitionistic Logic
(\S\ref{subsec:intuitionistic_logic}) with Sequents having at most one
RHS Formula. The Cut Rule for $\mathbf{LJ}$:
\[
    \frac{
        \Gamma \vdash A \quad \Pi, A \vdash B
    }{
        \Gamma, \Pi \vdash B
    }(Cut)
\]

\paragraph{Substructural Rule Sets} \hfill \\

A Substructural Logic (\S\ref{subsec:substructural_logic}) lacking the
usual Structural Rules is usually weaker than $\mathbf{LK}$.

In Relevance Logic (\S\ref{subsec:relevance_logic}), Weakening Rules
are not included on the grounds that introduced Formulas are not
\emph{Relevant}.

In Linear Logic (\S\ref{subsec:linear_logic}), duplicate Formulas are
treated differently so Contraction and Weakening Rules are is absent
or controlled.

% --------------------------------------------------------------------
\subsection{Calculus of Structures}
% --------------------------------------------------------------------

\emph{Calculus of Structures} is a Proof Calculus with \emph{Deep
  Inference} for studying Non-commutative Logic
(\S\ref{subsec:noncommutative_logic}). Deep Inference is a
generalization of Structure to handle greater Structural complexity
\cite{schutte77}.

% --------------------------------------------------------------------
\subsection{Tableau Calculus}\label{subsec:tableau_calculus}
% --------------------------------------------------------------------

\emph{Tableau Calculus} (or \emph{Method of Analytic Tableau}) is
commonly used as a Proof procedure for Modal Logics
(\S\ref{subsec:modal_logic}). An Analytic Tableau is a tree with a
Formula at the root and a Subformula at each node. A specific Tableau
Calculus is a finite collection of Rules for breaking down Logical
Connectives into constituent parts. Rules can be expressed as Sets,
Multisets, Lists, or Trees of Formulas. If Sets of Formulas are used
at each node (\emph{Set-labeled Tableau}), they are taken in
Conjunction.

A \emph{Refutation Tableau} attempts to show that a negation of the
root Formula cannot be satisfied, thereby proving Logical Truth of the
Formula. Rules for handling Logical Connectives may produce a branch
in the tree and if a branch leads to a Contradiction, the branch is
closed and if all branches are closed the Proof is complete and the
root Formula is proved. Nodes on a single branch are considered in
Conjunction, Nodes on separate branches are considered Disjunctively.

\emph{Non-destructive Tableau Calculi} use Rules that only allow
addition of nodes, while \emph{Destructive Tableau Calculi} use Rules
that allow modification of existing nodes. \emph{Proof Confluence} is
the property of a Tableau Calculus that a closed Tableau (for an
un-satisfiable set of Propositions) can always be generated from an
arbitrary partially constructed Tableau regardless of which Rules are
chosen at each application (if a choice between Rules is available). A
\emph{Strongly Complete Tableau} is one in which every Formula in
every branch has been expanded.

A method of dealing with non-determinism of rules involving Universal
Quantification (in First-order Tableau) is called
\emph{Unification}. This allows Free Variables to be substituted in
the Rule for Eliminating Universal Quantifiers, which can later be
Unified by choosing an appropriate Term to close the branch.

\emph{Clause Tableau} (Tableau Method applied to sets of Clauses) may
be used for increased efficiency. \emph{Connection Tableau} restrict
expansion of Clause Tableau branches (not the bare root) to contain
only Literals that unify with a Literal already on the branch
(\emph{Weak Connectedness}) or a Literal in the current leaf
(\emph{Strong Connectedness}).



% ====================================================================
\section{Reverse Mathematics} \label{sec:reverse_mathematics}
% ====================================================================



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Formal Semantics}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Formal Semantics} is the general study of \emph{Interpretations}
(\S\ref{subsec:interpretation}) of \emph{Formal Languages} (Part
\ref{sec:formal_language}).



% ====================================================================
\section{Soundness}\label{sec:soundness}
% ====================================================================

An Argument in a System of Logic is \emph{Sound} if and only if the
Argument is Valid and all of its Premises are True. The Logical System
itself has the Soundness Property if and only if its Inference Rules
(\S\ref{subsec:inference_rules}) Prove only Valid Formulas under
Semantic Interpretation. This usually amounts to the simple
requirement that the Axioms are Valid and the Inference Rules preserve
Validity.



% ====================================================================
\section{Truth}\label{sec:semantic_truth}
% ====================================================================

\emph{Tarski's Undefinability Theorem} \cite{tarski36} uses the same
techniques as G\"odel's Incompleteness Theorems to show that Truth
cannot be defined in an Object Language
(\S\ref{sec:metalanguage}). The two related conceptions of Truth are
the \emph{Correspondence Theory} (\S\ref{subsec:correspondence_truth})
and \emph{Deflationary Theory} (\S\ref{subsec:deflationary_truth}).

Briefly, the Undefinability Theorem results in a \emph{Material
  Adequacy Condition} (called \emph{Convention T}) that any Theory of
Truth must entail:
\[
    \forall P (\mathrm{True}(S) \leftrightarrow P)
\]
where $S$ is the name of the Sentence $P$ in the Metalanguage which is
an Interpretation of $P$ in the Object Language. This is the
\emph{T-Schema} used in \emph{Tarski's Semantic Theory of Truth} to
Inductively define Truth, expressed as a First-order Sentence. When a
Modal Logic is based on the T-Schema it is said to give rise to
\emph{T-Theory}. Tarski's Semantic Theory of Truth is used as the
definition for Truth in \emph{Model Theory}
(\S\ref{sec:model_theory}).

An example sentence conforming to Convention T in Natural Language
where the Object Language is German and the Metalanguage is English:
\begin{description}
\item ``\emph{Der Schnee ist wei\ss} is True if and only if snow is
  white''.
\end{description}
Here the right side of the Biconditional ('snow is white') is the
\emph{Truth-Condition} of the left side.

Tarski considered this definition of Truth to be a type of
Correspondence Theory.

% --------------------------------------------------------------------
\subsection{Correspondence Theory}\label{subsec:correspondence_truth}
% --------------------------------------------------------------------

The \emph{Correspondence Theory of Truth} defines Truth of a Statement
by its relation and Correspondence with the world.

% --------------------------------------------------------------------
\subsection{Coherence Theory}
% --------------------------------------------------------------------

The \emph{Coherence Theory of Truth} defines Truth of a Statement by
its relation to other Statements.

% --------------------------------------------------------------------
\subsection{Deflationary Theory}\label{subsec:deflationary_truth}
% --------------------------------------------------------------------

A \emph{Deflationary Theory of Truth} is one that states that
ascribing Truth to a Statement does not attribute a property of Truth
to any such Statement in one of a number of different ways below.

% --------------------------------------------------------------------
\subsubsection{Redundancy Theory}
% --------------------------------------------------------------------

The \emph{Redundancy Theory of Truth} states that the Predicate of
Truth is Redundant in that it is equal to the Statement it is applied
to.\cite{ramsey27} Essentially, Truth is a \emph{periphrasis} of the
Sentence it is applied to.

% --------------------------------------------------------------------
\paragraph{Disappearance Theory}
% --------------------------------------------------------------------
\hfill \\ A \emph{Disappearance Theory of Truth} states that Truth is
both Redundant and there is no such Property of Truth. A.J. Ayer is
known for this Theory.

% --------------------------------------------------------------------
\subsubsection{Performative Theory}
% --------------------------------------------------------------------

The \emph{Performative Theory of Truth} is a Deflationary Theory that
sees the Predicate of Truth as a signal of agreement with the
Statement, for such reasons as arriving at Consensus or such others.

% --------------------------------------------------------------------
\subsubsection{Disquotational}
% --------------------------------------------------------------------

The \emph{Disquotational Theory of Truth} is a Deflationary
interpretation of Tarski's definition of Truth by W.V.O. Quine. It
states the Truth predicate has the effect of \emph{Dereferencing}
Sentences (removing the quotation marks). So
\[
    S \leftrightarrow True(``S``)
\]
that is, $S$ is equivalent to \emph{``$S$'' is true}.

The effect of adding \emph{is True} to an Assertion is then to convert
the Use of the Assertion to a Mention.

% --------------------------------------------------------------------
\subsubsection{Prosententialism}
% --------------------------------------------------------------------

\emph{Prosententialism} denies that ``is true'' is a Predicate and is
instead a \emph{Prosentence} (the Sentential analog to
\emph{Pronouns}) that stands in for another Sentence.

% --------------------------------------------------------------------
\subsubsection{Minimal}
% --------------------------------------------------------------------

\emph{Minimalism} defines Truth as a \emph{Metalinguistic} property
and that only Propositoins are Truth-bearing.

% --------------------------------------------------------------------
\subsection{Normative}
% --------------------------------------------------------------------

A \emph{Normative Theory of Truth} states that Truth is the Normative
goal of Assertion.



% ====================================================================
\section{Definition}\label{sec:semantic_definition}
% ====================================================================

\emph{Intension}

\emph{Extension}



% ====================================================================
\section{Structure}\label{sec:mathematical_structure}
% ====================================================================

A \emph{Mathematical Structure} is composed of an arbitrary Set called
a \emph{Carrier Set} or \emph{Underlying Set} (or Domain or Universe)
with one or more \emph{Operators}. Allowing \emph{Infinitary
  Operators} leads to a Theory of \emph{Complete Lattices}.

Formal definition of a Structure:
\[
    \mathcal{A} = (A, \sigma, I)
\]
with Domain $A$, Signature $\sigma$, and \emph{Interpretation
  Function} $I$. The Domain of a Structure $\mathcal{A}$ may also be
written as $|\mathcal{A}|$.

The \emph{Signature} or \emph{Vocabulary} of a Structure is the Set of
Operators (Functions and Relations) that characterize it. The
Signature is a synonym for the \emph{Type} of the Structure
(Schematically represented by $\Omega$), and can be written as an
ordered sequence of Natural Numbers representing the arity of the
Operators. The arity, $n$, of a particular Operator symbol, $s$, may
be written $n=ar(s)$. Sometimes the Signature is given as a triple
\[
    (O,F,P)
\]
where $O$ are Constants, $F$ are Functions, and $P$ are Predicates
(Relations).

A Structure with no Relation Symbols is an \emph{Algebra}
(\S\ref{subsec:universal_algebra}). A Structure with no Functions may
be used as the basis for a \emph{Relational Model}
(\S\ref{sec:relational_model}) in \emph{Database Theory}.

A \emph{Reduct} of a Structure is created by omitting certain
Operations and Relations from the Signature. The converse is
\emph{Expansion}.



% --------------------------------------------------------------------
\subsection{Interpretation}\label{subsec:interpretation}
% --------------------------------------------------------------------

Roughly, an \emph{Interpretation} of a Formal Language is an
assignment of \emph{Meanings} to Symbols and \emph{Truth-Conditions}
(\S\ref{sec:semantic_truth}) to Sentences. An Interpretation of
First-order Logic Maps Terms to Individuals in the Universe and
Propositions to Truth Values.

The Interpretation Function in a Mathematical Structure maps Function
and Relation Symbols of the Signature to actual Functions and
Relations on the Domain:
\[
    f^{\mathcal{A}} = I (f)
\]
\[
    R^{\mathcal{A}} = I (R) \subseteq A^{ar(R)}
\]
A Constant (Nullary) Symbol is identified with an Element of the
Domain:
\[
    I(c) \in A
\]

Thus the Interpretation Function is the \emph{Extension}
(\S\ref{subsec:set_property}) of the Symbols and Strings of Symbols of
the Object Language.



% --------------------------------------------------------------------
\subsection{Semantic Consequence}\label{subsec:semantic_consequence}
% --------------------------------------------------------------------

\emph{Semantic Consequence} is written as
\[
    T \vDash_{\mathcal{S}} \varphi
\]
where $T$ is a Theory of a Formal System $\mathcal{S}$ and $\varphi$
is a Formula that is the Semantic Consequence of that Theory. This
Relation can only be True if there exists a Structure which
\emph{Satisfies} (\S\ref{subsec:satisfaction}) both $T$ and
$\varphi$. A \emph{Tautology} is expressed as
\[
    \vDash {\varphi}
\]
where a Formula $\varphi$ is the Semantic Consequence of the Empty
Set.



\subsubsection{Valuation}\label{subsec:model_valuation}

A \emph{Valuation} is the assignment of Values to Variables of a
Formula.

\emph{Supervaluation}



% --------------------------------------------------------------------
\subsection{Substructure}\label{subsec:model_substructure}
% --------------------------------------------------------------------

A Structure $\mathcal{A}$ is an \emph{Induced Substructure} of
Structure $\mathcal{B}$ when
\begin{itemize}
\item $\sigma(\mathcal{A}) = \sigma(\mathcal{B})$
\item $A \subseteq B$
\item $I_{\mathcal{A}}=I_{\mathcal{B}}$
\end{itemize}
denoted by the notation $\mathcal{A} \subseteq \mathcal{B}$ where
$\mathcal{B}$ is called the \emph{Extension} or \emph{Superstructure}
of $\mathcal{A}$.

A Substructure $A$ is an \emph{Elementary Substructure} of $B$ if $A$
and $B$ both \emph{Satisfy} (\S\ref{subsec:satisfaction}) the same
Sentences. Here $B$ would be an \emph{Elementary Extension} of $A$.

When a Structure is applied as a \emph{Model}
(\S\ref{sec:model_theory}) of a particular Theory
(\S\ref{subsec:formal_theory}), if no extensions of that Structure
result in Theories that are Consistent, that Theory is termed
\emph{Complete}. A Theory $T$ is called \emph{Model Complete}
(\S\ref{subsec:model_completion}) if every Substructure of a Model of
$T$ is itself a Model of $T$.

Induced Substructures (and \emph{Closed Subsets} described in the next
section) on a Structure form a \emph{Lattice}.



\subsubsection{Closed Subsets}

A Subset of a Domain is a \emph{Closed Subset} if it is closed under
the Operators of the Structure. For any Subset, $B$, of a Domain,
$|\mathcal{A}|$, there is a \emph{smallest Closed Subset} of
$|\mathcal{A}|$ that contains $B$ called the \emph{Hull} of $B$
denoted by $\langle B \rangle$ or $\langle B \rangle_{\mathcal{A}}$,
which is said to be \emph{generated} by $B$. $\langle \rangle$ is the
\emph{Finitary Closure Operator} (\S\ref{subsec:finitary_closure}).



\subsubsection{Embedding}\label{subsec:sigma_embedding}

% FIXME Generalized embedding, instances in specific domains

An \emph{$\sigma$-Embedding} of two $\sigma$-Structures $\mathcal{A}$
and $\mathcal{B}$ is given by an Injective Map $h: A \hookrightarrow
B$ (the ``hooked arrow'' is used to indicate the Map is an Embedding)
where
\begin{itemize}
\item for every $f_n \in \sigma$ and $a_1, \ldots, a_n \in A^n$,
  $h(f_{n}^A(a_1,\ldots,a_n)) = f_{n}^B(h(a_1),\ldots,h(a_n))$
\item for every $R_n \in \sigma$ and $a_1, \ldots, a_n \in A^n$, $A
  \vDash R(a_1, \ldots, a_n) \leftrightarrow B \vDash R(h(a_1),
  \ldots, h(a_n))$
\end{itemize}
Such an Embedding is an \emph{Elementary Embedding} if $h(A)$ is an
Elementary Substructure (\S\ref{subsec:model_substructure}) of $B$.



% ====================================================================
\section{Algebraic Logic}
% ====================================================================

\emph{Algebraic Logic} is the reasoning arising from the manipulation
of Equations with Free Variables. Algebraic Logic deals with
\emph{Algebraic Semantics} of Classes of Algebras which are the
specification of Semantics based on \emph{Abstract Algebra}
(\S\ref{sec:abstract_algebra}). This allows the matching of Logical
Systems with Structures that Model (\S\ref{sec:model_theory}) them.

% --------------------------------------------------------------------
\subsection{Abstract Algebraic Logic}
% --------------------------------------------------------------------

\emph{Abstract Algebraic Hierarchy} (also called the \emph{Leibniz Hierarchy})

% --------------------------------------------------------------------
\subsection{Term Algebra}\label{subsec:term_algebra}
% --------------------------------------------------------------------

A \emph{Term Algebra} (also termed \emph{Absolutely Free Algebra} or
\emph{Anarchic Algebra}) is an Algebraic Structure freely generated
over a given Signature. In Category Theory a Term Algebra is an
\emph{Initial Algebra} for the Category of all Algebras with a given
Signature.

A \emph{Free Algebra}, $\mathbf{A}$, is defined by a Set of \emph{Free
  Generators}, $S$, and a Type Signature, $\rho$, which Generate an
Underlying Set, $A$. If $\psi : S \rightarrow A$ is a Function,
$\mathbf{A}$ may be represented by the Free Algebra $(A,\psi)$ if for
every Algebra $\mathbf{B}$ of type $\rho$ with Function $\tau : S
\rightarrow B$, there exists a unique Homomorphism $\sigma : A
\rightarrow B$ such that $\sigma\psi = \tau$.

% --------------------------------------------------------------------
\subsubsection{Herbrand Universe}\label{subsec:herbrand_universe}
% --------------------------------------------------------------------
\hfill \\
A \emph{Herbrand Universe} is a Structure in Logic generated by a Set
of Clauses over a Set of Constant and Function Symbols. This results
in the Herbrand Universe being composed of all Ground Terms (Terms
without Variables).

A \emph{Herbrand Base} is the set of all \emph{Ground Atoms} (Atomic
Formulas (\S\ref{subsec:formation_rules}) in which only Ground Terms
appear).

% --------------------------------------------------------------------
\subsubsection{Quotient Algebra}\label{subsec:quotient_algebra}
% --------------------------------------------------------------------

For an Algebra $\mathbf{A}$ with Underlying Set $A$, the
\emph{Quotient Set}, $A / E$ is the Partitioning of $A$ into
Equivalence Classes by a \emph{Congruence Relation}
(\S\ref{subsec:congruence_relation}) $E$. Since the Operators are
Compatible with the Equivalence Classes of the Quotient Set, these
Classes are \emph{Quotient Algebras}.

% --------------------------------------------------------------------
\subsection{Universal Algebra}\label{subsec:universal_algebra}
% --------------------------------------------------------------------

%FIXME: ref Complete Lattices
Universal Algebra is the study of \emph{Algebraic Structure} (as
opposed to specific instances of Algebraic Systems). Universal Algebra
together with \emph{Category Theory} (Part \ref{sec:category_theory})
makes up \emph{Abstract Algebra} (\S\ref{sec:abstract_algebra}). An
Algebraic Structure differs from a general \emph{Mathematical
  Structure} in that its Signature consists of only Function Symbols
and no Relation Symbols.

An Algebra may be limited by Axioms of \emph{Equational Laws} (eg. the
Associative Axiom).



\subsubsection{Variety}\label{subsec:model_variety}

%FIXME ref Fields, Homomorphism, Subalgebra, Direct Product
A \emph{Variety} is a \emph{Class} of Algebras defined only by Axioms
that are Identities satisfied by a given Signature
(\S\ref{sec:formal_systems}). This is equivalent to saying a Variety
is the Class of Algebraic Structures with the same Signature that is
closed under \emph{Homomorphic Images}, \emph{Subalgebras}, and
\emph{Direct Products}; a result known as the \emph{HSP Theorem} or
\emph{Birkhoff's Theorem}\cite{birkhoff35}. This rules out Logical
Connectives, Existential Quantification, and all Relations besides
Equality (thus excluding the Class of \emph{Fields}) and Identities
being implicitly Universally Quantified over the Domain.

Algebraic Structures in a Variety are Quotient Algebras
(\S\ref{subsec:quotient_algebra}) generated by the Set of Identities
on the Term Algebra generated from the Signature and Underlying Set.

A \emph{Subvariety} is a Subclass of a Variety with the same Signature
(eg. the Class of \emph{Abelian Groups} is a Subvariety of the Class
of \emph{Groups}). Classes of Finite Algebras (Algebras with a finite
Underlying Set) are sometimes called \emph{Pseudovarieties}.

An example of a Variety with Signature $\Omega = (2)$ is the Class of
all \emph{Semigroups} with an equation defining the Associative Law:
\[
    x(yz) = (xy)z
\]

%FIXME: ref homomorphism
A Homomorphism between two Algebras $A$ and $B$ is a function $h: A
\rightarrow B$ defined for $n$-ary Operations:
\[
\forall f_A \in A, f_B \in B, h(f_A(x_1, ..., x_n)) = f_B(h(x_1), ...,
h(x_n))
\]

A Subalgebra of an Algebra, $A$, is a Subset of $A$ that is closed
under all the operations of $A$.

The Product of a set of Algebraic Structures is the \emph{Cartesian
  Product} of the Sets with the Operations defined coordinatewise.

% --------------------------------------------------------------------
\subsection{Elementary Class}\label{subsec:elementary_class}
% --------------------------------------------------------------------

A Class of Structures, $K$, with Signature $\sigma$ is an
\emph{Elementary Class} if there is a First-order Theory, $T$, with
Signature $\sigma$ such that $K$ contains all Models of $T$.
Expressed with the \emph{Satisfaction Relation}
(\S\ref{subsec:satisfaction}):
\[
    \mathcal{M} \in \mathcal{E}_T \leftrightarrow \mathcal{M} \vDash T
\]
where $\mathcal{E}_T$ is an Elementary Class, $\mathcal{M}$ is a
Model, and $T$ is a Theory.

If $T$ has only a single Sentence, then $K$ is a \emph{Basic
  Elementary Class}. The Reduct (\S\ref{sec:mathematical_structure})
of an Elementary Class is a \emph{Pseudoelementary Class}.

Elementary Classes are termed \emph{Axiomatizable in First-Order
  Logic} (or simply \emph{Axiomatizable} when implicitly First-Order).

The notion of \emph{Strength} of Formal Systems is defined in terms of
Elementary Clases. A Logic $\alpha$ is equal to another Logic $\beta$
when every Elementary Class in $\beta$ is an Elementary Class in
$\alpha$.

% --------------------------------------------------------------------
\subsection{Ultraproducts}\label{subsec:ultraproducts}
% --------------------------------------------------------------------



% ====================================================================
\section{Model Theory}\label{sec:model_theory}
% ====================================================================

\emph{Model Theory}, Formal Language (Part \ref{sec:formal_language}),
and Formal Logic (\S\ref{sec:formal_systems}) together compose the
study of \emph{Metalogic}. One definition of Model Theory is the
combination of Formal Logic with \emph{Universal Algebra}
(\S\ref{subsec:universal_algebra}). An alternative view of Model
Theory equates it with \emph{Algebraic Geometry}
(\S\ref{subsec:algebraic_geometry}). The broadest definition of Model
Theory includes four divisions: Classical Model Theory, Model Theory
of Groups and Fields, Geometric Model Theory, and Computable Model
Theory (\S\ref{subsec:computable_model_theory}).

\emph{Models} are \emph{Interpretations}
(\S\ref{subsec:interpretation}) of Theories
(\S\ref{subsec:formal_theory}) in a Formal Language. That is, an
Interpretation is a Model if it assigns Truth values to the Sentences
of a Theory. Model Theory uses Tarski's Semantic Theory of Truth
(\S\ref{sec:semantic_truth}) as the definition of Truth. Model Theory
also forms the foundation of \emph{Formal (Truth-conditional)
  Semantics}-- a reduction of the Meaning of Assertions in Natural
Languages to their Truth-conditions.

% --------------------------------------------------------------------
\subsection{Satisfaction}\label{subsec:satisfaction}
% --------------------------------------------------------------------

When defining a Theory as a set of Sentences in a Formal Language, a
\emph{Model} is an \emph{Interpretation} that \emph{Satisfies} the
Sentences of that Theory. For a Formula $\phi$ and a Structure
$\mathcal{M}$, a \emph{Satisfaction Relation} is denoted:
\[
    \mathcal{M} \vDash \phi
\]
For $\mathcal{M}$ to be a Model of a Theory, $T$, it is required that:
\begin{itemize}
\item The Language of $\mathcal{M}$ is the same as the Language of $T$
\item Every Sentence in $T$ is Satisfied by $\mathcal{M}$
\end{itemize}
%FIXME ref completeness theorem
By the Completeness Theorem a Consistent Theory is Satisfiable, that
is, a Theory has a Model if and only if it is Consistent. The
Compactness Theorem (\S\ref{subsec:firstorder_properties}) implies
that a Theory has a Model if and only if every Finite Subset of the
Sentences in that Theory also have Models.

% --------------------------------------------------------------------
\subsection{Compactness Theorem}
% --------------------------------------------------------------------

%FIXME

% --------------------------------------------------------------------
\subsection{Quantifier Elimination}
% --------------------------------------------------------------------

Within a Theory $T$, if every First-order Formula $\varphi(x_1,
\ldots, x_n)$ with Quantifiers is equivalent to a First-order Formula
$\psi(x_1, \ldots, x_n)$ without Quantifiers, $T$ is said to have the
property of \emph{Quantifier Elimination}. A Theory without Quantifier
Elimination may be made to have it by adding Symbols to its Signature.

% --------------------------------------------------------------------
\subsection{Model Completion}\label{subsec:model_completion}
% --------------------------------------------------------------------

A First-order Theory $T$ is called \emph{Model Complete} if every
Embedding (\S\ref{subsec:sigma_embedding}) of Models of $T$ is an
Elementary Embedding.

A Theory $T^*$ is a \emph{Companion} of another Theory $T$ if every
Model of $T$ can be Embedded in a Model of $T^*$ and likewise every
Model of $T^*$ can be Embedded in a Model of $T$. A \emph{Model
  Companion} is a \emph{Companion} of a Theory that is \emph{Model
  Complete}.

%FIXME ref Amalgamation Property
A \emph{Model Completion} is a Model Companion $T^*$ of a Model $T$
that has the \emph{Amalgamation Property}. This means that every Model
of $T$ can be uniquiely Embedded in a Model of $T^*$.

% --------------------------------------------------------------------
\subsection{Categoricity}
% --------------------------------------------------------------------

%FIXME ref Cardinal, Lowenheim-Skolem
A Theory is termed \emph{Categorical} if all its Models are
Isomorphic. With this definition and the L\"owenheim-Skolem Theorem it
follows that any First-order Theory with a Model of infinite
Cardinality can't be Categorical.

For a Cardinal $\kappa$, a Theory $T$ is \emph{$\kappa$-Categorical}
if any two Models of $T$ of Cardinality $\kappa$ are Isomorphic to one
another. By \emph{Morley's Categoricity Theorem}\cite{morley65} if a
First-order Theory in a Countable Language is Categorical in an
Uncountable Cardinal $\kappa$, then it is Categorical in all
Uncountable Cardinalities. There are three possible cases for
$\kappa$-Categoricity:
\begin{description}
\item[Totally Categorical] $\kappa$-Categorical for all Infinite
  Cardinals
\item[Uncountably Categorical] $\kappa$-Categorical if and only if
  $\kappa$ is an Uncountable Cardinal
\item[Countably Categorical] $\kappa$-Categorical if and only if
  $\kappa$ is a Countable Cardinal
\end{description}
The special case of $\kappa = \aleph_0$ is called
\emph{$\omega$-Categorical}.

% --------------------------------------------------------------------
\subsection{Interpretability}
% --------------------------------------------------------------------

Given two Structures, $M$ and $N$, an \emph{Interpretation} of $M$ in
$N$ is a pair $(n,f)$ where
\begin{itemize}
    \item $n \in \mathbb{N}$
    \item $f:f_{dom} \subset N^n \rightarrow M$ such that the
      $f^k$-preimage of every set $X \subseteq M^k$ definable in $M$
      by a First-order Formula is definable in $N$ by a First-order
      Formula
\end{itemize}

Two Structures are \emph{Bi-interpretable} if they can be interpreted
in each other. This can be used to define an Equivalence Relation
between Structures.

% --------------------------------------------------------------------
\subsection{Abstract Model Theory}
% --------------------------------------------------------------------

\subsubsection{Abstract Logic}

An \emph{Abstract Logic} is a Formal System that consists of a Class
of Sentences with a Satisfaction Relation
(\S\ref{subsec:satisfaction}).

%FIXME compactness, lowenheim-skolem
\emph{Lindstr\"om's Theorem} states that First-order Logic is the
Strongest (\S\ref{subsec:elementary_class}) Logic which has both
Countable Compactness and the Downward L\"owenheim-Skolem Property.

\subsubsection{Institutional Model Theory}

\emph{Institutional Model Theory} generalizes First-order Model Theory
to arbitrary Logical Systems formalized as \emph{Institutions}
(\S\ref{subsec:institution_theory}).

% --------------------------------------------------------------------
\subsection{Finite Model Theory}
% --------------------------------------------------------------------

\emph{Finite Model Theory} (FMT) is a restriction of Model Theory to
Interpretations of Finite Structures.

A Finite Structure can always be described by a single First-order
Sentence. An example structure of $n$ Elements:
\[
    \exists x_1 \cdots \exists x_n ( \varphi_1 \wedge \cdots \wedge
    \varphi_m )
\]
This may be extended to a Finite number of Structures:
\[
    \exists x_1 \cdots \exists x_n ( \varphi_1 \wedge \cdots \wedge
    \varphi_m )
    \vee
    \cdots
    \vee
    \exists x_1 \cdots \exists x_p ( \psi_1 \wedge \cdots \wedge
    \psi_q )
\]
Note the difference here with Infinite First-order Model Theory in
which a Model cannot be uniquely determined by a set of First-order
Sentences because of the Compactness Theorem (For every Infinite Model
a Non-isomorphic Model exists).

The ability of a \emph{Property} (\S\ref{subsec:set_property}) $P$ to
be expressed in First-order Logic may be determined by whether two
Structures $A \in P$ and $B \notin P$ satisfy all the same First-order
Sentences:
\[
    A \vDash \alpha \leftrightarrow B \vDash \alpha
\]

\subsubsection{Finite Model Property}

A System of Logic $S$ has the \emph{Finite Model Property} if there is
a Class of Models $\mathrm{M}$ such that any non-Theorem of $S$ is
Falsified by some Finite Model in $\mathrm{M}$. If $fmp(S)$, $A$ is a
$S$-theorem if and only if $A$ is a Theorem of the Theory of Finite
Models of $S$.

If $S$ is Finitely Axiomatizable (\S\ref{subsec:axiomatization}) and
$fmp(S)$ then it is Decidable (\S\ref{subsec:decidability}).

% --------------------------------------------------------------------
\subsection{Computable Model Theory}\label{subsec:computable_model_theory}
% --------------------------------------------------------------------

\cite{harizanov98}

% --------------------------------------------------------------------
\subsection{Geometric Model Theory}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsubsection{Classification Theory}
% --------------------------------------------------------------------

\emph{Classification Theory} is the division of Theories based on
their \emph{Stability} which is the ability of the Models of the
Theory to be \emph{Classified}.

% --------------------------------------------------------------------
\subsubsection{Types}
% --------------------------------------------------------------------

An \emph{$n$-type} of a Model, $\mathcal{M}$, over a (possibly empty)
Subset of Constants, $A \in M$, is a set of Formulas,
$p(x_1,\ldots,x_n) = p(\mathbf{x})$, with at most $n$ Free Variables
in the Language $L(A)$, formed by adding the members of $A$ to the
Language of $\mathcal{M}$:
\[
    L(A) = L \cup \{ c_a : a \in A \}
\]
such that for every Finite Subset $p_0(\mathbf{x}) \subseteq
p(\mathbf{x})$ there exist Elements $b_1,\ldots,b_n \in M$ with
$\mathcal{M} \vDash p_0(b_1,\ldots,b_n)$.

A \emph{Complete Type} is \emph{Maximal}
(\S\ref{subsec:formal_theory})) under Inclusion such that $\forall
\phi(\mathbf{x}) \in L(A,\mathbf{x})$ either $\phi(\mathbf{x}) \in
p(\mathbf{x})$ or $\neg \phi(\mathbf{x}) \in p(\mathbf{x})$. A
non-Complete type is called a \emph{Partial Type}.

An $n$-type is \emph{Realized} in $\mathcal{M}$ if there is an Element
$\mathbf{b} \in M^n$ such that $\mathcal{M} \vDash
p(\mathbf{b})$. This is guaranteed by the Compactness Theorem
(\S\ref{subsec:firstorder_properties}) in either $\mathcal{M}$ or an
Elementary Extension (\S\ref{subsec:model_substructure}) of
$\mathcal{M}$. This is denoted by $tp_{n}^{\mathcal{M}}(\mathbf{b}/A)$
which is read as ``the Complete Type of $\mathbf{b}$ over $A$''.

A Type $p(\mathbf{x})$ is \emph{Isolated} by a Formula
$\varphi(\mathcal{x})$ if $\forall \psi(\mathbf{x}) \in
p(\mathbf{x})$, $\varphi (\mathbf{x}) \rightarrow
\psi(\mathbf{x})$. Isolated Types are Realized in every Elementary
Substructure or Extension.

\paragraph{Saturation}\label{subsec:model_saturation}\hfill
\\

A Model $\mathcal{M}$ is \emph{$\kappa$-saturated} (where $\kappa$ is
a Cardinal number) if for all $A \subseteq M$ of Cardinality $<
\kappa$, $M$ Realizes all Complete Types over $A$. A Model is
\emph{Saturated} if it is $|M|$-saturated where $|M|$ is the
Cardinality of $M$.

\subsubsection{Stability}\label{subsec:model_stability}

A Theory $T$ is \emph{$\kappa$-stable} for an Infinite Cardinal $\kappa$
if for every set $A$ such that $|A| = \kappa$, the Set of Complete
Types over $A$ has Cardinality $\kappa$. Theories are Classified with
the following terms:
\begin{description}
\item [Stable] $\kappa$-stable for some Infinite Cardinal $\kappa$
\item [Unstable] not $\kappa$-stable for all Infinite Cardinals $\kappa$
\item [Superstable] $\kappa$-stable for all sufficiently large
  Cardinals $\kappa$
\item [Totally Transcendental] \emph{Morley Rank}\cite{morley65} less
  than $\infty$
\end{description}



% ====================================================================
\section{Frame Semantics}\label{sec:frame_semantics}
% ====================================================================

\emph{Frame Semantics} is the extension of Model Theory to
Non-classical Logic Systems, beginning with Modal Logic
(\S\ref{subsec:modal_logic}).

% --------------------------------------------------------------------
\subsection{Kripke Semantics}\label{subsec:kripke_semantics}
% --------------------------------------------------------------------

\begin{description}
\item [Kripke Frame] $\langle W,R \rangle$ where $W$ is a Non-empty
  Set of \emph{Nodes} (\emph{Worlds}) and $R$ is a Binary Relation
  called the \emph{Accessibility Relation}
\item [Kripke Model] $\langle W,R,\Vdash \rangle$ where $\Vdash$ is a
  \emph{Forcing Relation} for Nodes of $W$
\end{description}
Accessbility Relation % FIXME describe accessibility

The Forcing Relation $\Vdash$ (read as Satisfies or \emph{Forces}
(\S\ref{subsec:forcing})) has the following properties:
\begin{itemize}
\item $w \Vdash \neg A$ if and only if $w \nVdash A$
\item $w \Vdash A \rightarrow B$ if and only if $w \nVdash A$ or $w
  \Vdash B$
\item $w \Vdash \square A$ if and only if $u \Vdash A$ for all $u$
  such that $w R u$
\end{itemize}
\emph{Validity} of a Proposition is defined for
\begin{itemize}
\item Model $\langle W,R, \Vdash \rangle$ if $\forall w \in W,
  w \Vdash A$
\item Frame $\langle W,R \rangle$ if Valid in Model $\langle W,R,
  \Vdash \rangle$ for all choices of $\Vdash$
\item Class of Frames or Models, $C$, if Valid for all Frames or
  Models of the Class
\end{itemize}
$Thm(C)$ is defined as the Set of all Formulas Valid
(\S\ref{sec:logic_terminology}) in $C$. For a Set of Formulas $X$,
$Mod(X)$ is defined as the Class of all Frames which Validate every
Formula in $X$.

A Modal Theory, $T$, is \emph{Sound} (\S\ref{sec:soundness}) with
respect to a Class of Frames, $C$, if $T \subseteq Thm(C)$. $T$ is
\emph{Complete} with respect to $C$ if $T \supseteq Thm(C)$.

For any $C$, $Thm(C)$ is a \emph{Normal Modal Logic}
(\S\ref{subsec:alethic_logic}). A Normal Modal Logic is said to
\emph{Correspond} to $C$ if $C = Mod(L)$.

The \emph{Canonical Model} of a Modal Theory $T$ is a Kripke Model
$\langle W,R, \Vdash \rangle$ where $W$ is the Set of all Maximally
Consistent Sets for $T$ (\S\ref{subsec:formal_theory}) and:
\begin{itemize}
\item $XRY$ if and only if for all Formulae $A$, if $\square A
  \in X$ then $A \in Y$
\item $X\Vdash A$ if and only if $A \in X$
\end{itemize}

%FIXME

\emph{Unravelling}

\emph{Filtration}

% --------------------------------------------------------------------
\subsection{General Frame Semantics}
% --------------------------------------------------------------------

A \emph{Modal General Frame} is defined as a triple $\mathbf{F} =
\langle W,R,V \rangle$ where $\langle W,R \rangle$ is a Kripke Frame
and $V$ is a Set of Subsets of $W$ closed under Intersection, Union,
Complement, and the Operation $\square$ defined as
\[
    \square A = \{x \in W; \forall y \in W ( x R y \rightarrow y \in A ) \}
\]

% --------------------------------------------------------------------
\subsection{Intuitionistic Semantics}
% --------------------------------------------------------------------

The Semantics of Intuitionistic Logic
(\S\ref{subsec:intuitionistic_logic}) is definable as Kripke Semantics
(\S\ref{subsec:kripke_semantics}) or \emph{Heyting Algebra Semantics}.

\subsubsection{Heyting Algebra Semantics}\label{subsec:heyting_semantics}

Instead of assigning Valuations from a Boolean Algebra, Intuitionistic
Semantics uses Values from a \emph{Heyting Algebra}
(\S\ref{subsec:heyting_algebra}). A Formula is Valid if and only if it
receives the Value of the Top Element for any Valuation.

% --------------------------------------------------------------------
\subsection{Kripke-Joyal Semantics}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Boolean-valued Model}
% --------------------------------------------------------------------

\emph{Boolean-valued Models} are related to Heyting Algebras and
Intuitionistic Logic and is equivalent to the method of Forcing.

%FIXME ref complete boolean algebra
Instead of limiting Formulas in a System $S$ to True or False, they
may be assigned values from a fixed \emph{Complete Boolean Algebra}.



% ====================================================================
\section{Proof-theoretic Semantics}
% ====================================================================

\emph{Proof-theoretic Semantics} is based on the Propositions and
Logical Connectives of Systems of Inference (Part
\ref{sec:formal_systems}). See also \emph{Semantic Tableau}
(\S\ref{subsec:tableau_calculus}).

% --------------------------------------------------------------------
\subsection{Logical Harmony} \label{subsec:logical_harmony}
% --------------------------------------------------------------------

\emph{Logical Harmony} refers to constraints required between
Introduction and Elimination Rules.



% ====================================================================
\section{Probabilistic Semantics}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Truth-value Semantics}
% --------------------------------------------------------------------

\emph{Truth-value Semantics} is also called the \emph{Substitution
  Interpretation} for Quantifiers or \emph{Substitutional
  Quantification}.



% ====================================================================
\section{Composition Semantics}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Linear Semantics}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsubsection{Game Semantics}
% --------------------------------------------------------------------

\emph{Game Semantics} studies the \emph{Dialogical} properties of
Semantics. It is used in connection with Intuitionistic Logic
(\S\ref{subsec:intuitionistic_logic}) and Linear Logic
(\S\ref{subsec:linear_logic}).

% --------------------------------------------------------------------
\subsection{Independence-friendly Semantics}
% --------------------------------------------------------------------

Semantics of Independence-friendly Logics
(\S\ref{subsec:independence_logic}) is defined by Game Semantics where
players have Imperfect Information.

% --------------------------------------------------------------------
\subsection{Denotational Semantics}
% --------------------------------------------------------------------

Expressions in a Programming Language are interpreted as Mathematics
Objects called \emph{Denotations}.



% ====================================================================
\section{Operational Semantics}
% ====================================================================

\emph{Operational Semantics} are used in the interpretation of
Programming Languages.

\emph{Concurrency}

% --------------------------------------------------------------------
\subsection{Structural Semantics}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsubsection{Reduction Semantics}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Natural Semantics}
% --------------------------------------------------------------------



% ====================================================================
\section{Axiomatic Semantics}
% ====================================================================

\emph{Axiomatic Semantics} equates Meaning of a Sentence with the
Logical Formulas that describe it; that is what can be proven about it
in some System of Logic.



% ====================================================================
\section{Untyped $\lambda$-Calculus}\label{sec:untyped_lambda}
% ====================================================================

\emph{Untyped $\lambda$-Calculus} describes a Semantics for
\emph{Computable Functions} (\S\ref{sec:computable_function}).

\emph{Lambda Terms}

\emph{Free Variables}

\emph{Anonymous Functions}

\emph{Lambda Abstraction}

\emph{Application}

% --------------------------------------------------------------------
\subsection{Computation Rule}\label{subsec:computation_rule}
% --------------------------------------------------------------------

\[
    (\lambda x.t)(u) :\equiv t[u/x]
\]

% --------------------------------------------------------------------
\subsection{Alpha Equivalence}\label{subsec:alpha_equivalent}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Capture-avoiding Substitution}\label{subsec:capture_avoiding}
% --------------------------------------------------------------------

\emph{Capture-avoiding Substitution}

% --------------------------------------------------------------------
\subsection{Beta Reduction}\label{subsec:beta_reduction}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Eta Conversion}\label{subsec:eta_conversion}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Normalization \& Confluence}\label{subsec:normalization_confluence}
% --------------------------------------------------------------------



% ====================================================================
\section{Inner Model Theory}\label{sec:inner_model_theory}
% ====================================================================



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Computation Theory}\cite{czoo14}\label{sec:recursion_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

also \emph{Recursion Theory}

\emph{Church-Turing}



% ====================================================================
\section{Effective Method}\label{sec:effective_method}
% ====================================================================

An \emph{Effective Method} is a mechanical procedure for solving a
\emph{Function} (\S\ref{sec:set_function}) or \emph{Decision Problem}
(\S\ref{subsec:decidability}) of a specific \emph{Complexity Class}
(\S\ref{sec:complexity_theory}).



% ====================================================================
\section{Noncomputable Function}\label{sec:noncomputable_function}
% ====================================================================

also \emph{Undecidable Function}

\emph{Algorithmically Unsolvable}

\emph{Turing Degree}



% ====================================================================
\section{Computable Function}\label{sec:computable_function}
% ====================================================================

\emph{Computable Number} (\S\ref{subsec:computable_real})

\emph{Computable Functions} are the formalized analogues of
\emph{Algorithms} (\S\ref{subsec:algorithm}); that is a Function that
is \emph{Effectively Calculable} by an Effective Method
(\S\ref{sec:effective_method}).

\emph{Computable Functions} may be broadly divided into two Classes by
whether they are \emph{Partial} or \emph{Total}. A Total Computable
Function is sometimes called a (Total) \emph{Recursive} or
\emph{Decidable Function}.

There are several equivalent definitions of the class of Computable
Functions, which have reference to different \emph{Models of
  Computation} (\S\ref{sec:computation_model}):
\begin{enumerate}
\item Turing-computable Functions
\item $\mu$-recursive Functions
\item $\lambda$-recursive Functions
\end{enumerate}

% --------------------------------------------------------------------
\subsection{Partial Computable Function}\label{subsec:partial_recursive}
% --------------------------------------------------------------------

A \emph{Partial Computable Function} (\emph{Partial Recursive
  Function}) is also called \emph{Semidecidable} or \emph{Recursively
  Enumerable} and are the Class of Functions capable of generating
\emph{Recursively Enumerable Sets}
(\S\ref{subsec:recursively_enumerable}). A Set, $T$, is
\emph{Co-recursively Enumerable} if the Compliment $\mathbb{N} \ T$ is
Recursively Enumerable.

\emph{Recursively Enumerable} $\mathsf{coRE}$

The Lattice (\S\ref{subsec:lattice}) of $\mathsf{RE}$ Sets under
Inclusion is denoted $\mathcal{E}$.

% --------------------------------------------------------------------
\subsection{Total Computable Function}\label{subsec:recursive_function}
% --------------------------------------------------------------------

\emph{Total Recursive Function}

% --------------------------------------------------------------------
\subsubsection{Primitive Recursion}\label{subsec:primitive_recursion}
% --------------------------------------------------------------------

The Class of \emph{Primitive Recursive Functions}, $\mathsf{PR}$, are
those given by three Axioms:
\begin{enumerate}
    \item The $0$-ary \emph{Constant Function}, $0$, is Primitive
      Recursive
    \item The $1$-ary \emph{Successor Function}, $S(k) = k + 1$, is
      Primitive Recursive
    \item The $n$-ary \emph{Projection Function}, $P_i^n = k_i$,
      (returning the $i$th argument) is Primitive Recursive
\end{enumerate}
and the Operations:
\begin{enumerate}
    \item \emph{Composition}: Given a $k$-ary function, $f$, and $k$
      $m$-ary Primitive Recursive Functions, $g_1, \ldots, g_k$,
    \item \emph{Primitive Recursion}:
\end{enumerate}



% ====================================================================
\section{Models of Computation}\label{sec:computation_model}
% ====================================================================

% --------------------------------------------------------------------
\subsection{$\mu$-recursive Function}\label{subsec:mu_recursive}
% --------------------------------------------------------------------

also \emph{Partially Recursive Functions}

% --------------------------------------------------------------------
\subsection{Turing Machine}
% --------------------------------------------------------------------

See Part \ref{sec:automata_theory} Automata Theory
\S\ref{subsec:turing_machine} Turing Machines

\subsubsection{Post-Turing Machine}\label{subsec:post_turing}

% --------------------------------------------------------------------
\subsection{$\lambda$-Calculus}\label{subsec:lambda_calculus}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Tag System}\label{subsec:tag_system}
% --------------------------------------------------------------------

also \emph{Post Tag Machine}

% --------------------------------------------------------------------
\subsection{Register Machine}\label{subsec:register_machine}
% --------------------------------------------------------------------

\subsubsection{Counter Machine}

\subsubsection{Pointer Machine}

\subsubsection{Random Access Machine}

\subsubsection{Random Access Stored Program Machine}



% ====================================================================
\section{Complexity Theory}\label{sec:complexity_theory}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Algorithm}\label{subsec:algorithm}
% --------------------------------------------------------------------

An \emph{Algorithm} may be formalized as a sequence of operations that
can be simulated by a Turing-complete system and any function that is
computable by Algorithm is a Computable Function
(\S\ref{sec:computable_function}).

\subsubsection{Algorithmic Randomness}\label{subsec:algorithmic_randomness}

% --------------------------------------------------------------------
\subsection{Function Problem}\label{subsec:function_problem}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Complexity Class}\label{subsec:complexity_class}
% --------------------------------------------------------------------

\[
    \mathsf{PR} \subset \mathsf{R} = \mathsf{RE} \cap \mathsf{coRE}
\]



% --------------------------------------------------------------------
\subsection{Hierarchies}\label{subsec:complexity_hierarchy}
% --------------------------------------------------------------------

\[
    \mathsf{AC^0} \subseteq \mathsf{L} \subseteq \mathsf{NC} \subseteq
    \mathsf{P} \subseteq \mathsf{PSPACE} \subseteq \mathsf{EXP}
    \subseteq \mathsf{ALL}
\]

\[
    \Delta_0 = \Sigma_0 = \Pi_0 = \mathsf{R}
\]\[
    \Sigma_1^0 \leftrightarrow \mathsf{RE}
\]\[
    \Pi_1^0 \leftrightarrow \mathsf{coRE}
\]


\emph{Lightface} (no \emph{Set Parameters}) %FIXME explain ``set parameters''
\[
    \Sigma, \Pi, \Delta
\]

\emph{Boldface} (standard hierarchy of Borel Sets)
\[
    \mathbf{\Sigma}, \mathbf{\Pi}, \mathbf{\Delta}
\]

Formulas are considered in \emph{Prenex Normal Form}
(\S\ref{subsec:prenex_normal}).
\[
    \Sigma^k_n \cap \Pi^k_n = \Delta^k_n
\]
\begin{itemize}
    \item $k$ is the type of objects being Quantified over with type
      $0 = \mathbb{N}$, and type $i + 1$ are Functions from type $i
      \rightarrow \mathbb{N}$.
    \item $n$ is the number of alternating blocks of Existential and
      Universal Quantifiers
\end{itemize}
The outermost Quantifier block for $\Sigma$ Classes is Existential,
and for $\Pi$ Classes is Universal.



\subsubsection{Arithmetic Hierarchy}\label{subsec:arithmetic_hierarchy}

The \emph{Arithmetic Hierarchy} Classifies the Complexity of Formulas
in \emph{First-order Arithmetic}
(\S\ref{subsec:firstorder_arithmetic}). The Arithmetic Hierarchy is
extended by the \emph{Hyperarithmetic} and \emph{Analytic
  Hierarchies}.

Every Formula in the Language of First-order Arithmetic is in
$\Sigma^0_n$ or $\Pi^0_n$ for $n \in \mathbb{N}$. Formulas with only
\emph{Bounded Quantifiers} (\S\ref{subsec:firstorder_quantification})
are in $\Sigma^0_0$ or $\Pi^0_0$. $\Sigma^0_n$ and $\Pi^0_n$ are
defined Inductively for $n \in \mathbb{N}$:

\begin{itemize}
    \item $\phi = \exists x_1 \exists x_2 \cdots \exists x_k\psi, \psi
      \in \Pi^0_n \rightarrow \phi \in \Sigma^0_{n+1}$
    \item $\phi = \forall x_1 \forall x_2 \cdots \forall x_k\psi, \psi
      \in \Sigma^0_n \rightarrow \phi \in \Pi^0_{n+1}$
\end{itemize}

Thus a $\Sigma^0_n$ Formula begins with Existential Quantifiers and
alternates $n-1$ times between series of Existential and Universal
Quantifiers. The dual is true for $\Pi^0_n$.

By the addition of redundant Quantifiers, a Formula of $\Sigma^0_n$ or
$\Pi^0_n$ is also $\Sigma^0_m$ and $\Pi^0_m$ for $m > n$.

Sets of Natural Numbers that are definable in First-order Arithmetic
are assigned to Classes $\Sigma^0_n$ or $\Pi^0_n$, and to $\Delta^0_n$
if they are both $\Sigma^0_n$ and $\Pi^0_n$.

Turing Computable Sets are at level $\Delta^0_1$.

The \emph{Hyperarithmetic Sets} (\S\ref{subsec:hyperarithmetic_set})
are defined as $\Delta^1_1$.

\paragraph{Relativized Arithmetical Hierarchies}



\subsubsection{Analytic Hierarchy}\label{subsec:analytic_hierarchy}

The \emph{Analytic Hierarchy} extends the Arithmetic Hierarchy to
Second-order Formulas. The Classification is of \emph{Analytical Sets}
(\S\ref{subsec:analytical_set} of Natural Numbers by the difficulty of
specifying in Second-order Arithmetic (\S\ref{subsec:second_order}),
that is Second-order Formulas which include Quantifiers over
$\mathbb{N}$ and Functions from $\mathbb{N}$ to $\mathbb{N}$.

Every Formula in the Language of Second-order Arithmetic is in
$\Sigma^1_n$ or $\Pi^1_n$ for $n \in \mathbb{N}$.

Second-order Arithmetic with no Function Quantifiers:
\[
    \Delta^1_0 = \Sigma^1_0 = \Pi^1_0
\]

Second-order Arithmetic with Existential Function Quantifiers only:
\[
    \Sigma^1_1
\]

Second-order Arithmetic with Universal Function Quantifiers only:
\[
    \Pi^1_1
\]
Both $\Sigma^1_1$ and $\Pi^1_1$ are strictly larger than $\Delta^1_0$.

Second-order Arithmetic with both Existential and Universal Function
Quantifiers-- the class of \emph{Hyperarithmetic Sets}:
\[
    \Delta^1_1 = \Sigma^1_1 \cap \Pi^1_1
\]
is larger than $\Delta^1_0$.

$\Pi^1_1$ Formulas quantified over by Existential Functional
Quantifiers results in the Class $\Sigma^1_2$.

$\Sigma^1_1$ Formulas quantified over by Universal Functional
Quantifiers results in the Class $\Pi^1_2$.

Again, $\Delta^1_2$ is the Intersection of $\Sigma^1_2$ and $\Pi^1_2$
and Inductively this procedure extends to $\Sigma^1_n$, $\Pi^1_n$, and
$\Delta^1_n$.



\subsubsection{Projective Hierarchy}\label{subsec:projective_hierarchy}

\emph{Pointclass} (\S\ref{subsec:pointclass})

Pointclass of all \emph{Analytic Sets} (\S\ref{subsec:analytic_set})
\[
    \mathbf{\Sigma^1_1}
\]

\paragraph{Borel Hierarchy}



\subsubsection{Counting Hierarchy}

\subsubsection{Exponential Hierarchy}

\subsubsection{Fourier Hierarchy}

\subsubsection{Polynomial Hierarchy}

\subsubsection{Polynomial Communication Hierarchy}

\subsubsection{Boolean Hierarchy}




\subsubsection{Blum Complexity Measure}

\emph{Blum Axioms}



% ====================================================================
\section{Hypercomputation}\label{sec:hypercomputation}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Oracle}\label{sec:oracle}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{$\alpha$-recursion Theory}\label{subsec:alpha_recursion}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Hyperarithmetical Theory}\label{subsec:hyperarithmetical_theory}
% --------------------------------------------------------------------



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Type Theory}\label{sec:type_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Type Theory} is the study of classes of Formal Systems
(\S\ref{sec:formal_systems}) where each Term
(\S\ref{sec:logic_terminology}) has a \emph{Type} and Operations
are restricted to Terms of specific Types.

As a Formal Theory (Part \ref{sec:proof_theory}), Judgements in Type
Theory are of three kinds\cite{hott13}:
\begin{enumerate}

\item \emph{Well-formed Context} (\S\ref{sec:type_context})
\[
    (\Gamma) ctx
\]
``$\Gamma$ is a Well-formed Context''

\item \emph{Propositional Equality}
\[
    \Gamma \vdash a : A
\]
``Given Contex $\Gamma$, $a$ is a Term of Type $A$''

\item \emph{Definitional (Judgemental) Equality}
\[
    \Gamma \vdash a \equiv b : A
\]
``Given Context $\Gamma$, $a$ and $b$ are definitionally equal Terms
of Type $A$''

\end{enumerate}
with a Deductive Apparatus (\S\ref{subsec:deductive_apparatus})
consisting of Inference Rules only and no Axioms. Judgemental Equality
is an Equivalence Relation respected by Typing.



% ====================================================================
\section{Expression}\label{sec:type_expression}
% ====================================================================

\emph{Substitution}:
\[
    B[a/x]
\]
Substitute Term $a$ for Free occurrences of Variable $x$ in the Term
$B$. Generalized:
\[
    B[a_1,\ldots,a_n / x_1,\ldots,x_n]
\]



% ====================================================================
\section{Context}\label{sec:type_context}
% ====================================================================

A \emph{Context}, $\Gamma$, is a list of Assumptions of the form:
\[
    \Gamma = x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n
\]
where each Element $x_i : A_i$ is an Assumption that the distinct
Variable $x_i$ has type $A_i$.

Judgements are formulated under the Assumptions of a particular
Context, $\Gamma$:
\[
    \Gamma \vdash a : A
\]
For an empty Context:
\[
    \vdash a : A
\]
or
\[
    . \vdash a : A
\]



% ====================================================================
\section{Type Universe}\label{sec:type_universe}
% ====================================================================

A \emph{Type Universe} is a Type whose Elements are Types. A hierarchy:
\[
    \mathcal{U}_0, \mathcal{U}_1, \mathcal{U}_2, \ldots
\]
is such that any Type in $\mathcal{U}_i$ is also in
$\mathcal{U}_{i+1}$. See $\mathcal{U}-INTRO$ and $\mathcal{U}-CUMUL$
\S\ref{subsec:universe_rules}.



% ====================================================================
\section{Inference Rules}\label{sec:type_inference}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Context Rules}
% --------------------------------------------------------------------

The following Rules of Inference allow for the determination of a
Well-formed Context:
\begin{enumerate}
\item
\[
    {
        \frac{}{(.)ctx}
    } ctx-EMP
\]
\item
\[
    {
        \frac
        {x_1:A_1, \ldots, x_{n-1}:A_{n-1} \vdash A_n : \mathcal{U}_i}
        {(x_1:A_1,\ldots,x_n:A_n) ctx}
    } ctx-EXT
\]
\end{enumerate}



% --------------------------------------------------------------------
\subsection{Structural Rules}
% --------------------------------------------------------------------

Given a Context, derive Typing Judgements listed in the Context:
\[
    {
        \frac
        {(x_1:A_1, \ldots, x_n:A_n)ctx}
        {x_1:A_1, \ldots, x_n:A_n \vdash x_i:A_i}
    } Vble
\]

Substitution for Typing Judgements:
\[
    {
        \frac
        {\Gamma \vdash a : A \;\;\;\;\;\;\;
        \Gamma,x:A,\Delta \vdash b : B}
        {\Gamma,\Delta[a/x] \vdash b[a/x] : B[a/x]}
    } Subst_1
\]

Weakening for Typing Judgements:
\[
    {
        \frac
        {\Gamma \vdash A : \mathcal{U}_i \;\;\;\;\;\;\;
        \Gamma,\Delta \vdash b : B}
        {\Gamma,x:A,\Delta \vdash b:B}
    } Wkg_1
\]

Substitution for Judgemental Equality:
\[
    {
        \frac
        {\Gamma \vdash a : A \;\;\;\;\;\;\;
        \Gamma,x:A,\Delta \vdash b \equiv c : B}
        {\Gamma,\Delta[a/x] \vdash b[a/x] \equiv c[a/x] : B[a/x]}
    } Subst_2
\]

Weakening for Judgemental Equality:
\[
    {
        \frac
        {\Gamma \vdash A : \mathcal{U}_i \;\;\;\;\;\;\;
        \Gamma,\Delta \vdash b \equiv c : B}
        {\Gamma, x:A, \Delta \vdash b \equiv c : B}
    } Wkg_2
\]



% --------------------------------------------------------------------
\subsection{Universe Rules}\label{subsec:universe_rules}
% --------------------------------------------------------------------

\[
    {
        \frac
        {(\Gamma) ctx}
        {\Gamma \vdash \mathcal{U}_i : \mathcal{U}_{i+1}}
    } \mathcal{U}-INTRO
\]

\[
    {
        \frac
        {\Gamma \vdash A : \mathcal{U}_i}
        {\Gamma \vdash A : \mathcal{U}_{i+1}}
    } \mathcal{U}-CUMUL
\]



% --------------------------------------------------------------------
\subsection{Dependent Function Type Rules}\label{subsec:dependent_rules}
% --------------------------------------------------------------------

\[
    {
        \frac
        {\Gamma \vdash A : \mathcal{U}_i \;\;\;\;\;\;\;
        \Gamma,x:A \vdash B : \mathcal{U}_i}
        {\Gamma \vdash \prod_{(x:A)} B : \mathcal{U}_i}
    } \Pi-FORM
\]\[
    {
        \frac
        {}
        {}
    } \Pi-INTRO
\]\[
    {
        \frac
        {}
        {}
    } \Pi-ELIM
\]\[
    {
        \frac
        {}
        {}
    } \Pi-COMP
\]\[
    {
        \frac
        {}
        {}
    } \Pi-UNIQ
\]



% ====================================================================
\section{Typed $\lambda$-Calculus}\label{sec:typed_lambda_calculus}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Simply Typed $\lambda$-Calculus}\label{subsec:simply_typed}
% --------------------------------------------------------------------



% ====================================================================
\section{Intuitionistic Type Theory}
% ====================================================================

\emph{Intuitionistic Type Theory} (also \emph{Constructive Type
  Theory} or \emph{Martin-L\"of Type Theory})

Inductive Types



% --------------------------------------------------------------------
\subsection{Types}
% --------------------------------------------------------------------

\emph{Function Type}

\emph{Product Type}

\subsubsection{Empty Type $\mathbf{0}$}

\subsubsection{Unit Type $\mathbf{1}$}

\subsubsection{Natural Number Type}

\subsubsection{Identity Type}

\subsubsection{Dependent Function Type ($\Pi$-type)}

\[
    A \rightarrow B :\equiv \prod_{x:A} B
\]

\subsubsection{Dependent Pair Type ($\Sigma$-type)}

In Set Theory: Indexed Sum over a given Type.

\subsubsection{Coproduct Type}



% --------------------------------------------------------------------
\subsection{Intensional \& Extensional Type Theory}
\label{subsec:intension_extension}
% --------------------------------------------------------------------

\emph{Canonical Form}

\emph{Normal Form}



% ====================================================================
\section{Homotopy Type Theory}\label{sec:homotopy_type}
% ====================================================================

- Function Extensionality
- Univalence Axiom
- Higher Inductive Types



% ====================================================================
\section{Curry-Howard Correspondence}\label{sec:curry_howard}
% ====================================================================

\begin{tabular}{| l | l |}
\hline
\textbf{Type Theory} & \textbf{Logic} \\ \hline \hline
$A$ (Type) & Proposition \\ \hline
$a : A$ (Term) & Proof \\
\hline
\end{tabular}

Propositional Logic - Simple Types

Predicate Logic - Dependent Types



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Set Theory}\label{sec:set_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Set Theory} is formulated within First-order Logic
(\S\ref{subsec:predicate_logic}) and as such the objects of Set Theory
are Sets and Propositions. See \emph{Axiomatic Set Theory}
(\S\ref{sec:axiomatic_set_theory}) for specific formulations of Set
theory.



% ====================================================================
\section{Definition}\label{sec:set_definition}
% ====================================================================

\emph{Extensional Definition}

\emph{Intensional}

\emph{Identity} \emph{Determinable} \emph{Determinate}

\emph{Well-founded}

% --------------------------------------------------------------------
\subsection{Property}\label{subsec:set_property}
% --------------------------------------------------------------------

\emph{Properties} (or \emph{Predicables}) are objects that can be
Predicated (\S\ref{subsec:predicate_logic}) of other objects. The
Predicate or \emph{Indicator Function}
(\S\ref{subsec:indicator_function}) itself is not the Property, but
the \emph{Extension} of that Property.

\emph{Predicativity / Impredicativity} - Weyl

\emph{Vicious Circle Principle}

% --------------------------------------------------------------------
\subsection{Recursive Definition}\label{subsec:recursive_definition}
% --------------------------------------------------------------------

\emph{Recursive} = \emph{Inductive}

\begin{enumerate}
    \item Base case
    \item Inductive clause
    \item Extremal clause
\end{enumerate}

\emph{Structural Recursion}



% --------------------------------------------------------------------
\subsection{Circular Definition}\label{subsec:circular_definition}
% --------------------------------------------------------------------

\emph{Homoiconic}



% ====================================================================
\section{Sets}\label{sec:sets}
% ====================================================================

\emph{Sets} are collections of distinct objects (some of which may
themselves be other Sets), built on the Property of \emph{Membership}
which can be expressed as a \emph{Binary Relation}
(\S\ref{subsec:binary_relations}) ``$\in$'' which is the \emph{Set
  Membership Relation}. This Relation Maps 2-tuples of generic objects
and Sets to True or False depending on whether the object is a
\emph{Member} (or \emph{Element}) of the Set, e.g. $x \in A$ is True
when the object $x$ is a Member of the Set $A$.

An Element that is specifically not a Set is called an
\emph{Individual} or \emph{Urelement}.

\emph{Extension}

\emph{Intension}

% --------------------------------------------------------------------
\subsection{Cardinality}
% --------------------------------------------------------------------

The unique Set with Cardinality 0 is called the \emph{Empty Set} and
is denoted $\{\}$ or $\varnothing$. A Set with Cardinality 1 is called a
\emph{Singleton Set}.

% --------------------------------------------------------------------
\subsection{Unary Set Operators}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Binary Set Operators}
% --------------------------------------------------------------------

\subsubsection{Union}

\emph{Union}

\subsubsection{Disjoint Union}\label{subsec:disjoint_union}

\subsubsection{Infinitary Union}

\[
    x \in \bigcup S \leftrightarrow \exists y \in S : x \in y
\]



\subsubsection{Intersection}



\subsubsection{Subset}

\paragraph{Filter}

A \emph{Filter}, $\mathcal{F}$, of a Set, $X$, is a Set of Subsets of
$X$
\[
    \mathcal{F} \subseteq \mathcal{P}(X)
\]
where
\begin{itemize}
\item if $A \in \mathcal{F}$ and $B \supseteq A$, then $B \in
  \mathcal{F}$
\item if $A \in \mathcal{F}$ and $B \in \mathcal{F}$ then $A \cap B
  \in \mathcal{F}$
\item $X \in \mathcal{F}$ and $\emptyset \notin \mathcal{F}$
\end{itemize}
An \emph{Ultrafilter} $\mathcal{U}$ is a Filter such that for all $A
\subseteq X$, either $A \in \mathcal{U}$ or $X - A \in \mathcal{U}$.



\subsubsection{Difference}\label{subsec:set_difference}

\emph{Complement}

\emph{Symmetric Difference}



\subsubsection{de Morgan's Law}\label{subsec:de_morgan}

\subsubsection{Cartesian Product}\label{subsec:set_product}



% --------------------------------------------------------------------
\subsection{Closure}\label{subsec:set_closure}
% --------------------------------------------------------------------

\subsubsection{Finitary Closure}\label{subsec:finitary_closure}

% --------------------------------------------------------------------
\subsection{Forcing}\label{subsec:forcing}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Equalizers}\label{subsec:set_equalizer}
% --------------------------------------------------------------------

Given two Sets $X,Y$ and Functions $f,g : X \rightarrow Y$, the
\emph{Equalizer} of $f$ and $g$ is defined as
\[
    Eq(f,g) = { x \in X | f(x) = g(x) }
\]

\emph{Coequalizer}

% --------------------------------------------------------------------
\subsection{Index Sets}\label{subsec:index_set}
% --------------------------------------------------------------------

An \emph{Index Set} is one that \emph{Indexes} (or \emph{Labels})
Members of another Set. Indexing is a Surjective Function
(\S\ref{sec:set_function}) from an Index Set onto a target Set.

An \emph{Indexed Family} of Sets is a Function from an Index Set to
the Class of Sets. For Index Set $J$ and Indexed Set $A$, the Indexed
Family may be denoted
\[
    (A_j)_{j \in J}
\]

% --------------------------------------------------------------------
\subsection{Recursive Set}\label{subsec:recursive_set}
% --------------------------------------------------------------------

\subsubsection{Recursively Enumerable Set}\label{subsec:recursively_enumerable}

% --------------------------------------------------------------------
\subsection{Hyperarithmetic Set}\label{subsec:hyperarithmetic_set}
% --------------------------------------------------------------------

\emph{Hyperarithmetic Sets} are the Class of Sets denoted as
$\Delta^1_1$ in the \emph{Analytic Hierarchy}
(\S\ref{subsec:analytic_hierarchy}).

% --------------------------------------------------------------------
\subsection{Analytical Set}\label{subsec:analytical_set}
% --------------------------------------------------------------------




% ====================================================================
\section{Transitive Set}\label{sec:transitive_set}
% ====================================================================

A Set, $S$, is \emph{Transitive} if and only if
\[
    \bigcup S \subseteq S
\]

For two Transitive Sets, $S$ and $T$, the Set $S \cup T \cup \{S,T\}$
is Transitive.

A Set, $S$, containing no Urelements is Transitive if and only if $S
\subset \mathcal{P}(X)$

\emph{Transitive Closure}

% --------------------------------------------------------------------
\subsection{Admissible Set}\label{subsec:admissible_set}
% --------------------------------------------------------------------

An \emph{Admissible Set}, $A$, is a Transitive Set such that $\langle
A, \in \rangle$ is a Model (\S\ref{sec:model_theory}) of Kripke-Platek
Set Theory (\S\ref{subsec:kripke_platek}).

The smallest example of an Admissible Set is the Set of
\emph{Hereditarily Finite Sets}. %FIXME ref hereditarily finite



% ====================================================================
\section{Multisets}\label{sec:multi_sets}
% ====================================================================

A \emph{Multiset} (or \emph{Bag}) is a 2-tuple $(A,m)$ of an
\emph{Underlying Set}, $A$, together with a \emph{Multiplicity
  Function} (\S\ref{sec:set_function}), $m : A \rightarrow
\mathbb{N}_{\geq 1}$, mapping Elements of $A$ to Positive Natural
Numbers representing the \emph{Multiplicity} Elements, that is the
number of times an Element occurs in the Multiset. A Multiset may be
denoted with square brackets:
\[
    [a,a,b]
\]
If the Underlying Set is restricted to a Subset of a given
\emph{Universe}, $U$, the Multiplicity Function may be extended to
$m_U : U \rightarrow \mathbb{N}$ where $a \in U, a \notin A
\leftrightarrow m(a)=0$.

\emph{Indicator Function}



% ====================================================================
\section{Class}\label{sec:class}
% ====================================================================

A \emph{Class} is any Subset of the \emph{Universe}
(\S\ref{sec:set_universe}) of discussion.

\begin{description}
    \item [Proper Class] a Class that is not a Set
    \item [Small Class] a Class that is a Set
\end{description}



% ====================================================================
\section{Universe}\label{sec:set_universe}
% ====================================================================

% FIXME differentiate between Universes
A \emph{Universe} is a Set, $U$, with the following Closure Properties
\cite{maclane69}:
\begin{enumerate}
\item $x \in A \in U \rightarrow x \in U$
\item $x \in U \wedge y \in U \rightarrow \{x,y\}, \langle x,y
  \rangle, x \times y \in U$
\item $x \in U \rightarrow \mathcal{P}(x) \in U \wedge \bigcup x \in U$
\item $\omega = \{0,1,2,\ldots\} \in U$
\item Given a Surjective Function, $f : a \rightarrow b, a \in
  U, b \subset U \rightarrow b \in U$
\end{enumerate}
A \emph{Small Set} may be said to be a member of a Universe that is
not itself a Universe.



% --------------------------------------------------------------------
\subsection{Superstructure}\label{subsec:superstructure}
% --------------------------------------------------------------------

An Universe may be generated over a Set resulting in a
\emph{Superstructure}. The Superstructure over a Set $X$:
\[
    \mathbf{S}X := \bigcup^{\infty}_{i=0}\mathbf{S}_i X
\]
can be defined by Structural Recursion
(\S\ref{subsec:recursive_definition}) as follows:
\begin{itemize}

\item $\mathbf{S}_0 X = X$
\item $\mathbf{S}_1 X = X \cup \mathcal{P}(X)$
\item $\mathbf{S}_{n+1} X =
    \mathbf{S}_n X \cup \mathcal{P}(\mathbf{S}_n X)$

\end{itemize}
Some Properties of $\mathbf{S}\{\}$ (the Superstructure over the Empty
Set):
\begin{itemize}

\item $\mathbb{N} \subset \mathbf{S}\{\}$
\item $\mathbb{N} \notin \mathbf{S}\{\}$ (Elements of $\mathbf{S}\{\}$
  are Finite Sets)
\item $\mathbf{S}\{\}$ contains all of the Hereditarily Finite Sets
%FIXME ref Hereditarily finite sets

\end{itemize}

The Superstructure over $\mathbb{N}$, $\mathbf{S}\mathbb{N}$, is
considered the \emph{Universe of Ordinary Mathematics}.



% --------------------------------------------------------------------
\subsection{Von Neumann Universe}\label{subsec:vonneumann_universe}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Grothendieck Universe}\label{subsec:grothendieck_universe}
% --------------------------------------------------------------------

%FIXME similar to definitions above



% ====================================================================
\section{Map}\label{sec:set_map}
% ====================================================================

A \emph{Map} (or \emph{Mapping}) is a Relation or \emph{Morphism}
(\S\ref{sec:morphism}) that is either a \emph{Function}
(\S\ref{sec:set_function}) or \emph{Multimap} (\S\ref{sec:multimap}),
depending on whether the Mapping is Determinate or not.

Maps refer to the Extensional Definition of Functions (a Subset of the
Cartesian Product of the Domain and Codomain), while the underlying
Function may or may not be Extensionally Defined.



% ====================================================================
\section{Functions}\label{sec:set_function}
% ====================================================================

A \emph{Function} $f$, defined for all Members of Set $A$ and $image(f)
\subseteq B$ is written
\[
    f : A \rightarrow B
\]
The \emph{Input} or \emph{Domain} of $f$ is denoted $dom(f)$ and the
\emph{Ouptut} or \emph{Co-domain} as $cod(f)$. The \emph{Image} of the
Function is the Subset of the Codomain that the Function actually Maps
to, and the Subset of the Domain that Maps to it is called the
\emph{Preimage}. Each Element of the Preimage Maps to one Element of
the Image. This Property is expressed as
\[
    (a,b) \in f \wedge (a,c) \in f \rightarrow b = c
\]
A Relation without this Property is known as a \emph{Multimap}
(\S\ref{sec:multimap}).

In the case where $image(f) = cod(f)$, $f$ is known as a
\emph{Surjective Function} (\S\ref{subsec:surjective_function}).

\emph{Function Equality} is defined such that Equal Functions have the
same Output for a given Input. A Function can be seen as a Subset of
the Cartesian Product (\S\ref{subsec:set_product}) of the Domain and
Codomain:
\[
    f \subseteq A \times B
\]

Given a second Function $g : B \rightarrow C$, there is a
\emph{Composite Function}
\[
    g \circ f : A \rightarrow C
\]
where $(g \circ f)(a) = g(f(a))$ and $a \in A$. The \emph{Composition
  Operation} $\circ$ is Associative: $(h \circ g) \circ f = h \circ (g
\circ f)$. Composition of Functions may be represented with the
$\circ$ elided: $gf$.

%FIXME ref unit operation?
\emph{Unit Operations} for the Composition Operation are
\emph{Identity Functions} on Sets. The Identity Function for a Set $A$
\[
    I_A : A \rightarrow A
\]
is defined as
\[
    I_A(a) = a
\]
with the result given the function $f$ above
\[
    f \circ I_A = f = I_B \circ f
\]

An \emph{Empty Function} has the Empty Set as a Domain, defining a
Unique Function for each Set, $A$:
\[
    f_A : \varnothing \rightarrow A
\]

\emph{Finitary Function}

\emph{Infinitary Function}



% --------------------------------------------------------------------
\subsection{Injective Function}\label{subsec:injective_function}
% --------------------------------------------------------------------

An \emph{Injective Function} (or \emph{One-to-one Function}) is one
where the Elements of the Codomain are the Images of at most one
Elements of the Domain. A Function that is Non-injective is considered
an \emph{Information Losing Function} because the Inverse is no longer
a Function but it is a \emph{Multimap} (\S\ref{sec:multimap}).

% --------------------------------------------------------------------
\subsection{Surjective Function}\label{subsec:surjective_function}
% --------------------------------------------------------------------

A \emph{Surjective Function} is one such that the Image is equal to
the Codomain. Such a Function may be said to be \emph{Onto} but is not
necessarily \emph{Injective}.

% --------------------------------------------------------------------
\subsection{Bijective Function}\label{subsec:bijective_function}
% --------------------------------------------------------------------

A \emph{Bijective Function} is one that is both Surjective and
Injective (both One-to-one and Onto). A Function is Bijective if and
only if it is also \emph{Invertible}.

% --------------------------------------------------------------------
\subsection{Inverses}\label{subsec:inverse_functions}
% --------------------------------------------------------------------

For a Mapping between sets, $f: X \rightarrow Y$, a \emph{Left
  Inverse} or \emph{Retraction} of $f$ is a Map $g: Y \rightarrow X$
such that $gf = Id(X)$. A \emph{Right Inverse} or \emph{Section} of
$f$ would be a Map $h: Y \rightarrow X$ such that $fh = Id(Y)$.

% --------------------------------------------------------------------
\subsection{Idempotence}\label{subsec:idempotence}
% --------------------------------------------------------------------

A Function, $f$, is \emph{Idempotent} if $f^2 = f$.

% --------------------------------------------------------------------
\subsection{Partial Function}\label{subsec:partial_function}
% --------------------------------------------------------------------

A \emph{Total Function} is one where the Function is defined for every
Element of the Domain, while a \emph{Partial Function} the Function
may be defined for only a Subset of the Domain called the \emph{Domain
  of Definition}.

% --------------------------------------------------------------------
\subsection{Monotonicity}\label{subsec:monotonicity}
% --------------------------------------------------------------------

A \emph{Monotonic Function} is a Function between \emph{Posets}
(\S\ref{sec:order_theory}) where the Ordering of Elements of the
Domain Imply the Ordering of Elements in the Image of those Elements
under the Function.

% --------------------------------------------------------------------
\subsection{Inclusion Map}\label{subsec:inclusion_map}
% --------------------------------------------------------------------

An \emph{Inclusion Map} or \emph{Inclusion Function} is an Identity
Function that Maps Elements of a Subset to those in a Superset
\[
    \iota : A \hookrightarrow X
\]
where $A \subseteq X$.

% --------------------------------------------------------------------
\subsection{Pointed Sets}
% --------------------------------------------------------------------

A \emph{Pointed Set} is one that has a \emph{Null Element}
(\S\ref{sec:universal_property}).

% --------------------------------------------------------------------
\subsection{Indicator Functions}\label{subsec:indicator_function}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Function Space}\label{subsec:function_space}
% --------------------------------------------------------------------

The \emph{Function Space} of two Sets $A$ and $B$ is the Set of all
Functions from $A$ to $B$ denoted by $B^A$.



\subsubsection{Evaluation Function}\label{subsec:evaluation_function}

Given a Function Space $B^A$, the \emph{Evaluation Function} is
defined as:
\[
    eval : B^A \times A \rightarrow B
\]



% ====================================================================
\section{Relations}\label{sec:set_relations}
% ====================================================================

A \emph{Relation} is a Mapping between Truth Values and Tuples of
individuals. The general definition for an $n$-ary Relation $L$ over
Sets $X_1, \ldots, X_n$ is a Subset of the Cartesian Product $X_1
\times \ldots \times X_n$ called the \emph{Graph} of $L$:
\[
    G(L) \subseteq X_1 \times \ldots \times X_n
\]
The Expression $L x_1 \ldots x_n$ where $x_i \in X_i$ is True when
$(x_1, \ldots, x_n) \in G(L)$ and False otherwise. Such an $n$-ary
Relation may be completely specified by an $n + 1$-tuple called a
\emph{Correspondence}:
\[
    (X_1, \ldots, X_n, G(L))
\]
Such an $n$-ary Relation may also be described by a
\emph{Characteristic Function} (or \emph{Indicator Function}): %FIXME
                                %ref indicator function
\[
    f_L : X_1 \times \ldots \times X_n \rightarrow \{\top,\bot\}
\]

% --------------------------------------------------------------------
\subsection{Binary Relations}\label{subsec:binary_relations}
% --------------------------------------------------------------------

Also \emph{Dyadic Relation}. Given a \emph{Binary Relation} $R$ on a
Set $X$, $R$ is
\begin{description}
\item[Serial] when
\[
    \forall a \in X \exists b \in X : aRb
\]
\item[Reflexive] when
\[
    aRa = \top
\]
Reflexive implies Transitive and Serial
\item[Irreflexive] (also \emph{Strict}) when
\[
    aRa = \bot
\]
\item[Co-reflexive] when
\[
    aRb \rightarrow a = b
\]
\item[Transitive] when
\[
    aRb \wedge bRc \rightarrow aRc
\]
Transitive and Irreflexive if and only if Transitive and Asymmetric
\item[Symmetric] when
\[
    aRb \leftrightarrow bRa
\]
\item[Anti-symmetric] when
\[
    aRb \wedge bRa \rightarrow a = b
\]
\item[Asymmetric] when both Anti-symmetric and Irreflexive
\[
    aRb \rightarrow \neg bRa
\]
\item[Total] when
\[
    aRb \vee bRa
\]
Total implies Reflexive
\item[Trichotomous] when
\[
    aRb \vee bRa \vee a = b
\]
Trichotomous implies Irreflexive.
Trichotomous and Transitive implies Asymmetric.
A Transitive Trichotomous Relation is a Strict Total Order.
\item[Right Euclidean] when
\[
    aRb \wedge aRc \rightarrow bRc
\]
\item[Left Euclidean] when
\[
    bRa \wedge cRa \rightarrow bRc
\]
\end{description}
From the above types of Relations, the following Orders
(\S\ref{sec:order_theory}) are distinguished, listed here from most
general to most restricted:
\begin{description}
\item[Preorder] when Reflexive and Transitive.
\item[Partial Order] when Reflexive, Transitive, and Anti-symmetric.
\item[Total Preorder] (or Weak Order) when Preorder and Total.
\item[Total Order] when a Partial Order and Total.
\item[Partial Equivalence] when Symmetric and Transitive.
\item[Equivalence] when Reflexive, Symmetric, and Transitive
  (\S\ref{subsec:equivalence_relation}).
\end{description}

The Set of all Binary Relations on a Set $X$ is denoted
$\mathbf{Rel}(X)$ and is the Power Set of $X \times X$: $2^{X \times
  X}$.

Functions (\S\ref{sec:set_function}) are Well-defined Binary Relations.

A Dependency Relation is a Binary Relation that is Symmetric and
Reflexive.

Undirected Graphs (\S\ref{subsec:undirected_graph}) are Symmetric.
Any Binary Relation may be a Directed Graph
(\S\ref{subsec:directed_graph}). A Binary Relation is a Complete Graph
(\S\ref{subsec:complete_graph}) when $a \neq b \rightarrow aRb$ and
implies Symmetry. A Binary Relation is a Tournament when $a \neq b
\rightarrow aRb \vee bRa$ and implies Anti-symmetry.

% --------------------------------------------------------------------
\subsubsection{Equivalence Relation}\label{subsec:equivalence_relation}
% --------------------------------------------------------------------

An \emph{Equivalence Class} of an Element $a$ in a Set $X$ with
\emph{Equivalence Relation} $\sim$ is defined as
\[
    [a] = \{x \in X | a \sim x\}
\]
The \emph{Quotient Set} is the Set of Equivalence Classes of a
particular Equivalence Relation.

% --------------------------------------------------------------------
\subsubsection{Congruence Relation}\label{subsec:congruence_relation}
% --------------------------------------------------------------------

% ====================================================================
\section{Multimap}\label{sec:multimap}
% ====================================================================

A \emph{Multimap} (or \emph{Multi-valued Function}) is a Left-total
Relation.



% ====================================================================
\section{Axiomatic Set Theory}\label{sec:axiomatic_set_theory}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Zermelo-Fraenkel (ZFC)}\label{subsec:zermelo_fraenkel}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Kripke-Platek (KP)}\label{subsec:kripke_platek}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{New Foundations (NF)}\label{subsec:quine_foundations}
% --------------------------------------------------------------------



% ====================================================================
\section{Order Theory}\label{sec:order_theory}
% ====================================================================

\emph{Ordering Relations} are Binary Relations on a Set $P$ that are
Reflexive, Antisymmetric, and Transitive (\S\ref{sec:set_relations}).
A \emph{Partial Order} is where some pairs of Members are allowed to
not be included in the Ordering Relation. A \emph{Total Order} (or
\emph{Linear Order}) adds the requirement of Totality. A Totally
Ordered Subset of some Partially Ordered Set is called a \emph{Chain}.

\emph{Weak Ordering}

\emph{Top Element}

\emph{Lexicographic Order}



% --------------------------------------------------------------------
\subsection{Poset}\label{subsec:partially_ordered}
% --------------------------------------------------------------------

Monotonic Function

\subsubsection{Upper Set}\label{subsec:upper_set}

\subsubsection{Poset Product}\label{subsec:poset_product}

\subsubsection{Greatest Lower Bound}\label{subsec:greatest_lower_bound}

The Product of two Elements of a Poset is their Greatest Lower Bound.

\subsubsection{Least Upper Bound}\label{subsec:least_upper_bound}

The Coproduct of two Elements of a Poset is their Least Upper Bound.

% --------------------------------------------------------------------
\subsection{Ideal}\label{subsec:order_ideal}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Lattice}\label{subsec:lattice}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsubsection{Free Lattice}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Domain Theory}\label{subsec:domain_theory}
% --------------------------------------------------------------------



% ====================================================================
\section{Descriptive Set Theory}
% ====================================================================

\emph{Boldface Borel Hierarchy} (\S\ref{subsec:projective_hierarchy})

% --------------------------------------------------------------------
\subsection{Analytic Set}\label{subsec:analytic_set}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Polish Space}\label{subsec:polish_space}
% --------------------------------------------------------------------

\subsubsection{Cantor Space}

\emph{Cantor Space}, $2^{\omega}$, is the Set of all Infinite
Sequences of $0$s and $1$s.



\subsubsection{Baire Space}

\emph{Baire Space}, $\omega^{\omega}$ or $\mathcal{N}$, is the Set of
all Infinite Sequences of Natural Numbers.



% --------------------------------------------------------------------
\subsection{Pointclass}\label{subsec:pointclass}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Effective Descriptive Set Theory}
% --------------------------------------------------------------------

Combination of Descriptive Set Theory with \emph{Recursion Theory}
(Part \ref{sec:recursion_theory}).

% --------------------------------------------------------------------
\subsection{Borel Hierarchy}\label{subsec:borel_hierarchy}
% --------------------------------------------------------------------



% ====================================================================
\section{Combinatorics}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Permutations}\label{subsec:permutations}
% --------------------------------------------------------------------



% ====================================================================
\section{Constructive Set Theory}\label{sec:constructive_set_theory}
% ====================================================================



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Topology}\label{sec:topology}\cite{lc11}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A \emph{Topology}, $\tau$, is a collection of Subsets called
\emph{Open Sets} (\S\ref{subsec:open_set}) of a \emph{Metric Space}
(\S\ref{sec:metric_space}), $M$, subject to the following Inductive
definition:
\begin{enumerate}
\item $\varnothing \in \tau, M \in \tau$
\item $U,V \in \tau \rightarrow U \cap V \in \tau$
\item $\{U_i\}_{i \in I} \subseteq \tau \rightarrow \bigcup_{i \in I}
  U_i \in \tau$
\end{enumerate}

An equivalent definition is possible in terms of \emph{Closed Sets}
(\S\ref{subsec:closed_set}).

Given two Topologies, $\tau_1 \subset \tau_2$, $\tau_1$ is
\emph{Coarse} relative to $\tau_2$, and $\tau_2$ is \emph{Fine}
relative to $\tau_1$.



% ====================================================================
\section{Metric Space}\label{sec:metric_space}
% ====================================================================

A \emph{Metric Space} is a Set $M$ for which a \emph{Metric}
(\ref{subsec:metric}) is defined for all Elements of that Set.

A Metric Space $M$ can then be defined as the pair:
\[
    (M,d)
\]
where $M$ is a Set of Elements and $d$ is a Distance Function.

Subsets of a Metric Space may be \emph{Open}
(\S\ref{subsec:open_set}), \emph{Closed} (\S\ref{subsec:closed_set}),
both or neither.



% --------------------------------------------------------------------
\subsection{Metric}\label{subsec:metric}
% --------------------------------------------------------------------

A \emph{Metric} is a \emph{Distance Function} defined between all
Elements or Points of a Metric Space.

A Distance Function $d$ has the form:
\[
    d: M \times M \rightarrow \mathbb{R}^{+}
\]
with the following conditions:
\begin{enumerate}
\item $d(x_1, x_2) \geq 0$ (\emph{Non-negativity} or \emph{Separation
  Axiom})
\item $d(x_1, x_2) = 0 \leftrightarrow x_1 = x_2$ (\emph{Identity of
  Indiscernables} or \emph{Coincidence Axiom})
\item $d(x_1, x_2) = d(x_2, x_1)$ (\emph{Symmetry})
\item $d(x_1, x_3) \leq d(x_1, x_2) + d(x_2, x_3)$
  (\emph{Subadditivity} or \emph{Triangle Inequality})
\end{enumerate}
Two Metrics, $d_1$ and $d_2$, in a Metric Space, $M$, are
\emph{Metrically Equivalent}, $d_1 \sim d_2$, if for $\tau_1$ Induced
by $d_1$ and $\tau_2$ Induced by $d_2$, $\tau_1 = \tau_2$. A
sufficient condition for Metric Equivalence is given by:
\[
    \exists k_1, k_2 > 0 : \forall x \in M, \forall r > 0,
    B^{d1}_{rk_1}(x) \subseteq B^{d2}_r (x) \subseteq B^{d1}_{rk_2}(x)
\]

\emph{Euclidean Metric}:
\[
    d: \mathbb{R}^n \times \mathbb{R}^n \rightarrow \mathbb{R}
\]\[
    (\mathbf{p},\mathbf{q}) \mapsto \sqrt{\sum_{i=1}^{n}(q_i - p_i)^2}
\]

\emph{Discrete Metric}:
\[
    d: X \times X \rightarrow \mathbb{R}^{+}
\]\[
    (\mathbf{p},\mathbf{q}) \mapsto \left\{
    \begin{array}{l l}
        0: \mathbf{p} = \mathbf{q}\\
        1: \mathbf{p} \neq \mathbf{q}
    \end{array}\right.
\]

\emph{Max Metric}:
\[
    d: \mathbb{R}^n \times \mathbb{R}^n \rightarrow \mathbb{R}
\]\[
    (\mathbf{p},\mathbf{q}) \mapsto max_{1 \leq i \leq n}\{|q_i - p_i|\}
\]

\emph{Taxicab Metric}:
\[
    d: \mathbb{R}^n \times \mathbb{R}^n \rightarrow \mathbb{R}
\]\[
    (\mathbf{p},\mathbf{q}) \mapsto \sum_{i=1}^{n}|q_i - p_i|
\]



% --------------------------------------------------------------------
\subsection{Ball}\label{subsec:metric_ball}
% --------------------------------------------------------------------

A Metric \emph{Ball} is defined for a Point $p$ in a Metric Space
$(M,d)$ as the set of all Points (including $p$) within a given Radius
$r > 0$ as determined by the Distance Function of the Metric Space:
\[
    B_r(p) = {x \in M | d(x,p) < r }
\]
The above is termed an \emph{Open Ball} because it does not include
the points where $d(x,p) = r$. Such a Ball including these additional
Points is called a \emph{Closed Ball}.



% --------------------------------------------------------------------
\subsection{Open Set}\label{subsec:open_set}
% --------------------------------------------------------------------

An \emph{Open Set} is a Subset of a Metric Space, defined in terms of
\emph{Open Balls} (\S\ref{subsec:metric_ball}). For a Metric Space
$(M,d)$, the Set $U \subseteq M$ is \emph{Open} if
\[
    \forall x \in U, \exists r > 0 : B_r(x) \subseteq U
\]
where $B_r(x)$ is an Open Ball centered on Point $x$.

Open Sets of a Metric Space $(M,d)$ have the following three
properties:
\begin{enumerate}
\item $\varnothing, M$ are Open Sets
\item If $U, V \in M$ are Open, then $U \cap V$ is Open in $M$
\item If $\{ U_i \}_{i \in I}$ are Open, then $\bigcup_{i \in I}
  U_i$ is an Open Set
\end{enumerate}
Note that an arbitrary Intersection of Open Sets is not necessarily an
Open Set.



% --------------------------------------------------------------------
\subsection{Closed Set}\label{subsec:closed_set}
% --------------------------------------------------------------------

A Subset, $X \subseteq M$, of a Metric Space, $M$, is a \emph{Closed
  Set} if the Relative Complement (\ref{subsec:set_difference}), $M
\backslash X$, is an Open Set.

The three Properties of Closed Sets:
\begin{enumerate}
\item Given Topological Space $(X, \tau)$, if $\varnothing, X \in
  \tau$ then $\varnothing$ and $X$ are Closed
\item If $C, D$ are Closed in $X$, then $C \cup D$ is Closed in $X$
\item If $\{ U_i \}_{i \in I}$ are Closed, then $\bigcap_{i \in I}
  U_i$ is Closed
\end{enumerate}

If $C$ is a Closed Set and $f$ is a Continuous Function
(\S\ref{subsec:topological_continuity}), $f^{-1}(C)$ is a Closed Set.



\subsubsection{Perfect Set}

a Closed Set with no \emph{Isolated Points}
(\S\ref{subsec:isolated_point})



% ====================================================================
\section{Topological Space}\label{sec:topological_space}
% ====================================================================

A \emph{Topological Space} is a pair consisting of a Metric Space,
$M$, and a Toplogy, $\tau$ on that Metric Space:
\[
    (M,\tau)
\]

Every Metric Space gives a Topology, but Topologies may exist for
which there is no definable Metric Space. %FIXME explain

Given a Metric Space $M$, the following Topologies may be described:
\begin{description}
\item[Trivial Topology] $\tau = \{\varnothing, M\}$ (Open Sets under
  any Metric)

\item[Discrete Topology] $\tau = \mathcal{P}(M)$ (Open Sets under
  Discrete Metric)
\end{description}



% --------------------------------------------------------------------
\subsection{Base}\label{subsec:topological_base}
% --------------------------------------------------------------------

A \emph{Base}, $B$, is a Subset of a Topology, $\tau$, in a Metric
Space, $(M,\tau)$, such that:
\[
    \forall U \in \tau, \exists \{B_i\}_{i \in I} \subseteq B :
    \bigcup_{i \in I}B_i = U
\]
Properties:
\begin{enumerate}
    \item $B$ is a \emph{Covering} of $M$, as stated by:
\[
    M \subseteq \bigcup_{i \in I} B_i
\]

    \item
\[
    \forall B_1, B_2 \in B, \forall x \in B_1 \cap B_2,
    \exists B_3 \in B : x \in B_3 \wedge B_3 \subseteq B_1 \cap B_2
\]

\end{enumerate}
An example of a Base is the Set of all Open Balls in a Metric Space.

A Base is not necessarily Unique for a given Topology. Adding Elements
to a Base results in another Base.



\subsubsection{Subbase}

A \emph{Subbase}, $S$, is a Subset of a Topology, $\tau$, in a Metric
Space, $(M,\tau)$, such that the Set:
\[
    S \subseteq \tau : \{ \bigcap_{j \in J} S_j : |J| < \infty \}
\]
is a Base for $\tau$.

There is no unique Subbase for a given Topology but there is a unique
Topology for a given Subbase.



% --------------------------------------------------------------------
\subsection{Countability Axioms}\label{subsec:countability_axioms}
% --------------------------------------------------------------------

A Topological Space, $(M,\tau)$, is \emph{First Countable} or $1c$ if
$\forall X \in M$, there exists a Countable Neighborhood Base
(\S\ref{subsec:neighborhood_base}).

And the Topological Space is \emph{Second Countable} or $2c$ if $\tau$
has a Countable Base.
\[
    2c \rightarrow 1c
\]

All Metric Spaces are $1c$.



% ====================================================================
\section{Point-set Topology}\label{sec:point_set}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Point}\label{subsec:topological_point}
% --------------------------------------------------------------------

\emph{Point}

Two Points that are within the same Open Set of a Topology are said to
be \emph{Topologically Indistinguishable}.



\subsubsection{Isolated Point}\label{subsec:isolated_point}



% --------------------------------------------------------------------
\subsection{Interior}\label{subsec:interior}
% --------------------------------------------------------------------

For a Subset, $V$, of a Topology, $\tau$, a Point $x \in V$ is in the
\emph{Interior} of $V$, $V^{\circ}$, if there is a \emph{Neighborhood}
of $x$, $N \subset V$. Inductively, for $\{A_i\}_{i \in I} \subseteq
\tau \wedge \forall i, A_i \subseteq V$:
\[
    V^{\circ} = \bigcup_{i \in I} A_i \subseteq \tau
\]
Equivalently, the Interior of $V$ is every Open Set within $V$ and is
itself an Open Set.



\subsubsection{Neighborhood}\label{subsec:neighborhood}

A \emph{Neighborhood} of a Point $x$ in a Topological Space $(M,\tau)$
is a Set $V \subseteq M$ such that:
\[
    \exists U \in \tau : U \subseteq V \wedge x \in U
\]
That is, $x$ is in the Interior of $V$.



\subsubsection{Neighborhood System}\label{subsec:neighborhood_system}

Given a Point $x$ in any Topological Space, a \emph{Neighbordhood
  System} (or \emph{Neighborhood Filter}), $\mathcal{V}(x)$, is the
Set of all Neighborhoods of $x$.



\subsubsection{Neighborhood Base}\label{subsec:neighborhood_base}

Given a Neighborhood System, $V(x)$, a \emph{Neighborhood Base} for
$x$ is defined as a Subset of the Neighborhood System, $\mathcal{B}(x)
\subseteq \mathcal{V}(x)$, such that:
\[
    \forall v \in V(x), \exists b \in \mathcal{B}(x) : b \subseteq v
\]



% --------------------------------------------------------------------
\subsection{Continuity}\label{subsec:topological_continuity}
% --------------------------------------------------------------------

\emph{Continuity} of a Function $f : X \rightarrow Y$ between Metric
Spaces $(X,d)$ and $(Y,d')$ is defined at a Point $c$
if
\[
    \forall \epsilon > 0, \exists \delta > 0 :
    f (B_{\delta}(c)) \subseteq B_{\epsilon}(f(c))
\]
and likewise a \emph{Continuous Function} satisfies the above for all
$c$.

Alternatively, a Function $f: X \rightarrow Y$ is Continuous between
Metric Spaces if and only if for all Open Sets $V \subseteq Y$,
$f^{-1}(v)$ is an Open Set in $X$.

Continuity of a Function, $f : X \rightarrow Y$, between Topological
Spaces, $(X,\tau_1)$ and $(Y,\tau_2)$, is given by:
\[
    \forall V \in \tau_2, f^{-1}(V) \in \tau_1
\]
The following are Properties of Continuous Functions between
Topological Spaces:
\begin{enumerate}
    \item Any Constant Function is Continuous
    \item Given two Continuous Functions, $f : X \rightarrow Y$ and $g
      : Y \rightarrow Z$, the Function $g \circ f : X \rightarrow Z$ is
      Continuous
    \item Given $f : (X, \tau)) \rightarrow (Y, \sigma)$, $f$ is
      Continuous if $\tau = \mathcal{P}(X)$ (Discrete Topology) or
      $\sigma = \{\varnothing, Y\}$ (Trivial Topology)
\end{enumerate}



% --------------------------------------------------------------------
\subsection{Connectedness}\label{subsec:connectedness}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Compactness}\label{subsec:compactness}
% --------------------------------------------------------------------



% ====================================================================
\section{Algebraic Topology}\label{sec:algebraic_topology}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Homology Theory}\label{subsec:homology_theory}
% --------------------------------------------------------------------



% ====================================================================
\section{Geometric Topology}\label{sec:geometric_topology}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Manifold}\label{subsec:manifold}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Zariski Geometry}\label{subsec:zariski_geometry}
% --------------------------------------------------------------------



% ====================================================================
\section{Algebraic Geometry}\label{sec:algebraic_geometry}
% ====================================================================

\emph{Valuation}



% --------------------------------------------------------------------
\subsection{Algebraic Variety}\label{subsec:algebraic_variety}
% --------------------------------------------------------------------



% ====================================================================
\section{Singularity Theory}\label{sec:singularity_theory}
% ====================================================================



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Number Theory}\label{sec:number_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% ====================================================================
\section{Arithmetic}\label{sec:arithmetic}
% ====================================================================

% --------------------------------------------------------------------
\subsection{First-order Arithmetic}\label{subsec:firstorder_arithmetic}
% --------------------------------------------------------------------

\emph{First-order Logic} (\S\ref{subsec:predicate_logic})

% --------------------------------------------------------------------
\subsection{Second-order Arithmetic}\label{subsec:second_order_arithmetic}
% --------------------------------------------------------------------



% ====================================================================
\section{Natural Numbers}\label{sec:natural_number}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Principle of Mathematical Induction}
\label{subsec:induction_principle}
% --------------------------------------------------------------------



% ====================================================================
\section{Integers}\label{sec:integer}
% ====================================================================



% ====================================================================
\section{Rationals}\label{sec:rational}
% ====================================================================



% ====================================================================
\section{Real Numbers}\label{sec:real_number}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Computable Numbers}\label{subsec:computable_real}
% --------------------------------------------------------------------

also \emph{Recursive Numbers} or \emph{Computable Reals}

\emph{Real Closed Field} (\S\ref{subsec:closed_field})



% ====================================================================
\section{Ordinal Number}\label{sec:ordinal_number}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Admissible Number}\label{subsec:admissible_ordinal}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Von Neumann Ordinal}\label{subsec:vonneumann_ordinal}
% --------------------------------------------------------------------



% ====================================================================
\section{Cardinal Number}\label{sec:cardinal_number}
% ====================================================================



% ====================================================================
\section{Infinitesimal}\label{sec:infinitesimal}
% ====================================================================



% ====================================================================
\section{Hyperreal}\label{sec:hyperreal}
% ====================================================================



% ====================================================================
\section{Analytic Number Theory}\label{sec:analytic_number_theory}
% ====================================================================
% --------------------------------------------------------------------
\subsection{Dirichlet L-Series}\label{subsec:l_series}
% --------------------------------------------------------------------



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Graph Theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% ====================================================================
\section{Graphs} \label{sec:graphs}
% ====================================================================

A \emph{Graph}, $G$, is an Ordered Pair of Sets, $G = (V,E)$ where:
\begin{enumerate}
\item $V$ is the Set of \emph{Vertices} of generic Elements
\item $E$ is the Set of \emph{Edges} which are a ordered pairs of
  Vertices, that is $E \subseteq V \times V$
\end{enumerate}
The Vertices of an Edge are \emph{Endpoints} of that Edge, and the
Edge is \emph{Incident} to those Vertices. Two Vertices $A,B$ are
\emph{Adjacent} when
\[
    (A,B) \in E \vee (B,A) \in E
\]
A \emph{Self-loop} is an Edge with both Endpoints the same Vertex.



% --------------------------------------------------------------------
\subsection{Multigraph} \label{subsec:multigraph}
% --------------------------------------------------------------------

A \emph{Multigraph} (or \emph{Pseudo-graph}) is a Graph where $E$ is a
Multiset where Edges with Multiplicity $>1$ are called
\emph{Parallel}.



% --------------------------------------------------------------------
\subsection{Simple Graph} \label{subsec:simple_graph}
% --------------------------------------------------------------------

A \emph{Simple Graph} has no Self-loops and no Parallel Edges.



% --------------------------------------------------------------------
\subsection{Undirected Graph} \label{subsec:undirected_graph}
% --------------------------------------------------------------------

In an \emph{Undirected Graph}, it is required that for $A,B \in V$:
\[
    (A,B) \in E \leftrightarrow (B,A) \in E
\]
This is the definition of a Symmetric Relation
(\S\ref{subsec:binary_relations}) on $V$.



% --------------------------------------------------------------------
\subsection{Directed Graph} \label{subsec:directed_graph}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Complete Graph} \label{subsec:complete_graph}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Subgraph} \label{subsec:subgraphs}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Finite Graph} \label{subsec:finite_graph}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Dipole and Cycle Graphs} \label{subsec:dipole_cycle_graph}
% --------------------------------------------------------------------



% ====================================================================
\section{Trees} \label{sec:trees}
% ====================================================================



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{tex/category-theory.tex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Database Theory}\label{sec:database_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% ====================================================================
\section{Relational Model}\label{sec:relational_model}
% ====================================================================

\emph{Relational Calculus}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Mathematical Analysis}\label{sec:mathematical_analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% ====================================================================
\section{Sequence}\label{sec:sequence}
% ====================================================================



% ====================================================================
\section{Numerical Analysis}\label{sec:numerical_analysis}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Real Analysis}\label{subsec:real_analysis}
% --------------------------------------------------------------------



% ====================================================================
\section{Non-standard Analysis}\label{sec:nonstandard_analysis}
% ====================================================================



% ====================================================================
\section{Computable Analysis}\label{sec:computable_analysis}
% ====================================================================



% ====================================================================
\section{Constructive Analysis}\label{sec:constructive_analysis}
% ====================================================================



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Information Theory}\label{sec:information_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Control Theory}\label{sec:control_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{99}

\bibitem{turing38} Alan Turing, \emph{Systems of Logic Based on
  Ordinals}, Princeton, 1938.

\bibitem{kozen97}
    Dexter C. Kozen,
    \emph{Automata and Computability},
    Springer,
    1997

\bibitem{aho69}
    Alfred V. Aho,
    \emph{Nested stack automata},
    Journal of the ACM,
    1969

\bibitem{villemonte02}
    \'Eric Villemonte de la Clergerie,
    \emph{Parsing mildly context-sensitive languages with thread automata},
    COLING '02 Proceedings,
    2002

\bibitem{vijayashanker88}
    K. Vijayashanker,
    \emph{A study of tree adjoining grammars},
    University of Pennsylvania,
    1988

\bibitem{schutzenberger65}
    Mercel-Paul Sch\"utzenberger,
    \emph{On finite monoids having only trivial subgroups},
    Information and Computation,
    1965

\bibitem{mcnaughton-papert71}
    Robert McNaughton, Seymour Papert,
    \emph{Counter-free Automata},
    MIT Press,
    1971

\bibitem{skolem23}
    Thoralf Skolem,
    \emph{The foundations of elementary arithmetic},
    1923,
    trans. Jean van Heijenoort,
    \emph{From Frege to G\"odel: A Source Book in Mathematical Logic, 1879-1931},
    Harvard Univ. Press,
    1967

\bibitem{jaskowski34}
    Stanislaw Ja\'skowski,
    \emph{On the Rules of Suppositions in Formal Logic},
    1934,
    ed. Storrs McCall,
    \emph{Polish logic 1920-39},
    Oxford,
    1967

\bibitem{shapiro00}
    S. Shapiro,
    \emph{Foundations without Foundationalism: A Case for Second-order
    Logic},
    Oxford University Press,
    2000

\bibitem{prawitz65}
    Dag Prawitz,
    \emph{Natural Deduction: A proof-theoretical study},
    A\&W Stockholm,
    1965

\bibitem{schutte77}
    Kurt Sch\"utte,
    \emph{Proof Theory},
    Springer-Verlag,
    1977

\bibitem{birkhoff35}
    Garrett Birkhoff,
    \emph{On the Structure of Abstract Algebras},
    Proceedings of the Cambridge Philosophical Society,
    1935

\bibitem{tarski36}
    Alfred Tarski,
    \emph{Der Wahtheitsbegriff in den formalisierten Sprachen},
    Studia Philosophica,
    1936

\bibitem{ramsey27}
    F.P. Ramsey,
    \emph{Facts and Propositions},
    Aristotelian Society Supplementary Volume 7,
    1927

\bibitem{morley65}
    Michael Morley,
    \emph{Categoricity in Power},
    Transactions of the American Mathematical Society, Vol. 114, No. 2,
    1965

\bibitem{harizanov98}
    Valentina Harizanov,
    \emph{Pure Computable Model Theory},
    Studies in Logic and the Foundations of Mathematics,
    1998

\bibitem{awodey06}
    Steve Awodey,
    \emph{Category Theory},
    Carnegie Mellon,
    2006

\bibitem{maclane69}
    Saunders Mac Lane,
    \emph{Categories for the Working Mathematician},
    Springer,
    1969

\bibitem{boullier94}
    Pierre Boullier,
    \emph{Dynamic Grammars and Semantic Analysis},
    INRIA Research Report No. 2322,
    1994

\bibitem{hott13}
    Univalent Foundations Program,
    \emph{Homotopy Type Theory},
    Institude for Advanced Study,
    2013

\bibitem{lc11}
    Locally Compact,
    https://www.youtube.com/playlist?list=PLF94A6F65866F3F31,
    Thought Space Zero,
    2011

\bibitem{czoo14}
    MediaWiki,
    https://complexityzoo.uwaterloo.ca,
    University of Waterloo,
    2014

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
