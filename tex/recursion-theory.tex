%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Recursion Theory}\label{part:recursion_theory}\cite{czoo14}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

also \emph{Computability Theory}

\emph{Church-Turing}



% ====================================================================
\section{Computability}\label{sec:computability}
% ====================================================================

\begin{itemize}
\item Zero-function
\item Successor functions
\item Projection functions
\end{itemize}

Closed under:

\begin{itemize}
\item Composition
\item Primitive Recursion (\S\ref{sec:primitive_recursive})
\item Minimization (\S\ref{sec:mu_recursion})
\end{itemize}

If Minimization is not included, the resulting Functions are Primitive
Recursive Functions that are halting, but do not include all Total
Computable Functions (the Primitive Recursive Functions are a Strict
Subset of the Total $\mu$-recursive Functions).

The Minimization Operator (Unbounded $\mu$-operator) allows for
Unbounded Search and thus the definition of all Computable Functions.



% ====================================================================
\section{Decision Problem}\label{sec:decision_problem}
% ====================================================================

% ====================================================================
\section{Effective Calculability}\label{sec:effective_method}
% ====================================================================

A \emph{Function} (\S\ref{sec:set_function}) or \emph{Decision
  Problem} (\S\ref{sec:decision_problem}) is \emph{Effectively
  Calculable} if there exists an \emph{Effective Method} for solving
that problem.

An \emph{Effective Method} is a mechanical procedure for solving a
Function or Decision Problem of a specific \emph{Complexity Class}
(\S\ref{sec:complexity_theory}).

See \emph{Computable Function} (\S\ref{sec:computable_function}),
\emph{Computation Models} (\S\ref{sec:computation_model}) and
\emph{Algorithms} (\S\ref{sec:algorithm}).

Effective Topos (\S\ref{sec:effective_topos})



% ====================================================================
\section{Noncomputable Function}\label{sec:noncomputable_function}
% ====================================================================

also \emph{Undecidable Function}

\emph{Algorithmically Unsolvable}

\emph{Turing Degree}



% ====================================================================
\section{Computable Function}\label{sec:computable_function}
% ====================================================================

\emph{Computable Number} (\S\ref{sec:computable_real})

\emph{Computable Functions} are the formalized analogues of
\emph{Algorithms} (\S\ref{sec:algorithm}); that is a Function that
is \emph{Effectively Calculable} by an Effective Method
(\S\ref{sec:effective_method}).

\emph{Computable Functions} may be broadly divided into two Classes by
whether they are \emph{Partial} or \emph{Total}. A Total Computable
Function is sometimes called a (Total) \emph{Recursive} or
\emph{Decidable Function}.

There are several equivalent definitions of the class of Computable
Functions, which have reference to different \emph{Models of
  Computation} (\S\ref{sec:computation_model}):
\begin{enumerate}
\item Turing-computable Functions
\item $\mu$-recursive Functions
\item $\lambda$-recursive Functions
\end{enumerate}



% --------------------------------------------------------------------
\subsection{Partial Computable Function}\label{sec:partial_recursive}
% --------------------------------------------------------------------

A \emph{Partial Computable Function} (\emph{Partial Recursive
  Function}) is also called \emph{Semidecidable} or \emph{Recursively
  Enumerable} and are the Class of Functions capable of generating
\emph{Recursively Enumerable Sets}
(\S\ref{sec:recursively_enumerable}). A Set, $T$, is
\emph{Co-recursively Enumerable} if the Compliment $\mathbb{N} \ T$ is
Recursively Enumerable.

\emph{Recursively Enumerable} $\mathsf{coRE}$

The Lattice (\S\ref{sec:lattice}) of $\mathsf{RE}$ Sets under
Inclusion is denoted $\mathcal{E}$.

For a Computational Model of Partial Computable Functions see
$\mu$-recursion (\S\ref{sec:mu_recursion}).



\subsubsection{Admissible Numbering}\label{sec:admissible_numbering}



\subsubsection{Markov Algorithm}\label{sec:markov_algorithm}

String Rewriting System (\S\ref{sec:string_rewriting})



% --------------------------------------------------------------------
\subsection{Total Computable Function}\label{sec:recursive_function}
% --------------------------------------------------------------------

\emph{Total Recursive Function}



\subsubsection{General Recursion}\label{sec:general_recursion}

A \emph{General Recursive Function} is any Total Unbounded
$\mu$-recursive Function (\S\ref{sec:mu_recursion}). \emph{Primitive
  Recursive Functions} (\S\ref{sec:primitive_recursive}) are a Strict
Subset of General Recursive Functions.



\subsubsection{Primitive Recursion}\label{sec:primitive_recursive}

The Class of \emph{Primitive Recursive Functions}, $\mathsf{PR}$, are
those given by three Axioms:
\begin{enumerate}
  \item The $0$-ary \emph{Constant Function}, $0$, is Primitive
    Recursive
  \item The $1$-ary \emph{Successor Function}, $S(k) = k + 1$, is
    Primitive Recursive
  \item The $n$-ary \emph{Projection Function}, $P_i^n = k_i$,
    (returning the $i$th argument) is Primitive Recursive
\end{enumerate}
and the Operations:
\begin{enumerate}
  \item \emph{Composition}: Given a $k$-ary function, $f$, and $k$
    $m$-ary Primitive Recursive Functions, $g_1, \ldots, g_k$,
  \item \emph{Primitive Recursion}: Bounded $\mu$-recursion
    (\S\ref{sec:mu_recursion})
\end{enumerate}

Primitive Recursive Functions can be of four types: \cite{kleene52}

\begin{enumerate}
\item Number-theoretic Functions ($\mathbb{N} \rightarrow \mathbb{N}$)
\item Predicates ($\mathbb{N} \rightarrow \{T,F\}$)
\item Propositional Connectives ($\{T,F\} \rightarrow \{T,F\}$)
\item Representing Functions ($\{T,F\} \rightarrow \mathbb{N}$
\end{enumerate}



% --------------------------------------------------------------------
\subsection{Universal Function}\label{sec:universal_function}
% --------------------------------------------------------------------

\emph{UTM Theorem}

$u : \mathbb{N}^2 \rightarrow \mathbb{N}$



% ====================================================================
\section{Semicomputable Function}\label{sec:semicomputable_function}
% ====================================================================

\emph{Upper Semicomputable}

\emph{Lower Semicomputable}

A Partial Function that is both Upper and Lower Semicomputable is just
a Computable Function.



% ====================================================================
\section{Higher-order Function}\label{sec:higherorder_function}
% ====================================================================



% ====================================================================
\section{Models of Computation}\label{sec:computation_model}
% ====================================================================

% --------------------------------------------------------------------
\subsection{$\mu$-recursion}\label{sec:mu_recursion}
% --------------------------------------------------------------------

\emph{$\mu$-recursion} or \emph{Minimization}

\emph{$\mu$-recursive} or \emph{Partially Recursive Functions}

\emph{Bounded $\mu$-recursion}

\emph{Unbounded $\mu$-recursion}



% --------------------------------------------------------------------
\subsection{Turing Machine}
% --------------------------------------------------------------------

See Part \ref{sec:automata_theory} Automata Theory
\S\ref{sec:turing_machine} Turing Machines



\subsubsection{Post-Turing Machine}\label{sec:post_turing}



% --------------------------------------------------------------------
\subsection{Untyped $\lambda$-calculus}\label{sec:untyped_lambda}
% --------------------------------------------------------------------

\emph{Untyped $\lambda$-calculus} describes a Semantics for Computable
Functions (\S\ref{sec:computable_function}).

Untyped $\lambda$-calculus can be seen as a Typed $\lambda$-calculus
with a single Type (\S\ref{sec:type}).

Dana Scott - Set $D$ Isomorphic to Function Space $D \rightarrow D$ of
Functions on itself can be defined if only Continuous Functions are
considered, providing a Model for $\lambda$-calculus. cf. Denotational
Semantics (\S\ref{sec:denotational_semantics})

see also Combinatory Logic (\S\ref{sec:combinatory_logic})



\subsubsection{Lambda Expression}\label{sec:lambda_expression}

A \emph{Lambda Expression} is an Expression in the Language of Untyped
$\lambda$-calculus.

The Language of Untyped $\lambda$-calculus consists of the Symbols:
\begin{itemize}
  \item Variables $V = \{ x_1, x_2, \ldots, x_n, \ldots \}$
  \item Abstraction Symbols $\{ \lambda, . \}$
  \item Parentheses $\{ (, ) \}$
\end{itemize}

The Set of Lambda Expressions, $\Lambda$, is defined Inductively:
\begin{enumerate}
  \item $x \in V \Rightarrow x \in \Lambda$
  \item $x \in V \wedge M \in \Lambda \Rightarrow (\lambda x.M) \in
    \Lambda$ (\emph{Abstraction} \S\ref{sec:lambda_abstraction})
  \item $M,N \in \Lambda \Rightarrow (M N) \in \Lambda$
    (\emph{Application} \S\ref{sec:lambda_application})
\end{enumerate}
Notational conventions:
\begin{itemize}
  \item Outermost parentheses may be dropped:
    \[
      (M N) \equiv M N
    \]
  \item Applications are left-associative:
    \[
      M N P \equiv (M N) P
    \]
  \item Body extends as far right as possible:
    \[
      \lambda x.M N \equiv \lambda x.(M N)
    \]
  \item Sequences of Abstractions are contracted:
    \[
      \lambda x.\lambda y.\lambda z.M \equiv
      \lambda xyz.M
    \]
\end{itemize}

A Lambda Expression with no Free Variables is \emph{Closed}, or
sometimes referred to as \emph{Combinators}, equivalent to Terms in
Combinatory Logic (\S\ref{sec:combinatory_logic}).

A Function $f : \mathbb{N} \rightarrow \mathbb{N}$ is a Computable
Function (\S\ref{sec:computable_function}) if and only if there is a
Lambda Expression $F$ such that:
\[
  \forall x,y \in \mathbb{N} (f(x)=y \leftrightarrow F x =_\beta y)
\]



\subsubsection{Lambda Abstraction}\label{sec:lambda_abstraction}

\emph{Lambda Abstraction} is the definition of an \emph{Anonymous
  Function} by the Abstraction Operator $\lambda$ applied to a
Variable (or \emph{Formal Parameter}) $x \in V$ as Binding all Free
occurences of that Variable in the \emph{Body} following the '$.$'
Symbol.

The Variable named by the Lambda Abstraction is \emph{$lambda$-bound}
(or just \emph{Bound}) by the Abstraction.



\paragraph{Free Variable}\label{sec:free_variable}
\hfill \\

A \emph{Free Variable} is one not $\lambda$-bound by a Lambda
Abstraction.

\begin{itemize}
  \item The Free Variables of a Term $x$ consisting of the Variable
    $x$ is just $x$
  \item The Free Variables of $\lambda x.t$ are the Free Variables of
    $t$ without $x$
  \item The Free Variables of $ts$ is the Union of the Free Variables
    of $t$ and the Free Variables of $s$
\end{itemize}

A Free Variable is Bound by its ``nearest'' abstraction:
\[
  \lambda x.y (\lambda x.z x)
\]
The Free occurence of $x$ is Bound by the second Abstraction.



\subsubsection{Lambda Application}\label{sec:lambda_application}

\emph{Application}

The application of a Function $t$ to an Input $s$: $ts$ or $t(s)$



\subsubsection{Lambda Term}\label{sec:lambda_term}

A \emph{Lambda Term} is a Term (\S\ref{sec:term}) in the Language of
Untyped $\lambda$-calculus with the following Inductive definition:
\begin{itemize}
  \item a Variable $x$ is a Lambda Term
  \item for a Lambda Term $t$ and a Variable $x$, the Lambda
    Abstraction $(\lambda x.t)$ is a Lambda Term
  \item for Lambda Terms $t$ and $s$, the Application $(ts)$ is a
    Lambda Term
\end{itemize}
Bracketing may be needed to disambiguate Terms.

By the \emph{Church-Rosser Theorem}, the Reduction Rules of
$\lambda$-calculus are Confluent, so every Lambda Term has at most one
Normal Form. In general there is no Effective method for deciding
whether two arbitrary Lambda Terms are Equivalent.




\subsubsection{Substitution}\label{sec:lambda_substitution}

For a Lambda Term $t$ with Free Variable $x$, a \emph{Substitution}
$t[x/s]$ is the replacement of all occurences of $x$ by a Term $s$.

Substitution is defined uniquiely up to $\alpha$-equivalence
(\S\ref{sec:alpha_conversion}).

\HandRight\; See also Substitution (Logic \S\ref{sec:substitution})



\paragraph{Capture-avoiding Substitution}\label{sec:capture_avoiding}
\hfill \\

\emph{Capture-avoiding Substitution}

\emph{Freshness Condition}



\paragraph{Explicit Substitution}\label{sec:explicit_substitution}



\subsubsection{$\alpha$-conversion}\label{sec:alpha_conversion}

\emph{$\alpha$-conversion} (or \emph{$\alpha$-renaming}) is a renaming
of Bound Variables in a Term that results in an $\alpha$-equivalent
Term:
\[
  \lambda x.x =_\alpha \lambda y.y
\]

\emph{Variable Convention}:
\begin{enumerate}
  \item Bound Variables are distinct from Free Variables
  \item ``Binders'' only Bind Variables not already in Scope % FIXME
\end{enumerate}

When represented as De Bruijn Indices (\S\ref{sec:debruijn_index}),
$\alpha$-equivalent Expressions are Syntactically identical.

\HandRight\; See also Nominal Logic (\S\ref{sec:nominal_logic})



\paragraph{De Bruijn Index}\label{sec:debruijn_index}
\hfill \\

\emph{De Bruijn Indices} ``name-free''

Higher-order Abstract Syntax (\S\ref{sec:hoas})



\subsubsection{Contraction}\label{sec:contraction}\cite{seldin03}

Replacement of Subterms:
\begin{enumerate}
  \item $\lambda x . M =_\alpha \lambda y . [y/x]M$
  \item $(\lambda x . M)N =_\beta [N/x]M$
\end{enumerate}



\subsubsection{$\beta$-reduction}\label{sec:beta_reduction}

A \emph{$\beta$-reduction} is a Sequence of Zero or more Contractions
(\S\ref{sec:contraction}). A Term $M$ that Reduces to a Term $N$ is
written $M \rhd N$. $\beta$-reduction may not Terminate but
$\beta$-reduction is Confluent (\S\ref{sec:rewrite_confluence}).

As a Semantics for Functional Programming, a $\beta$-contraction
corresponds to a Computational Step.



\subsubsection{$\beta$-conversion}\label{sec:beta_conversion}
\cite{seldin03}

A \emph{$\beta$-conversion} is a Sequence of Zero or more Contractions
or reverse Contractions. A Conversion from Term $M$ to Term $N$ is
denoted $M =_* N$.



\subsubsection{$\eta$-conversion}\label{sec:eta_conversion}

\emph{$\eta$-reduction}:
\[
  \lambda x.y x \rightarrow_\eta y
\]
\emph{$\eta$-abstraction}:
\[
  y \rightarrow_\eta \lambda x.y x
\]

Extensional (\S\ref{sec:extension}) Equivalence of Expressions



\subsubsection{Church Encoding}\label{sec:church_encoding}

\subsubsection{Continuation}\label{sec:continuation}

Abstract Representation (???) of the Control State of a Computer
Program; Reifies the Program Control State

Continuation Monad: Computations which can be interrupted and resumed

Continuation as the ``Future'' of a Computation

Direct Style, Continuation Passing Style (CPS)

Example Identity Function in Direct Style:
\[
  (\lambda x . x) : a \rightarrow a
\]

Example Identity Function in Continuation Passing Style:
\[
  (\lambda x k.k x) : a \rightarrow (a \rightarrow r) \rightarrow r
\]



\subsubsection{Deductive $\lambda$-Calclulus}\label{sec:deductive_lambda}

\emph{Intensional Equality} (or \emph{Point-free Equality}): Equal if
$\alpha$-convertible (equality of Function implementations)

\emph{Extensional Equality} (or \emph{Point-wise Equality}): Equal if
Functionally equivalent (perform the same mapping on the same inputs)

Untyped $\lambda$-calculus with Intensional Equality is Inconsistent
as a Deductive System.

Rice's Theorem (\S\ref{sec:rices_theorem})

Von Neumann Universe (\S\ref{sec:vonneumann_universe})



\subsubsection{Reduction Strategy}\label{sec:reduction_strategy}



\subsubsection{Predicate Abstraction}\label{sec:predicate_abstraction}

\emph{Law of Abstraction}



% --------------------------------------------------------------------
\subsection{SKI Combinator Calculus}\label{sec:ski_calculus}
% --------------------------------------------------------------------

Combinatory Logic (\S\ref{sec:combinatory_logic})



% --------------------------------------------------------------------
\subsection{Tag System}\label{sec:tag_system}
% --------------------------------------------------------------------

also \emph{Post Tag Machine}



% --------------------------------------------------------------------
\subsection{Register Machine}\label{sec:register_machine}
% --------------------------------------------------------------------

\subsubsection{Counter Machine}

\subsubsection{Pointer Machine}

\subsubsection{Random Access Machine}

\subsubsection{Random Access Stored Program Machine}



% --------------------------------------------------------------------
\subsection{Process Calculus}\label{sec:process_calculus}
% --------------------------------------------------------------------

Family of approaches for modelling Concurrent Systems

Process Theory (???)

Linear Logic (\S\ref{sec:linear_logic})

Curry-Howard (\S\ref{sec:curry_howard}) for Process Calculi:
\begin{itemize}
  \item Propositions \emph{as} Session Types (\S\ref{sec:session_type})
  \item Proofs \emph{as} Processes (\S\ref{sec:process})
  \item Cut-elimination (\S\ref{sec:cut_elimination}) \emph{as}
    Communication (\S\ref{sec:communication})
\end{itemize}

Any Proof Reduction or Conversion corresponds to either a Computation
Step or Proces Equivalence \cite{caires-pfenning10}

Session \S\ref{sec:session}: Sequence of Communications


Communication Primitives:
\begin{itemize}
  \item Data Passing (\S\ref{sec:data_passing})
  \item Label Branching (\S\ref{sec:label_branching})
  \item Delegation (\S\ref{sec:delegation})
\end{itemize}


Constructions for Concurrent Programming:
\cite{honda-vasconcelos-kubo98}
\begin{itemize}
  \item Parallel Composition \S\ref{sec:parallel_composition}
  \item Name Hiding \S\ref{sec:name_hiding}
  \item Conditional \S\ref{sec:conditional}
  \item Recursion \S\ref{sec:process_recursion}
\end{itemize}

Inaction $\mono{inact}$ (Unit of $|$)


Session + Recursion $\Rightarrow$ Unbounded Thread of Communications
(\S\ref{sec:unbounded_interaction}) \cite{honda-vasconcelos-kubo98}

Summation-less Asynchronous $\pi$-calculus
(\S\ref{sec:asynchronous_pi_calculus}) \cite{honda-vasconcelos-kubo98}

Asynchronous Polyadic $\pi$-calculus
(\S\ref{sec:polyadic_pi_calculus}) with Branching
\cite{honda-vasconcelos-kubo98}


$\otimes$

$\parr$



\subsubsection{Process}\label{sec:process}

\emph{Process}

Free Names

Free Channels

Free Variables

Free Process Variables



\paragraph{Program}\label{sec:program}
\hfill \\

A \emph{Program} is a Process with no Free Variables or Free Channels



\paragraph{Replicated Input Process}
\label{sec:replicated_input_process}
\hfill \\

Replicated Input (\S\ref{sec:replicated_input})

$!x(y).P$

\emph{Server} waiting on Channel $x$ to be Invoked
(\S\ref{sec:invocation}) by \emph{Clients}



\subparagraph{Invocation}\label{sec:invocation}
\hfill \\

Replicated Input Process $!x(y).P$ (Server)

\emph{Invocation} by Client Spawns a new copy of the Process $P[a/y]$
with $a$ the Name passed by the Client to the Server during the
Invocation



\subparagraph{Shared Server}\label{sec:shared_server}
\hfill \\

Session-typed $\pi$-calculus (\S\ref{sec:session_typed_pi_calculus})

Replicated Server

$!A$ Shared Server for Sessions of Type $A$



\subsubsection{Channel}\label{sec:process_channel}

\emph{Channel}

allows for a Sequence of Communications (\S\ref{sec:communication}),
Messages (\S\ref{sec:message})

Private Port Designating a Session (\S\ref{sec:session}) through which
Communication (\S\ref{sec:communication}) is performed
\cite{honda-vasconcelos-kubo98}

\HandRight\; Cf. Information Theory \S\ref{sec:channel} Channels

Channels form a distinct Syntactic Domain (\S\ref{sec:formal_grammar})
\cite{honda-vasconcelos-kubo98}

Homogenous Channel (all Messages have the same Type)

Heterogenous Channel (Messages may have different Types)

Bidirectional Channel

Atomic Interactions:
\begin{itemize}
  \item \emph{Data Passing} \S\ref{sec:data_passing} (Value Passing,
    Name Passing, Synchronous Message Passing as in $\pi$-calculus
    \S\ref{sec:pi_calculus})
  \item \emph{Label Branching} \S\ref{sec:label_branching} (Method
    Invocation without Value Passing)
  \item \emph{Delegation} \S\ref{sec:delegation} (Channel Passing)
\end{itemize}

Channel Generation (???)



\paragraph{Session Channel}\label{sec:session_channel}
\hfill \\

Session-typed $\pi$-calculus (\S\ref{sec:session_typed_pi_calculus})

Heterogenous Bidirectional Communication Channel: each Message
(\S\ref{sec:message}) has a different Type and the possible Sequences
of Messages are determined by the Channel's Session Type
\cite{neubauer-thiemann04}



\paragraph{Standard Channel}\label{sec:standard_channel}
\hfill \\

$!A$ Non-session (Non-linearized, Shared) Channel used by Server to
spawn arbitrary number of Sessions of Type $A$

Session-typed $\pi$-calculus (\S\ref{sec:session_typed_pi_calculus})



\subsubsection{Communication}\label{sec:communication}

\emph{Communication} (or \emph{Dyadic Interaction} or \emph{Reciprocal
  Interaction})

Communication Effect (\S\ref{sec:communication_effect})

Remote Procedure Calls and Method Invocation as Session Type
(\S\ref{sec:session_type}) Abstractions
\cite{honda-vasconcelos-kubo98}

\emph{Passing}: Sending/Receiving

Communication Primitives (Atomic Interactions):
\cite{honda-vasconcelos-kubo98}
\begin{itemize}
  \item Data Passing \S\ref{sec:data_passing}) (Value Passing, Name
    Passing, Synchronous Message Passing as in $\pi$-calculus
    \S\ref{sec:pi_calculus})
  \item Label Branching \S\ref{sec:label_branching} (Method Invocation
    without Value Passing)
  \item Delegation \S\ref{sec:delegation} (Channel Passing)
\end{itemize}
organized by Sessions (\S\ref{sec:session})


Combining Communication Primitives:
\cite{honda-vasconcelos-kubo98}
\begin{itemize}
  \item Parallel Composition \S\ref{sec:parallel_composition}
  \item Name Hiding \S\ref{sec:name_hiding}
  \item Conditional \S\ref{sec:conditional}
  \item Recursion \S\ref{sec:process_recursion}
\end{itemize}


Interaction at Channels: Deterministic

Interaction at Names: Non-deterministic

Interaction Structure



\paragraph{Data Passing}\label{sec:data_passing}
\hfill \\

Value, Name Passing

\emph{Synchronous Message Passing}

Message (\S\ref{sec:message})

Expressions $e_i$

Variables $x_i$

$!$ Send

$?$ Receive

\[
    k![e_1 \cdots e_n]; P
    \quad\quad\quad
    k?(x_1 \cdots x_n) \; \mono{in} \; P
\]



\subparagraph{Value Passing}\label{sec:value_passing}

\subparagraph{Name Passing}\label{sec:name_passing}



\paragraph{Label Branching}\label{sec:label_branching}
\hfill \\

Label Branching/Selection

Method Invocation (without Value Passing)

Labels $l$

\[
  k \lhd l; P
  \quad\quad\quad
  k \rhd \{ l_1 : P_1 \llbracket \cdots \rrbracket l_n : P_n \}
\]



\paragraph{Delegation}\label{sec:delegation}
\hfill \\

Channel Passing

Distributed Programming

\[
  \mono{throw} \; k[k']; P
  \quad\quad\quad
  \mono{catch} \; k(k') \; \mono{in} \; P
\]

$\otimes_n P$

Client is unaware of Delegation in Server



\paragraph{Message}\label{sec:message}



\subsubsection{Operators}\label{sec:process_operators}

\paragraph{Sequential Composition}\label{sec:sequential_composition}
\hfill \\

\[
  P_1; P_2
\]



\paragraph{Parallel Composition}\label{sec:parallel_composition}
\hfill \\

(or \emph{Concurrent Composition})

\[
  P_1 | P_2
\]


\textbf{Reduction Semantics} (\S\ref{sec:reduction_semantics})

Reduction Rule:
\[
  x<y>.P | x(v).Q ---> P | Q[y/v]
\]



\subparagraph{Inaction}\label{sec:inaction}
\hfill \\

Unit of $|$

$\mono{inact}$



\paragraph{Conditional}\label{sec:conditional}
\hfill \\

Boolean Expression $e$

\[
  \text{if } e \text{ then } P \text{ else } Q
\]



\paragraph{Name Hiding}\label{sec:name_hiding}
\hfill \\

Declares Name (or Channel) to be Local in Scope

\[
  (\nu a)P \quad (\nu k)P
\]



\paragraph{Recursion}\label{sec:process_recursion}
\hfill \\

Process Variable (???) $X$

\[
  \mono{def} \; X_1(\tilde{x}_1 \tilde{k}_1)
  = P_1 \; \mono{and} \; \cdots \; \mono{and} \;
  X_n(\tilde{x}_n \tilde{k}_n) = P_n \; \mono{in} \; P
\]

$\mu t.P$ Enter Recursive Scope

$t$ Recurse (DeBruijn Indices ???) %FIXME



\subparagraph{Replication}\label{sec:replication}
\hfill \\

Recursively Defined Agents (???)

$!P$

Replicated Input (\S\ref{sec:replicated_input})



\subsubsection{Null Process}\label{sec:null_process}



\subsubsection{Session}\label{sec:session}

Session Type (\S\ref{sec:session_type}) determines the allowed
Sequences of Messages, Defined by a Regular Language
(\S\ref{sec:regular_language}) on Atomic Communication Actions
(\S\ref{sec:communication}). Channel Type (\S\ref{sec:channel_type})
specifies the Language with a Fix-point Expression. Operations peel
off ``outermost'' Action (???) of the Channel Type and change the
Channel Type (Linearity). \cite{neubauer-thiemann04}

Protocol

Only Processes with Dual Protocols can Interact

\cite{honda-vasconcelos-kubo98}:

Session: Chain (Sequence \S\ref{sec:sequence}) of Dyadic Interactions,
possibly with Branching and Recursion

Process (Program \S\ref{sec:process}): Collection of Dyadic
Interactions (Communications) in a Session

Channel (\S\ref{sec:process_channel}): Private Port Designating a
Session through which Interactions are performed in the Session; fresh
Channel for each Session

Session + Recursion $\Rightarrow$ Unbounded Thread of Communications
\cite{honda-vasconcelos-kubo98}



\paragraph{Session Initiation}\label{sec:session_initiation}
\hfill \\

\cite{honda-vasconcelos-kubo98}:
\[
  \mono{request} \; a(k) \; \mono{in} \; P
  \quad\quad\quad
  \mono{accept} \; a(k) \; \mono{in} \; P
\]

Request via Name $a$ to Initiate a Session and Generation of Channel
$k$ (to be bound in $P$)

Accept via Name $a$ to Initiate a Session and Generation of Channel
$k$ (to be bound in $P$)

Session Initiation Channels, Standard Types $!A$



\paragraph{Continuation Session}\label{sec:continuation_session}
\hfill \\

Continuation (\S\ref{sec:continuation})

$A \otimes B$: First $A$ is Sent as Output and then behaves (???) as
\emph{Continuation Session} $B$



\paragraph{Session Protocol}\label{sec:session_protocol}

\paragraph{Finite Session}\label{sec:finite_session}



\subsubsection{Communication Pattern}\label{sec:communication_pattern}

\paragraph{Replicated Input}\label{sec:replicated_input}
\hfill \\

Replicated Input $!x(y).P$

Structural Congruence Axiom:
\[
  !x(y).P \equiv x(y).P | !x(y).P
\]

Replicated Input Process (\S\ref{sec:replicated_input_process}) such
as $!x(y).P$ can be understood as \emph{Server} waiting on Channel $x$
to be Invoked by \emph{Client}



\paragraph{Continuous Interaction}\label{sec:continuous_interaction}
\hfill \\

Sequence of Sessions



\paragraph{Unbounded Interaction}\label{sec:unbounded_interaction}
\hfill \\

Recursion with a Session



\subsubsection{$\pi$-calculus}\label{sec:pi_calculus}

Name Passing (\S\ref{sec:name_passing})

Labelled Transition Semantics $P \xrightarrow{\alpha} P'$

Non-deterministic Choice Operator $P + Q$

Match Operator (Name Equality) $[x=y]P$

Replication (\S\ref{sec:replication}) $!P$

\emph{Summation-less}, \emph{Asynchronous
  $\pi$-calculus} %FIXME def
\cite{honda-vasconcelos-kubo98}

Bisimulation Equivalence (\S\ref{sec:bisimulation}) is Decidable for
Recursion-free $\pi$-calculus (\S\ref{sec:recursionfree_pi_calculus})
and Finite-control $\pi$-calculus
(\S\ref{sec:finitecontrol_pi_calculus}); number of Parallel components
in any Process is Bounded by a Constant)


\textbf{Namespaces} \cite{honda-vasconcelos-kubo98}

\begin{itemize}
\item Names $a,b,c,\ldots$
\item Channels $k,k',k'',\ldots$
\item Variables $x,y,z,\ldots$
\item Constants $c,c',c'',\ldots$
\item Expressions $e,e',e'',\ldots$
\item Labels $l,l',l'',\ldots$
\item Process Variables $X,Y,Z,\ldots$
\item Names or Channels $u, u', u'', \ldots$
\item Processes $P,Q,R, \ldots$
\end{itemize}


\textbf{Example of a Program} \cite{honda-vasconcelos-kubo98}
\[
  \mono{accept} \; a(k) \; \mono{in} \; k![1];
  k?(y) \; \mono{in} \; P
  \quad | \quad
  \mono{request} \; a(k) \; \mono{in} \; k?(x)
  \; \mono{in} \; k![x+1]; \mono{inact}
\]
First Process Receives Request for a new Session via $a$, Generates
new Channel $k$, then Sequentially Sends $1$ on $k$ and Receives
Return Value $y$ on $k$ (??? and Continues on $(y)$ bound in $P$ ???)

Second Process Requests Initiation of Session
(\S\ref{sec:session_initiation}) via $a$, and Sequentially Receives
Value $x$ on Generated Channel $k$ and Sends Return Value $x + 1$ on
$k$ (??? $\mono{inact}$)

Alpha Equivalence $\equiv_\alpha$

Evaluation Relation $\downarrow$

Inductive Mapping into Structuring Primitives $\llbracket \cdot
\rrbracket$

Free Names $fn(P)$

Free Channels $fc(P)$

Free Variables $fv(P)$

Free Process Variables $fpv(P)$

$fu(P) =_{\text{def}} fc(P) \cup fn(P)$


\textbf{Structural (Syntactic) Equality}
(\S\ref{sec:structural_equality})
\cite{honda-vasconcelos-kubo98}

Structural Equality $equiv$ given by the Smallest Congruence Relation
(\S\ref{sec:congruence_relation}) such that:
\begin{enumerate}
  \item $P \equiv_\alpha Q \Rightarrow P \equiv Q$
  \item $P \;|\; \mono{inact} \equiv P$, \quad\quad $P | Q \equiv Q
    | P$, \quad\quad $(P|Q)|R \equiv P|(Q|R)$
  \item $(\nu u) \; \mono{inact}$, \quad
    $(\nu u u)P \equiv (\nu u)P$, \quad
    $(\nu u u')P \equiv (\nu u' u)P$, \\
    $u \notin fu(Q) \Rightarrow (\nu u)P | Q \equiv (\nu u)(P|Q)$, \\
    $u \notin fu(D) \Rightarrow
    (\nu u) \mono{def} \; D \; \mono{in} \; P
    \equiv \mono{def} \; D \; \mono{in} \; (\nu u)P$
  \item $fpv(D) \cap fpv(Q) = \varnothing \Rightarrow
    (\mono{def} \; D \; \mono{in} \; P) | Q
    \equiv \mono{def} \; D \; \mono{in} \; (P|Q)$
  \item $fpv(D) \cap fpv(D') = \varnothing \Rightarrow
    \mono{def} \; D \; \mono{in} \;
    (\mono{def} \; D' \; \mono{in} \; P)
    \equiv \mono{def} \; D \; \mono{and} \; D' \mono{in} \; P$
\end{enumerate}


\textbf{Operational Semantics} (\S\ref{sec:operational_semantics})
\cite{honda-vasconcelos-kubo98}

Operational Semantics given by the Smallest Reduction Relation
(\S\ref{sec:reduction_relation}) $P \rightarrow Q$ such that:

\begin{itemize}
  \item Link
  \item Com
  \item Label
  \item Pass
  \item If1
  \item If2
  \item Def
  \item Scop
  \item Par
  \item Str
\end{itemize}

$\rightarrow^*$


\textbf{Example of a Reduction (Synchronous)}
\cite{honda-vasconcelos-kubo98}

%FIXME


\textbf{Call-return} (Remote Procedure Call)

Synchronous Call-return

Asynchronous Call-return: Rendez-vous, Futures


\textbf{Method Invocation} (\S\ref{sec:label_branching})

Cell (Read/Write)


\textbf{Continuous Interaction} (\S\ref{sec:continuous_interaction}



\paragraph{Synchronous $\pi$-calculus}
\label{sec:synchronous_pi_calculus}
\hfill \\

\textbf{Synchronous $\pi$-calculus with Guarded (Binary) Choice}
\cite{caires-pfenning10}

Names $\Lambda = \{x,y,z,u,v,\ldots\}$

\textbf{Processes} $P, Q, R,\ldots$:
\cite{caires-pfenning10}
\[
\begin{split}
  P ::=&\quad \mathbf{0} \quad
      | \quad P|Q \quad
      | \quad (\nu y)P \quad \\
      |&\quad x\langle y \rangle.P \quad
      | \quad x(y).P \quad
      | \quad !x(y).P \quad \\
      |&\quad x.\mono{inl}; P \quad
      | \quad x.\mono{inr}; P \quad
      | \quad x.\mono{case}(P,Q)
\end{split}
\]

``Static'' Fragment:
\begin{itemize}
  \item $\mathbf{0}$ (Inaction)
  \item $P|Q$ (Parallel Composition)
  \item $(\nu y)P$ (Name Restriction)
\end{itemize}

\begin{itemize}
  \item $x\langle y \rangle.P$ (Output: Send $y$ on $x$ and continue
    as $P$)
  \item $x(y).P$ (Input: Receive Name $z$ on $x$ and continue as $P$
    with Paramter $y$ replaced with $z$)
  \item $!x(y).P$ (Replicated (Persistent) Input)
\end{itemize}

(Minimal) Labelled Choice Mechanism:
\begin{itemize}
  \item $x.\mono{inl}; P$
  \item $x.\mono{inr}; P$
  \item $x.\mono{case}(P,Q)$
\end{itemize}

Free Names $fn(P)$, Bound Names $bn(P)$

\emph{Closed Process} has no Free Names

Alpha Equivalence (consistent renaming of Bound Names) $\equiv_\alpha$

Capture Avoiding Substitution $P\{x/y\}$


\textbf{Structural (Syntactic) Congruence}
(\S\ref{sec:structural_equality})

$(P \equiv Q)$: Identities on the Structure of Processes; Least
Congruence Relation on Processes such that:

\begin{tabular}{l l}
  $P|\mathbf{0} \equiv P$ & $(S\mathbf{0})$ \\
  $P|Q \equiv Q|P$ & $(S|C)$ \\
  $(\nu x) \mathbf{0} \equiv \mathbf{0}$ & $(S \nu \mathbf{0})$ \\
  $(\nu x)(\nu y)P \equiv (\nu y)(\nu x)P$ & $(S\nu\nu)$ \\
  $P \equiv_\alpha Q \Rightarrow P \equiv Q$ & $(S\alpha)$ \\
  $P|(Q|R) \equiv (P|Q)|R$ & $(S|A)$ \\
  $x \notin fn(P) \Rightarrow P|(\nu x)Q \equiv (\nu x)(P|Q)$
  & $(S\nu|)$
\end{tabular}


\textbf{Reduction}

$(P \rightarrow Q)$: Behavior of Processes; Closed under Structural
Congruence

\begin{tabular}{l l}
  $x\langle y \rangle.Q | x(z).P \rightarrow Q | P \{y/z\}$
  & $(RC)$ \\
  $x\langle y \rangle.Q | !x(z).P \rightarrow Q | P \{y/z\} | !x(z).P$
  & $(R!)$ \\
  $x.\mono{inl}; P | x.\mono{case}(Q,R) \rightarrow P | Q$
  & $(RL)$ \\
  $x.\mono{inr}; P | x.\mono{case}(Q,R) \rightarrow P | R$
  & $(RR)$ \\
  $Q \rightarrow Q' \Rightarrow P|Q \rightarrow P|Q'$
  & $(R|)$ \\
  $P \rightarrow Q \Rightarrow (\nu y)P \rightarrow (\nu y)Q$
  & $(R\nu)$ \\
  $P \equiv P', P' \rightarrow Q', Q'
    \equiv Q \Rightarrow P \rightarrow Q$
  & $(R\equiv)$
\end{tabular}


\textbf{Labelled Transition System}
(\S\ref{sec:state_transition_system})

$P \xrightarrow{\alpha} Q$: Process $P$ may Transition to Process $Q$
by Action $\alpha$

Co-action $\overline{\alpha}$

\[
\begin{split}
  \alpha ::=&\quad x(y) \quad
           | \quad \overline{x \langle y \rangle} \quad
           | \quad \overline{(\nu y) x \langle y \rangle} \quad \\
           |&\quad x.\mono{inl} \quad
           | \quad x.\mono{inr} \quad
           | \quad \overline{x.\mono{inl}} \quad
           | \quad \overline{x.\mono{inr}} \quad
\end{split}
\]
Side Conditions:
$(\mono{res})$
$(\mono{par})$
$(\overline{\mono{par}})$
$(\mono{com})$
$(\overline{\mono{com}})$
$(\mono{close})$
$(\overline{\mono{close}})$
$(\mono{open})$
$(\mono{out})$
$(\mono{in})$
$(\mono{rep})$
$(\mono{lout})$
$(\mono{rout})$
$(\mono{lin})$
$(\mono{rin})$

\begin{itemize}
  \item $x.(y)$ (Input)
  \item $\overline{x \langle y \rangle}$ (Output)
  \item $\overline{(\nu y) x \langle y \rangle}$ (Bound Output; Output
    new Name $y$ on Channel $x$)
  \item $x.\mono{inl}$ (Left Offer)
  \item $x.\mono{inr}$ (Right Offer )
  \item $\overline{x.\mono{inl}}$ (Left Select)
  \item $\overline{x.\mono{inr}}$ (Right Select)
  \item $\xrightarrow{\tau}$ (Internal Action)
\end{itemize}

\emph{Subject} of $\alpha$: $s(\alpha)$ (e.g. $x$ in $x\langle y
\rangle$) (???) \cite{caires-pfenning10}

\emph{Internal Action} $\tau$

Relation Composition $\rho_1 \rho_2$ (e.g. $\xrightarrow{\tau}\equiv$)



\textbf{Types}
%FIXME move to session-typed pi-calculus?



\paragraph{Asynchronous $\pi$-calculus}
\label{sec:asynchronous_pi_calculus}
\hfill \\

Allows only Outputs with no Suffix (Output Atoms have the form
$\overline{x}\langle y \rangle$)

Any Process in the original $\pi$-calculus can be represented in
Asynchronous $\pi$-calculus using an extra Channel to simulate explicit
acknowledgement from the receiving Process

Strictly less expressive than the Synchronous $\pi$-calculus with the
Choice Operator



\paragraph{Local $\pi$-calculus}\label{sec:local_pi_calculus}

\paragraph{Finite-control $\pi$-calculus}
\label{sec:finitecontrol_pi_calculus} \hfill \\

Decidable Bisimulation Equivalence



\paragraph{Recursion-free $\pi$-calculus}
\label{sec:recursionfree_pi_calculus} \hfill \\

Decidable Bisimulation Equivalence



\paragraph{Polyadic $\pi$-calculus}\label{sec:polyadic_pi_calculus}
\hfill \\

Communicating more than one Name

Polyadic Input

Polyadic Output



\paragraph{Higher-order $\pi$-calculus}
\label{sec:higherorder_pi_calculus}
\hfill \\

Processes may be sent through Channels



\paragraph{Monadic $\pi$-calculus}\label{sec:monadic_pi_calculus}
\hfill \\

Ill-sorted, Well-typed % FIXME



\paragraph{Session-typed $\pi$-calculus}
\label{sec:session_typed_pi_calculus}
\cite{honda-vasconcelos-kubo98}
\cite{caires-pfenning10}
\hfill \\

Session Types \S\ref{sec:session_type}

Terms (Functions, Values): Linear $\lambda$-calculus Types
(\S\ref{sec:typed_lambda})

Names (Channels \S\ref{sec:channel}): ``Interpretation Types''
describing Session Protocols (\S\ref{sec:session_protocol})

Dual Intuitionistic Linear Logic \cite{caires-pfenning10}

\emph{Session-based Concurrency}: Processes (\S\ref{sec:process})
Communicate (\S\ref{sec:communication}) through Session Channels
(\S\ref{sec:session_channel}) connecting exactly two Subsystems (???)
and Communication disciplined by Session Protocols
(\S\ref{sec:session_protocol}) such that Actions (???) always occur in
Dual Pairs (e.g. Send/Receive, Offer/Choose, etc.) and no further
Interaction can occur after a Session Terminates (???), new Sessions
Initiated (\S\ref{sec:session_initiation}) (Dynamically Created) by
Invocation (\S\ref{sec:invocation}) of Shared Servers
(\S\ref{sec:shared_server}) \cite{caires-pfenning10}

Multiple simultaneous Sessions

Data Races in Unshared Resources Forbidden

Mobility: Server and Session Name Passing (Delegation
\S\ref{sec:delegation})

Finite Session (\S\ref{sec:finite_session})


\textbf{Syntax}
\cite{honda-vasconcelos-kubo98}

Sorts $S, S', \ldots$

Sort Variables $s, s', \dots$

Type Variables $t, t', \ldots$

Types $\alpha, \beta, \ldots$

Cotypes $\overline{\alpha}, \overline{\beta}, \ldots$ %FIXME

Sort Syntax:
\cite{honda-vasconcelos-kubo98}
\[
  S ::= \quad \mathbf{nat} \quad
      | \quad \mathbf{bool} \quad
      | \quad \langle \alpha, \overline{\alpha} \rangle \quad
      | \quad s \quad
      | \quad \mu s.S
\]

Type Syntax:
\cite{honda-vasconcelos-kubo98}
\[
\begin{split}
  \alpha  ::=&\quad \uparrow[\alpha]; \beta \quad
            | \quad \downarrow[\alpha]; \beta \\
            |&\quad \uparrow[\tilde{S}]; \alpha \quad
            | \quad \downarrow[\tilde{S}]; \alpha \\
            |&\quad \& \{ l_1 : \alpha_1, \ldots, l_n : \alpha_n \} \quad
            | \quad \oplus \{ l_1 : \alpha_1, \ldots, l_n : \alpha_n \} \\
            |&\quad \mathbf{1} \quad
            | \quad \bot \quad \\
            |&\quad t \quad
            | \quad \mu t.\alpha
\end{split}
\]

$\&$ External Choice, Passive Selection, ``Offer''

$\oplus$ Internal Choice, Active Selection, ``Choose''


Cotype definitions:
\cite{honda-vasconcelos-kubo98}
\begin{itemize}
  \item $\overline{\uparrow[\alpha]; \beta}
    = \downarrow[\alpha]; \overline{\beta}$
  \item $\overline{\downarrow[\alpha]; \beta}
    = \uparrow[\alpha]; \overline{\beta}$
  \item $\overline{\uparrow[\tilde{S}]; \alpha}
    = \downarrow[\tilde{S}]; \overline{\alpha}$
  \item $\overline{\downarrow[\tilde{S}]; \alpha}
    = \uparrow[\tilde{S}]; \overline{\alpha}$
  \item $\overline{\& \{ l_i : \alpha_i \}}
    = \oplus \{ l_i : \overline{\alpha_i} \}$
  \item $\overline{\oplus \{ l_i : \alpha_i \}}
    = \& \{ l_i : \overline{\alpha_i} \}$
  \item $\overline{\mathbf{1}} = \mathbf{1}$
  \item $\overline{t} = t$
  \item $\overline{\mu t.\alpha} = \mu t.\overline{\alpha}$
\end{itemize}

$\overline{\overline{\alpha}} = \alpha$ when $\overline{\alpha}$ is
  Defined

Sort $\langle \alpha, \overline{\alpha} \rangle$ represents two
complementary Interaction Structures: one starting with a
$\mono{request}$ and another with an $\mono{accept}$


\textbf{Sorting}: Finite Partial Mapping from Names and Variables to
Sorts $\Gamma, \Gamma', \ldots$

\textbf{Typing}: Finite Partial Mapping from Channels to Types
$\Delta, \Delta', \ldots$

\textbf{Basis}: Finite Partial Mapping from Process Variables to
Sequences of Sorts and Types $\Theta, \Theta', \ldots$



Main Sequent of Typing System:

$\Theta; \Gamma \vdash P \rhd \Delta$

Given Environment $\Theta; \Gamma$, Process $P$ has Typing $\Delta$

\cite{honda-vasconcelos-kubo98}:
\begin{enumerate}
  \item (Invariance under $\equiv$)
    $\Theta; \Gamma \vdash P \rhd \Delta \wedge P \equiv Q
    \Rightarrow \Theta; \Gamma \vdash Q \rhd \Delta$
  \item (Subject Reduction)
    $\Theta; \Gamma \vdash P \rhd \Delta \wedge P \rightarrow^* Q
    \Rightarrow \Theta; \Gamma \vdash Q \rhd \Delta$
\end{enumerate}


\textbf{Types} $A, B, C, \ldots$ (Intuitionistic Linear Logic
\S\ref{sec:linear_logic})
\cite{caires-pfenning10}
\[
\begin{split}
  A,B ::=&\quad \mathbf{1} \quad
        | \quad !A\\
        |&\quad A \otimes B \quad
        | \quad A \oplus B \\
        |&\quad A \multimap B \quad
        | \quad A \& B
\end{split}
\]

Types are assigned to Channel Names $x:A$: Process uses Channel $x$
according to Type $A$


\textbf{Session Types}
(Finite Session Types)
\cite{caires-pfenning10}

Sessions either Terminate ($\mathbf{1}$) or become a Replicated Server
\S\ref{sec:shared_server} ($!A$)

Session Type Constructors $\leftrightarrow$ Intuitionistic Linear
Logic Connectives

Intuitionistic: enforces Locality of Shared Channels

\begin{itemize}
  \item $A \otimes B$: Channel first performs Output, Sending a
    Session Channel of Type $A$, and then behaves (???) as $B$
    (Continuation Session \S\ref{sec:continuation_session})
  \item $A \multimap B$: Channel first performs Input, Receiving a
    Session Channel of Type $A$, and then behaves (???) as $B$
  \item $\mathbf{1}$: Session is Terminated (Names still exist)
  \item $A \oplus B$: Either Selects ``left'' and then behaves (???)
    as $A$ or Selects ``right'' and then behaves (???) as $B$
    (Internal Choice, ``Choice'')
  \item $A \& B$: Offer either ``left'' Choice of behavior $A$ or
    ``right'' Choice of behavior $B$ as $A$ or Selects ``right'' and
    then behaves (???) as $B$ (External Choice, ``Branch'')
  \item $!A$: Non-session (Non-linearized, Shared) Channel (Standard
    Channel \S\ref{sec:standard_channel}); used by Shared Server
    (\S\ref{sec:shared_server}) spawning arbitrary number of Sessions
    of Type $A$
\end{itemize}


\textbf{Type Environment}
\cite{caires-pfenning10}

Typing Judgements correspond to Sequents in Dual Intuitionistic Linear
Logic (\S\ref{sec:dual_linear_logic}) by erasing Processes

Name : Type

$x : A$

Linear $\Delta$, Unrestricted $\Gamma$ (Weakening, Contraction)

(Linear) Variables $x,y,z,\ldots \in \Delta$
(Unrestricted) Variables $u,v,w,\ldots \in \Gamma$


Judgements:
\[
  \Gamma; \Delta \vdash P :: z:C
\]
Process $P$ (safely) provides a usage (???) of $z$ according to
behavior (Session) specified by Type $C$ in Processing Environment
providing usages (???) of Names according to behaviors (Sessions)
specified by Names in $\Gamma; \Delta$

\emph{or} (equivalently)

System providing behavior (Session) $C$ at Channel $z$ building on
``services'' declared in $\Gamma; \Delta$

$fn(P) \subseteq \Gamma \cup \Delta \cup \{z\}$

$\Gamma; \Delta \vdash \hat{D}^z :: z:A$ is Derivable in $\pi$-DILL if and
only if $\Gamma; \Delta \vdash D : A$ is Derivable in DILL

Type Extraction: Proof $D$ Extracts to Process $\hat{D}^z$

Examples:

$\Gamma; \Delta \vdash Q :: -:\mathbf{1}$: Pure Client $Q$ relying on
external services and not providing any

$\Gamma; \Delta \vdash R :: z:!A$: Shared Server $R$

$\stackrel{\triangle}{=}$

Example Session-based Interaction %FIXME

$\mathbf{0} :: x : \mathbf{1}$ Inactive (Terminated) Process (does not
use $x$)

Simple Process Interacting in different Sessions %FIXME

$id_A(x,y)$: (Process) implements a Synchronous Mediator;
bidirectionally behaves as Protocol $A$ between Channels $x$ and $y$

Behavioral Equivalences: Derivable from known Properties of Typed
Processes (Replication Theorems)
%FIXME cite pi calculus sangiorgi & walker

$\simeq_s$: Typed Behavioral Equivalence on Processes

Computational Conversions, Structural Conversions

Subject Reduction (\S\ref{sec:subject_reduction})

Contextual Progress Property, Global Progress Property,
Non-replicated Guarded Process %FIXME



\subparagraph{Classical Processes}\label{sec:classical_processes}
\hfill \\
\cite{wadler12}

\emph{Classical Processes} (CP)

Caires-Pfenning \cite{caires-pfenning10}

No Deadlocks

$\pi$-DILL:
\begin{itemize}
  \item Output: $- \vdash \otimes$, $\multimap \vdash -$

  \item Input: $- \vdash \multimap$, $\otimes \vdash -$
\end{itemize}

CP:
\begin{itemize}
  \item Output: $\vdash \otimes$

  \item Input: $\vdash \parr$
\end{itemize}

Th. \textbf{Subject Reduction}:
\[
  \text{If } P \vdash \Gamma \text{ and } P \Rightarrow Q
  \text{ then } Q \vdash \Gamma
\]

Th. \textbf{Cut Elimination}:
\[
  \text{If } P \vdash \Gamma \text{ then there exists } Q
  \text{ such that } P \Rightarrow^* Q \text{ and } Q
  \text{ is not a } Cut
\]



\subparagraph{Good Variation}\label{sec:good_variation}
\hfill \\
\cite{wadler12}

Gay-Vasconcelos %FIXME

Th. \textbf{Translation Preserves Types}

\[
  \text{If } \Phi \vdash M : T \text{ then }
  \llbracket M \rrbracket x \vdash \llbracket \Phi \rrbracket^\bot,
  x : \llbracket T \rrbracket
\]



% ====================================================================
\section{Recursive Function Theory}\label{sec:recursive_function_theory}
% ====================================================================

Point-free, cf. Combinatory Logic



% ====================================================================
\section{Complexity Theory}\label{sec:complexity_theory}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Algorithm}\label{sec:algorithm}
% --------------------------------------------------------------------

An \emph{Algorithm} may be formalized as a sequence of operations that
can be simulated by a Turing-complete system and any Function that is
computable by Algorithm is a Computable Function
(\S\ref{sec:computable_function}).



\subsubsection{Algorithmic Randomness}\label{sec:algorithmic_randomness}



% --------------------------------------------------------------------
\subsection{Function Problem}\label{sec:function_problem}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Communication Complexity}\label{sec:communication_complexity}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Complexity Class}\label{sec:complexity_class}
% --------------------------------------------------------------------

\[
  \mathsf{PR} \subset \mathsf{R} = \mathsf{RE} \cap \mathsf{coRE}
\]



\subsubsection{Double Exponential}\label{sec:double_exponential}

Cylindrical Algebraic Decomposition
(\S\ref{sec:algebraic_decomposition})



% --------------------------------------------------------------------
\subsection{Decidable Set}\label{sec:decidable_set}
% --------------------------------------------------------------------

\emph{Semi-decidable Set}



% --------------------------------------------------------------------
\subsection{Recursive Set}\label{sec:recursive_set}
% --------------------------------------------------------------------

\subsubsection{Recursively Enumerable Set}\label{sec:recursively_enumerable}



% --------------------------------------------------------------------
\subsection{Hyperarithmetic Set}\label{sec:hyperarithmetic_set}
% --------------------------------------------------------------------

\emph{Hyperarithmetic Sets} are the Class of Sets denoted as
$\Delta^1_1$ in the \emph{Analytic Hierarchy}
(\S\ref{sec:analytic_hierarchy}).



% --------------------------------------------------------------------
\subsection{Analytical Set}\label{sec:analytical_set}
% --------------------------------------------------------------------



% --------------------------------------------------------------------
\subsection{Hierarchies}\label{sec:complexity_hierarchy}
% --------------------------------------------------------------------

\[
  \mathsf{AC^0} \subseteq \mathsf{L} \subseteq \mathsf{NC} \subseteq
  \mathsf{P} \subseteq \mathsf{PSPACE} \subseteq \mathsf{EXP}
  \subseteq \mathsf{ALL}
\]

\[
  \Delta_0 = \Sigma_0 = \Pi_0 = \mathsf{R}
\]\[
  \Sigma_1^0 \leftrightarrow \mathsf{RE}
\]\[
  \Pi_1^0 \leftrightarrow \mathsf{coRE}
\]

\emph{$\mathsf{NC}$} is the Class of problems decidable in
Polyalgorithmic Time on a Parallel Computer with a Polynomial number
of Processors.

\emph{Lightface} (no \emph{Set Parameters}) %FIXME explain ``set parameters''
\[
  \Sigma, \Pi, \Delta
\]

\emph{Boldface} (standard hierarchy of Borel Sets)
\[
  \mathbf{\Sigma}, \mathbf{\Pi}, \mathbf{\Delta}
\]

Formulas are considered in \emph{Prenex Normal Form}
(\S\ref{sec:prenex_normal}).
\[
  \Sigma^k_n \cap \Pi^k_n = \Delta^k_n
\]
\begin{itemize}
  \item $k$ is the type of objects being Quantified over with type
    $0 = \mathbb{N}$, and type $i + 1$ are Functions from type $i
    \rightarrow \mathbb{N}$.
  \item $n$ is the number of alternating blocks of Existential and
    Universal Quantifiers
\end{itemize}
The outermost Quantifier block for $\Sigma$ Classes is Existential,
and for $\Pi$ Classes is Universal.



\subsubsection{Arithmetic Hierarchy}\label{sec:arithmetic_hierarchy}

The \emph{Arithmetic Hierarchy} Classifies the Complexity of Formulas
in \emph{First-order Arithmetic}
(\S\ref{sec:firstorder_arithmetic}). The Arithmetic Hierarchy is
extended by the \emph{Hyperarithmetic} and \emph{Analytic
  Hierarchies}.

Every Formula in the Language of First-order Arithmetic is in
$\Sigma^0_n$ or $\Pi^0_n$ for $n \in \mathbb{N}$. Formulas with only
\emph{Bounded Quantifiers} (\S\ref{sec:quantifier}) are in
$\Sigma^0_0$ or $\Pi^0_0$. $\Sigma^0_n$ and $\Pi^0_n$ are defined
Inductively for $n \in \mathbb{N}$:

\begin{itemize}
  \item $\phi = \exists x_1 \exists x_2 \cdots \exists x_k\psi, \psi
    \in \Pi^0_n \rightarrow \phi \in \Sigma^0_{n+1}$
  \item $\phi = \forall x_1 \forall x_2 \cdots \forall x_k\psi, \psi
    \in \Sigma^0_n \rightarrow \phi \in \Pi^0_{n+1}$
\end{itemize}

Thus a $\Sigma^0_n$ Formula begins with Existential Quantifiers and
alternates $n-1$ times between series of Existential and Universal
Quantifiers. The dual is true for $\Pi^0_n$.

By the addition of redundant Quantifiers, a Formula of $\Sigma^0_n$ or
$\Pi^0_n$ is also $\Sigma^0_m$ and $\Pi^0_m$ for $m > n$.

Sets of Natural Numbers that are definable in First-order Arithmetic
are assigned to Classes $\Sigma^0_n$ or $\Pi^0_n$, and to $\Delta^0_n$
if they are both $\Sigma^0_n$ and $\Pi^0_n$.

Turing Computable Sets are at level $\Delta^0_1$.

The \emph{Hyperarithmetic Sets} (\S\ref{sec:hyperarithmetic_set})
are defined as $\Delta^1_1$.

\paragraph{Relativized Arithmetical Hierarchies}



\subsubsection{Analytic Hierarchy}\label{sec:analytic_hierarchy}

The \emph{Analytic Hierarchy} extends the Arithmetic Hierarchy to
Second-order Formulas. The Classification is of \emph{Analytical Sets}
(\S\ref{sec:analytical_set} of Natural Numbers by the difficulty of
specifying in Second-order Arithmetic
(\S\ref{sec:second_order_arithmetic}), that is Second-order Formulas which
include Quantifiers over $\mathbb{N}$ and Functions from $\mathbb{N}$
to $\mathbb{N}$.

Every Formula in the Language of Second-order Arithmetic is in
$\Sigma^1_n$ or $\Pi^1_n$ for $n \in \mathbb{N}$.

Second-order Arithmetic with no Function Quantifiers:
\[
  \Delta^1_0 = \Sigma^1_0 = \Pi^1_0
\]

Second-order Arithmetic with Existential Function Quantifiers only:
\[
  \Sigma^1_1
\]

Second-order Arithmetic with Universal Function Quantifiers only:
\[
  \Pi^1_1
\]
Both $\Sigma^1_1$ and $\Pi^1_1$ are strictly larger than $\Delta^1_0$.

Second-order Arithmetic with both Existential and Universal Function
Quantifiers-- the class of \emph{Hyperarithmetic Sets}:
\[
  \Delta^1_1 = \Sigma^1_1 \cap \Pi^1_1
\]
is larger than $\Delta^1_0$.

$\Pi^1_1$ Formulas quantified over by Existential Functional
Quantifiers results in the Class $\Sigma^1_2$.

$\Sigma^1_1$ Formulas quantified over by Universal Functional
Quantifiers results in the Class $\Pi^1_2$.

Again, $\Delta^1_2$ is the Intersection of $\Sigma^1_2$ and $\Pi^1_2$
and Inductively this procedure extends to $\Sigma^1_n$, $\Pi^1_n$, and
$\Delta^1_n$.



\subsubsection{Projective Hierarchy}\label{sec:projective_hierarchy}

\emph{Pointclass} (\S\ref{sec:pointclass})

Pointclass of all \emph{Analytic Sets} (\S\ref{sec:analytic_set})
\[
  \mathbf{\Sigma^1_1}
\]

\paragraph{Borel Hierarchy}



\subsubsection{Counting Hierarchy}

\subsubsection{Exponential Hierarchy}

\subsubsection{Fourier Hierarchy}

\subsubsection{Polynomial Hierarchy}

\paragraph{Pseudo-polynomial}\label{sec:pseudo_polynomial}

\subsubsection{Polynomial Communication Hierarchy}

\subsubsection{Boolean Hierarchy}




\subsubsection{Blum Complexity Measure}

\emph{Blum Axioms}



% ====================================================================
\section{Hypercomputation}\label{sec:hypercomputation}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Oracle}\label{sec:oracle}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{$\alpha$-recursion Theory}\label{sec:alpha_recursion}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Hyperarithmetical Theory}\label{sec:hyperarithmetical_theory}
% --------------------------------------------------------------------



% ====================================================================
\section{Recursion}\label{sec:recursion}
% ====================================================================

Breaking down to reach a Base Case

Self-referential Functions

\HandRight\; Cf. \emph{Process Recursion} \S\ref{sec:process_recursion}



% --------------------------------------------------------------------
\subsection{Single Recursion}\label{sec:single_recursion}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Multiple Recursion}\label{sec:multiple_recursion}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Direct Recursion}\label{sec:direct_recursion}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Indirect Recursion}\label{sec:indirect_recursion}
% --------------------------------------------------------------------

(or \emph{Mutual Recursion})

A Set of Mutually Recursive Functions are Primitive Recursive
(\S\ref{sec:primitive_recursive})

Recursive Descent Parser (\S\ref{sec:recursive_descent})

Tree Type (\S\ref{sec:tree_type})



% --------------------------------------------------------------------
\subsection{Structural Recursion}\label{sec:structural_recursion}
% --------------------------------------------------------------------

\emph{Structural Induction} (\S\ref{sec:structural_induction})

Recursive Definition (\S\ref{sec:recursive_definition})

Well-ordering (\S\ref{sec:well_order})

Inductive Type (\S\ref{sec:inductive_type})



% --------------------------------------------------------------------
\subsection{Transfinite Recursion}\label{sec:transfinite_recursion}
% --------------------------------------------------------------------

Transfinite Induction (\S\ref{sec:transfinite_induction})



% ====================================================================
\section{Corecursion}\label{sec:corecursion}
% ====================================================================

Building up from a Base Case

Self-referential Data



\subsubsection{Primitive Corecursion}\label{sec:primitive_corecursion}



% ====================================================================
\section{Generative Recursion}\label{sec:generative_recursion}
% ====================================================================
