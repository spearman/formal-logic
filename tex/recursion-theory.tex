%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Recursion Theory}\label{part:recursion_theory}\cite{czoo14}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

also \emph{Computability Theory}

\emph{Church-Turing}



% ====================================================================
\section{Computability}\label{sec:computability}
% ====================================================================

\begin{itemize}
\item Zero-function
\item Successor functions
\item Projection functions
\end{itemize}

Closed under:

\begin{itemize}
\item Composition
\item Primitive Recursion (\S\ref{sec:primitive_recursion})
\item Minimization (\S\ref{sec:mu_recursion})
\end{itemize}

If Minimization is not included, the resulting Functions are Primitive
Recursive Functions that are halting, but do not include all Total
Computable Functions (the Primitive Recursive Functions are a Strict
Subset of the Total $\mu$-recursive Functions).

The Minimization Operator (Unbounded $\mu$-operator) allows for
Unbounded Search and thus the definition of all Computable Functions.



% ====================================================================
\section{Decision Problem}\label{sec:decision_problem}
% ====================================================================



% ====================================================================
\section{Effective Calculability}\label{sec:effective_method}
% ====================================================================

A \emph{Function} (\S\ref{sec:function}) or \emph{Decision
Problem} (\S\ref{sec:decision_problem}) is \emph{Effectively
Calculable} if there exists an \emph{Effective Method} for solving
that problem.

An \emph{Effective Method} is a mechanical procedure for solving a
Function or Decision Problem of a specific \emph{Complexity Class}
(\S\ref{sec:complexity_theory}).

See \emph{Computable Function} (\S\ref{sec:computable_function}),
\emph{Computation Models} (\S\ref{sec:computation_model}) and
\emph{Algorithms} (\S\ref{sec:algorithm}).

Effective Topos (\S\ref{sec:effective_topos})



% ====================================================================
\section{Noncomputable Function}\label{sec:noncomputable_function}
% ====================================================================

also \emph{Undecidable Function}

\emph{Algorithmically Unsolvable}

\emph{Turing Degree}



% ====================================================================
\section{Computable Function}\label{sec:computable_function}
% ====================================================================

\emph{Computable Number} (\S\ref{sec:computable_real})

\emph{Computable Functions} are the formalized analogues of
\emph{Algorithms} (\S\ref{sec:algorithm}); that is a Function that
is \emph{Effectively Calculable} by an Effective Method
(\S\ref{sec:effective_method}).

\emph{Computable Functions} may be broadly divided into two Classes by
whether they are \emph{Partial} or \emph{Total}. A Total Computable
Function is sometimes called a (Total) \emph{Recursive} or
\emph{Decidable Function}.

There are several equivalent definitions of the class of Computable
Functions, which have reference to different \emph{Models of
  Computation} (\S\ref{sec:computation_model}):
\begin{enumerate}
\item Turing-computable Functions
\item $\mu$-recursive Functions
\item $\lambda$-recursive Functions
\end{enumerate}



% --------------------------------------------------------------------
\subsection{Partial Computable Function}\label{sec:partial_recursive}
% --------------------------------------------------------------------

A \emph{Partial Computable Function} (\emph{Partial Recursive
  Function}) is also called \emph{Semidecidable} or \emph{Recursively
  Enumerable} and are the Class of Functions capable of generating
\emph{Recursively Enumerable Sets}
(\S\ref{sec:recursively_enumerable}). A Set, $T$, is
\emph{Co-recursively Enumerable} if the Compliment $\mathbb{N} \ T$ is
Recursively Enumerable.

\emph{Recursively Enumerable} $\mathsf{coRE}$

The Lattice (\S\ref{sec:lattice}) of $\mathsf{RE}$ Sets under
Inclusion is denoted $\mathcal{E}$.

For a Computational Model of Partial Computable Functions see
$\mu$-recursion (\S\ref{sec:mu_recursion}).



\subsubsection{Admissible Numbering}\label{sec:admissible_numbering}



\subsubsection{Markov Algorithm}\label{sec:markov_algorithm}

String Rewriting System (\S\ref{sec:string_rewriting})



% --------------------------------------------------------------------
\subsection{Total Computable Function}\label{sec:recursive_function}
% --------------------------------------------------------------------

\emph{Total Recursive Function}



\subsubsection{General Recursion}\label{sec:general_recursion}

A \emph{General Recursive Function} is any Total Unbounded
$\mu$-recursive Function (\S\ref{sec:mu_recursion}). \emph{Primitive
  Recursive Functions} (\S\ref{sec:primitive_recursion}) are a Strict
Subset of General Recursive Functions.



\subsubsection{Primitive Recursion}\label{sec:primitive_recursion}

The Class of \emph{Primitive Recursive Functions}, $\mathsf{PR}$, are
those given by three Axioms:
\begin{enumerate}
  \item The $0$-ary \emph{Constant Function}, $0$, is Primitive
    Recursive
  \item The $1$-ary \emph{Successor Function}, $S(k) = k + 1$, is
    Primitive Recursive
  \item The $n$-ary \emph{Projection Function}, $P_i^n = k_i$,
    (returning the $i$th argument) is Primitive Recursive
\end{enumerate}
and the Operations:
\begin{enumerate}
  \item \emph{Composition}: Given a $k$-ary function, $f$, and $k$
    $m$-ary Primitive Recursive Functions, $g_1, \ldots, g_k$,
  \item \emph{Primitive Recursion}: Bounded $\mu$-recursion
    (\S\ref{sec:mu_recursion})
\end{enumerate}

Primitive Recursive Functions can be of four types: \cite{kleene52}

\begin{enumerate}
\item Number-theoretic Functions ($\mathbb{N} \rightarrow \mathbb{N}$)
\item Predicates ($\mathbb{N} \rightarrow \{T,F\}$)
\item Propositional Connectives ($\{T,F\} \rightarrow \{T,F\}$)
\item Representing Functions ($\{T,F\} \rightarrow \mathbb{N}$
\end{enumerate}



% --------------------------------------------------------------------
\subsection{Universal Function}\label{sec:universal_function}
% --------------------------------------------------------------------

\emph{UTM Theorem}

$u : \mathbb{N}^2 \rightarrow \mathbb{N}$



% ====================================================================
\section{Semicomputable Function}\label{sec:semicomputable_function}
% ====================================================================

\emph{Upper Semicomputable}

\emph{Lower Semicomputable}

A Partial Function that is both Upper and Lower Semicomputable is just
a Computable Function.



% ====================================================================
\section{Higher-order Function}\label{sec:higherorder_function}
% ====================================================================



% ====================================================================
\section{Models of Computation}\label{sec:computation_model}
% ====================================================================

% --------------------------------------------------------------------
\subsection{$\mu$-recursion}\label{sec:mu_recursion}
% --------------------------------------------------------------------

\emph{$\mu$-recursion} or \emph{Minimization}

\emph{$\mu$-recursive} or \emph{Partially Recursive Functions}

\emph{Bounded $\mu$-recursion}

\emph{Unbounded $\mu$-recursion}



% --------------------------------------------------------------------
\subsection{Turing Machine}
% --------------------------------------------------------------------

See Part \ref{sec:automata_theory} Automata Theory
\S\ref{sec:turing_machine} Turing Machines



\subsubsection{Post-Turing Machine}\label{sec:post_turing}



% --------------------------------------------------------------------
\subsection{Untyped $\lambda$-calculus}\label{sec:untyped_lambda}
% --------------------------------------------------------------------

\emph{Untyped $\lambda$-calculus} describes a Semantics for Computable
Functions (\S\ref{sec:computable_function}).

Untyped $\lambda$-calculus can be seen as a Typed $\lambda$-calculus
with a single Type (\S\ref{sec:type}).

Dana Scott - Set $D$ Isomorphic to Function Space $D \rightarrow D$ of
Functions on itself can be defined if only Continuous Functions are
considered, providing a Model for $\lambda$-calculus. cf. Denotational
Semantics (\S\ref{sec:denotational_semantics})

see also Combinatory Logic (\S\ref{sec:combinatory_logic})



\subsubsection{Lambda Expression}\label{sec:lambda_expression}

A \emph{Lambda Expression} is an Expression in the Language of Untyped
$\lambda$-calculus.

The Language of Untyped $\lambda$-calculus consists of the Symbols:
\begin{itemize}
  \item Variables $V = \{ x_1, x_2, \ldots, x_n, \ldots \}$
  \item Abstraction Symbols $\{ \lambda, . \}$
  \item Parentheses $\{ (, ) \}$
\end{itemize}

The Set of Lambda Expressions, $\Lambda$, is defined Inductively:
\begin{enumerate}
  \item $x \in V \Rightarrow x \in \Lambda$
  \item $x \in V \wedge M \in \Lambda \Rightarrow (\lambda x.M) \in
    \Lambda$ (\emph{Abstraction} \S\ref{sec:lambda_abstraction})
  \item $M,N \in \Lambda \Rightarrow (M N) \in \Lambda$
    (\emph{Application} \S\ref{sec:lambda_application})
\end{enumerate}
Notational conventions:
\begin{itemize}
  \item Outermost parentheses may be dropped:
    \[
      (M N) \equiv M N
    \]
  \item Applications are left-associative:
    \[
      M N P \equiv (M N) P
    \]
  \item Body extends as far right as possible:
    \[
      \lambda x.M N \equiv \lambda x.(M N)
    \]
  \item Sequences of Abstractions are contracted:
    \[
      \lambda x.\lambda y.\lambda z.M \equiv
      \lambda xyz.M
    \]
\end{itemize}

A Lambda Expression with no Free Variables is \emph{Closed}, or
sometimes referred to as \emph{Combinators}, equivalent to Terms in
Combinatory Logic (\S\ref{sec:combinatory_logic}).

A Function $f : \mathbb{N} \rightarrow \mathbb{N}$ is a Computable
Function (\S\ref{sec:computable_function}) if and only if there is a
Lambda Expression $F$ such that:
\[
  \forall x,y \in \mathbb{N} (f(x)=y \leftrightarrow F x =_\beta y)
\]



\subsubsection{Lambda Abstraction}\label{sec:lambda_abstraction}

\emph{Lambda Abstraction} is the definition of an \emph{Anonymous
  Function} by the Abstraction Operator $\lambda$ applied to a
Variable (or \emph{Formal Parameter}) $x \in V$ as Binding all Free
occurences of that Variable in the \emph{Body} following the '$.$'
Symbol.

The Variable named by the Lambda Abstraction is \emph{$lambda$-bound}
(or just \emph{Bound}) by the Abstraction.



\paragraph{Free Variable}\label{sec:free_variable}
\hfill \\

A \emph{Free Variable} is one not $\lambda$-bound by a Lambda
Abstraction.

\begin{itemize}
  \item The Free Variables of a Term $x$ consisting of the Variable
    $x$ is just $x$
  \item The Free Variables of $\lambda x.t$ are the Free Variables of
    $t$ without $x$
  \item The Free Variables of $ts$ is the Union of the Free Variables
    of $t$ and the Free Variables of $s$
\end{itemize}

A Free Variable is Bound by its ``nearest'' abstraction:
\[
  \lambda x.y (\lambda x.z x)
\]
The Free occurence of $x$ is Bound by the second Abstraction.



\subsubsection{Lambda Application}\label{sec:lambda_application}

\emph{Application}

The application of a Function $t$ to an Input $s$: $ts$ or $t(s)$



\subsubsection{Lambda Term}\label{sec:lambda_term}

A \emph{Lambda Term} is a Term (\S\ref{sec:term}) in the Language of
Untyped $\lambda$-calculus with the following Inductive definition:
\begin{itemize}
  \item a Variable $x$ is a Lambda Term
  \item for a Lambda Term $t$ and a Variable $x$, the Lambda
    Abstraction $(\lambda x.t)$ is a Lambda Term
  \item for Lambda Terms $t$ and $s$, the Application $(ts)$ is a
    Lambda Term
\end{itemize}
Bracketing may be needed to disambiguate Terms.

By the \emph{Church-Rosser Theorem}, the Reduction Rules of
$\lambda$-calculus are Confluent, so every Lambda Term has at most one
Normal Form. In general there is no Effective method for deciding
whether two arbitrary Lambda Terms are Equivalent.




\subsubsection{Substitution}\label{sec:lambda_substitution}

For a Lambda Term $t$ with Free Variable $x$, a \emph{Substitution}
$t[x/s]$ is the replacement of all occurences of $x$ by a Term $s$.

Substitution is defined uniquiely up to $\alpha$-equivalence
(\S\ref{sec:alpha_conversion}).

see also Substitution (Formal Logic \S\ref{sec:substitution})



\paragraph{Capture-avoiding Substitution}\label{sec:capture_avoiding}
\hfill \\

\emph{Capture-avoiding Substitution}

\emph{Freshness Condition}



\paragraph{Explicit Substitution}\label{sec:explicit_substitution}



\subsubsection{$\alpha$-conversion}\label{sec:alpha_conversion}

\emph{$\alpha$-conversion} (or \emph{$\alpha$-renaming}) is a renaming
of Bound Variables in a Term that results in an $\alpha$-equivalent
Term:
\[
  \lambda x.x =_\alpha \lambda y.y
\]

\emph{Variable Convention}:
\begin{enumerate}
  \item Bound Variables are distinct from Free Variables
  \item ``Binders'' only Bind Variables not already in Scope % FIXME
\end{enumerate}

\emph{De Bruijn Indices} ``name-free''

When represented as De Bruijn Indices, $\alpha$-equivalent Expressions
are Syntactically identical.

see also Nominal Logic (\S\ref{sec:nominal_logic})



\subsubsection{Contraction}\label{sec:contraction}\cite{seldin03}

Replacement of Subterms:
\begin{enumerate}
  \item $\lambda x . M =_\alpha \lambda y . [y/x]M$
  \item $(\lambda x . M)N =_\beta [N/x]M$
\end{enumerate}



\subsubsection{$\beta$-reduction}\label{sec:beta_reduction}

A \emph{$\beta$-reduction} is a Sequence of Zero or more Contractions
(\S\ref{sec:contraction}). A Term $M$ that Reduces to a Term $N$ is
written $M \rhd N$. $\beta$-reduction may not Terminate but
$\beta$-reduction is Confluent (\S\ref{sec:rewrite_confluence}).

As a Semantics for Functional Programming, a $\beta$-contraction
corresponds to a Computational Step.



\subsubsection{$\beta$-conversion}\label{sec:beta_conversion}
\cite{seldin03}

A \emph{$\beta$-conversion} is a Sequence of Zero or more Contractions
or reverse Contractions. A Conversion from Term $M$ to Term $N$ is
denoted $M =_* N$.



\subsubsection{$\eta$-conversion}\label{sec:eta_conversion}

\emph{$\eta$-reduction}:
\[
  \lambda x.y x \rightarrow_\eta y
\]
\emph{$\eta$-abstraction}:
\[
  y \rightarrow_\eta \lambda x.y x
\]

Extensional (\S\ref{sec:extension}) Equivalence of Expressions



\subsubsection{Church Encoding}\label{sec:church_encoding}

\subsubsection{Deductive $\lambda$-Calclulus}\label{sec:deductive_lambda}

\emph{Intensional Equality} (or \emph{Point-free Equality}): Equal if
$\alpha$-convertible (equality of Function implementations)

\emph{Extensional Equality} (or \emph{Point-wise Equality}): Equal if
Functionally equivalent (perform the same mapping on the same inputs)

Untyped $\lambda$-calculus with Intensional Equality is Inconsistent
as a Deductive System.

Rice's Theorem (\S\ref{sec:rices_theorem})

Von Neumann Universe (\S\ref{sec:vonneumann_universe})



\subsubsection{Reduction Strategy}\label{sec:reduction_strategy}



\subsubsection{Predicate Abstraction}\label{sec:predicate_abstraction}

\emph{Law of Abstraction}



% --------------------------------------------------------------------
\subsection{SKI Combinator Calculus}\label{sec:ski_calculus}
% --------------------------------------------------------------------

Combinatory Logic (\S\ref{sec:combinatory_logic})



% --------------------------------------------------------------------
\subsection{Tag System}\label{sec:tag_system}
% --------------------------------------------------------------------

also \emph{Post Tag Machine}



% --------------------------------------------------------------------
\subsection{Register Machine}\label{sec:register_machine}
% --------------------------------------------------------------------

\subsubsection{Counter Machine}

\subsubsection{Pointer Machine}

\subsubsection{Random Access Machine}

\subsubsection{Random Access Stored Program Machine}



% --------------------------------------------------------------------
\subsection{Process Calculus}\label{sec:process_calculus}
% --------------------------------------------------------------------

Family of approaches for modelling Concurrent Systems



% ====================================================================
\section{Recursive Function Theory}\label{sec:recursive_function_theory}
% ====================================================================

Point-free, cf. Combinatory Logic



% ====================================================================
\section{Complexity Theory}\label{sec:complexity_theory}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Algorithm}\label{sec:algorithm}
% --------------------------------------------------------------------

An \emph{Algorithm} may be formalized as a sequence of operations that
can be simulated by a Turing-complete system and any function that is
computable by Algorithm is a Computable Function
(\S\ref{sec:computable_function}).

\subsubsection{Algorithmic Randomness}\label{sec:algorithmic_randomness}

% --------------------------------------------------------------------
\subsection{Function Problem}\label{sec:function_problem}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Communication Complexity}\label{sec:communication_complexity}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Complexity Class}\label{sec:complexity_class}
% --------------------------------------------------------------------

\[
  \mathsf{PR} \subset \mathsf{R} = \mathsf{RE} \cap \mathsf{coRE}
\]



\subsubsection{Double Exponential}\label{sec:double_exponential}

Cylindrical Algebraic Decomposition
(\S\ref{sec:algebraic_decomposition})



% --------------------------------------------------------------------
\subsection{Decidable Set}\label{sec:decidable_set}
% --------------------------------------------------------------------

\emph{Semi-decidable Set}



% --------------------------------------------------------------------
\subsection{Recursive Set}\label{sec:recursive_set}
% --------------------------------------------------------------------

\subsubsection{Recursively Enumerable Set}\label{sec:recursively_enumerable}



% --------------------------------------------------------------------
\subsection{Hyperarithmetic Set}\label{sec:hyperarithmetic_set}
% --------------------------------------------------------------------

\emph{Hyperarithmetic Sets} are the Class of Sets denoted as
$\Delta^1_1$ in the \emph{Analytic Hierarchy}
(\S\ref{sec:analytic_hierarchy}).



% --------------------------------------------------------------------
\subsection{Analytical Set}\label{sec:analytical_set}
% --------------------------------------------------------------------



% --------------------------------------------------------------------
\subsection{Hierarchies}\label{sec:complexity_hierarchy}
% --------------------------------------------------------------------

\[
  \mathsf{AC^0} \subseteq \mathsf{L} \subseteq \mathsf{NC} \subseteq
  \mathsf{P} \subseteq \mathsf{PSPACE} \subseteq \mathsf{EXP}
  \subseteq \mathsf{ALL}
\]

\[
  \Delta_0 = \Sigma_0 = \Pi_0 = \mathsf{R}
\]\[
  \Sigma_1^0 \leftrightarrow \mathsf{RE}
\]\[
  \Pi_1^0 \leftrightarrow \mathsf{coRE}
\]

\emph{$\mathsf{NC}$} is the Class of problems decidable in
Polyalgorithmic Time on a Parallel Computer with a Polynomial number
of Processors.

\emph{Lightface} (no \emph{Set Parameters}) %FIXME explain ``set parameters''
\[
  \Sigma, \Pi, \Delta
\]

\emph{Boldface} (standard hierarchy of Borel Sets)
\[
  \mathbf{\Sigma}, \mathbf{\Pi}, \mathbf{\Delta}
\]

Formulas are considered in \emph{Prenex Normal Form}
(\S\ref{sec:prenex_normal}).
\[
  \Sigma^k_n \cap \Pi^k_n = \Delta^k_n
\]
\begin{itemize}
  \item $k$ is the type of objects being Quantified over with type
    $0 = \mathbb{N}$, and type $i + 1$ are Functions from type $i
    \rightarrow \mathbb{N}$.
  \item $n$ is the number of alternating blocks of Existential and
    Universal Quantifiers
\end{itemize}
The outermost Quantifier block for $\Sigma$ Classes is Existential,
and for $\Pi$ Classes is Universal.



\subsubsection{Arithmetic Hierarchy}\label{sec:arithmetic_hierarchy}

The \emph{Arithmetic Hierarchy} Classifies the Complexity of Formulas
in \emph{First-order Arithmetic}
(\S\ref{sec:firstorder_arithmetic}). The Arithmetic Hierarchy is
extended by the \emph{Hyperarithmetic} and \emph{Analytic
  Hierarchies}.

Every Formula in the Language of First-order Arithmetic is in
$\Sigma^0_n$ or $\Pi^0_n$ for $n \in \mathbb{N}$. Formulas with only
\emph{Bounded Quantifiers} (\S\ref{sec:quantifier}) are in
$\Sigma^0_0$ or $\Pi^0_0$. $\Sigma^0_n$ and $\Pi^0_n$ are defined
Inductively for $n \in \mathbb{N}$:

\begin{itemize}
  \item $\phi = \exists x_1 \exists x_2 \cdots \exists x_k\psi, \psi
    \in \Pi^0_n \rightarrow \phi \in \Sigma^0_{n+1}$
  \item $\phi = \forall x_1 \forall x_2 \cdots \forall x_k\psi, \psi
    \in \Sigma^0_n \rightarrow \phi \in \Pi^0_{n+1}$
\end{itemize}

Thus a $\Sigma^0_n$ Formula begins with Existential Quantifiers and
alternates $n-1$ times between series of Existential and Universal
Quantifiers. The dual is true for $\Pi^0_n$.

By the addition of redundant Quantifiers, a Formula of $\Sigma^0_n$ or
$\Pi^0_n$ is also $\Sigma^0_m$ and $\Pi^0_m$ for $m > n$.

Sets of Natural Numbers that are definable in First-order Arithmetic
are assigned to Classes $\Sigma^0_n$ or $\Pi^0_n$, and to $\Delta^0_n$
if they are both $\Sigma^0_n$ and $\Pi^0_n$.

Turing Computable Sets are at level $\Delta^0_1$.

The \emph{Hyperarithmetic Sets} (\S\ref{sec:hyperarithmetic_set})
are defined as $\Delta^1_1$.

\paragraph{Relativized Arithmetical Hierarchies}



\subsubsection{Analytic Hierarchy}\label{sec:analytic_hierarchy}

The \emph{Analytic Hierarchy} extends the Arithmetic Hierarchy to
Second-order Formulas. The Classification is of \emph{Analytical Sets}
(\S\ref{sec:analytical_set} of Natural Numbers by the difficulty of
specifying in Second-order Arithmetic
(\S\ref{sec:second_order_arithmetic}), that is Second-order Formulas which
include Quantifiers over $\mathbb{N}$ and Functions from $\mathbb{N}$
to $\mathbb{N}$.

Every Formula in the Language of Second-order Arithmetic is in
$\Sigma^1_n$ or $\Pi^1_n$ for $n \in \mathbb{N}$.

Second-order Arithmetic with no Function Quantifiers:
\[
  \Delta^1_0 = \Sigma^1_0 = \Pi^1_0
\]

Second-order Arithmetic with Existential Function Quantifiers only:
\[
  \Sigma^1_1
\]

Second-order Arithmetic with Universal Function Quantifiers only:
\[
  \Pi^1_1
\]
Both $\Sigma^1_1$ and $\Pi^1_1$ are strictly larger than $\Delta^1_0$.

Second-order Arithmetic with both Existential and Universal Function
Quantifiers-- the class of \emph{Hyperarithmetic Sets}:
\[
  \Delta^1_1 = \Sigma^1_1 \cap \Pi^1_1
\]
is larger than $\Delta^1_0$.

$\Pi^1_1$ Formulas quantified over by Existential Functional
Quantifiers results in the Class $\Sigma^1_2$.

$\Sigma^1_1$ Formulas quantified over by Universal Functional
Quantifiers results in the Class $\Pi^1_2$.

Again, $\Delta^1_2$ is the Intersection of $\Sigma^1_2$ and $\Pi^1_2$
and Inductively this procedure extends to $\Sigma^1_n$, $\Pi^1_n$, and
$\Delta^1_n$.



\subsubsection{Projective Hierarchy}\label{sec:projective_hierarchy}

\emph{Pointclass} (\S\ref{sec:pointclass})

Pointclass of all \emph{Analytic Sets} (\S\ref{sec:analytic_set})
\[
  \mathbf{\Sigma^1_1}
\]

\paragraph{Borel Hierarchy}



\subsubsection{Counting Hierarchy}

\subsubsection{Exponential Hierarchy}

\subsubsection{Fourier Hierarchy}

\subsubsection{Polynomial Hierarchy}

\paragraph{Pseudo-polynomial}\label{sec:pseudo_polynomial}

\subsubsection{Polynomial Communication Hierarchy}

\subsubsection{Boolean Hierarchy}




\subsubsection{Blum Complexity Measure}

\emph{Blum Axioms}



% ====================================================================
\section{Hypercomputation}\label{sec:hypercomputation}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Oracle}\label{sec:oracle}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{$\alpha$-recursion Theory}\label{sec:alpha_recursion}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Hyperarithmetical Theory}\label{sec:hyperarithmetical_theory}
% --------------------------------------------------------------------



% ====================================================================
\section{Recursion}\label{sec:recursion}
% ====================================================================

Breaking down to reach a Base Case

Self-referential Functions



% --------------------------------------------------------------------
\subsection{Structural Recursion}\label{sec:structural_recursion}
% --------------------------------------------------------------------

\emph{Structural Induction} (\S\ref{sec:structural_induction})

Recursive Definition (\S\ref{sec:recursive_definition})

Well-ordering (\S\ref{sec:well_order})

Inductive Type (\S\ref{sec:inductive_type})



% --------------------------------------------------------------------
\subsection{Transfinite Recursion}\label{sec:transfinite_recursion}
% --------------------------------------------------------------------

\emph{Transfinite Induction} (\S\ref{sec:transfinite_induction})



% ====================================================================
\section{Corecursion}\label{sec:corecursion}
% ====================================================================

Building up from a Base Case

Self-referential Data



\subsubsection{Primitive Corecursion}\label{sec:primitive_corecursion}



% ====================================================================
\section{Generative Recursion}\label{sec:generative_recursion}
% ====================================================================
