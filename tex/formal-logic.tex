%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Formal Logic}\label{part:formal_logic}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Formal Logic} (or \emph{Symbolic Logic}) is the study of Logical
Systems (\S\ref{sec:logical_system}), that is, Formal Systems
(\S\ref{sec:formal_system}) with an underlying Language that is
suitable for the particular Logic under consideration, together with a
form of Semantics (Part \ref{part:formal_semantics}), usually as a
Model-theoretic Interpretation (\S\ref{sec:interpretation}).



% ====================================================================
\section{Logic}\label{sec:logic}
% ====================================================================

A \emph{Logic} is a Family of Languages that differ from eachother
only in \emph{Signature} (\S\ref{sec:signature}), such as
\emph{First-order Logic} (\S\ref{sec:firstorder_logic}), \emph{Modal
  Logic} (\S\ref{sec:modal_logic}), etc.

Symbols in a Language are broadly divided into \emph{Variables}
(\S\ref{sec:variable}) and \emph{Constants}, the latter of which are
divided into \emph{Logical Constants} (\S\ref{sec:logical_constant})
and \emph{Non-Logical Constants} (\S\ref{sec:nonlogical_constant}).

\emph{Extra-logical Symbols} are those of a Metalanguage
(\S\ref{sec:metalanguage}), such as the Symbol for Logical Consequence
(Entailment \S\ref{sec:logical_consequence}), $\vdash$, or
Metavariables (\emph{Schematic Variables}), $\varphi, \psi, \ldots$.

Symbols that don't have individual Meaning in isolation are termed
\emph{Syncategorematic} (see Term Logic \S\ref{sec:term_logic}),
otherwise they are called \emph{Categorematic}.

Other Symbols may be used for \emph{Punctuation}, like Parentheses and
Commas, as long as they don't appear in one of the other kinds of
Symbols.

The Cardinality of the underlying Language $\mathcal{L}$,
$|\mathcal{L}|$, is equal to the number of Equivalence Classes defined
by the Variance Relation (\S\ref{sec:variant}) on the Formulas of
$\mathcal{L}$.



% --------------------------------------------------------------------
\subsection{Logical Constant}\label{sec:logical_constant}
% --------------------------------------------------------------------

\emph{Logical Constants} (or \emph{Logical Symbols}) have the same
Semantic Meaning under every Interpretation
(\S\ref{sec:interpretation}) of the Language.

Two types of Logical Constants are \emph{Logical Connectives}
(\S\ref{sec:logical_connective} and \emph{Quantifiers}
(\S\ref{sec:quantifier}).



\subsubsection{Logical Connective}\label{sec:logical_connective}

A \emph{Logical Connective} (or \emph{Logical Operator}) is a Truth
Function (\S\ref{sec:truth_function}) that assigns a Truth-value to a
Compound Sentence as a Function of the Truth-value of its
Sub-sentences.

A \emph{Functionally Complete} Set of Logical Connectives allows the
expression of arbitrary Truth Functions. The smallest such Set may be
a single Connective (called a \emph{Sole-sufficient Operator}), such
as Alternative Denial ($\uparrow$, \S\ref{sec:alternative_denial}) or
Joint Denial ($\downarrow$, \S\ref{sec:joint_denial})



\paragraph{Disjunction}\label{sec:disjunction}\hfill

\emph{Disjunction} (also \emph{Alternation} or ``\emph{Logical Or}'')



\paragraph{Conjunction}\label{sec:conjunction}\hfill

\emph{Conjunction} (or ``\emph{Logical And}'')



\paragraph{Material Conditional}\label{sec:material_conditional}\hfill

\emph{Material Conditional}, \emph{Material Implication},
\emph{Material Consequence}



\paragraph{Joint Denial}\label{sec:joint_denial}\hfill

\emph{Joint Denial} or ``\emph{Nor}''



\paragraph{Alternative Denial}\label{sec:alternative_denial}\hfill

\emph{Alternative Denial} or ``\emph{Nand}'' (also \emph{Sheffer
  Stroke})



\subsubsection{de Morgan's Laws}\label{sec:de_morgan}

\[
  \neg (P \wedge Q) \Leftrightarrow (\neg P) \vee (\neg Q)
\] \[
  \neg (P \vee Q) \Leftrightarrow (\neg P) \wedge (\neg Q)
\]

Set Theory, Boolean Algebra



\subsubsection{Quantifier}\label{sec:quantifier}

A \emph{Quantifier} limits (\emph{Binds}) a Variable to a certain
quantity of members of the Domain, the two fundamental Quantifiers
being the \emph{Universal Quantifier} ($\forall$) and
\emph{Existential Quantifier} ($\exists$).

A \emph{Bound Quantifier} is one with a restricted Range, e.g.
$\exists x > 0$ or $\forall x \in \mathbb{R}$.

The \emph{Unique Existential Quantifier}, denoted by $\exists !$, is
expressed in natural language as ``there is one and only one.'' A
First-Order System requires the \emph{Equality Relation}
(\S\ref{sec:firstorder_equality}) in order to be able to express
Uniqueness Quantification.



\paragraph{Existential Quantifier}\label{sec:existential_quantifier}\hfill

Dependent Sum Type (\S\ref{sec:sigma_type})



\paragraph{Universal Quantifier}\label{sec:universal_quantifier}\hfill

Dependent Product Type (\S\ref{sec:pi_type})



\paragraph{Quantifier Rank}\label{sec:quantifier_rank}\hfill

\emph{Quantifier Rank} is the depth of nesting of Quantifiers in a
Formula.

Inductive definition of Quantifier Rank function $qr$:
\begin{itemize}
  \item $qr(\varphi) = 0$ if $\varphi$ is Atomic
  \item $qr(\varphi_1 \wedge \varphi_2) =
    qr(\varphi_1 \vee \varphi_2) = max(qr(\varphi_1),qr(\varphi_2))$
  \item $qr(\neg \varphi) = qr(\varphi)$
  \item $qr(\exists_x \varphi) = qr(\varphi) + 1$
\end{itemize}



\paragraph{Prenex Normal Form}\label{sec:prenex_normal}\hfill

Normal Form (\S\ref{sec:normal_form})



\paragraph{Plural Quantification}\label{sec:plural_quantification}
\hfill

\emph{Plural Quantification}



% --------------------------------------------------------------------
\subsection{Non-logical Constant}\label{sec:nonlogical_constant}
% --------------------------------------------------------------------

\emph{Non-Logical Symbols} only have Meaning under an Interpretation
(\S\ref{sec:interpretation}). These are Symbols such as Predicate
(\S\ref{sec:predicate}) and Function Symbols (Operators
\S\ref{sec:operator}).

The set of Non-Logical Symbols used in a particular discourse is
called the Signature (\S\ref{sec:signature}) of the discourse.



\subsubsection{Signature}\label{sec:signature}

The \emph{Signature} (or \emph{Vocabulary}) defines the Non-logical
Constants (\S\ref{sec:nonlogical_constant}) of the Language of a
Logical System as a Set of Function and Predicate Symbols that
characterize it together with an \emph{Arity Function} ``$ar$'' that
maps each Function and Predicate Symbol $s$ to a corresponding Natural
Number $n$ which is the Arity of $s$: $n = ar(s)$.

The corresponding Formal Language is the Set of
\emph{$\sigma$-formulas} and a Structure (\S\ref{sec:structure}) with
Signature $\sigma$ may be called a \emph{$\sigma$-structure}.

A Signature is defined as a triple:
\[
  (F,R,ar)
\]
where $F$ is a Set of Function Symbols (or \emph{Operators}), and $R$
is a Set of Predicate (or \emph{Relation}) Symbols and $ar$ is the
Arity Function:
\[
  ar: F \cup R \rightarrow \mathbb{N}_0
\]
If both $F$ and $R$ are Finite Sets, $\sigma$ is a \emph{Finite
  Signature}.

Technically the Function Symbols, which are Interpreted
(\S\ref{sec:interpretation_function}) as Functional Predicates
(\S\ref{sec:functional_predicate}), could also be Realized as
Relations, and thus it is only for convenience that they are included
in addition to Predicate Symbols, not out of necessity.

Function Symbols without Interpretations
(\S\ref{sec:uninterpreted_function}) leads to a Theory of
Uninterpreted Functions (Empty Theory \S\ref{sec:empty_theory}).

A Nullary Function Symbol is a \emph{Constant Symbol} (represents a
Constant Element) and a Nullary Predicate Symbol is a
\emph{Propositional Variable} (represents a Constant Truth-value). A
Function or Predicate Symbol $s$ of Arity $n$ is sometimes denoted
$\prescript{n}{}{s}$. Allowing for \emph{Infinitary Operators} leads
to a Theory of Complete Lattices (\S\ref{sec:complete_lattice}).

A Signature with no Predicate Symbols is an \emph{Algebraic
  Signature}, and the associated Structure an Algebra
(\S\ref{sec:universal_algebra}).

A Signature with no Function Symbols is a \emph{Relational Signature},
and the associated Structure is a \emph{Relational Structure}. A
Relational Structure may be used as the basis for a Relational Model
(\S\ref{sec:relational_model}) in Database Theory.

In Model Theory, a \emph{Structure} (\S\ref{sec:structure}) is an
Interpretation of a given Signature with the Empty Theory
(\S\ref{sec:empty_theory}). Theories with different Signatures may
have the same Categories of Models (\S\ref{sec:category_of_models}).

The Signature is a synonym for the \emph{Type} (\S\ref{sec:type}) of
the Structure (Schematically represented by $\Omega$), and can be
written as an ordered sequence of Natural Numbers representing the
Arity of the Operators.

A \emph{Reduct} of a Structure is created by omitting certain Function
and Predicate Symbols from the Signature; the converse is
\emph{Expansion} (\S\ref{sec:reduct_expansion}). A Signature $\sigma$
Expanded by a Set of Symbols $S$ may be denoted $\sigma(S)$.

\begin{enumerate}
  \item $(2)$         Semigroup (\S\ref{sec:semigroup})
  \item $(2,0)$       Monoid (\S\ref{sec:monoid})
  \item $(2,1,0)$     Group (\S\ref{sec:group})
  \item $(2,2,1,0)$   Rng (\S\ref{sec:rng})
  \item $(2,2,1,0,0)$ Unital Ring (\S\ref{sec:unital_ring})
\end{enumerate}



\paragraph{Many-sorted Signature}\label{sec:manysorted_signature}\hfill

A \emph{Many-sorted Signature} is given as:
\[
  (S, \sigma, type)
\]
which adds to a Signature $\sigma$ a Set of Sorts (\S\ref{sec:sort}),
$S$, and a Function $type$ that maps each Symbol of $\sigma$ to a Type
(\S\ref{sec:type}) over $S$. The Arity Function of $\sigma$ is also
modified to give Tuples of Sorts rather than Natural Numbers.



\paragraph{Cardinality}\label{sec:signature_cardinality}\hfill

The \emph{Cardinality} of a Signature $\sigma = (F,R,ar)$ is denoted
$|\sigma|$ and is the least Infinite Cardinal
(\S\ref{sec:cardinal_number}) $n$ such that $n \geq (|F| + |R|)$, that
is, greater than or equal to the number of Symbols in the Signature
$\sigma$. This is equal to the number of First-order Formulas
(\S\ref{sec:predicate_logic}) of $\sigma$.



\paragraph{Reduction \& Expansion}\label{sec:reduct_expansion}\hfill

For two Signatures $\sigma^-$ and $\sigma^+$ where $\sigma^- \subset
\sigma^+$, any $\sigma^+$-structure $\mathcal{A}$ is also a
$\sigma^-$-structure called the \emph{$\sigma^-$-reduct} of
$\mathcal{A}$ denoted $\mathcal{A}|\sigma^-$, having the same Domain
as $\mathcal{A}$ (although the Set of Constant Elements corresponding
to Constant Functions in the Signature of $\sigma^-$ may be smaller).

A Homomorphism of $\sigma^+$-structures $h : \mathcal{A} \rightarrow
\mathcal{B}$ is also a Homomorphism of $\sigma^-$-structures $h :
\mathcal{A} | \sigma^- \rightarrow \mathcal{B} | \sigma^-$.

If a Structure $\mathcal{B}$ is a $\sigma^-$-reduct of a
$\sigma^+$-structure $\mathcal{A}$ then $\mathcal{A}$ is called the
\emph{Expansion} of $\mathcal{B}$ to $\sigma^+$. Such an Expansion is
not necessarily unique. The notation for an Expansion by certain
additional Function or Predicate Symbols, $f, g, h$, is denoted
$\mathcal{A} = (\mathcal{B}, f, g, h)$.



\subsubsection{Predicate}\label{sec:predicate}

Indicator Function (\S\ref{sec:indicator_function})

Boolean-valued Function (\S\ref{sec:boolean_function})



\subsubsection{Operator}\label{sec:operator}

Operation = Realized Operator (Function Symbol)

Set Function (\S\ref{sec:set_function})

Morphism (\S\ref{sec:morphism})

Map (\S\ref{sec:map})



\paragraph{Functional Predicate}\label{sec:functional_predicate}\hfill

Function Symbol, Functional Predicate



% --------------------------------------------------------------------
\subsection{Variable}\label{sec:variable}
% --------------------------------------------------------------------

A \emph{Variable} is a placeholder that ranges over the objects in the
Domain of Discourse (\S\ref{sec:domain}).

Variables are called \emph{Free} or \emph{Bound} depending on whether
or not they are Quantified (\S\ref{sec:quantifier}). Free and Bound
Variables are sometimes called \emph{Real} and \emph{Apparent},
respectively.

Inductive definition of Free and Bound Variables:
\begin{enumerate}
\item A Variable $x$ is Free in Atomic Formula
  (\S\ref{sec:atomic_formula}) $\varphi$ if $x$ occurs in $\varphi$
  (Atomic Formulas are Quantifier-free)
\item A Variable is Free or Bound in the Compound Formula
  (\S\ref{sec:formula}) $\varphi \bullet \psi$ if $x$ is Free or Bound
  in either $\varphi$ or $\psi$, where $\bullet$ is a Binary Logical
  Connective (\S\ref{sec:logical_connective})
\item A Variable $x$ is Free in $\forall y \varphi$ iff $x$ is Free in
  $\varphi$ and $x$ is not $y$. Conversely $x$ is Bound in $\forall y
  \varphi$ if $x$ is $y$ or $x$ is Bound in $\varphi$.
\end{enumerate}

A Term (\S\ref{sec:term}) with no Free Variables is a \emph{Ground
  Term} and a Formula with no Free Variables in First-order Logic is a
\emph{Sentence} (\S\ref{sec:sentence}, also called a \emph{Closed
  Formula}). Sentences have well-defined Truth values. In some
treatments, Free Variables may be Implicitly Universally Quantified,
but in general this is not the case.



\subsubsection{Witness}\label{sec:witness}

An Existentially Quantified Variable, $\exists x$, may be removed by
introducing a new Constant Symbol, $c$, that provides a \emph{Witness}
of an Element that Satisfies the Formula in which it appears.

cf. Type Witness (\S\ref{sec:type_witness})



\subsubsection{Plural Variable}\label{sec:plural_variable}
\cite{laycock10}

A \emph{Plural Variable} may be distinguished in cases where an
Irreducably Plural Predicate is required.



\subsubsection{Skolemisation}\label{sec:skolemisation}

\emph{Skolemisation} is the removal of an Existential Quantifier that
appears after a Universal Quantifier, $\forall x \exists y : P (x,y)$,
by introducing a new Function Symbol, $f$:
\[
  \forall x : P (x, f(x))
\]
that produces a Witness (\S\ref{sec:witness}) depending on $x$.



\subsubsection{Metavariable}\label{sec:metavariable}

A \emph{Metavariable} is a Variable written in a Metalanguage that
stands in for an Element in the Object Language. The Formalization of
Metavariables falls under \emph{Type Theory} (Part
\ref{part:type_theory}).

Metavariables may be referred to as \emph{Schematic Variables} in the
context of Axiom Schemata (\S\ref{sec:axiom_schema}) and Rule Schemata
(\S\ref{sec:rule_schema}). A Schematic Variable ranges over all
Propositions (\S\ref{sec:proposition}).



% --------------------------------------------------------------------
\subsection{Term}\label{sec:term}
% --------------------------------------------------------------------

A \emph{Term} represents an object of the Domain (\S\ref{sec:domain}).

A Term denotes a Mathematical Object, a Formula denotes a Mathematical
Fact.

Terms can be defined Inductively from Constants, Variables, and
Functions. Given Terms, $T$, Variables, $V$, n-ary Functions, $F = F_0
\cup F_1 \cup F_2 \cup \cdots \cup F_n$, Constants, $C = F_0$:
\[
  V \subseteq T
\]\[
  C \subseteq T
\]\[
  \forall \tau_n=\{t_1,\cdots,t_n\} \in \pow(T), \forall f
  \in F_n \exists f(t_1,\cdots,t_n) \in T
\]



\subsubsection{Ground Term}\label{sec:ground_term}

If no Free Variables appear in a Term it is called a \emph{Ground
  Term} (or \emph{Closed Term}).



\subsubsection{Linear Term}\label{sec:linear_term}

A \emph{Linear Term} is a Term where no Variable occurs more than
once.



\subsubsection{Singular Term}\label{sec:singular_term}
\cite{chalmers02}

A \emph{Singular Term} has as its Extension (\S\ref{sec:extension}) an
Individual (\S\ref{sec:urelement})



\subsubsection{General Term}\label{sec:general_term}
\cite{chalmers02}

A \emph{General Term} has as its Extension (\S\ref{sec:extension}) a
Class (\S\ref{sec:class})



\subsubsection{Kind Term}\label{sec:kind_term}
\cite{chalmers02}

A \emph{Kind Term} has as its Extension (\S\ref{sec:extension}) a
particular Kind (\S\ref{sec:kind})




% --------------------------------------------------------------------
\subsection{Formula}\label{sec:formula}
% --------------------------------------------------------------------

Expressions (\S\ref{sec:expression}) belonging to the underlying
Language of a Logical System are called ``\emph{Well-formed
  Formulas}'' (\emph{WFFs}) or just \emph{Formulas}.

A Term (\S\ref{sec:term}) denotes a Mathematical Object, a Formula
denotes a Mathematical Fact.

The Syntax (\S\ref{sec:formal_grammar}) of a Formula is defined by the
Symbols and \emph{Formation Rules} for a particular kind of Logic. A
Formula containing no Logical Connectives is called an \emph{Atomic
  Formula} (\S\ref{sec:atomic_formula}). A Formula composed of Atomic
Formulas combined with Logical Connectives is a \emph{Compound
  Formula} (\S\ref{sec:compound_formula}).

As a Syntactic Object, a Formula is given Semantic Meaning
(\S\ref{sec:meaning}) by an Interpretation
(\S\ref{sec:interpretation}), which usually Interprets the Formula as
a Proposition (\S\ref{sec:proposition}). A Formula that is True under
some Interpretation is called \emph{Satisfiable}
(\S\ref{sec:satisfaction}). A Formula that is True under all
Interpretations is called \emph{Valid} (\S\ref{sec:validity}).



\subsubsection{Atomic Formula}\label{sec:atomic_formula}

An \emph{Atomic Formula} (or \emph{Atom}) is a Formula with no Logical
Constants (Connectives or Quantifiers).

Atomic Formulas can be defined Inductively by Formation Rules on Terms
and Predicates. Given Terms, $T = \{t_0,\ldots,t_n\}$, and Predicates,
$P = \{r_0,\ldots,r_m\}$:
\begin{itemize}
  \item $t_i = t_j$ is a Formula
  \item $r_k(t_0,\ldots,t_n)$ is a Formula and $r_k$ is an n-ary
    Predicate
\end{itemize}
If no Free Variables occur in an Atomic Formula it is called a
\emph{Ground Atom}.



\paragraph{Literal}\label{sec:literal}\hfill

A \emph{Literal} is an Atomic Formula, $\phi$, or its Negation, $\neg
\phi$.



\subsubsection{Compound Formula}\label{sec:compound_formula}

A \emph{Compound Formula} is made up of one or more Literals
(\S\ref{sec:literal}) in combination with one or more Logical
Constants (\S\ref{sec:logical_constant}). The component Formulas that
make up a Compound Formula are called \emph{Subformulas} and all
Formulas are considered Subformulas of themselves. A Subformula that
is not the entire Formula is called a \emph{Proper Subformula}.



\subsubsection{Clause}\label{sec:clause}

A Finite Disjunction (\S\ref{sec:disjunction}) of Literals is called a
\emph{Clause}.



\paragraph{Horn Clause}\label{sec:horn_clause}\hfill

\emph{Horn Clause}



\subsubsection{Variant}\label{sec:variant}

A Formula is a \emph{Variant} of another Formula if the two Formulas
differ only in the choice of Variables. \emph{Variance} is an
Equivalence Relation on the Class of Formulas.



\subsubsection{Sentence}\label{sec:sentence}

A \emph{Sentence} (or \emph{Ground Formula}) is a Proposition with no
Free Variables.



\paragraph{Statement}\label{sec:statement}\hfill

A \emph{Statement} is the Normal Form (\S\ref{sec:normal_form}) of a
Sentence, so that there may be more than one Sentence that makes the
same Statement.



% --------------------------------------------------------------------
\subsection{Substitution}\label{sec:substitution}
% --------------------------------------------------------------------

A \emph{Substitution} is the replacement of all occurences of a Free
Variable by a Term, which can be defined as a Total Mapping $\sigma: X
\rightarrow T$ from Variables $X$ to Terms $T$.

\emph{Syntactic Substitution}

The \emph{Application} of a Substitution $\sigma$ to a Term $t$ is
denoted $t\sigma$, or explicitly in postfix notation:
\[
  t(x_1 \ldots x_n)[s_1 \ldots s_n]
\]
where $x_1 \ldots x_n$ are the Free Variables of $t$, and $s_1 \ldots
s_n$ are the Terms $s_i$ to be Substituted for each $x_i$.

The result of Applying a Substitution, $t\sigma$, is called a
\emph{Substitution Instance} of $t$. The \emph{Domain} of a
Substitution $dom(\sigma)$ is the Set of Variables actually replaced:
\[
  \{ x \in X \;|\; x\sigma \neq x \}
\]
A Substitution $\sigma$ is a \emph{Ground Substitution} if all
Variables are Mapped to Ground Terms, and $t\sigma$ is a Ground Term
if all the Variables of $t$ are in $dom(\sigma)$.

\emph{Simultaneous Substitution}

Variable Capture (???)

Admissable Rule

Explicity Substitution


\textbf{Categorical Semantics} (\S\ref{sec:categorical_semantics})

(from nLab): %FIXME

Terms are Interpreted by Morphisms

Substitution of Term $t$ into Term $t'$ is Interpreted by Composition
of Morphisms: $t \circ t'$

Propositions are Interpreted by Subobjects (\S\ref{sec:subobject})

Substitution of Term $t$ into Proposition $P$ is Interpreted by
Pullback (\S\ref{sec:pullback}) or Inverse Image
(\S\ref{sec:preimage}) of the Subobject Interpreting $P$ along the
Morphism Interpreting $t$

Dependent Types are Interpreted by Display Maps
(\S\ref{sec:display_map})

Substitution of Term $t$ into Dependent Type $B$ is Interpreted by
Pullback of the Display Map Interpreting $B$ along the Morphism
Interpreting $t$

\emph{or} (note there may be an issue of Associativity here: from nLab)
%FIXME

Dependent Types are Interpreted by Classifying Morphisms
(\S\ref{sec:classifying_morphism}) into a Type of Types (Type Universe
\S\ref{sec:type_universe})

Substitution of Term $t$ into Dependent Type $B$ is Interpreted by
Composition of the Classifying Morphism Interpreting $B$ with the
Morphism Interpreting $t$



% ====================================================================
\section{Propositional Logic}\label{sec:propositional_logic}
% ====================================================================

\emph{Propositional Logic} (or \emph{Sentential} or \emph{Statement
  Logic}) studies the Truth-value of \emph{Propositional Formulas}
(\S\ref{sec:propositional_formula}) built up from Atomic Formulas
(\S\ref{sec:atomic_formula}) and Logical Connectives
(\S\ref{sec:logical_connective}).

The Language of Propositional Logic therefore consists of
\emph{Propositional Variables} (or \emph{Sentential Variables}), and a
Functionally Complete set of Logical Connectives. A Propositional
Variable that has been given a Truth Valuation (\S\ref{sec:valuation})
by a Truth Assignment (\S\ref{sec:interpretation}) is sometimes called
a \emph{Propositional Constant}. Propositional Variables act as the
Atomic Formulas of Propositional Logic.

A Propositional Formula is equivalent to a Boolean Term
(\S\ref{sec:boolean_algebra}). The Formal System for Propositional
Logic is Propositional Calculus (\S\ref{sec:propositional_calculus}).
The Semantics for Propositional Logic is provided by Truth-tables
(\S\ref{sec:truth_table}).

A Signature (\S\ref{sec:signature}) for Propositional Logic consists
only of Nullary Predicate Symbols for each Propositional Variable, and
a Model (\S\ref{sec:model}) provides a Truth Valuation for each.

In Propositional Logic, the Extra-logical Symbol for Entailment,
$\vdash$, and the Material Implication Operator, $\rightarrow$,
coincide in that:
\[
  (A \vdash B) \Leftrightarrow (\vdash A \rightarrow B)
\]
but the difference is that $\vdash$ describes a Deduction, that is a
Relation between Sentences, and $\rightarrow$ is a Logical Connective
within a Formula.

Propositional Calculus is Isomorphic to Simply-typed
$\lambda$-calculus (\S\ref{sec:simply_typed}) and is Strongly
Normalizing (\S\ref{sec:normalization}) to either a Conjunctive Normal
Form (\S\ref{sec:conjunctive_form}) or Disjunctive Normal Form
(\S\ref{sec:disjunctive_form}), and thus is not a Turing Complete
system.

Formal definition of a System of Propositional Calculus $\mathcal{S}$:
\[
    \mathcal{S} = (\sigma, \Omega, A, I)
\]
where:
\begin{itemize}
  \item $\sigma$ is the Signature (\S\ref{sec:signature}) for a
    Propositional Calculus consisting of a Finite Set $R = \{P_1, P_2,
    P_3, \ldots\}$ of Nullary Predicate Symbols which are the
    Propositional Variables of $\mathcal{S}$: $\sigma = (R)$
  \item $\Omega$ is a Finite, Functionally Complete Set of Logical
    Connective Symbols $\{\neg$, $\wedge$, $\vee$, $\ldots\}$
  \item $A$ is a Finite Set of Axioms (Formulas in the Language defined
    by the Formation Rules over the Signature $\sigma$ and the Logical
    Operators $\Omega$)
  \item $I$ is a Finite Set of Inference Rules
\end{itemize}
Atomic Formulas of $\mathcal{S}$ are just the Propositional Variables
$P_1, P_2, P_3, \ldots$, which means that a Literal in $\mathcal{S}$
is just a Propositional Variable or its Negation.

The Formulas of $\mathcal{S}$ are then Inductively defined as the
smallest Class, $\mathcal{L}$, such that:
\begin{enumerate}
  \item Any Literal of $\mathcal{S}$ is a Formula in $\mathcal{L}$
  \item For Formulas $\phi_1, \phi_2, \cdots, \phi_n$ and an $n$-ary
    Logical Operator $f \in \mathbf{\Omega}_n$ where $\mathbf{\Omega}_n$
    is the Partition of $\mathbf{\Omega}$ containing all $n$-ary Logical
    Operators, then $f(\phi_1, \phi_2, \cdots, \phi_n)$ is also a
    Formula in $\mathcal{L}$
\end{enumerate}
Propositional Logic is closed under Truth-Functional Operators, so the
above Formation Rules define all Formulas: nothing else is a Formula
of $\mathcal{S}$.

Formulas Derived by the Axioms and Inference Rules of a Propositional
Logic are Theorems (\S\ref{sec:theorem}) in that System. Allowing for
Axiom Schemata (an Infinite number of Axioms) extends Propositional
Logic; an example of such a System is Skolem Arithmetic
(\S\ref{sec:skolem_arithmetic}).

Inference Rules of a Propositional Logic define Valid Argument Forms
(\S\ref{sec:logical_form}). The simplest Argument Form that is both
necessary and given a complete set of Axioms is sufficient to define
all other Argument Forms is \emph{Modus Ponens}, shown here
Schematicized:

$\textrm{1. }\varphi \rightarrow \psi$

$\textrm{2. }\varphi$

$\therefore\textrm{ }\psi$ \\
where lines one and two are Premises and line three is the Conclusion
(the symbol $\therefore$ is read as \emph{therefore}). This is written
in Sequent Notation (\S\ref{sec:sequent}) as:
\[
  (\varphi \rightarrow \psi), \varphi \vdash \psi
\]
The Schematic representation of \emph{Modus Tollens}:

$\textrm{1. }\varphi \rightarrow \psi$

$\textrm{2. }\neg\psi$

$\therefore\textrm{ }\neg\varphi$\\



% --------------------------------------------------------------------
\subsection{Propositional Formula}\label{sec:propositional_formula}
% --------------------------------------------------------------------

A \emph{Propositional Formula} is a Formula that is assigned a
Truth-value (\S\ref{sec:truth_value}), i.e. it is a Truth-bearer
(\S\ref{sec:truth_bearer}). An \emph{Atomic Proposition}
(\S\ref{sec:atomic_formula}) contains no Logical Connectives. A
\emph{Compound Proposition} is composed by Recursive application of
Logical Connectives to Propositions by a corresponding
\emph{Concatenation Rule} that assigns a new Truth-value to the
Compound Proposition. A Proposition with no Free Variables is called a
\emph{Sentence} (\S\ref{sec:sentence}).

A Valuation (\S\ref{sec:valuation}) is an Interpretation
(\S\ref{sec:interpretation}) that gives a Proposition a particular
Truth-value. A Propositional Formula is Satisfiable
(\S\ref{sec:satisfaction}) if it is True under at least one
Interpretation.



\subsubsection{Tautology}\label{sec:tautology}

A Propositional Formula that is \emph{Valid} (\S\ref{sec:validity}) is
one that is True under every possible Interpretation
(\S\ref{sec:interpretation}) and is called a \emph{Tautology}.

The Set of Tautologies over a Countable Alphabet is a Decidable Set
(\S\ref{sec:decidable_set}).



% --------------------------------------------------------------------
\subsection{Conjunctive Normal Form}\label{sec:conjunctive_form}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Disjunctive Normal Form}\label{sec:disjunctive_form}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Second-order Propositional Logic}
\label{sec:secondorder_propositional_logic}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Multi-valued Logic}\label{sec:multi_valued_logic}
% --------------------------------------------------------------------

\subsubsection{Fuzzy Logic}\label{sec:fuzzy_logic}

\paragraph{T-norm Fuzzy Logic}\label{sec:tnorm_logic}\hfill

\subparagraph{Basic Logic}\label{sec:basic_logic}\hfill



\paragraph{Lukasiewicz Logic}\label{sec:lukasiewicz_logic}\hfill





\subsubsection{Probabilistic Logic}\label{sec:probabilistic_logic}



% ====================================================================
\section{Zeroth-order Logic}\label{sec:zerothorder_logic}
% ====================================================================

%FIXME

Language:

Propositional Variables (Predicates of Arity 0)

Predicates of Arity >= 1

Constants (Functions of Arity 0)

Functions of Arity >= 1

Logical Connectives

Grouping Symbols (parentheses, etc.)



% ====================================================================
\section{Predicate Logic}\label{sec:predicate_logic}
% ====================================================================

\emph{Predicate Logic} (or \emph{Predicate Calculus}) describes
Logical Systems with Formulas containing Variables
(\S\ref{sec:variable}) that can be Quantified
(\S\ref{sec:quantifier}). This includes Systems of First-order Logic
(\S\ref{sec:firstorder_logic}), Second-order Logic
(\S\ref{sec:secondorder_logic}), Higher-order Logic
(\S\ref{sec:higherorder_logic}), Many-sorted Logic
(\S\ref{sec:manysorted_logic}), and Infinitary Logic
(\S\ref{sec:infinitary_logic}). This is in contrast to Logical Systems
without Variables or Quantifiers such as Propositional Logic
(\S\ref{sec:propositional_logic}) and Zeroth-order Logic
(\S\ref{sec:zerothorder_logic}).

Logic with Quantification corresponds to Dependent Type Theory
(\S\ref{sec:dependent_type}) by Curry-Howard Isomorphism
(\S\ref{sec:curry_howard})



% --------------------------------------------------------------------
\subsection{First-order Logic}\label{sec:firstorder_logic}
% --------------------------------------------------------------------

\emph{First-order Logic} (or \emph{Lower Predicate Logic}) allows
Quantification over individual Objects in the Domain of Discourse
(\S\ref{sec:domain}). This is in contrast to Systems of Predicate
Logic that allow Plural Quantification (Quantification over Sets
\S\ref{sec:plural_quantification}), such as Second-order Logic
(\S\ref{sec:secondorder_logic}) and Higher-order Logic
(\S\ref{sec:higherorder_logic}).

A System of First-order Logic, $\mathcal{S}$, is defined as:
\[
  \mathcal{S} = (\sigma,\Omega,V,A,I)
\]
where:
\begin{itemize}
  \item $\sigma$ is a Signature (\S\ref{sec:signature}) for
    First-order Logic consisting of a Finite Set $F = \{f_1, f_2, f_3,
    \ldots \}$ of Function Symbols and a Finite Set $P = \{ R_1, R_2,
    R_3, \ldots\}$ of Predicate Symbols, and $ar : F \cup P
    \rightarrow \mathbb{N}_0$ a Function Mapping Function and
    Predicate Symbols to their Arity:
    \[\sigma = (F,P,ar)\]
  \item $\Omega$ is a Finite, Functionally Complete Set of Logical
    Connective Symbols $\{\neg$, $\wedge$, $\vee$, $\ldots\}$
  \item $V$ is a Set of Variable Symbols:
    \[V = \{v_1, v_2, v_3, \ldots\}\]
  \item $A$ is a Finite Set of Axioms (Formulas in the Language
    defined by the Formation Rules over the Signature $\sigma$, the
    Logical Operators $\Omega$, and the Variable Symbols $V$)
  \item $I$ is a Finite Set of Inference Rules
\end{itemize}

The Formation Rules for Formulas in a System of First-order Logic
generally describe a Context-free Grammar (\S\ref{sec:context_free}).

Terms are limited to Variables and a Finite number of $n$-ary Function
applications, defined Inductively by:
\begin{enumerate}
  \item Every Variable is a Term
  \item For Terms $t_1, t_2, \ldots, t_n$ and $n$-ary Function Symbol
    $f$, then $f(t_1, t_2, \ldots, t_n)$ is a Term.
\end{enumerate}
Atomic Formulas are defined as:
\begin{enumerate}
  \item If $t_1$ and $t_2$ are Terms, and there is a Logical Operator
    for Equality\\$(=) \in \Omega$, then $t_1 = t_2$ is an Atomic
    Formula.
  \item If $R$ is an $n$-ary Predicate, and $t_1,\ldots,t_n$ are
    terms, then $R(t_1,\ldots,t_n)$ is an Atomic Formula.
\end{enumerate}
The Class $\mathcal{L}$ of Formulas is defined Inductively by the
Formation Rules:
\begin{enumerate}
  \item All Atomic Formulas are Formulas in $\mathcal{L}$
  \item If $\phi \in \mathcal{L}$ then $\neg \phi \in \mathcal{L}$
  \item If $\phi_1, \phi_2, \dots, \phi_n$ are Formulas in
    $\mathcal{L}$, and $f \in \Omega_n$ is an $n$-ary Logical Operator,
    then $f (\phi_1, \phi_2, \ldots, \phi_n) \in \mathcal{L}$
  \item If $x \in V$ and $\phi \in \mathcal{L}$, then $\exists x \phi
    \in \mathcal{L}$ and $\forall x \phi \in \mathcal{L}$
\end{enumerate}
A First-order Formula that is a Substitution Instance
(\S\ref{sec:substitution}) of a Tautological Propositional Formula
(\S\ref{sec:tautology}) is a \emph{First-order Tautology}.

Certain Equivalences for First-order Logical Systems fail to hold if
Empty Domains (\S\ref{sec:domain}) are allowed and Function Symbols
are always Interpreted (\S\ref{sec:interpretation_function}) with
assignment of Well-defined (\S\ref{sec:well_defined}) Total Functions
to the Symbols.

First-order Logic may be used as the System of Logic for Deductive
Systems with Finite Domains that are Sound (\S\ref{sec:soundness}) and
Complete (\S\ref{sec:completeness}), but for Domains of Infinite
Cardinality a System of Higher-order Logic is required. First-order
Logic is Semi-decidable (\S\ref{sec:semidecidable}), that is the
Consequence Relation for two Formulas of First-order Logic, $\phi
\vdash \psi$, is Recursively Enumerable. Satisfiability
(\S\ref{sec:satisfiability}) and Validity (\S\ref{sec:validity}) of
arbitrary First-order Formulas are Undecidable.

The L\"owenheim-Skolem Theorem (\S\ref{sec:lowenheim_skolem}) implies
that First-order Logic is unable to characterize the concept of
Countability or Uncountability \S\ref{sec:cardinality}).

The Compactness Theorem (\S\ref{sec:compactness}) implies that
if a Formula is derived from a System of First-order Logic with an
Infinite Set of Axioms, then it can be derived from a Finite Subset of
those Axioms. This has implications for the determination of Connected
Components of a Directed Graph (\S\ref{sec:directed_graph}).

An Interpretation of First-order Logic can be given in any Topos
(\S\ref{sec:topos}).

Frame Problem %FIXME



\subsubsection{First-order Theory}\label{sec:firstorder_theory}

\subsubsection{Universal Generalization}\label{sec:universal_generalization}

\emph{Universal Generalization} is an Inference Rule:
\[
  P(x) \vdash \forall x P(x)
\]



\subsubsection{First-order Logic with Equality}
\label{sec:firstorder_equality}

Including a primitive Logical Symbol for Equality, $=$, Interpreted as
the real Equality Relation between members of the Domain such that
``two'' given Elements are the same Element adds the following Axioms:

\begin{enumerate}
\item \textbf{Reflexivity}: $\forall x, x=x$
\item \textbf{Substitution for functions}: given a function, $f$,
  $\forall x \forall y, x = y \rightarrow f(\ldots,x,\ldots) =
  f(\ldots,y,\ldots)$
\item \textbf{Substitution for formulas (Leibniz's Law)}: given a
  Formula $\varphi$ with Free occurrences of $x$, and $\varphi '$ with
  Free occurrences of $y$, $\forall x \forall y, x = y \rightarrow
  (\varphi \rightarrow \varphi ')$
\end{enumerate}

Defining a theory with a Binary Relation $A(x,y)$ that satisfies
Reflexivity and Leibniz's law is sufficient to derive any other
equality Theorems.

First-order Logic with Equality is Algebraeized as Cylindric Algebra
(\S\ref{sec:cylindric_algebra}).



\subsubsection{First-order Logic without Equality}
\label{sec:firstorder_no_equality}

An alternative convention to First-order Logic with Equality
(\S\ref{sec:firstorder_equality}) is to consider the Equality Relation
to be a Non-logical Symbol of the Signiature of a particular Logical
System. This allows two distinct individuals to be considered equal by
an arbitraray Equivalence Relation. If this convention is used, but no
distinct individuals (\S\ref{sec:discernibility}), $a$ and $b$ satisfy
$a=b$ then the Interpretation is termed a \emph{Normal Model} (that is
equivalent to a First-order Logic with Equality). In such a case the
Axioms related to Equality automatically hold and don't need to be
included explicitly.

First-order Logic without Equality is Algebraized as a Polyadic
Algebra (\S\ref{sec:polyadic_algebra}).



\subsubsection{Equational Logic}\label{sec:equational_logic}

\emph{Equational Logic} is First-order Logic without Quantifiers.

Universal Algebra (\S\ref{sec:universal_algebra})

Algebraic Theory (\S\ref{sec:algebraic_theory})

Equational Reasoning (\S\ref{sec:equational_reasoning})



\paragraph{Equation}\label{sec:equation}\hfill

%FIXME possibly move

Categorical Semantics is given by Pullbacks (\S\ref{sec:pullback})



\paragraph{Equational Theory}\label{sec:equational_theory}\hfill

Algebraic Theory (\S\ref{sec:algebraic_theory})

An Effect Theory (\S\ref{sec:effect_theory}) gives rise to a standard
(possibly Infinitary) Equational Theory. \cite{plotkin-pretnar09}



\paragraph{Unification}\label{sec:unification}\hfill

wiki:

$V$ -- Set of \emph{Variables}

$T$ -- Set of \emph{Terms} where $V \subseteq T$

$fv : T \rightarrow \pow(V)$ -- Mapping from Terms $t$ to the Set of
\emph{Free Variables} $fv(t) \subseteq V$ occurring in $t$

$\equiv \subseteq T \times T$ -- Equivalence Relation on $T$; for
Higher-order Unification, usually $t \equiv u$ if $t$ and $u$ are
$\alpha$-equivalent (\S\ref{sec:alpha_equivalence}). If only
Syntactically identical Terms are considered Equal (Syntactic
Unification \S\ref{sec:syntactic_unification}) then $\equiv$ is the
Free Theory (or \emph{Empty Theory} \S\ref{sec:empty_theory})


First-order Unification

Higher-order Unification

\fist ? See also Universal Algebra (\S\ref{sec:universal_algebra})



\subparagraph{Syntactic Unification}\label{sec:syntactic_unification}
\hfill

Empty Theory (\S\ref{sec:empty_theory})



\subsubsection{Monadic First-order Logic}\label{sec:monadic_firstorder}

\emph{Monadic First-order Logic} (or \emph{Monadic Predicate
  Calculus}) restricts First-order Logic to Unary Predicates and no
Function Symbols. This weaker form of First-order Logic is fully
Decidable.



\subsubsection{Many-sorted First-order Logic}
\label{sec:manysorted_logic}

\emph{Many-sorted First-order Logic} allows Variables to be Quantified
over different Domains, thus giving Variables different \emph{Sorts}
(\S\ref{sec:sort}). With Finitely many Sorts, Many-sorted First-order
Logic can be reduced to Single-sorted First-order Logic. This can be
accomplished by adding Unary Predicates to a First-order Logic that
Partition (\S\ref{sec:set_partition}) the Domain.

Many-sorted Signature (\S\ref{sec:manysorted_signature})



\paragraph{Nominal Logic}\label{sec:nominal_logic}\hfill
\emph{Nominal Logic}

Variable Binding

see also $\alpha$-conversion (\S\ref{sec:alpha_conversion})



\paragraph{Order-sorted Logic}\label{sec:order_sorted}\hfill

Higher-order?



\subsubsection{Infinitary Logic}\label{sec:infinitary_logic}

\emph{Infinitary Logic} allows Formulas of Infinite length, through
either Conjunctons and Disjunctions, Infinite-arity Predicates and
Functions, or Quantification over Infinitely many Variables.



\paragraph{$\Omega$-logic}\label{sec:omega_logic}\hfill

\emph{$\Omega$-logic}



\subsubsection{Elementary Logic}\label{sec:elementary_logic}

\paragraph{Elementary Theory}\label{sec:elementary_theory}\hfill

Axioms using only Finitary First-order Logic %FIXME heyting category?

Weaker condition than Algebraic Theory (\S\ref{sec:algebraic_theory})

Elementary Sentence

Elementary Definition

Elementary Theory of the Reals gives the Real Closed Field
(\S\ref{sec:real_closed})



\subsubsection{Regular Logic}\label{sec:regular_logic}

Internal Language: Regular Categories (\S\ref{sec:regular_category})



\paragraph{Regular Theory}\label{sec:regular_theory}\hfill



\subsubsection{Coherent Logic}\label{sec:coherent_logic}

Internal Language: Coherent Categories (\S\ref{sec:coherent_category})



\paragraph{Coherent Theory}\label{sec:coherent_theory}\hfill



\subsubsection{Geometric Logic}\label{sec:geometric_logic}

Internal Language: Geometric Categories
(\S\ref{sec:geometric_category})


youtube: Carmello - Introduction to categorical logic, classifying
toposes

Grothendieck Topos (\S\ref{sec:grothendieck_topos})

Geometric Formulas:

Finitary Conjunctions $\wedge$

Infinitary Disjunctions $\bigvee$

Existential Quantification $\exists$

Finite number of Free Variables



\paragraph{Geometric Theory}\label{sec:geometric_theory}\hfill

Axioms of the form:
\[
  \varphi \vdash_{\overline{x}} \psi
\]
where $\varphi$ and $\psi$ are Geometric Formulas and $\overline{x}$
is the Context (Free Variables) %FIXME

$\forall \overline{x} (\varphi \Rightarrow \psi)$



% --------------------------------------------------------------------
\subsection{Second-order Logic}\label{sec:secondorder_logic}
% --------------------------------------------------------------------

\emph{Second-order Logic} allows for Quantifiers to range over
Predicates and Functions and thus \emph{Sorts} of Variables that range
over $k$-ary Predicates and Functions. It is possible to leave out a
definition of Quantifiers for Functions since $k$-ary Functions can be
represented by $k+1$-ary Predicates.\cite{shapiro00} Quantification
over Functions allows the creation of the Analytic Hierarchy
(\S\ref{sec:analytic_hierarchy}).

Because the Powerset Operation (\S\ref{sec:powerset}) is Definable in
Second-order Logic, Second-order Logic can simulate Higher-order
Logics (\S\ref{sec:higherorder_logic}).

Quantification over Propositional Variables in Second-order Logic
corresponds to Type Abstraction in Second-order $\lambda$-calculus
(\S\ref{sec:system_f}).



\subsubsection{Principal of Bivalence}\label{sec:bivalence_principal}

\subsubsection{Monadic Second-order Logic}\label{sec:monadic_secondorder}

\paragraph{Plural Monadic Second-order Logic}\hfill
\label{sec:plural_monadic_secondorder}\hfill \\

An alternative formulation of Second-order Logic is to allow Variables
to take on \emph{Plural} Values. It is equi-interpretable with
\emph{Monadic Second-order Logic}, which restricts Quantification to
Unary Predicates (Sets).



\subsubsection{Existential Second-order Logic}
\label{sec:existential_secondorder}

\paragraph{Independence-friendly\hfill
  Logic}\label{sec:independence_logic}\hfill \\

\emph{Independence-friendly Logic} has \emph{Branching Quantifiers}.



% --------------------------------------------------------------------
\subsection{Higher-order Logic}\label{sec:higherorder_logic}
% --------------------------------------------------------------------

\emph{Higher-order Logic} is the Union of First-, Second-, Third-,
$\ldots$ order Logic and allows Quantification over arbitrarily deep
nested Sets.

\textbf{Standard Semantics} (Full Semantics): Quantifiers range over all
possible Objects of a given Type

\textbf{Henkin Semantics}: Each Higher-order Type has its own Domain,
equivalent to Many-sorted First-order Logic
(\S\ref{sec:manysorted_logic})

Stronger than First-order Logic, e.g. admits Categorical
Axiomatization (\S\ref{sec:categoricity}) of the Natural Numbers or
the Real Numbers

Can be simulated in Second-order Logic (\S\ref{sec:secondorder_logic})
through use of the Powerset Operation as it is Definable in
Second-order Logic

Unifiability (\S\ref{sec:unification}) is Undecidable for
Type-theoretic (\S\ref{sec:intuitionistic_type}) Third-order Logic.



% ====================================================================
\section{Intensional Logic}\label{sec:intensional_logic}
% ====================================================================

\emph{Intensional Logic} adds to First-order Logic \emph{Sentential
  Functors} (\emph{Intensions}) that range over Terms. An Intension is
the \emph{Sense} in which a Logical Assertion is made, as opposed to
the \emph{Reference} to which the Assertion applies (i.e. Extensional
Quantification).



% --------------------------------------------------------------------
\subsection{Modal Logic}\label{sec:modal_logic}
% --------------------------------------------------------------------

\emph{Modal Logic} extends Propositional and Predicate Logic to
include Operators expressing \emph{Modality}. Various meanings for
these Modal Operators include Alethic Modality
(\S\ref{sec:alethic_logic} Necessity and Possibility), Temporal
Modality (\S\ref{sec:temporal_logic} qualification in terms of time,
e.g. Always, Eventually, Until), Deontic Modality
(\S\ref{sec:deontic_logic} Obligation and Permission), and Doxastic
Modality (\S\ref{sec:doxastic_logic} Belief).

An unary \emph{Primitive Modal Operator}, $\square$, defines a Dual
Operator, $\Diamond$, such that the following analogues of de Morgan's
Laws (\S\ref{sec:de_morgan}) hold:
\[
  \Diamond P \leftrightarrow \neg \square \neg P
\]
\[
  \square P \leftrightarrow \neg \Diamond \neg P
\]
By the Curry-Howard Correspondence (\S\ref{sec:curry_howard}), Modal
Logic corresponds to Monads (\S\ref{sec:monad}).



\subsubsection{Modality}\label{sec:modality}

``way of being True''

\emph{or}

``way of Being''

Truncated Types, $h$-level (???) %FIXME

Modal Type Theory (\S\ref{sec:modal_type_theory})

Adjoint Modality (\S\ref{sec:adjoint_modality})



\subsubsection{Classical Modal Logic}\label{sec:classical_modal}

A \emph{Classical Modal Logic} has as an Axiom or Theorem the Duality
of the Modal Operators:
\[
  \Diamond A \equiv \neg \square \neg A
\]\[
  \square A \equiv \neg \Diamond \neg A
\]
and Closed under the Inference Rule (and its Dual):
\[
  A \equiv B \vdash \square A \equiv \square B
\]\[
  A \equiv B \vdash \Diamond A \equiv \Diamond B
\]
The weakest Classical Modal Logic System $\mathsf{E}$ is Non-normal
(\S\ref{sec:normal_modal}).



\paragraph{Regular Modal Logic}\label{sec:regular_modal}\hfill

A \emph{Regular Modal Logic} is Closed under:
\begin {itemize}

\item $\Diamond A \equiv \neg \square \neg A$

\item $(A \wedge B) \rightarrow C \vdash
  (\square A \wedge \square B) \rightarrow \square C$

\end {itemize}
Every Regular Modal Logic is Classical (\S\ref{sec:classical_modal})
and every Normal Modal Logic (\S\ref{sec:normal_modal}) is Regular.



\paragraph{Normal Modal Logic}\label{sec:normal_modal}\hfill

A Normal Modal Logic contains all Propositional Tautologies
(\S\ref{sec:tautology}) and all Instances of the Distribution Axiom
(or Kripke Schema):
\[
  \square (A \rightarrow B) \rightarrow
  (\square A \rightarrow \square B)
\]
and is Closed under:
\begin{itemize}
  \item Modus Ponens (\emph{Detachment Rule}): $A \rightarrow B$, $A
    \vdash B$
  \item Necessitation Rule: $\vdash A \Rightarrow \vdash \square A$
\end{itemize}
The Smallest Logic satisfying these conditions is called \emph{System
  $\mathsf{K}$}.



\subsubsection{Multimodal Logic}\label{sec:multimodal_logic}

A Modal Logic with more than one Primitive Modal Operator is called a
\emph{Multimodal Logic}. A Multimodal Logic with exactly $n$ Primitive
Modal Operators is called an \emph{$n$-modal Logic} with $n > 1$ and
Operators $\square_i, i \in \{1, \ldots, n\}$.



\subsubsection{Alethic Logic}\label{sec:alethic_logic}

\emph{Alethic Logic}

Possible World Semantics (\S\ref{sec:possible_world})

Most Systems of Alethic Logic are based on an extension of
Propositional Logic called \emph{System $\mathsf{K}$} which is a
Normal Modal Logic (\S\ref{sec:normal_modal}) where:
\begin{enumerate}
\item $\square$, unary operator for \emph{Necessity}.
\item \emph{Necessitation Rule} $N$ : stating if $p$ is a
  Theorem, then $\square p$ is a Theorem.
\item \emph{Distribution Axiom} (or \emph{Kripke Schema}) $K$ :
  \[
    \square(p \rightarrow q) \rightarrow
    (\square p \rightarrow \square q)
  \]
\end{enumerate}
There are also further Axioms used to extend System $\mathsf{K}$:
\begin{itemize}
  \item \emph{Reflexivity Axiom} $T$ : $\square p \rightarrow p$
  \item $4$: $\square p \rightarrow \square \square p$
  \item $B$: $p \rightarrow \square \Diamond p$
  \item $D$: $\square p \rightarrow \Diamond p$
  \item $5$: $\Diamond p \rightarrow \square \Diamond p$
\end{itemize}
The Axioms correspond to various Frame Conditions
(\S\ref{sec:frame_semantics}) on the Accessibility Relation $R : W
\rightarrow W$ that specify Classes of Frames $\langle W,R \rangle$:
\begin{itemize}
  \item $K$: no Frame Conditions
  \item $T$: Reflexive ($wRw$)
  \item $4$: Transitive ($wRv \wedge vRu \Rightarrow wRu$)
  \item $4$: Dense ($wRu \Rightarrow \exists v (w R v \wedge v R u)$)
  \item $B$: Symmetric
  \item $D$: Serial
  \item $5$: Euclidean
  \item $GL$: $R$ Transitive, $R^{-1}$ Well-founded
  \item $Grz$: $R$ Reflexive and Transitive, $R^{-1} - Id$
    Well-founded
  \item $H$: $w R u \wedge w R v \Rightarrow u R v \vee v R u$
  \item $M$
  \item $G$: Convergent
\end{itemize}
Adding some of these Axioms to System $\mathsf{K}$ gives rise to a
nested hierarchy of Systems of Normal Modal Logic:
\begin{itemize}
  \item $\mathsf{K} := K + N$
  \item $\mathsf{T} := \mathsf{K} + T$
  \item $\mathsf{S4} := \mathsf{T} + 4$ (Staged Computation)
    \cite{wadler14}
  \item $\mathsf{S5} := \mathsf{S4} + 5$
    (Spatially Distributed Computation) \cite{wadler14}
  \item $\mathsf{D} := \mathsf{K} + D$
\end{itemize}

Necessity:
\[
  \square p \equiv \neg \Diamond \neg p
\]
Possibility:
\[
  \Diamond p \equiv \neg \square \neg p
\]
Impossibility:
\[
  \neg \Diamond p \equiv \square \neg p
\]
Analyticity:
\[
  \square p \vee \square \neg p
  \equiv \neg (\Diamond p \wedge \Diamond \neg p)
\]
Contingency:
\[
  \Diamond p \wedge \Diamond \neg p
  \equiv \neg (\square p \vee \square \neg p)
\]



\subsubsection{Doxastic Logic}\label{sec:doxastic_logic}

\emph{Doxastic Logic} uses the unary Modal Operator, $\mathcal{B}$, to
denote \emph{Belief}. Example:
\[
  \mathcal{B} x
\]
has the meaning ``It is Believed that $x$ is the case''. A set of
Beliefs is usually denoted:
\[
  \mathbb{B}: \{ b_1, b_2, \ldots, b_n \}
\]



\subsubsection{Deontic Logic}\label{sec:deontic_logic}

\emph{Standard Deontic Logic} ($\mathbf{SDL}$) adds the following
Axioms to Propositional Logic (\S\ref{sec:propositional_logic}):
\[
  O(A \rightarrow B) \rightarrow (OA \rightarrow OB)
\]
\[
  PA \rightarrow \neg O \neg A
\]
with Primitive Operators $O$ (\emph{Obligatory}) and $P$
(\emph{Permissible}). \emph{Forbidden} is defined as:
\[
  FA = O \neg A
\]
or:
\[
  FA = \neg P A
\]
Deontic Logic may be extended by Alethic Operators with the Axiom:
\[
  OA \rightarrow \Diamond A
\]
which has the meaning ``ought implies can''.



\subsubsection{Temporal Logic}\label{sec:temporal_logic}

(Curry-Howard): Partial Evaluation (\S\ref{sec:partial_evaluation}),
Functional Reactive Programming (\S\ref{sec:frp}), Reactive Types
(\S\ref{sec:reactive_type})

\begin{itemize}
  \item Logical Operators (Logical Connectives
    \S\ref{sec:logical_connective})
  \item Modal Operators
\end{itemize}


Unary Operators:
\begin{itemize}
  \item $A\phi$ -- All
  \item $E\phi$ -- Exists
\end{itemize}

Unary Modal Operators:
\begin{itemize}
  \item $N\phi$, $\ocircle\phi$ -- Next
  \item $G\phi$, $\square\phi$ -- Globally (Behavior
    Signals? \S\ref{sec:signal}) %FIXME
  \item $F\phi$, $\lozenge\phi$ -- Future, Finally (Event
    \S\ref{sec:frp_event})
\end{itemize}

Binary Modal Operators:
\begin{itemize}
  \item $\phi \until \psi$ -- Until
  \item $\phi R \psi$ -- Release
  \item $\phi \since \psi$ -- Since
\end{itemize}

\fist Note simple Temporal Logics such as Basic Temporal Language
(\S\ref{sec:btl}) may have fewer or different Operators or some
Operators cannot be expressed.

Reflexive, Irreflexive Ordering


\asterism


Categorical Semantics (\S\ref{sec:categorical_semantics})

Category $\cat{C}$

Internal Category (\S\ref{sec:internal_category}) given by:
\[
  b,e : \cat{Time}_1 \rightrightarrows \cat{Time}_0
\]
where Elements of $\cat{Time}_1$ are Time Intervals with $b$ and $e$
marking Beginning and End points. Time may have additional Structure
(Poset \S\ref{sec:poset}, Linear Order \S\ref{sec:total_order})

Each Arrow $b,e$ Generates an Adjoint Triple:
\begin{align*}
  \Sigma_b \dashv b^* \dashv \Pi_b \\
  \Sigma_e \dashv e^* \dashv \Pi_e
\end{align*}
between Slices (\S\ref{sec:slice_category}) $\cat{C}/\cat{Time}_0$ and
$\cat{C}/\cat{Time}_1$ where $\Sigma$ is Dependent Sum
(\S\ref{sec:dependent_sum}), $-^*$ is Base Change
(\S\ref{sec:base_change}), and $\Pi$ is Dependent Product
(\S\ref{sec:dependent_product})

Adjunctions

$\Sigma_b e^* \dashv \Pi_e b^*$

$\Sigma_e b^* \dashv \Pi_b e^*$

Propositions $\phi, \psi$

$\Sigma_b e^* \phi$ -- ``there exists an Interval Beginning now such
that $\phi$ is True at its End'', i.e. $F \phi$

$\Pi_e b^* \psi$ -- ``for all Intervals Ending now, $\psi$ is True at
their Beginning'', i.e. $H \psi$

Therefore:
\begin{itemize}
  \item $F \dashv H$
  \item $P \dashv G$
\end{itemize}

$\phi S \psi := \Sigma_e (b^* \psi \times \Pi_c(ep)^*\phi)$ -- ``there
is a Subinterval Ending now such that $\psi$ was True at its Beginning
and $\phi$ was True at all Times inside it''

$\phi U \psi := \Sigma_b (e^* \psi \times \Pi_c(ep)^*\phi)$ --
``$\phi$ will be True until a Time when $\psi$ is True''

where $p,q$ are Projections for the $\cat{Time}$ Category:
\[
  p,q : \cat{Time}_1 \times_{\cat{Time}_0} \cat{Time}_1
    \rightarrow \cat{Time}_1
\]
and $c$ is Composition for the $\cat{Time}$ Category:
\[
  c : \cat{Time}_1 \times_{\cat{Time}_0} \cat{Time}_1
    \rightarrow \cat{Time}_1
\]
and $ep = bq$.

Instant-based, Interval-based (Interval Temporal Logic
\S\ref{sec:interval_temporal}) approaches

Adjoint Logic (\S\ref{sec:adjoint_logic})



\paragraph{Basic Temporal Language (BTL)}\label{sec:btl}\hfill

Unary Modal Operators:
\begin{itemize}
  \item $F\phi$ -- Future: $\phi$ will be True at some Future Time
  \item $P\phi$ -- Past: $\phi$ was True at some Past Time
\end{itemize}

Duals of $F$ and $P$
\begin{itemize}
  \item $G\phi = \neg F \neg\phi$ -- Globally: at no Future Time is
    $\phi$ not True
  \item $H\phi = \neg P \neg\phi$ -- History: at no Past Time is
    $\phi$ not True
\end{itemize}

Frame (\S\ref{sec:kripke_frame}): Set $T$ with Binary Relations $R_F$
and $R_P$

$x R_F y$ -- ``at $x$, $y$ is in the Future''

$R_P$ is Converse (\S\ref{sec:converse}) to $R_F$

\emph{Bidirectional Frame} $(T,R,R^{op})$



\paragraph{Tense Logic}\label{sec:tense_logic}\hfill

\emph{Tense Logic} is a 2-modal Logic that adds operators $[F]$ for
\emph{Future} and $[P]$ for \emph{Past} Modalities.



\paragraph{CTL*}\label{sec:ctl_star}\hfill

Superset of \emph{Computation Tree Logic} and \emph{Linear
  Temporal Logic}

Branching-time



\subparagraph{Computation Tree Logic}\label{sec:ctl}\hfill

Temporal Logic with \emph{Path} Modalities.

Branching-time



\subparagraph{Linear Temporal Logic}\label{sec:linear_temporal}\hfill

\cite{jeffrey12}:

\emph{Linear Temporal Logic} (LTL or \emph{Linear-time Temporal
  Logic}) is a Modal Logic with Modalities referring to \emph{Time}.

Propositions of LTL correspond to Reactive Types
(\S\ref{sec:reactive_type}) in Functional Reactive Programming
(\S\ref{sec:frp})

Modalities (\S\ref{sec:modality}) of LTL \emph{as} Combinators of
Reactive Types

Primitive Modalities:
\begin{itemize}
  \item $\ocircle \phi$ -- Next
  \item $\phi \until \psi$ -- Until
\end{itemize}

Derived Modalities:
\begin{itemize}
  \item $\lozenge \phi$ -- Future
  \item $\square \phi$ -- Globally: $\phi$ True at all Future Times
  \item $\phi \underline{\until} \psi$ -- Non-strict Until
  \item $\phi \rhd \psi$ -- Constrains
  \item $\phi \unrhd \psi$ -- Non-strict Constrains
  \item $\phi \rightsquigarrow \psi$ -- Choice: Constructively defines
    a Choice Function, Classically collapses to $\Rightarrow$
\end{itemize}

Duals of $\ocircle$, $\underline{\until}$, $\lozenge$, $\square$:
\begin{itemize}
  \item $\ominus \phi$ -- Yesterday: $\phi$ True at Time $s$ when True
    at Time $s - 1$
  \item $\phi \underline{\since} \psi$ -- Non-strict Since
  \item $\blacklozenge \phi$ -- Once: True when $\phi$ is True at some
    Past Time
  \item $\boxminus \phi$ -- Historically: True whenever $\phi$ is True
    at all Past Times
\end{itemize}

Constrains Modality was introduced for Rely/Guarantee Properties (???)
of Parallel Systems; $\rhd$ has Fixed Points
%FIXME

Derivations of Modalities: %FIXME

$\pow(\Sigma^\omega)$ provides a Model for Linear-time Temporal Logic
\cite{abramsky-gay-nagarajan96}



\paragraph{Interval Temporal Logc}\label{sec:interval_temporal}\hfill

Interval Types (\S\ref{sec:interval_type})



\paragraph{Modal $\mu$-calculus}\label{sec:modal_mu}\hfill



\subsubsection{Dynamic Logic}\label{sec:dynamic_logic}

\emph{Dynamic Logic} adds Terms denoting \emph{Actions}:
\[
  [a]p
\]
where after performing Action $a$ is necessitated that $p$ holds and
\[
  \langle a \rangle p
\]
where after performing Action $a$ it is possible that $p$ holds.



\subsubsection{Provability Logic}\label{sec:provability_logic}

\paragraph{Polymodal Logic}\label{sec:polymodal_logic}\hfill

$\mathsf{GLP}$



\paragraph{Interpretability Logic}\label{sec:interpretability_logic}\hfill

$\mathsf{ILM}$

$\mathsf{TOL}$



\subsubsection{Epistemic Modal Logic}\label{sec:epistemic_logic}

\subsubsection{Adjoint Logic}\label{sec:adjoint_logic}

Adjunctions (\S\ref{sec:adjunction}) of Modal Operators: Adjoint
Modality (\S\ref{sec:adjoint_modality})



\paragraph{Adjoint Modality}\label{sec:adjoint_modality}\hfill

Adjoint Cylinder (\S\ref{sec:adjoint_cylinder})

Adjoint Monads (\S\ref{sec:adjoint_monad})

Hegelian ``Unity of Opposites''

Dialectical Reasoning (???) %FIXME

Category of Being (\S\ref{sec:category_of_being})

Cohesiveness, Differential Cohesion (???)

\[
  \begin{matrix}
    \lozenge & \dashv & \ocircle \\
    \bot & \empty & \bot \\
    \ocircle & \dashv & \square
  \end{matrix}
\]



% --------------------------------------------------------------------
\subsection{Transparent Intensional Logic}
\label{sec:transparent_intensional_logic}
% --------------------------------------------------------------------

\emph{Constructions} (Procedures), ``Mode of Presentation'' (Frege)



% ====================================================================
\section{Term Logic}\label{sec:term_logic}
% ====================================================================

\emph{Syncategorematic Term}

\emph{Syllogistic Calculus} (\S\ref{sec:syllogistic_calculus})



\subsubsection{Square of Opposition}\label{sec:square_of_opposition}



% ====================================================================
\section{Logical System}\label{sec:logical_system}
% ====================================================================

A \emph{Logical System} (or \emph{System of Logic}) is a Formal System
(\S\ref{sec:formal_system}) together with a form of Semantics that
gives Meanings to the Formulas in the underlying Language.

A Structure (\S\ref{sec:structure}) that Satisfies
(\S\ref{sec:satisfaction}) the Axioms of a Logical System is called a
\emph{Model} (\S\ref{sec:model}) of the System.



% --------------------------------------------------------------------
\subsection{Classical Logic}\label{sec:classical_logic}
% --------------------------------------------------------------------

\emph{Classical Logic} is the class of Propositional and
First-order Systems of Logic characterized by the following Inference
Rules:

\begin{description}

\item [Tertium non datur] (\emph{Law of excluded middle})
  \[
    \vdash(p \vee \neg p)
  \]

\item [Double Negation]
  \[
    p \vdash \neg\neg p
  \]

\item [Law of Non-contradiction]
  \[
    \vdash \neg(p \wedge \neg p)
  \]

\item [Ex falso quodlibet] (\emph{Principle of explosion},
  \emph{Principle of Psuedo-Scotus})
  \[
    \vdash 0 \rightarrow p
  \]

%FIXME finish properties and rules

\end{description}

The intended Semantic Interpretation (\S\ref{sec:interpretation}) of
Classical Logic is subject to the Principle of Bivalence
(\S\ref{sec:bivalence_principal}) which says that every Proposition
has one Truth-value: True or False. Non-classical Logics such as
Intuitionistic Logic (\S\ref{sec:intuitionistic_logic}) does not have
this Property.

\fist $\lambda\mu$-calculus (\S\ref{sec:lambda_mu})

\fist Classical Pure Type Systems (\S\ref{sec:cpts})



\subsubsection{Propositional Calculus}
\label{sec:propositional_calculus}

\paragraph{Pierce's Law}\label{sec:pierces_law}\hfill

$((P \rightarrow Q) \rightarrow P) \rightarrow P$

Implies Law of Excluded Middle

$\mathtt{call-cc}$ %FIXME



% --------------------------------------------------------------------
\subsection{Intuitionistic Logic}\label{sec:intuitionistic_logic}
% --------------------------------------------------------------------

\emph{Intuitionistic Logic} (or \emph{Constructive Logic}) replaces
Truth with the concept of \emph{Constructive Provability}. This is to
say that Logical Operations in Intuitionistic Logic preserve
\emph{Justification} (\S\ref{sec:formal_proof}) rather than
Truth-value. Such systems are restrictions of Classical Logic
(\S\ref{sec:classical_logic}) without the Law of the Excluded Middle
or Double Negation Elimination.

Whereas First-order Logic (\S\ref{sec:firstorder_logic}) is a
foundation for Set Theory (Part \ref{part:set_theory}), Intuitionistic
Logic is used as a foundation for Type Theory (Part
\ref{part:type_theory}) and Constructive Set Theory
(\S\ref{sec:constructive_set_theory}).

A Formula in Intuitionistic Logic does not necessarily have a Prenex
Normal Form (\S\ref{sec:prenex_normal}).

Intuitionistic Propositional Calculus is Modelled (\S\ref{sec:model})
by Heyting Algebra (\S\ref{sec:heyting_semantics}, also a Cartesian
Closed Preorder \S\ref{sec:cartesian_preorder}) or Kripke Semantics
(\S\ref{sec:kripke_semantics}) and lacks the Principle of Bivalence
(\S\ref{sec:bivalence_principal}); thus there is no Sole-sufficient
Operator in Intuitionistic Logic. A Formula in Intuitionistic Logic is
Valid if and only if it receives the Value of the Top Element for any
Valuation on a Heyting Algebra.

Intuitionistic First-order Logic is Modelled by a Heyting Category
(\S\ref{sec:heyting_category}).

Intuitionistic-Classical Embedding corresponds to Continuation Passing
Style (\S\ref{sec:continuation}) in Programming Languages.

Functionally Complete Sets of Propositional Operators are:
\[
  \{ \vee, \leftrightarrow, \bot \}
\]
and:
\[
  \{ \vee, \leftrightarrow, \neg \}
\]

Theorem (Intuitionistic Propositional Logic does not refute the Law of
the Excluded Middle)\cite{harper12}:
\[
  \forall A, \neg (\neg (A \vee \neg A))
\]



\subsubsection{Existence Property}\label{sec:existence_property}

Proofs in a Theory (\S\ref{sec:formal_theory}), $\mathcal{T}$, based
on Intuitionistic Logic have the \emph{Existence Property}:
\[
  (\exists x)A(x) \in \mathcal{T} \rightarrow (\exists t)A(t)
\]
where $A(x)$ has $x$ as the only Free Variable and $t$ is a Term.



\subsubsection{Disjunction Property}\label{sec:disjunction_property}

\emph{Disjunction Property}:
\[
  A \vee B \in \mathcal{T}
  \rightarrow A \in \mathcal{T} \vee B \in \mathcal{T}
\]



\subsubsection{Positive Implicational Calculus}
\label{sec:positive_implicational}



\subsubsection{Positive Propositional Calculus}
\label{sec:positive_propositional}

Satisfiability (\S\ref{sec:satisfiability}) is Trivial

Validity (\S\ref{sec:validity}) is co-NP Complete %FIXME ref co-np



\subsubsection{Minimal Logic}\label{sec:minimal_logic}

\emph{Minimal Logic} is an Intuitionistic Logic without the Principle
of Explosion (\S\ref{sec:explosion_principle}).

(Zeroth-order) Minimal Logic corresponds with Simply-typed
$\lambda$-calculus (\S\ref{sec:simply_typed})

First-order Minimal Logic corresponds with First-order Dependently-typed
$\lambda$-calculus (\S\ref{sec:dependent_lambda})



\subsubsection{Superintuitionistic Logic}
\label{sec:superintuitionistic_logic}

A \emph{Superintuitionistic Logic} is an extended Intuitionistic
Logic. The strongest Consistent Superintuitionistic Logic is Classical
Logic (\S\ref{sec:classical_logic}).



\paragraph{Intermediate Logic}\label{sec:intermediate_logic}\hfill

\emph{Intermediate Logic} is an extended Intuitionistic Logic
(Superintuitionistic Logic) that is Consistent and still weaker than
the strongest Consistent Superintuitionistic Logic: Classical Logic.



% --------------------------------------------------------------------
\subsection{Substructural Logic}\label{sec:substructural_logic}
% --------------------------------------------------------------------

Substructural Type Theory (\S\ref{sec:substructural_type})



\subsubsection{Display Logic}\label{sec:display_logic}

\subsubsection{Relevance Logic}\label{sec:relevance_logic}

\emph{Relevance Logic} (or \emph{Relevant Logic})

Strict Logic



\subsubsection{Linear Logic}\label{sec:linear_logic}

Dualities of Classical Logic + Constructive properties of
Intuitionistic Logic

\begin{itemize}
\item Interpretation of Intuitionistic Logic replacing Cartesian Closed
  Categories (\S\ref{sec:cartesian_closed}) with Symmetric Monoidal
  Categories (\S\ref{sec:symmetric_monoidal})
\item Interpretation of Classical Logic replacing Boolean Algebras
  (\S\ref{sec:boolean_algebra}) by C$^*$-algebras
  (\S\ref{sec:cstar_algebra}).
\end{itemize}

Internal Language of Closed Symmetric Monoidal Categories
(\S\ref{sec:closed_symmetric_monoidal})

An Algebraic Semantics (\S\ref{sec:algebraic_semantics}) for Linear
Logic is given by Quantales (\S\ref{sec:quantale})

Game Semantics (\S\ref{sec:game_semantics}): Geometry of Interaction
(\S\ref{sec:interaction_geometry})

Classical Linear Logic (\S\ref{sec:cll})

Intuitionistic Linear Logic

Dual Intuitionistic Linear Logic \S\ref{sec:dual_linear_logic}
(Session Types \S\ref{sec:session_type}) \cite{caires-pfenning10}

Resources, Effects, Non-interference \cite{caires-pfenning10}

Process Calculus (\S\ref{sec:process_calculus})

Session-typed $\pi$-calculus (\S\ref{sec:sessiontyped_pi})

Interaction Nets %FIXME

Context (\S\ref{sec:sequent_context})

Exchange (\S\ref{sec:exchange_rule})

Omitted Rules: Weakening (\S\ref{sec:weakening_rule}), Contraction
(\S\ref{sec:contraction_rule})

Exponentials $!$, $?$: controlled access to Weakening and Contraction

Initial Sequent (Unit for Composition)

Cut (\S\ref{sec:cut_elimination}) (Composition)

Translation from Intuitionistic Logic into Linear Logic:
G\"odel-Gentzen Negative Translation (\S\ref{sec:godel_gentzen}),
embedding Classical First-order Logic into Linear First-order Logic

Traced Monoidal Categories (\S\ref{sec:traced_monoidal}): Operational
Categorical Semantics for Linear Logic (Geometry of Interactions
\S\ref{sec:interaction_geometry})

Exponential Modality $!$ is an example of a Comonad
(\S\ref{sec:comonad}): Counit is \emph{Deriliction} $!A \rightarrow A$
and Comultiplication is \emph{Digging} $!A \rightarrow !!A$

also has the Structure of a Comonoid (\S\ref{sec:comonoid}): Weakening
$!A \rightarrow ()$, Contraction $!A \rightarrow !A \times !A$



\paragraph{Canonical Form Property}\label{sec:canonical_form_property}\hfill

\emph{Canonical Form Property}:
\begin{itemize}
  \item \emph{Completeness of Atomic Initial Sequents}: arbitrary
    Initial Sequents can be Derived from Atomic Initial Sequents
  \item \emph{Cut-elimination Theorem}: whenever a Sequent is Provable
    it can be given a Cut-free Proof
\end{itemize}

Subformula Property



\paragraph{Classical Linear Logic}\label{sec:cll} \hfill

\emph{Classical Linear Logic} (CLL)

Entailment Relation in Full CLL is Undecidable

MLL, MALL, MELL

Interaction Category (\S\ref{sec:interaction_category}) $\cat{SProc}$
of Synchronous Processes is a Model for CLL.

Two standard Translations of Intuitionistic Logic into Classical
Linear Logic (Equivalent to Translations of $\lambda$-calculus
\S\ref{sec:untyped_lambda} into Linear
$\lambda$-calculus \S\ref{sec:linear_lambda}):\cite{wadler12}
\begin{enumerate}
  \item Call-by-name (\S\ref{sec:call_by_name}) (Girard):
\[
  (A \rightarrow B)^\circ = !A^\circ \multimap B^\circ
\]
  \item Call-by-value (\S\ref{sec:call_by_value}):
\[
  (A \rightarrow B)^* = !(A^* \multimap B^*)
\]
\end{enumerate}
GV (Session-typed $\pi$-calculus \S\ref{sec:good_variation}) uses the
second Translation.

Syntax (BNF notation):
\[
\begin{split}
  A ::=& \; p \; | \; p^\bot\\
      |& \; A \otimes A \; | \; A \oplus A\\
      |& \; A \& A \; | \; A \parr A\\
      |& \; 1 \; | \; 0 \; | \; \top \; | \; \bot\\
      |& \; !A \; | \; ?A
\end{split}
\]

$p$ and $p^\bot$ ranging over Logical Atoms
(\S\ref{sec:atomic_formula})

Multiplicatives $\otimes$, $\parr$, $1$, $\bot$

Additives $\oplus$, $\&$, $0$, $\top$

Exponentials $!$, $?$

\begin{itemize}
  \item $\otimes$ Multiplicative Conjunction (``Tensor'', simultaneous
    occurrence of Resources)
  \item $\oplus$ Additive Disjunction (``Plus'', alternative occurence
    of Resources, Internal Choice, ``Choice'')
  \item $\&$ Additive Conjunction (``With'', alternative occurence of
    Resources, External Choice, ``Branch'')
  \item $\parr$ Multiplicative Disjunction (``Parr'')
  \item $1$ Unit for Multiplicative Conjunction (absence of any
    Resource)
  \item $0$ Unit for Additive Disjunction (Resource that cannot be
    created)
  \item $\top$ Unit for Additive Conjunction (unspecified alternative)
  \item $\bot$
  \item $!$ (``Bang'')
  \item $?$ (``Why Not'')
\end{itemize}

Duals for Propositions %FIXME

Linear Negation of $A$: $A^\bot$

$A^{\bot\bot} = A$

\cite{llwiki16}
$\Gamma, A \vdash \Delta$ is Provable if and only if $\Gamma \vdash
A^\bot, \Delta$ is Provable

One-sided Sequents:

$\Gamma \vdash \Delta$ is Provable if and only if $\vdash \Gamma^\bot,
\Delta$ is Provable


\textbf{Polarity}

Positive: $\otimes$, $\oplus$, $1$, $0$, $!$

Negative: $\parr$, $\&$, $\bot$, $\top$, $?$


\textbf{Linear Implication}

\[
  A \multimap B := \; A^{\bot} \parr B
\]
(Resource Interpretation: Validity of Transforming Resource $A$ into
Resource $B$)


\textbf{Intuistionistic Implication}

$!A \multimap B$


\textbf{Classical Implication}

$!A \multimap ?B$


\textbf{Equivalences}

$A \equiv B = (A \multimap B) \& (B \multimap A)$


\textbf{Distributivity}

$A \otimes (B \oplus C) \equiv (A \otimes B) \oplus (A \otimes C)$


\textbf{Linear Distribution} (Weak Distribution)

$(A \otimes (B \parr C)) \multimap ((A \otimes B) \parr C)$


\textbf{Exponential Isomorphism}

$!(A \& B) \equiv !A \otimes !B$


\textbf{LU Presentation}



\paragraph{Dual Intuitionistic Linear Logic}\hfill
\label{sec:dual_linear_logic}

\cite{andreoli92}

\emph{Dual Intuitionistic Linear Logic} (sometimes \emph{DILL})

Dyadic

Session Types (\S\ref{sec:session_type})

Session-typed $\pi$-calculus (\S\ref{sec:sessiontyped_pi})



\paragraph{Elementary Linear Logic}\label{sec:elementary_linear_logic}\hfill

\paragraph{Light Linear Logic}\label{sec:light_linear_logic}\hfill

Characterizing Complexity Classes (\S\ref{sec:complexity_class})



\paragraph{Multiplicative Linear Logic}\hfill
\label{sec:multiplicative_linear_logic}

\cite{haghverdi-scott05}

$MLL$

Multiplicative Exponential Linear Logic $MELL$

Multiobject Geometry of Interaction (\S\ref{sec:multiobject_goi})



\paragraph{Soft Linear Logic}\label{sec:soft_linear_logic}\hfill

\paragraph{Non-commutative Logic}\label{sec:noncommutative_logic}\hfill

\emph{Ordered Logic}



\paragraph{Affine Logic}\label{sec:affine_logic}\hfill

An \emph{Affine Logic} is a Linear Logic with Weakening.



\subsubsection{Bunched Logic}\label{sec:bunched_logic}

Tree of Hypotheses instead of flat List

Modelled by Kripke Semantics with Worlds having a Monoidal Product
% FIXME



\paragraph{Deep Inference}\label{sec:deep_inference}\hfill



% --------------------------------------------------------------------
\subsection{Ordinal Logic}\label{sec:ordinal_logic}
% --------------------------------------------------------------------

Alan Turing's PhD Thesis \cite{turing38}



% --------------------------------------------------------------------
\subsection{Categorical Logic}\label{sec:categorical_logic}
% --------------------------------------------------------------------

Many-sorted Logic, Type Theory, Categorical Logic

Categorical Semantics (\S\ref{sec:categorical_semantics})

\begin{itemize}
  \item Syntax and Symantics are given by a Category
  \item Interpretation is given by a Functor
\end{itemize}

Syntactic Category (\S\ref{sec:syntactic_category})

Topos Theory (\S\ref{sec:topos_theory})


\textbf{First-order Categorical Logic}

youtube: Carmello - Introduction to categorical logic, classifying
toposes

Semantics: Mathematical Structures (\S\ref{sec:structure})

Syntax: First-order Languages (\S\ref{sec:firstorder_logic}) --
Sorts, Terms, Formulas

Grothendieck Topos (\S\ref{sec:grothendieck_topos})

Sorts: Kinds of Individuals (e.g. Objects, Morphisms) %FIXME xref kinds?

Terms: Individuals

Formulas: Assertions about Individuals


First-order Signature $\Sigma$:
\begin{itemize}
  \item $\Sigma_{sort}$ -- $A,B,C,\ldots$
  \item $\Sigma_{fun}$ -- $f : A_1, \ldots, A_n \rightarrow B$
  \item $\Sigma_{rel}$ -- $R \hookrightarrow A_1 \times \cdots \times
    A_n$
\end{itemize}

Context $\overline{x}$ -- Finite Set of Free Variables

Sequent $\varphi \vdash_{\overline{x}} \psi$

$\forall \overline{x} (\varphi \Rightarrow \psi)$

Model, Interpretation

$\struct{M}$

$\llbracket \overline{x}.\varphi \rrbracket_M \hookrightarrow M(A_1)
\times \cdots \times M(A_n)$


Algebraic Theory -- Axioms of form $\top \vdash t = s$ (Equalities
between Terms)

Regular Theories -- $\varphi \vdash_{\overline{x}} \psi$ ($\varphi$,
$\psi$ Regular: $\exists$, Finitary $\wedge$)

Coherent Theories -- ($\varphi$, $\psi$ Coherent: $\exists$, Finitary
$\wedge$, $\vee$)

Geometric Logic -- ($\varphi$, $\psi$ Geometric: $\exists$, Finitary
$\wedge$, Infinitary $\vee$)

%FIXME xrefs



\subsubsection{Term-model Construction}\label{sec:term_model}

\subsubsection{Internal Logic}\label{sec:internal_logic}

or \emph{Internal Language}

Simply-typed $\lambda$ Calculus gives the Internal Logic for
Cartesian Closed Categories

Extensional Martin-L\"of Type Theories give the Internal Logic for
Cartesian Closed Quasicategories

$Lan$ -- Functor from Categories to Type Theories; Right-adjoint
(\S\ref{sec:adjoint_functor}) to Functor $Syn$ mapping Theories to
Syntactic Categories (\S\ref{sec:syntactic_category})



% --------------------------------------------------------------------
\subsection{Hoare Logic}\label{sec:hoare_logic}
% --------------------------------------------------------------------

\emph{Concurrency}



% --------------------------------------------------------------------
\subsection{Free Logic}\label{sec:free_logic}
% --------------------------------------------------------------------

\subsubsection{Inclusive Logic}\label{sec:inclusive_logic}



% --------------------------------------------------------------------
\subsection{Connexive Logic}\label{sec:connexive_logic}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Non-monotonic Logic}\label{sec:nonmonotonic_logic}
% --------------------------------------------------------------------

Defeasible Inference (\S\ref{sec:defeasible_inference})



\subsubsection{Default Logic}\label{sec:default_logic}

Default Inference (\S\ref{sec:default_inference})



\subsubsection{Autoepistemic Logic}\label{sec:autoepistemic_logic}



% --------------------------------------------------------------------
\subsection{Paraconsistent Logic}\label{sec:paraconsistent_logic}
% --------------------------------------------------------------------

\subsubsection{Discursive Logic}\label{sec:discursive_logic}

\subsubsection{Non-adjunctive Logic}\label{sec:nonadjunctive_logic}

\subsubsection{Adaptive Logic}\label{sec:adaptive_logic}

\subsubsection{Formal Inconsistency}\label{sec:formal_inconsistency}

\subsubsection{Logic of Paradox}\label{sec:logic_of_paradox}

Graham Priest



% --------------------------------------------------------------------
\subsection{Mereology}\label{sec:mereology}
% --------------------------------------------------------------------

Nominalism (\S\ref{sec:nominalism})



% ====================================================================
\section{Metalogic}\label{sec:metalogic}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Logical Quality}\label{sec:logical_quality}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Logical Truth}\label{sec:logical_truth}
% --------------------------------------------------------------------

\emph{Interpretation} (\emph{Valuation}, \emph{Assignment})
\S\ref{sec:interpretation}

\emph{Corresponding Conditional} is \emph{Logical Truth}

\emph{Satisfiable}

\emph{Necessarily True}

\emph{Semantic Theory} (\S\ref{sec:semantic_truth})

\emph{Correspondence Theory} (\S\ref{sec:correspondence_truth})

\emph{Deflationary Theory} (\S\ref{sec:deflationary_truth})



\subsubsection{Truth-value}\label{sec:truth_value}

\emph{Truth-value} (\emph{Logical Value})

In Intuitionistic Type Theory (\S\ref{sec:intuitionistic_type}),
\emph{Types} take the place of Truth-values.

A Truth-value is the Extension (\S\ref{sec:extension}) of a Sentence
(\S\ref{sec:sentence}).



\paragraph{Vacuous Truth}\label{sec:vacuous_truth}\hfill

A \emph{Vacuous Truth} is a Conditional Statement with a False
Antecedent (\S\ref{sec:antecedent}).

A Sentence (\S\ref{sec:sentence}) that Asserts (\S\ref{sec:assertion})
all Members of the Empty Set have a certain Property
(\S\ref{sec:property}) is also a Vacuous Truth and may be also be
reduced to a Conditional Statement with a False Antecedent.

Used as Base Case in Proofs by Mathematical Induction
(\S\ref{sec:mathematical_induction})



\subsubsection{Truth-bearer}\label{sec:truth_bearer}

\begin{itemize}
  \item Proposition
  \item Type-token
  \item Judgement
\end{itemize}



\paragraph{Proposition}\label{sec:proposition}\hfill

A \emph{Proposition} is the Referent (\S\ref{sec:referent}) of a
Propositional Formula (\S\ref{sec:propositional_formula}) or other
Content Clause (\S\ref{sec:content_clause}).



\subsubsection{Analytic Truth}\label{sec:analytic_truth}

\paragraph{Preservation}\label{sec:preservation}\hfill

\emph{Truth-preserving}

\emph{False-preserving}

\emph{Non-preserving}



\paragraph{$n$-validity}\label{sec:n_validity}\hfill

\paragraph{$\omega$-validity}\label{sec:omega_validity}\hfill



\subsubsection{Truth Function}\label{sec:truth_function}

A \emph{Truth Function} is a Function to and from Truth-values
(\S\ref{sec:truth_value}).



\subsubsection{Soundness}\label{sec:soundness}

\emph{Sound}

A Logical Argument (\S\ref{sec:logical_argument}) is Sound if and only
if it is Valid (\S\ref{sec:validity}) and all of its Premises are
True.

A Formal System (\S\ref{sec:formal_system}) is Sound if and only if
its Inference Rules (\S\ref{sec:inference_rule}) Prove only Valid
Formulas under Semantic Interpretation (\S\ref{sec:interpretation}).
This usually amounts to the simple requirement that the Axioms are
Valid and the Inference Rules preserve Validity, i.e. any Theorem
Provable in the System is Valid, thus all Provable Sentences are True.

In a Theory, $\mathcal{T}$, of Propositional
(\S\ref{sec:propositional_calculus}) or First-order Logic
(\S\ref{sec:firstorder_logic}):
\[
  \Gamma \vdash \varphi \Rightarrow \Gamma \vDash \varphi
\]
where $\Gamma$ is a Set of Sentences and $\varphi \in \mathcal{T}$.

The converse of Soundness, Completeness (\S\ref{sec:completeness})
requires that all True Sentences are Provable. By the Incompleteness
Theorem (\S\ref{sec:incompleteness_theorem}), not all Sound Deductive
Systems are Complete. In Propositional and First-order Logic,
Soundness and Completeness are equivalent Properties.

\emph{Weak Soundness}

\emph{Strong Soundness}

\emph{Arithmetic Soundness}



% --------------------------------------------------------------------
\subsection{Logical Inference}\label{sec:logical_inference}
% --------------------------------------------------------------------

\emph{Logical Inference} (or \emph{Logical Reasoning})

\begin{enumerate}
\item \emph{Premise} (\emph{Precondition}, \emph{Antecedent})

\item \emph{Material Conditional} (\emph{Corresponding Conditional},
  \emph{Implication Rule}, \emph{Inference Rule} (?)
  \S\ref{sec:inference_rule})

\item \emph{Logical Consequence} (\emph{Conclusion},
  \emph{Consequent}, \emph{Idiomatic})
\end{enumerate}

The Premise and Conclusion are \emph{Truth-bearers}
(\S\ref{sec:truth_bearer}).

\begin{description}
\item [Coherent] \hfill\\
  \S\ref{sec:paraconsistent_inference}
  \emph{Paraconsistent Inference}

\item [Consistent] \hfill\\
  \S\ref{sec:deductive_inference} \emph{Deductive Inference}

\item [Non-monotonic] \hfill\\
  \S\ref{sec:inductive_inference} \emph{Inductive Inference}

  \S\ref{sec:abductive_inference} \emph{Abductive Inference}

\end{description}

? \emph{Analogical Inference}



% --------------------------------------------------------------------
\subsection{Logical Consequence}\label{sec:logical_consequence}
\cite{beall-restall05}
% --------------------------------------------------------------------

\emph{Logical Consequence} (\emph{Entailment}):
\[
  S \in \mathbf{L}, D \subset \mathbf{L}, S \leftrightarrow D
\]
\begin{itemize}
  \item 1. Logical Form (\S\ref{sec:logical_form})
  \item 2. A Priori
  \item 3. Modality (\S\ref{sec:modality})
\end{itemize}

A Premise \emph{Logically Entails} a Conclusion if and only if the
negation of the Conclusion is \emph{Logically Inconsistent} with the
Premises.



\subsubsection{Formal Consequence}\label{sec:formal_consequence}

\emph{Syntactic Consequence} (\S\ref{sec:syntactic_consequence})

\emph{Semantic Consequence} (\S\ref{sec:semantic_consequence})

\emph{Validity} (\S\ref{sec:validity})



\subsubsection{Material Consequence}

\emph{Material Consequence} (\emph{Implication})



% --------------------------------------------------------------------
\subsection{Paraconsistent Inference}\label{sec:paraconsistent_inference}
\cite{priest-tanaka-weber13}
% --------------------------------------------------------------------

\subsubsection{Paraconsistent Consequence}\label{sec:paraconsistent_consequence}

A Logical Consequence Relation is a \emph{Paraconsistent Consequence
  Relation} if and only if it is not \emph{Explosive}. Such a Relation
is required to be \emph{Coherent} (\emph{Absolutely Consistent} or
\emph{Non-trivial}), meaning that no Paraconsistent Theory
(\S\ref{sec:formal_theory}) can include all Sentences.

A Consequence Relation $\vDash$ is \emph{Explosive} when:
\[
  \forall A, B. \{A, \neg A\} \vDash B
\]
which is the case with \emph{Consistent Consequence Relations}.



% --------------------------------------------------------------------
\subsection{Deductive Inference}\label{sec:deductive_inference}
% --------------------------------------------------------------------

\emph{Top-down Logic}

\subsubsection{Deductive Consequence}\label{sec:deductive_consequence}

A \emph{Deductive Consequence} is a Modally \emph{Necessary}
Conclusion drawn from given Premises and Inference Rules.

\emph{Consistency}

Deductive Consequence can be extended to provide \emph{Inductive
  Support} in \emph{Inductive Consequence}
(\S\ref{sec:inductive_consequence})



\paragraph{Principle of Explosion}\label{sec:explosion_principle}\hfill

\emph{Principle of Explosion}



\subsubsection{Mathematical Induction}\label{sec:mathematical_induction}

\emph{Mathematical Induction} as an Inference Rule is the
\emph{Implicative} process where a \emph{Base Case} is shown to extend
to the more general by means of Implication (the Inductive step).

Note that Mathematical Induction is not \emph{Inductive Reasoning}
(\S\ref{sec:inductive_inference}) which is an empirical or
Probabilistic Inference (\S\ref{sec:probabilistic_inference}) and not
a form of Deduction. The \emph{Principle of Mathematical Induction}
(\S\ref{sec:induction_principle}) is an application of Mathematical
Induction to the \emph{Natural Numbers} (\S\ref{sec:natural_number}).

The Base Case may be given as a Vacuous Truth
(\S\ref{sec:vacuous_truth}).



\subsubsection{Structural Induction}\label{sec:structural_induction}

Prove that $P(x)$ holds for all $x$ of some Recursively Defined
Structure (\S\ref{sec:recursive_definition}), Inductive Type
(\S\ref{sec:inductive_type}).

Well-founded (\S\ref{sec:well_founded}) Partial Order
(\S\ref{sec:partial_order}) implies that any Non-empty Subset must
have a Minimal Element.

Prove that $P(x)$ holds for all Minimal Structures (Base Case), and if
holding for the immediate Substructures of a Structure $S$, then it
must hold for $S$ also (Inductive Step). %FIXME expand or xref

Smallest Class of things Closed under some ``Constructor'' Operations;
Closed under Intersections \cite{shulman11}

Initial Algebra %FIXME



\paragraph{Coinduction}\label{sec:coinduction}\hfill

Dual to Structural Induction

Largest Class of things Closed under some ``Destructor'' Operations;
Closed under Unions \cite{shulman11}

Coalgebra (\S\ref{sec:coalgebra}), Terminal Coalgebra
(\S\ref{sec:terminal_coalgebra})

Describes how an Object can be ``Observed'', ``Broken Down'', or
``Destructed''

\emph{Codata} (\S\ref{sec:coinductive_type})

Prove that $P(x)$ holds for all Implementations of a Specification
%FIXME expand or xref



\subsubsection{Noetherian Induction}\label{sec:noetherian_induction}

\emph{Well-founded Relation}



\subsubsection{Transfinite Induction}\label{sec:transfinite_induction}

Extension of Mathematical Induction
(\S\ref{sec:mathematical_induction}) to Well-ordered Sets
(\S\ref{sec:well_order}), e.g. Ordinal Numbers
(\S\ref{sec:ordinal_number})

Zero Case

Successor Case

Limit Case

Transfinite Recursion (\S\ref{sec:transfinite_recursion})



% --------------------------------------------------------------------
\subsection{Inductive Inference}\label{sec:inductive_inference}
\cite{hawthorne08}
% --------------------------------------------------------------------

\emph{Universal Inductive Inference}

\emph{Inductive Reasoning}



\subsubsection{Inductive Consequence}\label{sec:inductive_consequence}

\emph{Inductive Consequence} (\emph{Inductive Support}) is an
extension of Deductive Consequence where the Modality of Necessity is
relaxed to that of \emph{Sufficiency}.



\subsubsection{Defeasible Inference}\label{sec:defeasible_inference}

\subsubsection{Probabilistic Inference}\label{sec:probabilistic_inference}

Inferential Statistics (\S\ref{sec:inferential_statistics})



% --------------------------------------------------------------------
\subsection{Abductive Inference}\label{sec:abductive_inference}
% --------------------------------------------------------------------



% --------------------------------------------------------------------
\subsection{Default Inference}\label{sec:default_inference}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Logical Argument}\label{sec:logical_argument}
% --------------------------------------------------------------------

A \emph{Logical Argument}, \emph{Formal Argument}, or
\emph{Derivation} (see \S\ref{sec:formal_proof} \emph{Formal Proof})
is a sequence of Logical Inferences. Generally this is an Ordered Set
of Sentences (\S\ref{sec:truth_bearer} Truth-bearers).



\subsubsection{Corresponding Conditional}\label{sec:corresponding_conditional}

The \emph{Corresponding Conditional} of a Derivation is a
\emph{Material Conditional} (\S\ref{sec:material_conditional}) whose
Antecedent is the Conjunction of the Derivation's Premises and whose
Consequent is the Derivation's Conclusion.



% --------------------------------------------------------------------
\subsection{Logical Form}\label{sec:logical_form}
% --------------------------------------------------------------------

Normal Form (\S\ref{sec:normal_form})

The Logical Form of an \emph{Argument} (\S\ref{sec:logical_argument})
is Derived from the Logical Form of its constituent Sentences. When
considering Terms as \emph{Schematic Variables}
(\S\ref{sec:metavariable}), the Logical Form of the whole Argument or
\emph{Argument Form} is called the \emph{Schemata} or
\emph{Inferential Structure} of the Argument.



Logical Constant (\S\ref{sec:logical_constant})



% --------------------------------------------------------------------
\subsection{Property}\label{sec:property}
% --------------------------------------------------------------------

\emph{Properties} (or \emph{Predicables} or \emph{Attributes}
\S\ref{sec:attribute}) are Objects that can be Predicated of other
Objects. A Predicate (\S\ref{sec:predicate}) or \emph{Relation} (cf.
Set Relation \S\ref{sec:set_relation}) is not itself the Property, but
the \emph{Extension} (\S\ref{sec:extension}) of that Property.

An Extension of a Property is a Class (\S\ref{sec:class}), but not
every Property has an Extension as exemplified by Russell's Paradox
(\S\ref{sec:russells_paradox}).

\emph{Predicativity / Impredicativity} - Weyl

\emph{Vicious Circle Principle}

Circular Definition (\S\ref{sec:circular_definition})

Explicit Circularity

Circular Quantification

The Property of ``Predicability'' is Impredicative
(\S\ref{sec:impredicative_definition}), that is, it can't be defined
within a Ramified Theory of Types.\cite{kleene52}



\subsubsection{Instantiation}\label{sec:instantiation}

Abstract Structure (\S\ref{sec:instantiation})



\paragraph{Descriptive Predicate}\label{sec:descriptive_predicate}\hfill

Empirical Property (Carnap \cite{carnap59})



\paragraph{Logical Predicate}\label{sec:logical_predicate}\hfill



\subsubsection{Pointwise}\label{sec:pointwise}



% ====================================================================
\section{Universal Logic}\label{sec:universal_logic}
% ====================================================================

Institutions (\S\ref{sec:institution})
