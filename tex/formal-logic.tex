%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Formal Logic}\label{part:formal_logic}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Formal Logic} (or \emph{Symbolic Logic}) is the study of Logical
Systems (\S\ref{sec:logical_system}), that is, Formal Systems
(\S\ref{sec:formal_system}) with an underlying Language that is
suitable for the particular Logic under consideration, together with a
form of Semantics (Part \ref{part:formal_semantics}), usually as a
Model-theoretic Interpretation (\S\ref{sec:interpretation}).

cf. Per Martin-L\"of - \emph{On the Meanings of the Logical Constants and
  Justification of Logical Laws}



% ====================================================================
\section{Logic}\label{sec:logic}
% ====================================================================

A \emph{Logic} is a Family of Languages that differ from eachother
only in \emph{Signature} (\S\ref{sec:signature}), such as
\emph{First-order Logic} (\S\ref{sec:firstorder_logic}), \emph{Modal
  Logic} (\S\ref{sec:modal_logic}), etc.

Symbols in a Language are broadly divided into \emph{Variables}
(\S\ref{sec:variable}) and \emph{Constants}, the latter of which are
divided into \emph{Logical Constants} (\S\ref{sec:logical_constant})
and \emph{Non-Logical Constants} (\S\ref{sec:nonlogical_constant}).

\emph{Extra-logical Symbols} are those of a Metalanguage
(\S\ref{sec:metalanguage}), such as the Symbol for Logical Consequence
(Entailment \S\ref{sec:logical_consequence}), $\vdash$, or
Metavariables (\emph{Schematic Variables}), $\varphi, \psi, \ldots$.

Symbols that don't have individual Meaning in isolation are termed
\emph{Syncategorematic} (see Term Logic \S\ref{sec:term_logic}),
otherwise they are called \emph{Categorematic}.

Other Symbols may be used for \emph{Punctuation}, like Parentheses and
Commas, as long as they don't appear in one of the other kinds of
Symbols.

The Cardinality of the underlying Language $\mathcal{L}$,
$|\mathcal{L}|$, is equal to the number of Equivalence Classes defined
by the Variance Relation (\S\ref{sec:variant}) on the Formulas of
$\mathcal{L}$.



% --------------------------------------------------------------------
\subsection{Logical Constant}\label{sec:logical_constant}
% --------------------------------------------------------------------

\emph{Logical Constants} (or \emph{Logical Symbols}) have the same
Semantic Meaning under every Interpretation
(\S\ref{sec:interpretation}) of the Language.

Two types of Logical Constants are \emph{Logical Connectives}
(\S\ref{sec:logical_connective} and \emph{Quantifiers}
(\S\ref{sec:quantifier}).



\subsubsection{Logical Connective}\label{sec:logical_connective}

A \emph{Logical Connective} (or \emph{Logical Operator}) is a Truth
Function (\S\ref{sec:truth_function}) that assigns a Truth-value to a
Compound Sentence as a Function of the Truth-value of its
Sub-sentences.

A \emph{Functionally Complete} Set of Logical Connectives allows the
expression of arbitrary Truth Functions. The smallest such Set may be
a single Connective (called a \emph{Sole-sufficient Operator}), such
as Alternative Denial ($\uparrow$, \S\ref{sec:alternative_denial}) or
Joint Denial ($\downarrow$, \S\ref{sec:joint_denial})



\paragraph{Disjunction}\label{sec:disjunction}\hfill

\emph{Disjunction} (also \emph{Alternation} or ``\emph{Logical Or}'')

\fist \emph{Role-based Interpretation} of Conjunction/Disjunction
Duality (Linear Multirole Logic \S\ref{sec:lmrl})



\paragraph{Conjunction}\label{sec:conjunction}\hfill

\emph{Conjunction} (or ``\emph{Logical And}'')

\fist \emph{Role-based Interpretation} of Conjunction/Disjunction
Duality (Linear Multirole Logic \S\ref{sec:lmrl})



\paragraph{Material Conditional}\label{sec:material_conditional}\hfill

\emph{Material Conditional}, \emph{Material Implication},
\emph{Material Consequence}



\paragraph{Joint Denial}\label{sec:joint_denial}\hfill

\emph{Joint Denial} or ``\emph{Nor}''



\paragraph{Alternative Denial}\label{sec:alternative_denial}\hfill

\emph{Alternative Denial} or ``\emph{Nand}'' (also \emph{Sheffer
  Stroke})



\subsubsection{de Morgan's Laws}\label{sec:de_morgan}

\[
  \neg (P \wedge Q) \Leftrightarrow (\neg P) \vee (\neg Q)
\] \[
  \neg (P \vee Q) \Leftrightarrow (\neg P) \wedge (\neg Q)
\]

Set Theory, Boolean Algebra



\subsubsection{Quantifier}\label{sec:quantifier}

A \emph{Quantifier} limits (\emph{Binds}) a Variable to a certain
quantity of members of the Domain, the two fundamental Quantifiers
being the \emph{Universal Quantifier} ($\forall$) and
\emph{Existential Quantifier} ($\exists$).

A \emph{Bound Quantifier} is one with a restricted Range, e.g.
$\exists x > 0$ or $\forall x \in \mathbb{R}$.

The \emph{Unique Existential Quantifier}, denoted by $\exists !$, is
expressed in natural language as ``there is one and only one.'' A
First-Order System requires the \emph{Equality Relation}
(\S\ref{sec:firstorder_equality}) in order to be able to express
Uniqueness Quantification.

Quantification over Natural Numbers is \emph{Predicative}

Quantification over Types (\S\ref{sec:type}) is \emph{Impredicative}
(\S\ref{sec:impredicative_definition})



\paragraph{Existential Quantifier}\label{sec:existential_quantifier}\hfill

Dependent Sum Type (\S\ref{sec:sigma_type})



\paragraph{Universal Quantifier}\label{sec:universal_quantifier}\hfill

Dependent Product Type (\S\ref{sec:pi_type})



\paragraph{Quantifier Rank}\label{sec:quantifier_rank}\hfill

\emph{Quantifier Rank} is the depth of nesting of Quantifiers in a
Formula.

Inductive definition of Quantifier Rank function $qr$:
\begin{itemize}
  \item $qr(\varphi) = 0$ if $\varphi$ is Atomic
  \item $qr(\varphi_1 \wedge \varphi_2) =
    qr(\varphi_1 \vee \varphi_2) = max(qr(\varphi_1),qr(\varphi_2))$
  \item $qr(\neg \varphi) = qr(\varphi)$
  \item $qr(\exists_x \varphi) = qr(\varphi) + 1$
\end{itemize}



\paragraph{Prenex Normal Form}\label{sec:prenex_normal}\hfill

Normal Form (\S\ref{sec:normal_form})



\paragraph{Plural Quantification}\label{sec:plural_quantification}
\hfill

\emph{Plural Quantification}



% --------------------------------------------------------------------
\subsection{Non-logical Constant}\label{sec:nonlogical_constant}
% --------------------------------------------------------------------

\emph{Non-Logical Symbols} only have Meaning under an Interpretation
(\S\ref{sec:interpretation}). These are Symbols such as Predicate
(\S\ref{sec:predicate}) and Function Symbols (Operators \S\ref{sec:operator}).

The set of Non-Logical Symbols used in a particular discourse is called the
Signature (\S\ref{sec:signature}) of the discourse.



\subsubsection{Signature}\label{sec:signature}

The \emph{Signature} (or \emph{Vocabulary}) defines the Non-logical
Constants (\S\ref{sec:nonlogical_constant}) of the Language of a
Logical System as a Set of Function and Predicate Symbols that
characterize it together with an \emph{Arity Function} ``$ar$'' that
maps each Function and Predicate Symbol $s$ to a corresponding Natural
Number $n$ which is the Arity of $s$: $n = ar(s)$.

The corresponding Formal Language is the Set of
\emph{$\sigma$-formulas} and a Structure (\S\ref{sec:structure}) with
Signature $\sigma$ may be called a \emph{$\sigma$-structure}.

A Signature is defined as a triple:
\[
  (F,R,ar)
\]
where $F$ is a Set of Function Symbols (or \emph{Operators}), and $R$
is a Set of Predicate (or \emph{Relation}) Symbols and $ar$ is the
Arity Function:
\[
  ar: F \cup R \rightarrow \mathbb{N}_0
\]
If both $F$ and $R$ are Finite Sets, $\sigma$ is a \emph{Finite
  Signature}.

Technically the Function Symbols, which are Interpreted
(\S\ref{sec:interpretation_function}) as Functional Predicates
(\S\ref{sec:functional_predicate}), could also be Realized as
Relations, and thus it is only for convenience that they are included
in addition to Predicate Symbols, not out of necessity.

Function Symbols without Interpretations
(\S\ref{sec:uninterpreted_function}) leads to a Theory of
Uninterpreted Functions (Empty Theory \S\ref{sec:empty_theory}).

A Nullary Function Symbol is a \emph{Constant Symbol} (represents a
Constant Element) and a Nullary Predicate Symbol is a
\emph{Propositional Variable} (represents a Constant Truth-value). A
Function or Predicate Symbol $s$ of Arity $n$ is sometimes denoted
$\prescript{n}{}{s}$. Allowing for \emph{Infinitary Operators} leads
to a Theory of Complete Lattices (\S\ref{sec:complete_lattice}).

A Signature with no Predicate Symbols is an \emph{Algebraic
  Signature}, and the associated Structure an Algebra
(\S\ref{sec:universal_algebra}).

A Signature with no Function Symbols is a \emph{Relational Signature},
and the associated Structure is a \emph{Relational Structure}. A
Relational Structure may be used as the basis for a Relational Model
(\S\ref{sec:relational_model}) in Database Theory.

In Model Theory, a \emph{Structure} (\S\ref{sec:structure}) is an
Interpretation of a given Signature with the Empty Theory
(\S\ref{sec:empty_theory}). Theories with different Signatures may
have the same Categories of Models (\S\ref{sec:category_of_models}).

The Signature is a synonym for the \emph{Type} (\S\ref{sec:type}) of
the Structure (Schematically represented by $\Omega$), and can be
written as an ordered sequence of Natural Numbers representing the
Arity of the Operators.

A \emph{Reduct} of a Structure is created by omitting certain Function
and Predicate Symbols from the Signature; the converse is
\emph{Expansion} (\S\ref{sec:reduct_expansion}). A Signature $\sigma$
Expanded by a Set of Symbols $S$ may be denoted $\sigma(S)$.

\begin{enumerate}
  \item $(2)$         Semigroup (\S\ref{sec:semigroup})
  \item $(2,0)$       Monoid (\S\ref{sec:monoid})
  \item $(2,1,0)$     Group (\S\ref{sec:group})
  \item $(2,2,1,0)$   Rng (\S\ref{sec:rng})
  \item $(2,2,1,0,0)$ Unital Ring (\S\ref{sec:unital_ring})
\end{enumerate}



\paragraph{Many-sorted Signature}\label{sec:manysorted_signature}\hfill

A \emph{Many-sorted Signature} is given as:
\[
  (S, \sigma, type)
\]
which adds to a Signature $\sigma$ a Set of Sorts (\S\ref{sec:sort}),
$S$, and a Function $type$ that maps each Symbol of $\sigma$ to a Type
(\S\ref{sec:type}) over $S$. The Arity Function of $\sigma$ is also
modified to give Tuples of Sorts rather than Natural Numbers.



\paragraph{Cardinality}\label{sec:signature_cardinality}\hfill

The \emph{Cardinality} of a Signature $\sigma = (F,R,ar)$ is denoted
$|\sigma|$ and is the least Infinite Cardinal
(\S\ref{sec:cardinal_number}) $n$ such that $n \geq (|F| + |R|)$, that
is, greater than or equal to the number of Symbols in the Signature
$\sigma$. This is equal to the number of First-order Formulas
(\S\ref{sec:predicate_logic}) of $\sigma$.



\paragraph{Reduction \& Expansion}\label{sec:reduct_expansion}\hfill

For two Signatures $\sigma^-$ and $\sigma^+$ where $\sigma^- \subset
\sigma^+$, any $\sigma^+$-structure $\mathcal{A}$ is also a
$\sigma^-$-structure called the \emph{$\sigma^-$-reduct} of
$\mathcal{A}$ denoted $\mathcal{A}|\sigma^-$, having the same Domain
as $\mathcal{A}$ (although the Set of Constant Elements corresponding
to Constant Functions in the Signature of $\sigma^-$ may be smaller).

A Homomorphism of $\sigma^+$-structures $h : \mathcal{A} \rightarrow
\mathcal{B}$ is also a Homomorphism of $\sigma^-$-structures $h :
\mathcal{A} | \sigma^- \rightarrow \mathcal{B} | \sigma^-$.

If a Structure $\mathcal{B}$ is a $\sigma^-$-reduct of a
$\sigma^+$-structure $\mathcal{A}$ then $\mathcal{A}$ is called the
\emph{Expansion} of $\mathcal{B}$ to $\sigma^+$. Such an Expansion is
not necessarily unique. The notation for an Expansion by certain
additional Function or Predicate Symbols, $f, g, h$, is denoted
$\mathcal{A} = (\mathcal{B}, f, g, h)$.



\subsubsection{Predicate}\label{sec:predicate}

Indicator Function (\S\ref{sec:indicator_function})

Boolean-valued Function (\S\ref{sec:boolean_function})



\paragraph{Descriptive Predicate}\label{sec:descriptive_predicate}\hfill

Empirical Property (Carnap \cite{carnap59})

Properties (\S\ref{sec:property})



\paragraph{Logical Predicate}\label{sec:logical_predicate}\hfill



\subsubsection{Operator}\label{sec:operator}

Operation = Realized Operator (Function Symbol)

\fist cf. \emph{Operator} (\S\ref{sec:space_operator}) -- a Mapping from a Space
to itself

see also:
\begin{itemize}
\item Set Function (\S\ref{sec:set_function})
\item Morphism (\S\ref{sec:morphism})
\item Map (\S\ref{sec:map})
\end{itemize}



\paragraph{Functional Predicate}\label{sec:functional_predicate}\hfill

Function Symbol, Functional Predicate



% --------------------------------------------------------------------
\subsection{Variable}\label{sec:variable}
% --------------------------------------------------------------------

A \emph{Variable} is a placeholder that ranges over the objects in the
Domain of Discourse (\S\ref{sec:domain}).

Variables are called \emph{Free} or \emph{Bound} depending on whether
or not they are Quantified (\S\ref{sec:quantifier}). Free and Bound
Variables are sometimes called \emph{Real} and \emph{Apparent},
respectively.

Inductive definition of Free and Bound Variables:
\begin{enumerate}
\item A Variable $x$ is Free in Atomic Formula
  (\S\ref{sec:atomic_formula}) $\varphi$ if $x$ occurs in $\varphi$
  (Atomic Formulas are Quantifier-free)
\item A Variable is Free or Bound in the Compound Formula
  (\S\ref{sec:formula}) $\varphi \bullet \psi$ if $x$ is Free or Bound
  in either $\varphi$ or $\psi$, where $\bullet$ is a Binary Logical
  Connective (\S\ref{sec:logical_connective})
\item A Variable $x$ is Free in $\forall y \varphi$ iff $x$ is Free in
  $\varphi$ and $x$ is not $y$. Conversely $x$ is Bound in $\forall y
  \varphi$ if $x$ is $y$ or $x$ is Bound in $\varphi$.
\end{enumerate}

A Term (\S\ref{sec:term}) with no Free Variables is a \emph{Ground
  Term} and a Formula with no Free Variables in First-order Logic is a
\emph{Sentence} (\S\ref{sec:sentence}, also called a \emph{Closed
  Formula}). Sentences have well-defined Truth values. In some
treatments, Free Variables may be Implicitly Universally Quantified,
but in general this is not the case.

see also:
\begin{itemize}
  \item Independent (\S\ref{sec:independent_variable}) and Dependent
    (\S\ref{sec:dependent_variable}) Variables -- Symbols representing
    Elements of the Domain and Codomain, respectively, of a Set Function
\end{itemize}



\subsubsection{Witness}\label{sec:witness}

An Existentially Quantified Variable, $\exists x$, may be removed by
introducing a new Constant Symbol, $c$, that provides a \emph{Witness}
of an Element that Satisfies the Formula in which it appears.

cf. Type Witness (\S\ref{sec:type_witness})



\subsubsection{Plural Variable}\label{sec:plural_variable}
\cite{laycock10}

A \emph{Plural Variable} may be distinguished in cases where an
Irreducably Plural Predicate is required.



\subsubsection{Skolemisation}\label{sec:skolemisation}

\emph{Skolemisation} is the removal of an Existential Quantifier that
appears after a Universal Quantifier, $\forall x \exists y : P (x,y)$,
by introducing a new Function Symbol, $f$:
\[
  \forall x : P (x, f(x))
\]
that produces a Witness (\S\ref{sec:witness}) depending on $x$.



\subsubsection{Metavariable}\label{sec:metavariable}

A \emph{Metavariable} is a Variable written in a Metalanguage that
stands in for an Element in the Object Language. The Formalization of
Metavariables falls under \emph{Type Theory} (Part
\ref{part:type_theory}).

Metavariables may be referred to as \emph{Schematic Variables} in the
context of Axiom Schemata (\S\ref{sec:axiom_schema}) and Rule Schemata
(\S\ref{sec:rule_schema}). A Schematic Variable ranges over all
Propositions (\S\ref{sec:proposition}).



% --------------------------------------------------------------------
\subsection{Term}\label{sec:term}
% --------------------------------------------------------------------

A \emph{Term} represents an object of the Domain (\S\ref{sec:domain}).

A Term denotes a Mathematical Object, a Formula denotes a Mathematical
Fact.

Terms can be defined Inductively from Constants, Variables, and
Functions. Given Terms, $T$, Variables, $V$, n-ary Functions, $F = F_0
\cup F_1 \cup F_2 \cup \cdots \cup F_n$, Constants, $C = F_0$:
\[
  V \subseteq T
\]\[
  C \subseteq T
\]\[
  \forall \tau_n=\{t_1,\cdots,t_n\} \in \pow(T), \forall f
  \in F_n \exists f(t_1,\cdots,t_n) \in T
\]



\subsubsection{Ground Term}\label{sec:ground_term}

If no Free Variables appear in a Term it is called a \emph{Ground
  Term} (or \emph{Closed Term}).



\subsubsection{Linear Term}\label{sec:linear_term}

A \emph{Linear Term} is a Term where no Variable occurs more than
once.



\subsubsection{Singular Term}\label{sec:singular_term}
\cite{chalmers02}

A \emph{Singular Term} has as its Extension (\S\ref{sec:extension}) an
Individual (\S\ref{sec:urelement})



\subsubsection{General Term}\label{sec:general_term}
\cite{chalmers02}

A \emph{General Term} has as its Extension (\S\ref{sec:extension}) a
Class (\S\ref{sec:class})



\subsubsection{Kind Term}\label{sec:kind_term}
\cite{chalmers02}

A \emph{Kind Term} has as its Extension (\S\ref{sec:extension}) a
particular Kind (\S\ref{sec:kind})




% --------------------------------------------------------------------
\subsection{Formula}\label{sec:formula}
% --------------------------------------------------------------------

Expressions (\S\ref{sec:expression}) belonging to the underlying Language of a
Logical System are called ``\emph{Well-formed Formulas}'' (\emph{WFFs}) or just
\emph{Formulas}.

A Term (\S\ref{sec:term}) denotes a Mathematical Object, a Formula
denotes a Mathematical Fact.

The Syntax (\S\ref{sec:formal_grammar}) of a Formula is defined by the
Symbols and \emph{Formation Rules} for a particular kind of Logic. A
Formula containing no Logical Connectives is called an \emph{Atomic
  Formula} (\S\ref{sec:atomic_formula}). A Formula composed of Atomic
Formulas combined with Logical Connectives is a \emph{Compound
  Formula} (\S\ref{sec:compound_formula}).

As a Syntactic Object, a Formula is given Semantic Meaning
(\S\ref{sec:meaning}) by an Interpretation
(\S\ref{sec:interpretation}), which usually Interprets the Formula as
a Proposition (\S\ref{sec:proposition}). A Formula that is True under
some Interpretation is called \emph{Satisfiable}
(\S\ref{sec:satisfaction}). A Formula that is True under all
Interpretations is called \emph{Valid} (\S\ref{sec:validity}).



\subsubsection{Atomic Formula}\label{sec:atomic_formula}

An \emph{Atomic Formula} (or \emph{Atom}) is a Formula with no Logical
Constants (Connectives or Quantifiers).

Atomic Formulas can be defined Inductively by Formation Rules on Terms
and Predicates. Given Terms, $T = \{t_0,\ldots,t_n\}$, and Predicates,
$P = \{r_0,\ldots,r_m\}$:
\begin{itemize}
  \item $t_i = t_j$ is a Formula
  \item $r_k(t_0,\ldots,t_n)$ is a Formula and $r_k$ is an n-ary
    Predicate
\end{itemize}
If no Free Variables occur in an Atomic Formula it is called a
\emph{Ground Atom}.



\paragraph{Literal}\label{sec:literal}\hfill

A \emph{Literal} is an Atomic Formula, $\phi$, or its Negation, $\neg
\phi$.



\subsubsection{Compound Formula}\label{sec:compound_formula}

A \emph{Compound Formula} is made up of one or more Literals
(\S\ref{sec:literal}) in combination with one or more Logical
Constants (\S\ref{sec:logical_constant}). The component Formulas that
make up a Compound Formula are called \emph{Subformulas} and all
Formulas are considered Subformulas of themselves. A Subformula that
is not the entire Formula is called a \emph{Proper Subformula}.



\subsubsection{Clause}\label{sec:clause}

A Finite Disjunction (\S\ref{sec:disjunction}) of Literals is called a
\emph{Clause}.



\paragraph{Horn Clause}\label{sec:horn_clause}\hfill

\emph{Horn Clause}

\fist Logic Programming (\S\ref{sec:logic_programming})



\subsubsection{Variant}\label{sec:variant}

A Formula is a \emph{Variant} of another Formula if the two Formulas
differ only in the choice of Variables. \emph{Variance} is an
Equivalence Relation on the Class of Formulas.



\subsubsection{Sentence}\label{sec:sentence}

A \emph{Sentence} (or \emph{Ground Formula}) is a Proposition with no
Free Variables.

\emph{Sentence Spectrum} (\S\ref{sec:sentence_spectrum}): the Set of Natural
Numbers occurring as the size of a Finite Model
(\S\ref{sec:finite_model}) in which a given Sentence is True



\paragraph{Statement}\label{sec:statement}\hfill

A \emph{Statement} is the Normal Form (\S\ref{sec:normal_form}) of a
Sentence, so that there may be more than one Sentence that makes the
same Statement.



% --------------------------------------------------------------------
\subsection{Substitution}\label{sec:substitution}
% --------------------------------------------------------------------

A \emph{Substitution} is the replacement of all occurences of a Free
Variable by a Term, which can be defined as a Total Mapping $\sigma: X
\rightarrow T$ from Variables $X$ to Terms $T$.

\emph{Syntactic Substitution}

The \emph{Application} of a Substitution $\sigma$ to a Term $t$ is
denoted $t\sigma$, or explicitly in postfix notation:
\[
  t(x_1 \ldots x_n)[s_1 \ldots s_n]
\]
where $x_1 \ldots x_n$ are the Free Variables of $t$, and $s_1 \ldots
s_n$ are the Terms $s_i$ to be Substituted for each $x_i$.

The result of Applying a Substitution, $t\sigma$, is called a
\emph{Substitution Instance} of $t$. The \emph{Domain} of a
Substitution $dom(\sigma)$ is the Set of Variables actually replaced:
\[
  \{ x \in X \;|\; x\sigma \neq x \}
\]
A Substitution $\sigma$ is a \emph{Ground Substitution} if all
Variables are Mapped to Ground Terms, and $t\sigma$ is a Ground Term
if all the Variables of $t$ are in $dom(\sigma)$.

\emph{Simultaneous Substitution}

Variable Capture (???)

Admissable Rule

Explicity Substitution


\textbf{Categorical Semantics} (\S\ref{sec:categorical_semantics})

(from nLab): %FIXME

Terms are Interpreted by Morphisms

Substitution of Term $t$ into Term $t'$ is Interpreted by Composition
of Morphisms: $t \circ t'$

Propositions are Interpreted by Subobjects (\S\ref{sec:subobject})

Substitution of Term $t$ into Proposition $P$ is Interpreted by
Pullback (\S\ref{sec:pullback}) or Inverse Image
(\S\ref{sec:preimage}) of the Subobject Interpreting $P$ along the
Morphism Interpreting $t$

Dependent Types are Interpreted by Display Maps
(\S\ref{sec:display_map})

Substitution of Term $t$ into Dependent Type $B$ is Interpreted by
Pullback of the Display Map Interpreting $B$ along the Morphism
Interpreting $t$

\emph{or} (note there may be an issue of Associativity here: from nLab)
%FIXME

Dependent Types are Interpreted by Classifying Morphisms
(\S\ref{sec:classifying_morphism}) into a Type of Types (Type Universe
\S\ref{sec:type_universe})

Substitution of Term $t$ into Dependent Type $B$ is Interpreted by
Composition of the Classifying Morphism Interpreting $B$ with the
Morphism Interpreting $t$



% ====================================================================
\section{Propositional Logic}\label{sec:propositional_logic}
% ====================================================================

\emph{Propositional Logic} (or \emph{Sentential} or \emph{Statement Logic})
studies the Truth-value of \emph{Propositional Formulas}
(\S\ref{sec:propositional_formula}) built up from Atomic Formulas
(\S\ref{sec:atomic_formula}) and Logical Connectives
(\S\ref{sec:logical_connective}).

The Language of Propositional Logic therefore consists of \emph{Propositional
  Variables} (or \emph{Sentential Variables}), and a Functionally Complete set
of Logical Connectives. A Propositional Variable that has been given a Truth
Valuation (\S\ref{sec:valuation}) by a Truth Assignment
(\S\ref{sec:interpretation}) is sometimes called a \emph{Propositional
  Constant}. Propositional Variables act as the Atomic Formulas of Propositional
Logic.

A Propositional Formula is equivalent to a Boolean Term
(\S\ref{sec:boolean_algebra}). The Formal System for Propositional Logic is
Propositional Calculus (\S\ref{sec:propositional_calculus}). The Semantics for
Propositional Logic is provided by Truth-tables (\S\ref{sec:truth_table}).

Boolean Algebras are to Set Theory (Part \ref{part:set_theory}) and ordinary
Propositional Logic what Interior Algebras (\S\ref{sec:interior_algebra}) are to
Topology (Part \S\ref{part:topology}) and Modal $\mathsf{S4}$ Logic
(\S\ref{sec:modal_logic}).

A Signature (\S\ref{sec:signature}) for Propositional Logic consists
only of Nullary Predicate Symbols for each Propositional Variable, and
a Model (\S\ref{sec:model}) provides a Truth Valuation for each.

In Propositional Logic, the Extra-logical Symbol for Entailment, $\vdash$, and
the Material Implication Operator, $\rightarrow$, coincide in that:
\[
  (A \vdash B) \Leftrightarrow (\vdash A \rightarrow B)
\]
but the difference is that $\vdash$ describes a Deduction, that is a Relation
between Sentences, and $\rightarrow$ is a Logical Connective within a Formula.

Propositional Calculus is Isomorphic to Simply-typed $\lambda$-calculus
(\S\ref{sec:simply_typed}) and is Strongly Normalizing
(\S\ref{sec:normalization}) to either a Conjunctive Normal Form
(\S\ref{sec:conjunctive_form}) or Disjunctive Normal Form
(\S\ref{sec:disjunctive_form}), and thus is not a Turing Complete system.

Formal definition of a System of Propositional Calculus $\mathcal{S}$:
\[
    \mathcal{S} = (\sigma, \Omega, A, I)
\]
where:
\begin{itemize}
  \item $\sigma$ is the Signature (\S\ref{sec:signature}) for a Propositional
    Calculus consisting of a Finite Set $R = \{P_1, P_2, P_3, \ldots\}$ of
    Nullary Predicate Symbols which are the Propositional Variables of
    $\mathcal{S}$: $\sigma = (R)$
  \item $\Omega$ is a Finite, Functionally Complete Set of Logical Connective
    Symbols $\{\neg$, $\wedge$, $\vee$, $\ldots\}$
  \item $A$ is a Finite Set of Axioms (Formulas in the Language defined by the
    Formation Rules over the Signature $\sigma$ and the Logical Operators
    $\Omega$)
  \item $I$ is a Finite Set of Inference Rules
\end{itemize}
Atomic Formulas of $\mathcal{S}$ are just the Propositional Variables
$P_1, P_2, P_3, \ldots$, which means that a Literal in $\mathcal{S}$
is just a Propositional Variable or its Negation.

The Formulas of $\mathcal{S}$ are then Inductively defined as the smallest
Class, $\mathcal{L}$, such that:
\begin{enumerate}
  \item Any Literal of $\mathcal{S}$ is a Formula in $\mathcal{L}$
  \item For Formulas $\phi_1, \phi_2, \cdots, \phi_n$ and an $n$-ary
    Logical Operator $f \in \mathbf{\Omega}_n$ where $\mathbf{\Omega}_n$
    is the Partition of $\mathbf{\Omega}$ containing all $n$-ary Logical
    Operators, then $f(\phi_1, \phi_2, \cdots, \phi_n)$ is also a
    Formula in $\mathcal{L}$
\end{enumerate}
Propositional Logic is closed under Truth-Functional Operators, so the
above Formation Rules define all Formulas: nothing else is a Formula
of $\mathcal{S}$.

Formulas Derived by the Axioms and Inference Rules of a Propositional
Logic are Theorems (\S\ref{sec:theorem}) in that System. Allowing for
Axiom Schemata (an Infinite number of Axioms) extends Propositional
Logic; an example of such a System is Skolem Arithmetic
(\S\ref{sec:skolem_arithmetic}).

Inference Rules of a Propositional Logic define Valid Argument Forms
(\S\ref{sec:logical_form}). The simplest Argument Form that is both
necessary and given a complete set of Axioms is sufficient to define
all other Argument Forms is \emph{Modus Ponens}, shown here
Schematicized:

$\textrm{1. }\varphi \rightarrow \psi$

$\textrm{2. }\varphi$

$\therefore\textrm{ }\psi$ \\
where lines one and two are Premises and line three is the Conclusion
(the symbol $\therefore$ is read as \emph{therefore}). This is written
in Sequent Notation (\S\ref{sec:sequent}) as:
\[
  (\varphi \rightarrow \psi), \varphi \vdash \psi
\]
The Schematic representation of \emph{Modus Tollens}:

$\textrm{1. }\varphi \rightarrow \psi$

$\textrm{2. }\neg\psi$

$\therefore\textrm{ }\neg\varphi$\\



% --------------------------------------------------------------------
\subsection{Propositional Formula}\label{sec:propositional_formula}
% --------------------------------------------------------------------

A \emph{Propositional Formula} is a Formula that is assigned a Truth-value
(\S\ref{sec:truth_value}), i.e. it is a Truth-bearer (\S\ref{sec:truth_bearer}).
An \emph{Atomic Proposition} (\S\ref{sec:atomic_formula}) contains no Logical
Connectives. A \emph{Compound Proposition} is composed by Recursive application
of Logical Connectives to Propositions by a corresponding \emph{Concatenation
  Rule} that assigns a new Truth-value to the Compound Proposition. A
Proposition with no Free Variables is called a \emph{Sentence}
(\S\ref{sec:sentence}).

A Valuation (\S\ref{sec:valuation}) is an Interpretation
(\S\ref{sec:interpretation}) that gives a Proposition a particular Truth-value.
A Propositional Formula is Satisfiable (\S\ref{sec:satisfaction}) if it is True
under at least one Interpretation.



\subsubsection{Tautology}\label{sec:tautology}

A Propositional Formula that is \emph{Valid} (\S\ref{sec:validity}) is
one that is True under every possible Interpretation
(\S\ref{sec:interpretation}) and is called a \emph{Tautology}.

The Set of Tautologies over a Countable Alphabet is a Decidable Set
(\S\ref{sec:decidable_set}).



% --------------------------------------------------------------------
\subsection{Conjunctive Normal Form}\label{sec:conjunctive_form}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Disjunctive Normal Form}\label{sec:disjunctive_form}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Second-order Propositional Logic}
\label{sec:secondorder_propositional_logic}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Multi-valued Logic}\label{sec:multi_valued_logic}
% --------------------------------------------------------------------

\subsubsection{Fuzzy Logic}\label{sec:fuzzy_logic}

the Real Unit Interval $[0,1]$ interpreted as a generalization of the Boolean
Domain $\{0, 1\}$

Possibility Theory (\S\ref{sec:possibility_theory}) -- alternative to
Probability Theory (Part \ref{sec:probability_theory}) for dealing with certain
types of Uncertainty



\paragraph{T-norm Fuzzy Logic}\label{sec:tnorm_logic}\hfill

\subparagraph{Basic Logic}\label{sec:basic_logic}\hfill



\paragraph{Lukasiewicz Logic}\label{sec:lukasiewicz_logic}\hfill



\subsubsection{Probabilistic Logic}\label{sec:probabilistic_logic}

uses Probability Theory (Part \ref{sec:probability_theory}) to handle
Uncertainty (\S\ref{sec:uncertainty}) in Deductive Logic

cf. Probability Axioms (Kolmogorov Axioms \S\ref{sec:probability_axioms})

2011 - \emph{Interpretations of Probability} -
\url{https://plato.stanford.edu/entries/probability-interpret/}

some interpretations of 'Probability' fail to Satisfy the Probability Axioms,
while some quantities that are not conceptually related to 'Probability' do
Satisfy the Axioms, e.g. Normalized Mass, length, Area, Volume, etc. in Measure
Theory (Part \ref{sec:measure_theory})

\emph{Logical Probability} (or \emph{Non-deductive Logic}) generalizes the
Classical Interpretation of Probability to assigning unequal weights to
possibilities, and Probabilities may be computed from asymmetric evidence;
generalizes Deductive Logic and its notion of Implication to a complete theory
of Inference with a notion of ``\emph{Degree of Implication}'' that relates
Evidence to Hypotheses-- Deductive Logic is the case where the Confirmation
Function takes values 1 and 0

Carnap

$^*$ choice of Language and Confirmation Function are in a sense arbitrary

cf. \emph{Subjective Probability} (Subjective Bayesianism), Doxastic Logic
(\S\ref{sec:doxastic_logic}) -- Probability as a \emph{degree of belief}

2013 - \emph{Logic and Probability} -
\url{https://plato.stanford.edu/entries/logic-probability/} (Stanford
Encyclopedia of Philosophy)

cf. \emph{Inductive Logic} (\S\ref{sec:inductive_inference}) -- extension of
Deductive Logic (\S\ref{sec:deductive_inference}) to less-than-certain
Inferences; makes extensive use of Probabilistic notions; most work on Inductive
Logic falls under the ``Probability Preservation'' approach

\emph{Probabilistic Semantics} (\S\ref{sec:probabilistic_semantics}) for
Classical Languages: Probabilistic Consequence Relation yields \emph{Probability
  Preserving} (dually, \emph{Uncertainty Propagating}) Deductive Validity rather
than Truth Preserving (\S\ref{sec:truth_preservation}); the Premises of a Valid
Argument can be Uncertain as well as the Conclusion

Probabilistic Operators

Modal Probabilistic Operators



\paragraph{Probabilistic Inference}\label{sec:probabilistic_inference}\hfill

Inferential Statistics (\S\ref{sec:inferential_statistics})



\subsubsection{Quantum Logic}\label{sec:quantum_logic})

1936 - Birkhoff, von Neumann - \emph{The Logic of Quantum Mechanics}

(wiki): can be formulated as modified Propositional Logic or Non-commutative,
Non-associative Many-valued Logic

\fist Quantum Information Theory (\S\ref{sec:quantum_information_theory})

\fist Quantum Systems (\S\ref{sec:quantum_system})

2002 - \emph{Quantum Logic and Probability Theory} -
\url{https://plato.stanford.edu/entries/qt-quantlog/}



% ====================================================================
\section{Zeroth-order Logic}\label{sec:zerothorder_logic}
% ====================================================================

%FIXME

Language:

Propositional Variables (Predicates of Arity 0)

Predicates of Arity >= 1

Constants (Functions of Arity 0)

Functions of Arity >= 1

Logical Connectives

Grouping Symbols (parentheses, etc.)



% ====================================================================
\section{Predicate Logic}\label{sec:predicate_logic}
% ====================================================================

\emph{Predicate Logic} (or \emph{Predicate Calculus}) describes Logical Systems
with Formulas containing Variables (\S\ref{sec:variable}) that can be Quantified
(\S\ref{sec:quantifier}). This includes Systems of First-order Logic
(\S\ref{sec:firstorder_logic}), Second-order Logic
(\S\ref{sec:secondorder_logic}), Higher-order Logic
(\S\ref{sec:higherorder_logic}), Many-sorted Logic
(\S\ref{sec:manysorted_logic}), and Infinitary Logic
(\S\ref{sec:infinitary_logic}). This is in contrast to Logical Systems without
Variables or Quantifiers such as Propositional Logic
(\S\ref{sec:propositional_logic}) and Zeroth-order Logic
(\S\ref{sec:zerothorder_logic}).

Logic with Quantification corresponds to Dependent Type Theory
(\S\ref{sec:dependent_type}) by Curry-Howard Isomorphism
(\S\ref{sec:curry_howard})



% --------------------------------------------------------------------
\subsection{First-order Logic}\label{sec:firstorder_logic}
% --------------------------------------------------------------------

\emph{First-order Logic} (or \emph{Lower Predicate Logic}) allows
Quantification over individual Objects in the Domain of Discourse
(\S\ref{sec:domain}). This is in contrast to Systems of Predicate
Logic that allow Plural Quantification (Quantification over Sets
\S\ref{sec:plural_quantification}), such as Second-order Logic
(\S\ref{sec:secondorder_logic}) and Higher-order Logic
(\S\ref{sec:higherorder_logic}).

A System of First-order Logic, $\mathcal{S}$, is defined as:
\[
  \mathcal{S} = (\sigma,\Omega,V,A,I)
\]
where:
\begin{itemize}
  \item $\sigma$ is a Signature (\S\ref{sec:signature}) for First-order Logic
    consisting of a Finite Set $F = \{f_1, f_2, f_3, \ldots \}$ of Function
    Symbols and a Finite Set $P = \{ R_1, R_2, R_3, \ldots\}$ of Predicate
    Symbols, and $ar : F \cup P \rightarrow \mathbb{N}_0$ a Function Mapping
    Function and Predicate Symbols to their Arity:
    \[\sigma = (F,P,ar)\]
  \item $\Omega$ is a Finite, Functionally Complete Set of Logical Connective
    Symbols $\{\neg$, $\wedge$, $\vee$, $\ldots\}$
  \item $V$ is a Set of Variable Symbols:
    \[V = \{v_1, v_2, v_3, \ldots\}\]
  \item $A$ is a Finite Set of Axioms (Formulas in the Language
    defined by the Formation Rules over the Signature $\sigma$, the
    Logical Operators $\Omega$, and the Variable Symbols $V$)
  \item $I$ is a Finite Set of Inference Rules
\end{itemize}

The Formation Rules for Formulas in a System of First-order Logic
generally describe a Context-free Grammar (\S\ref{sec:context_free}).

Terms are limited to Variables and a Finite number of $n$-ary Function
applications, defined Inductively by:
\begin{enumerate}
  \item Every Variable is a Term
  \item For Terms $t_1, t_2, \ldots, t_n$ and $n$-ary Function Symbol
    $f$, then $f(t_1, t_2, \ldots, t_n)$ is a Term.
\end{enumerate}
Atomic Formulas are defined as:
\begin{enumerate}
  \item If $t_1$ and $t_2$ are Terms, and there is a Logical Operator
    for Equality\\$(=) \in \Omega$, then $t_1 = t_2$ is an Atomic
    Formula.
  \item If $R$ is an $n$-ary Predicate, and $t_1,\ldots,t_n$ are
    terms, then $R(t_1,\ldots,t_n)$ is an Atomic Formula.
\end{enumerate}
The Class $\mathcal{L}$ of Formulas is defined Inductively by the
Formation Rules:
\begin{enumerate}
  \item All Atomic Formulas are Formulas in $\mathcal{L}$
  \item If $\phi \in \mathcal{L}$ then $\neg \phi \in \mathcal{L}$
  \item If $\phi_1, \phi_2, \dots, \phi_n$ are Formulas in
    $\mathcal{L}$, and $f \in \Omega_n$ is an $n$-ary Logical Operator,
    then $f (\phi_1, \phi_2, \ldots, \phi_n) \in \mathcal{L}$
  \item If $x \in V$ and $\phi \in \mathcal{L}$, then $\exists x \phi
    \in \mathcal{L}$ and $\forall x \phi \in \mathcal{L}$
\end{enumerate}
A First-order Formula that is a Substitution Instance
(\S\ref{sec:substitution}) of a Tautological Propositional Formula
(\S\ref{sec:tautology}) is a \emph{First-order Tautology}.

Certain Equivalences for First-order Logical Systems fail to hold if
Empty Domains (\S\ref{sec:domain}) are allowed and Function Symbols
are always Interpreted (\S\ref{sec:interpretation_function}) with
assignment of Well-defined (\S\ref{sec:well_defined}) Total Functions
to the Symbols.

First-order Logic may be used as the System of Logic for Deductive
Systems with Finite Domains that are Sound (\S\ref{sec:soundness}) and
Complete (\S\ref{sec:completeness}), but for Domains of Infinite
Cardinality a System of Higher-order Logic is required. First-order
Logic is Semi-decidable (\S\ref{sec:semidecidable}), that is the
Consequence Relation for two Formulas of First-order Logic, $\phi
\vdash \psi$, is Recursively Enumerable. Satisfiability
(\S\ref{sec:satisfiability}) and Validity (\S\ref{sec:validity}) of
arbitrary First-order Formulas are Undecidable.

The L\"owenheim-Skolem Theorem (\S\ref{sec:lowenheim_skolem}) implies
that First-order Logic is unable to characterize the concept of
Countability or Uncountability \S\ref{sec:cardinality}).

The Compactness Theorem (\S\ref{sec:compactness}) implies that
if a Formula is derived from a System of First-order Logic with an
Infinite Set of Axioms, then it can be derived from a Finite Subset of
those Axioms. This has implications for the determination of Connected
Components of a Directed Graph (\S\ref{sec:directed_graph}).

An Interpretation of First-order Logic can be given in any Topos
(\S\ref{sec:topos}).

\fist A Topos can be understood as a Cartesian Closed Category
(\S\ref{sec:cartesian_category}) with a ``natural categorical abstraction'' of
the notions of Subalgebra of any Algebraic Structure
(\S\ref{sec:algebraic_structure}), as an Elementary
(\S\ref{sec:elementary_logic}) or First-order (\S\ref{sec:firstorder_logic})
definition of \emph{Subobject} of an Object-- Subobject Classifier
(\S\ref{sec:subobject_classifier}).
Note this notion is definable in any Category, not just Topoi, using
\emph{Second-order} (\S\ref{sec:secondorder_logic}) definitions.

Frame Problem %FIXME



\subsubsection{First-order Theory}\label{sec:firstorder_theory}

Tarski-Seidenberg Theorem (\S\ref{sec:tarski_seidenberg}): the First-order
Theory of the Real Field is Decidable



\subsubsection{Universal Generalization}\label{sec:universal_generalization}

\emph{Universal Generalization} is an Inference Rule:
\[
  P(x) \vdash \forall x P(x)
\]



\subsubsection{First-order Logic with Equality}
\label{sec:firstorder_equality}

Including a primitive Logical Symbol for Equality, $=$, Interpreted as
the real Equality Relation between members of the Domain such that
``two'' given Elements are the same Element adds the following Axioms:

\begin{enumerate}
\item \textbf{Reflexivity}: $\forall x, x=x$
\item \textbf{Substitution for functions}: given a function, $f$,
  $\forall x \forall y, x = y \rightarrow f(\ldots,x,\ldots) =
  f(\ldots,y,\ldots)$
\item \textbf{Substitution for formulas (Leibniz's Law)}: given a
  Formula $\varphi$ with Free occurrences of $x$, and $\varphi '$ with
  Free occurrences of $y$, $\forall x \forall y, x = y \rightarrow
  (\varphi \rightarrow \varphi ')$
\end{enumerate}

Defining a theory with a Binary Relation $A(x,y)$ that satisfies
Reflexivity and Leibniz's law is sufficient to derive any other
equality Theorems.

First-order Logic with Equality is Algebraeized as Cylindric Algebra
(\S\ref{sec:cylindric_algebra}).



\subsubsection{First-order Logic without Equality}
\label{sec:firstorder_no_equality}

An alternative convention to First-order Logic with Equality
(\S\ref{sec:firstorder_equality}) is to consider the Equality Relation
to be a Non-logical Symbol of the Signiature of a particular Logical
System. This allows two distinct individuals to be considered equal by
an arbitraray Equivalence Relation. If this convention is used, but no
distinct individuals (\S\ref{sec:discernibility}), $a$ and $b$ satisfy
$a=b$ then the Interpretation is termed a \emph{Normal Model} (that is
equivalent to a First-order Logic with Equality). In such a case the
Axioms related to Equality automatically hold and don't need to be
included explicitly.

First-order Logic without Equality is Algebraized as a Polyadic
Algebra (\S\ref{sec:polyadic_algebra}).



\subsubsection{Equational Logic}\label{sec:equational_logic}

\emph{Equational Logic} is First-order Logic without Quantifiers.

Universal Algebra (\S\ref{sec:universal_algebra})

Algebraic Theory (\S\ref{sec:algebraic_theory})

Equational Reasoning (\S\ref{sec:equational_reasoning})



\paragraph{Equation}\label{sec:equation}\hfill

%FIXME possibly move

``Equations are summaries of reversible processes, a purely Algebraic concept of
space emerges in which reversible processes can be treated as \emph{Paths}
(Algebraic Topology \S\ref{sec:algebraic_topology})''
(John Baez)

Categorical Semantics is given by Pullbacks (\S\ref{sec:pullback})

\begin{itemize}
  \item Polynomial Equations (\S\ref{sec:polynomial_equation})
  \begin{itemize}
    \item Diophantine Equations (\S\ref{sec:diophantine_equations})
    \item Linear Equations (\S\ref{sec:linear_equation})
  \end{itemize}
  \item Differential Equations (\S\ref{sec:differential_equation}) -- Equations
    involving one or more Functions and their Derivatives; Solved by finding an
    Expression of the Unknown Function that does not involve Derivatives
  \item Parametric Equations (\S\ref{sec:parametric_equation})
  \item System of Equations (\S\ref{sec:equation_system})
\end{itemize}



\paragraph{Equational Theory}\label{sec:equational_theory}\hfill

Algebraic Theory (\S\ref{sec:algebraic_theory})

An Effect Theory (\S\ref{sec:effect_theory}) gives rise to a standard
(possibly Infinitary) Equational Theory. \cite{plotkin-pretnar09}

Lawvere63: an Equational Theory is a Presentation (\S\ref{sec:presentation}) of
a Category with Finite Products where all Objects are Powers of a single
Generating Object (i.e. a Lawvere Theory \S\ref{sec:lawvere_theory})



\paragraph{Unification}\label{sec:unification}\hfill

wiki:

$V$ -- Set of \emph{Variables}

$T$ -- Set of \emph{Terms} where $V \subseteq T$

$fv : T \rightarrow \pow(V)$ -- Mapping from Terms $t$ to the Set of
\emph{Free Variables} $fv(t) \subseteq V$ occurring in $t$

$\equiv \subseteq T \times T$ -- Equivalence Relation on $T$; for
Higher-order Unification, usually $t \equiv u$ if $t$ and $u$ are
$\alpha$-equivalent (\S\ref{sec:alpha_equivalence}). If only
Syntactically identical Terms are considered Equal (Syntactic
Unification \S\ref{sec:syntactic_unification}) then $\equiv$ is the
Free Theory (or \emph{Empty Theory} \S\ref{sec:empty_theory})


First-order Unification

Higher-order Unification

\fist ? See also Universal Algebra (\S\ref{sec:universal_algebra})



\subparagraph{Syntactic Unification}\label{sec:syntactic_unification}
\hfill

Empty Theory (\S\ref{sec:empty_theory})



\subsubsection{Monadic First-order Logic}\label{sec:monadic_firstorder}

\emph{Monadic First-order Logic} (or \emph{Monadic Predicate
  Calculus}) restricts First-order Logic to Unary Predicates and no
Function Symbols. This weaker form of First-order Logic is fully
Decidable.



\subsubsection{Many-sorted First-order Logic}
\label{sec:manysorted_logic}

\emph{Many-sorted First-order Logic} allows Variables to be Quantified
over different Domains, thus giving Variables different \emph{Sorts}
(\S\ref{sec:sort}). With Finitely many Sorts, Many-sorted First-order
Logic can be reduced to Single-sorted First-order Logic. This can be
accomplished by adding Unary Predicates to a First-order Logic that
Partition (\S\ref{sec:set_partition}) the Domain.

Many-sorted Signature (\S\ref{sec:manysorted_signature})



\paragraph{Nominal Logic}\label{sec:nominal_logic}\hfill
\emph{Nominal Logic}

Variable Binding

see also $\alpha$-conversion (\S\ref{sec:alpha_conversion})



\paragraph{Order-sorted Logic}\label{sec:order_sorted}\hfill

allows one Sort to be the Subsort of another Sort

Higher-order?



\subsubsection{Infinitary Logic}\label{sec:infinitary_logic}

\emph{Infinitary Logic} allows Formulas of Infinite length, through
either Conjunctons and Disjunctions, Infinite-arity Predicates and
Functions, or Quantification over Infinitely many Variables.



\paragraph{$\Omega$-logic}\label{sec:omega_logic}\hfill

\emph{$\Omega$-logic}



\subsubsection{Elementary Logic}\label{sec:elementary_logic}

\paragraph{Elementary Theory}\label{sec:elementary_theory}\hfill

Axioms using only Finitary First-order Logic %FIXME heyting category?

Weaker condition than Algebraic Theory (\S\ref{sec:algebraic_theory})

Elementary Sentence

Elementary Definition

Elementary Theory of the Reals gives the Real Closed Field
(\S\ref{sec:real_closed})

\begin{itemize}
  \item Tarki's Axioms for Euclidean Geometry (\S\ref{sec:euclidean_geometry})
\end{itemize}



\subsubsection{Horn Logic}\label{sec:horn_logic}

Finitary Disjunctions



\subsubsection{Regular Logic}\label{sec:regular_logic}

Internal Language: Regular Categories (\S\ref{sec:regular_category})



\paragraph{Regular Theory}\label{sec:regular_theory}\hfill

Axioms of form:

$\varphi \vdash_{\overline{x}} \psi$

$\wedge$, $\exists$



\subsubsection{Coherent Logic}\label{sec:coherent_logic}

Internal Language: Coherent Categories (\S\ref{sec:coherent_category})



\paragraph{Coherent Theory}\label{sec:coherent_theory}\hfill

Axioms of form:

$\varphi \vdash_{\overline{x}} \psi$

$\wedge$, $\exists$, $\vee$



\subsubsection{Geometric Logic}\label{sec:geometric_logic}

Internal Language: Geometric Categories
(\S\ref{sec:geometric_category})


youtube: Caramello - Introduction to categorical logic, classifying
toposes

Grothendieck Topos (\S\ref{sec:grothendieck_topos})

Geometric Formulas:

Finitary Conjunctions $\wedge$

Infinitary Disjunctions $\bigvee$

Existential Quantification $\exists$

Finite number of Free Variables



\paragraph{Geometric Theory}\label{sec:geometric_theory}\hfill

Axioms of the form:
\[
  \varphi \vdash_{\overline{x}} \psi
\]
where $\varphi$ and $\psi$ are Geometric Formulas and $\overline{x}$
is the Context (Free Variables) %FIXME

$\forall \overline{x} (\varphi \Rightarrow \psi)$



\subsubsection{Cartesian Logic}\label{sec:cartesian_logic}

Logic of Cartesian Categories (\S\ref{sec:cartesian_category})

``Finitely Complete''



\paragraph{Cartesian Theory}\label{sec:cartesian_theory}\hfill

Axioms of the form:

$\varphi \vdash_{\overline{x}} \psi$

$\wedge$

$\exists$ -- Provably Unique in the Theory

any Syntactic Category (\S\ref{sec:syntactic_category}) of a Cartesian
Theory is a Cartesian Category (\S\ref{sec:cartesian_category})



% --------------------------------------------------------------------
\subsection{Second-order Logic}\label{sec:secondorder_logic}
% --------------------------------------------------------------------

\emph{Second-order Logic} allows for Quantifiers to range over
Predicates and Functions and thus \emph{Sorts} of Variables that range
over $k$-ary Predicates and Functions. It is possible to leave out a
definition of Quantifiers for Functions since $k$-ary Functions can be
represented by $k+1$-ary Predicates.\cite{shapiro00} Quantification
over Functions allows the creation of the Analytic Hierarchy
(\S\ref{sec:analytic_hierarchy}).

Because the Powerset Operation (\S\ref{sec:powerset}) is Definable in
Second-order Logic, Second-order Logic can simulate Higher-order
Logics (\S\ref{sec:higherorder_logic}).

Quantification over Propositional Variables in Second-order Logic
corresponds to Type Abstraction in Second-order $\lambda$-calculus
(\S\ref{sec:system_f}).



\subsubsection{Principal of Bivalence}\label{sec:bivalence_principal}

\subsubsection{Monadic Second-order Logic}\label{sec:monadic_secondorder}

\paragraph{Plural Monadic Second-order Logic}\hfill
\label{sec:plural_monadic_secondorder}\hfill \\

An alternative formulation of Second-order Logic is to allow Variables
to take on \emph{Plural} Values. It is equi-interpretable with
\emph{Monadic Second-order Logic}, which restricts Quantification to
Unary Predicates (Sets).



\subsubsection{Existential Second-order Logic}
\label{sec:existential_secondorder}

\paragraph{Independence-friendly\hfill
  Logic}\label{sec:independence_logic}\hfill \\

\emph{Independence-friendly Logic} has \emph{Branching Quantifiers}.



% --------------------------------------------------------------------
\subsection{Higher-order Logic}\label{sec:higherorder_logic}
% --------------------------------------------------------------------

\emph{Higher-order Logic} is the Union of First-, Second-, Third-,
$\ldots$ order Logic and allows Quantification over arbitrarily deep
nested Sets.

\textbf{Standard Semantics} (Full Semantics): Quantifiers range over all
possible Objects of a given Type

\textbf{Henkin Semantics}: Each Higher-order Type has its own Domain,
equivalent to Many-sorted First-order Logic
(\S\ref{sec:manysorted_logic})

Stronger than First-order Logic, e.g. admits Categorical
Axiomatization (\S\ref{sec:categoricity}) of the Natural Numbers or
the Real Numbers

Can be simulated in Second-order Logic (\S\ref{sec:secondorder_logic})
through use of the Powerset Operation as it is Definable in
Second-order Logic

Unifiability (\S\ref{sec:unification}) is Undecidable for
Type-theoretic (\S\ref{sec:intuitionistic_type}) Third-order Logic.



% ====================================================================
\section{Intensional Logic}\label{sec:intensional_logic}
% ====================================================================

\emph{Intensional Logic} adds to First-order Logic \emph{Sentential
  Functors} (\emph{Intensions}) that range over Terms. An Intension is
the \emph{Sense} in which a Logical Assertion is made, as opposed to
the \emph{Reference} to which the Assertion applies (i.e. Extensional
Quantification).



% --------------------------------------------------------------------
\subsection{Modal Logic}\label{sec:modal_logic}
% --------------------------------------------------------------------

\emph{Modal Logic} extends Propositional and Predicate Logic to
include Operators expressing \emph{Modality}. Various meanings for
these Modal Operators include Alethic Modality
(\S\ref{sec:alethic_logic} Necessity and Possibility), Temporal
Modality (\S\ref{sec:temporal_logic} qualification in terms of time,
e.g. Always, Eventually, Until), Deontic Modality
(\S\ref{sec:deontic_logic} Obligation and Permission), and Doxastic
Modality (\S\ref{sec:doxastic_logic} Belief).

\fist Modal $\mu$-calculus (Fixed-point Logic \S\ref{sec:modal_mu_logic})

Modal Logic can be seen as a restriction on the allowed Proofs in a
Standard ``Structural'' Logic by placing restrictions on the
\emph{positions} in which certain Variables can be used, usually
enforced by a specific ``context structure'' (e.g. Trees, Lists,
Multisets, Sets, Dual zones, etc.) that Products, Implications, and
Modalities manipulate
%TODO explain

Modal Algebras (\S\ref{sec:modal_algebra}) provides Models (\S\ref{sec:model})
of Propositional Modal Logic in the same way that Boolean Algebras
(\S\ref{sec:boolean_algebra}) are Models of Classical Logic
(\S\ref{sec:classical_logic})

Interior (Modal) Algebras (\S\ref{sec:interior_algebra}) are to Topology (Part
\S\ref{part:topology}) and Modal $\mathsf{S4}$ Logic what Boolean Algebras
(\S\ref{sec:boolean_algebra}) are to Set Theory (Part \ref{part:set_theory}) and
ordinary Propositional Logic (\S\ref{sec:propositional_logic})

the Variety (\S\ref{sec:variety}) of all Modal Algebras is the equivalent
Algebraic Semantics (\S\ref{sec:algebraic_semantics}) of the Normal Modal Logic
$\mathrm{K}$ (\S\ref{sec:normal_modal}), in the sense of Abstract Algebraic
Logic (\S\ref{sec:abstract_algebraic_logic}), and the Lattice
(\S\ref{sec:lattice}) if its Subvarieties is ``Dually Isomorphic'' (FIXME:
clarify) to the Lattice of Normal Modal $\mathrm{K}$ Logics

Modal Logic describes Monads (\S\ref{sec:monad}) and Comonads
(\S\ref{sec:comonad}) in Category Theory; cf. Substructural Logics
(\S\ref{sec:substructural_logic}) as Internal Languages
(\S\ref{sec:internal_logic}) of various Monoidal Categories
(\S\ref{sec:monoidal_category})

$\lozenge, \bigcirc$ -- \emph{Modal Possibility}: Monads

$\square$ -- \emph{Modal Necessity}: Comonad

1991 - Milner,Parrow,Walker - \emph{Modal Logics for Mobile Processes} \fist
$\pi$-calculus (\S\ref{sec:pi_calculus})

\asterism

An unary \emph{Primitive Modal Operator}, $\square$, defines a Dual
Operator, $\Diamond$, such that the following analogues of de Morgan's
Laws (\S\ref{sec:de_morgan}) hold:
\[
  \Diamond P \leftrightarrow \neg \square \neg P
\]
\[
  \square P \leftrightarrow \neg \Diamond \neg P
\]
By the Curry-Howard Correspondence (\S\ref{sec:curry_howard}), Modal
Logic corresponds to Monads (\S\ref{sec:monad}).

\asterism

2015 - Licata,Shulman - \emph{Adjoint Logic with a 2-Category of Modes} \fist
Adjoint Logic (\S\ref{sec:adjoint_logic})

Licata-Shulman-Riley17:

\fist Mode Theory (\S\ref{sec:mode_theory}) -- Modal Logics will generally
involve a Mode Theory with more than one Mode

\url{https://golem.ph.utexas.edu/category/2018/04/what_is_an_ntheory.html}

in a Syntactic $2$-theory with multiple Generating Types, the Objects of the
resulting Semantic $2$-category are \emph{Diagrams} of several Categories with
Functors and Natural Transformations between them, so the corresponding
Syntactic $1$-theories have several ``classes'' of Types (one for each
Category) called ``\emph{Modes}'', and Type Theory or Logic with multiple Modes
is called ``\emph{Modal}'', and Functors between the Categories are called
``\emph{Modalities}''

traditional Modal Logic involves ``Logical Modalities'' (e.g. $\square$
``Necessity'', and $\lozenge$ ``Possibility''), in Cohesive Homotopy Type
Theory (\S\ref{sec:cohesive_hott}) there are $\int$, $\flat$, $\sharp$
corresponding to the Monads and Comonads on a Cohesive Topos,
and in Crisp Type Theory (\S\ref{sec:crisp_type_theory}), a Type Theory for
Parameterized Spectra involving Self-adjoint Modality $\natural$, and a Type
Theory for ``Differential Cohesion'' involving six Modalities of $\int$,
$\flat$, $\sharp$, $\mathfrak{R}$, $\mathfrak{I}$, and $\&$



\subsubsection{Modality}\label{sec:modality}

``way of being True''

\emph{or}

``way of Being''

Truncated Types, $h$-level (???) %FIXME

Modal Type Theory (\S\ref{sec:modal_type_theory})

Adjoint Modality (\S\ref{sec:adjoint_modality})

2018 - Corfield - \emph{Modal Homotopy Type Theory} -- Modalities
(\S\ref{sec:modality}) as Monads (\S\ref{sec:monad}); Adjoint Triples
(\S\ref{sec:adjoint_triple})

Monad -- ``Some'', Possibly

Comonad -- ``Only'', Necessary

$\Diamond p(w) \rightarrow q(w) \Leftrightarrow p(w) \rightarrow \square q(w)$

``necessarily true, true, possibly true''

``everywhere, here, somewhere''



\subsubsection{Classical Modal Logic}\label{sec:classical_modal}

A \emph{Classical Modal Logic} has as an Axiom or Theorem the Duality
of the Modal Operators:
\[
  \Diamond A \equiv \neg \square \neg A
\]\[
  \square A \equiv \neg \Diamond \neg A
\]
and Closed under the Inference Rule (and its Dual):
\[
  A \equiv B \vdash \square A \equiv \square B
\]\[
  A \equiv B \vdash \Diamond A \equiv \Diamond B
\]
The weakest Classical Modal Logic System $\mathsf{E}$ is Non-normal
(\S\ref{sec:normal_modal}).



\paragraph{Regular Modal Logic}\label{sec:regular_modal}\hfill

A \emph{Regular Modal Logic} is Closed under:
\begin {itemize}

\item $\Diamond A \equiv \neg \square \neg A$

\item $(A \wedge B) \rightarrow C \vdash
  (\square A \wedge \square B) \rightarrow \square C$

\end {itemize}
Every Regular Modal Logic is Classical (\S\ref{sec:classical_modal})
and every Normal Modal Logic (\S\ref{sec:normal_modal}) is Regular.



\paragraph{Normal Modal Logic}\label{sec:normal_modal}\hfill

A Normal Modal Logic contains all Propositional Tautologies
(\S\ref{sec:tautology}) and all Instances of the Distribution Axiom
(or Kripke Schema):
\[
  \square (A \rightarrow B) \rightarrow
  (\square A \rightarrow \square B)
\]
and is Closed under:
\begin{itemize}
  \item Modus Ponens (\emph{Detachment Rule}): $A \rightarrow B$, $A
    \vdash B$
  \item Necessitation Rule: $\vdash A \Rightarrow \vdash \square A$
\end{itemize}
The Smallest Logic satisfying these conditions is called \emph{System
  $\mathsf{K}$}.

the Variety (\S\ref{sec:variety}) of all Modal Algebras
(\S\ref{sec:modal_algebra}) is the equivalent Algebraic Semantics
(\S\ref{sec:algebraic_semantics}) of the Normal Modal Logic $\mathrm{K}$, in the
sense of Abstract Algebraic Logic (\S\ref{sec:abstract_algebraic_logic}), and
the Lattice (\S\ref{sec:lattice}) if its Subvarieties is ``Dually Isomorphic''
(FIXME: clarify) to the Lattice of Normal Modal $\mathrm{K}$ Logics



\subsubsection{Quantified Modal Logic}\label{sec:quantified_modal}

\paragraph{Barcan Formula}\label{sec:barcan_formula}\hfill

Schema: ``\emph{If everything is Necessarily $F$, then it is Necessary that
  Everything is $F$}''

$\forall x \square Fx \rightarrow \square \forall x Fx$

is equivalent to:

$\Diamond \exists x Fx \rightarrow \square \exists x \Diamond Fx$

\emph{Actualism} -- ``there are no \emph{merely} Possible individuals'': in
terms of Possible World Semantics (\S\ref{sec:possible_world}), implies that all
objects which ``exist'' in any Possible World that is ``\emph{Accessible}'' to
the ``Actual World'', exist in the Actual World; cf. \emph{Possibilism} (there
are some entities that are \emph{merely possible})



\subsubsection{Multimodal Logic}\label{sec:multimodal_logic}

A Modal Logic with more than one Primitive Modal Operator is called a
\emph{Multimodal Logic}. A Multimodal Logic with exactly $n$ Primitive
Modal Operators is called an \emph{$n$-modal Logic} with $n > 1$ and
Operators $\square_i, i \in \{1, \ldots, n\}$.



\subsubsection{Alethic Logic}\label{sec:alethic_logic}

\emph{Alethic Logic}

Possible World Semantics (\S\ref{sec:possible_world})

Most Systems of Alethic Logic are based on an extension of
Propositional Logic called \emph{System $\mathsf{K}$} which is a
Normal Modal Logic (\S\ref{sec:normal_modal}) where:
\begin{enumerate}
\item $\square$, unary operator for \emph{Necessity}.
\item \emph{Necessitation Rule} $N$ : stating if $p$ is a
  Theorem, then $\square p$ is a Theorem.
\item \emph{Distribution Axiom} (or \emph{Kripke Schema}) $K$ :
  \[
    \square(p \rightarrow q) \rightarrow
    (\square p \rightarrow \square q)
  \]
\end{enumerate}
There are also further Axioms used to extend System $\mathsf{K}$:
\begin{itemize}
  \item \emph{Reflexivity Axiom} $T$ : $\square p \rightarrow p$
  \item $4$: $\square p \rightarrow \square \square p$
  \item $B$: $p \rightarrow \square \Diamond p$
  \item $D$: $\square p \rightarrow \Diamond p$
  \item $5$: $\Diamond p \rightarrow \square \Diamond p$
\end{itemize}
The Axioms correspond to various Frame Conditions
(\S\ref{sec:frame_semantics}) on the Accessibility Relation $R : W
\rightarrow W$ that specify Classes of Frames $\langle W,R \rangle$:
\begin{itemize}
  \item $K$: no Frame Conditions
  \item $T$: Reflexive ($wRw$)
  \item $4$: Transitive ($wRv \wedge vRu \Rightarrow wRu$)
  \item $4$: Dense ($wRu \Rightarrow \exists v (w R v \wedge v R u)$)
  \item $B$: Symmetric
  \item $D$: Serial
  \item $5$: Euclidean
  \item $GL$: $R$ Transitive, $R^{-1}$ Well-founded
  \item $Grz$: $R$ Reflexive and Transitive, $R^{-1} - Id$
    Well-founded
  \item $H$: $w R u \wedge w R v \Rightarrow u R v \vee v R u$
  \item $M$
  \item $G$: Convergent
\end{itemize}
Adding some of these Axioms to System $\mathsf{K}$ gives rise to a
nested hierarchy of Systems of Normal Modal Logic:
\begin{itemize}
  \item $\mathsf{K} := K + N$
  \item $\mathsf{T} := \mathsf{K} + T$
  \item $\mathsf{S4} := \mathsf{T} + 4$ (Staged Computation)
    \cite{wadler14} -- ($\mono{quote}$/$\mono{eval}$ -
    Pfenning-OPLSS17-lecture); Semantics given by \emph{Closure Algebras}
    (\S\ref{sec:closure_algebra})
  \item $\mathsf{S5} := \mathsf{S4} + 5$
    (Spatially Distributed Computation) \cite{wadler14} -- (Kripke
    Semantics ??? Pfenning17)
  \item $\mathsf{D} := \mathsf{K} + D$
\end{itemize}

Necessity:
\[
  \square p \equiv \neg \Diamond \neg p
\]
Possibility:
\[
  \Diamond p \equiv \neg \square \neg p
\]
Impossibility:
\[
  \neg \Diamond p \equiv \square \neg p
\]
Analyticity:
\[
  \square p \vee \square \neg p
  \equiv \neg (\Diamond p \wedge \Diamond \neg p)
\]
Contingency:
\[
  \Diamond p \wedge \Diamond \neg p
  \equiv \neg (\square p \vee \square \neg p)
\]



\subsubsection{Doxastic Logic}\label{sec:doxastic_logic}

\emph{Doxastic Logic} uses the unary Modal Operator, $\mathcal{B}$, to
denote \emph{Belief}. Example:
\[
  \mathcal{B} x
\]
has the meaning ``It is Believed that $x$ is the case''. A set of
Beliefs is usually denoted:
\[
  \mathbb{B}: \{ b_1, b_2, \ldots, b_n \}
\]

cf. \emph{Subjective Probability} (Subjective Bayesianism) -- Probability as a
\emph{degree of belief}



\subsubsection{Deontic Logic}\label{sec:deontic_logic}

\emph{Standard Deontic Logic} ($\mathbf{SDL}$) adds the following
Axioms to Propositional Logic (\S\ref{sec:propositional_logic}):
\[
  O(A \rightarrow B) \rightarrow (OA \rightarrow OB)
\]
\[
  PA \rightarrow \neg O \neg A
\]
with Primitive Operators $O$ (\emph{Obligatory}) and $P$
(\emph{Permissible}). \emph{Forbidden} is defined as:
\[
  FA = O \neg A
\]
or:
\[
  FA = \neg P A
\]
Deontic Logic may be extended by Alethic Operators with the Axiom:
\[
  OA \rightarrow \Diamond A
\]
which has the meaning ``ought implies can''.



\subsubsection{Temporal Logic}\label{sec:temporal_logic}

(Curry-Howard): Partial Evaluation (\S\ref{sec:partial_evaluation}),
Functional Reactive Programming (\S\ref{sec:frp}), Reactive Types
(\S\ref{sec:reactive_type})

may be Interpreted by Kripke Structures
(\S\ref{sec:kripke_structure})-- State Transition Systems
(\S\ref{sec:state_transition}) with a Labelling Function for States
(Nodes) mapping each Node to a Set of Properties that hold in that
State

\begin{itemize}
  \item Logical Operators (Logical Connectives
    \S\ref{sec:logical_connective})
  \item Modal Operators
\end{itemize}


Unary Operators:
\begin{itemize}
  \item $A\phi$ -- All
  \item $E\phi$ -- Exists
\end{itemize}

Unary Modal Operators:
\begin{itemize}
  \item $N\phi$, $\ocircle\phi$ -- Next
  \item $G\phi$, $\square\phi$ -- Globally
    (Signal Types? \S\ref{sec:signal_type}) %FIXME
  \item $F\phi$, $\lozenge\phi$ -- Future, Finally (Event
    \S\ref{sec:frp_event})
\end{itemize}

Binary Modal Operators:
\begin{itemize}
  \item $\phi \until \psi$ -- Until
  \item $\phi R \psi$ -- Release
  \item $\phi \since \psi$ -- Since
\end{itemize}

\fist Note simple Temporal Logics such as Basic Temporal Language
(\S\ref{sec:btl}) may have fewer or different Operators or some
Operators cannot be expressed.

Reflexive, Irreflexive Ordering


\asterism


Categorical Semantics (\S\ref{sec:categorical_semantics})

Category $\cat{C}$

Internal Category (\S\ref{sec:internal_category}) given by:
\[
  b,e : \cat{Time}_1 \rightrightarrows \cat{Time}_0
\]
where Elements of $\cat{Time}_1$ are Time Intervals with $b$ and $e$
marking Beginning and End points. Time may have additional Structure
(Poset \S\ref{sec:poset}, Linear Order \S\ref{sec:total_order})

Each Arrow $b,e$ Generates an Adjoint Triple:
\begin{align*}
  \Sigma_b \dashv b^* \dashv \Pi_b \\
  \Sigma_e \dashv e^* \dashv \Pi_e
\end{align*}
between Slices (\S\ref{sec:slice_category}) $\cat{C}/\cat{Time}_0$ and
$\cat{C}/\cat{Time}_1$ where $\Sigma$ is Dependent Sum
(\S\ref{sec:dependent_sum}), $-^*$ is Base Change
(\S\ref{sec:base_change}), and $\Pi$ is Dependent Product
(\S\ref{sec:dependent_product})

Adjunctions

$\Sigma_b e^* \dashv \Pi_e b^*$

$\Sigma_e b^* \dashv \Pi_b e^*$

Propositions $\phi, \psi$

$\Sigma_b e^* \phi$ -- ``there exists an Interval Beginning now such
that $\phi$ is True at its End'', i.e. $F \phi$

$\Pi_e b^* \psi$ -- ``for all Intervals Ending now, $\psi$ is True at
their Beginning'', i.e. $H \psi$

Therefore:
\begin{itemize}
  \item $F \dashv H$
  \item $P \dashv G$
\end{itemize}

$\phi S \psi := \Sigma_e (b^* \psi \times \Pi_c(ep)^*\phi)$ -- ``there
is a Subinterval Ending now such that $\psi$ was True at its Beginning
and $\phi$ was True at all Times inside it''

$\phi U \psi := \Sigma_b (e^* \psi \times \Pi_c(ep)^*\phi)$ --
``$\phi$ will be True until a Time when $\psi$ is True''

where $p,q$ are Projections for the $\cat{Time}$ Category:
\[
  p,q : \cat{Time}_1 \times_{\cat{Time}_0} \cat{Time}_1
    \rightarrow \cat{Time}_1
\]
and $c$ is Composition for the $\cat{Time}$ Category:
\[
  c : \cat{Time}_1 \times_{\cat{Time}_0} \cat{Time}_1
    \rightarrow \cat{Time}_1
\]
and $ep = bq$.

Instant-based, Interval-based (Interval Temporal Logic
\S\ref{sec:interval_temporal}) approaches -- (Corfield 2018): \emph{Time} as an
Internal Category (\S\ref{sec:internal_category}); \emph{Instantaneous events}
are represented by time intervals and should be distinguished from
\emph{instantaneous holding of fluents} [properties of states], which are
evaluated at time points. Formally, the point $a$ should be distinguished from
the interval $[a,a]$ and the truths in these should not necessarily imply each
other.'' (Balbiani et al. 2011);
as a consequence of taking \emph{Time} as an
Internal Category, the Future \emph{includes} the Present; cf. Time as a
Semicategory (FIXME: xref ???)

branching Time: CLT$^*$ (Computation Tree Logic \S\ref{sec:ctl_star})

Incipative, Terminative Events; Event Nucleus: Preparation (initiative),
Achievement (terminative), Transition (culminative)

Adjoint Logic (\S\ref{sec:adjoint_logic})



\paragraph{Basic Temporal Language (BTL)}\label{sec:btl}\hfill

Unary Modal Operators:
\begin{itemize}
  \item $F\phi$ -- Future: $\phi$ will be True at some Future Time
  \item $P\phi$ -- Past: $\phi$ was True at some Past Time
\end{itemize}

Duals of $F$ and $P$
\begin{itemize}
  \item $G\phi = \neg F \neg\phi$ -- Globally: at no Future Time is
    $\phi$ not True
  \item $H\phi = \neg P \neg\phi$ -- History: at no Past Time is
    $\phi$ not True
\end{itemize}

Frame (\S\ref{sec:kripke_frame}): Set $T$ with Binary Relations $R_F$
and $R_P$

$x R_F y$ -- ``at $x$, $y$ is in the Future''

$R_P$ is Converse (\S\ref{sec:converse}) to $R_F$

\emph{Bidirectional Frame} $(T,R,R^{op})$



\paragraph{Tense Logic}\label{sec:tense_logic}\hfill

\emph{Tense Logic} is a 2-modal Logic that adds operators $[F]$ for
\emph{Future} and $[P]$ for \emph{Past} Modalities.



\paragraph{Temporal Logic of Actions (TLA)}\label{sec:tla}\hfill

TLA+ -- formal specification language



\paragraph{CTL*}\label{sec:ctl_star}\hfill

Superset of \emph{Computation Tree Logic} and \emph{Linear Temporal Logic}

Branching-time

chip design and verification



\subparagraph{Computation Tree Logic}\label{sec:ctl}\hfill

Temporal Logic with \emph{Path} Modalities.

Branching-time

\fist Linear Temporal Logic can be encoded in Modal $\mu$-calculus
(Fixed-point Logic \S\ref{sec:modal_mu_logic})



\subparagraph{Linear Temporal Logic}\label{sec:linear_temporal}\hfill

\fist Linear Temporal Logic can be encoded in Modal $\mu$-calculus
(Fixed-point Logic \S\ref{sec:modal_mu_logic})

\cite{jeffrey12}:

\emph{Linear Temporal Logic} (LTL or \emph{Linear-time Temporal
  Logic}) is a Modal Logic with Modalities referring to \emph{Time}.

Propositions of LTL correspond to Reactive Types
(\S\ref{sec:reactive_type}) in Functional Reactive Programming
(\S\ref{sec:frp})

B\"uchi Automata \S\ref{sec:buchi_automaton}) give Automata-theoretic
versions of Formulas in Linear Temporal Logic

Modalities (\S\ref{sec:modality}) of LTL \emph{as} Combinators of
Reactive Types

Primitive Modalities:
\begin{itemize}
  \item $\ocircle \phi$ -- Next
  \item $\phi \until \psi$ -- Until
\end{itemize}

Derived Modalities:
\begin{itemize}
  \item $\lozenge \phi$ -- Future
  \item $\square \phi$ -- Globally: $\phi$ True at all Future Times
  \item $\phi \underline{\until} \psi$ -- Non-strict Until
  \item $\phi \rhd \psi$ -- Constrains
  \item $\phi \unrhd \psi$ -- Non-strict Constrains
  \item $\phi \rightsquigarrow \psi$ -- Choice: Constructively defines
    a Choice Function, Classically collapses to $\Rightarrow$
\end{itemize}

Duals of $\ocircle$, $\underline{\until}$, $\lozenge$, $\square$:
\begin{itemize}
  \item $\ominus \phi$ -- Yesterday: $\phi$ True at Time $s$ when True
    at Time $s - 1$
  \item $\phi \underline{\since} \psi$ -- Non-strict Since
  \item $\blacklozenge \phi$ -- Once: True when $\phi$ is True at some
    Past Time
  \item $\boxminus \phi$ -- Historically: True whenever $\phi$ is True
    at all Past Times
\end{itemize}

Constrains Modality was introduced for Rely/Guarantee Properties (???)
of Parallel Systems; $\rhd$ has Fixed Points
%FIXME xref fixed-point logics?

Derivations of Modalities: %FIXME

$\pow(\Sigma^\omega)$ provides a Model for Linear-time Temporal Logic
\cite{abramsky-gay-nagarajan96}



\paragraph{Interval Temporal Logc}\label{sec:interval_temporal}\hfill

Interval Types (\S\ref{sec:interval_type})



\subsubsection{Dynamic Logic}\label{sec:dynamic_logic}

\emph{Dynamic Logic} adds Terms denoting \emph{Actions}:
\[
  [a]p
\]
where after performing Action $a$ is necessitated that $p$ holds and
\[
  \langle a \rangle p
\]
where after performing Action $a$ it is possible that $p$ holds.



\paragraph{Hennessy-Milner Logic}\label{sec:hennessy_milner}
\hfill

used to specify Properties of Labelled Transition Systems
(\S\ref{sec:labelled_transition})

\emph{Action Modalities}



\subparagraph{Spatial Logic}\label{sec:spatial_logic}
\hfill

Spatial Separation (Separation Logic \S\ref{sec:separation_logic})

Spatial-behavioral Types (\S\ref{sec:spatial_behavioral})

Caires04 - \emph{Behavioral and Spatial Observations in a Logic for the
  $\pi$-Calculus} -- $\pi$-calculus (\S\ref{sec:pi_calculus})



\subparagraph{Namespace Logic}\label{sec:namespace_logic}
\hfill

2005 - Meredith, Radestock - \emph{Namespace Logic: A Logic for a Reflective
  Higher-order Calculus}

2013 - Meredith, Stay, Drossopoulou - \emph{Policy as Types}

RHO Calculus (\S\ref{sec:rho_calculus})

in addition to Action Modalities there are Formulae for \emph{Separation} (cf.
Separation Logic \S\ref{sec:separation_logic}) corresponding to the
``\emph{structural content}'' of the Parallel Operator of the RHO Calculus

Deniability -- Rely/Guarantee combined with Adjunct to Spatial Separation

\asterism

Meredith-Radestock05:

Practical: Distributed Computing is practiced using \emph{Names}-- MAC
addresses, IP addresses, domain names, URLs, etc.

Theoretical: existing Computer Science tools \emph{do not} provide a Countably
Infinite Set of \emph{Atomic} entities that might function as Names; rather such
Sets (e.g. Natural Numbers or Set of Strings of Finite Length) are
\emph{Generated} from a \emph{Finite Presentation}
(\S\ref{sec:finite_presentation}) and inherit \emph{structure} from the
Generating procedure.

RHO Calculus (\S\ref{sec:rho_calculus}): Asynchronous Message-passing Calculus
built on notion of \emph{Quoting}, where \emph{Names} have the structure of
\emph{Quoted Processes} (representing the \emph{Code} of some Process, i.e. a
\emph{Reification} of the Syntactic Structure of some Process up to some
Equivalence); yields Higher-order characteristics without introduction of
Process Variables; as a Higher-order Calculus, Replication and/or Recursion are
no longer needed as Primitive Operations; the introduction of a \emph{Process
  Constructor} to Dynamically (FIXME: i.e. at runtime ???) convert a Process
into its Code is required for Computational completeness and at the same time
performs the function of the $\nu$ Operator

\emph{Namespace Logic}: Spatial Logic with Operators ``detecting''
\emph{Structural} as well as \emph{Behavioral} content of Processes; in addition
to usual Formulae for Denoting Sets of Processes, the additional
\emph{Reflective} structure on Names gives rise to a class of Formulae Denoting
Sets of \emph{Names}, referred to as \emph{Namespaces}

\emph{not} a Typesystem; only Semi-decidable

\asterism

2013 - Meredith, Stay, Drossopoulou - \emph{Policy as Types} -- (Curry-Howard
Isomorphism \S\ref{sec:curry_howard}) Namespace Logic treats the Type of a
Concurrent Process as an Assertion that it belongs to a Set of Processes, all of
which satisfy some Property, and treat these Properties as \emph{Contracts}
governing the Behavior of the Process \fist Spatial Behavioral Types
(\S\ref{sec:spatial_behavioral})

unlike usual notion of Type where a Type's Inhabitants are instances of Data
Structures, in Namespace Logic a Formula (i.e. a Type) $\phi$ is Inhabited by
\emph{Programs}, namely all the Programs that Satisfy the Formula, and
Inhabitants of Quoted Formulae $\textopencorner{\phi}\textcorner$ are Names, so
they are \emph{Namespaces}

a \emph{Capability}, i.e. \emph{access} to a Behavior, power or Authority, is
represented by a \emph{Channel}

\emph{Equivalence Theorem}; there is no Algorithm for guaranteeing that a check
for the Witness Relation will Terminate, however there is a large class of
Formulae for which the Witness check does Terminate; including Separation makes
the Logic strictly more ``observent'' than Bisimulation

\emph{Capability Policies}

\emph{Deniability} -- use Rely-guarantee combined with Adjunct to Spatial
Separation

2013 - Drossopoulou, Noble - \emph{The Need for Capability Policies}

\emph{Deniability} -- describes Policies which are \emph{Open} (i.e. apply to a
``Module'' as well as to its ``Extensions'') and describes \emph{Necessary
  Conditions} for some ``Effect'' to take place; cf. classical Hoare Logic
(\S\ref{sec:hoare_logic}) specifications which describe \emph{Sufficient
  Conditions} and are \emph{Closed}



\subsubsection{Provability Logic}\label{sec:provability_logic}

Infinitary Theory: Axiom of Choice will not suffice to reconstruct a
Theory from its Set-based Models
%FIXME this might not belong here but has to do with provability,
%Godel completeness; move to model theory?



\paragraph{Polymodal Logic}\label{sec:polymodal_logic}\hfill

$\mathsf{GLP}$



\paragraph{Interpretability Logic}\label{sec:interpretability_logic}\hfill

$\mathsf{ILM}$

$\mathsf{TOL}$



\subsubsection{Epistemic Modal Logic}\label{sec:epistemic_logic}

Curry-Howard Correspondence (\S\ref{sec:curry_howard}) with
``Distributed Programming''



\subsubsection{Adjoint Logic}\label{sec:adjoint_logic}

Adjunctions (\S\ref{sec:adjunction}) of Modal Operators: Adjoint
Modality (\S\ref{sec:adjoint_modality})

2015 - Licata, Shulman - \emph{Adjoint Logic with a $2$-category of Modes}

\fist Mode Theory (\S\ref{sec:mode_theory})



\paragraph{Adjoint Modality}\label{sec:adjoint_modality}\hfill

Adjoint Cylinder (\S\ref{sec:adjoint_cylinder})

Adjoint Monads (\S\ref{sec:adjoint_monad})

Hegelian ``Unity of Opposites''

Dialectical Reasoning (???) %FIXME

Category of Being (\S\ref{sec:category_of_being})

Cohesiveness, Differential Cohesion (???)

\[
  \begin{matrix}
    \lozenge & \dashv & \ocircle \\
    \bot & \empty & \bot \\
    \ocircle & \dashv & \square
  \end{matrix}
\]



\subsubsection{Propositional Lax Logic (PLL)}\label{sec:propositional_lax_logic}

1997 - Fairtlough, Mendler - \emph{Propositional Lax Logic}

Hardware verification

Two-frame Kripke Models featuring Worlds with Inconsistent information

\url{https://existentialtype.wordpress.com/2017/11/04/sequentiality-is-the-essence-of-parallelism/}

Parallelism

Lax Modality links the two levels of Pure Expressions (or \emph{Values}) and
Impure Commands (or \emph{Computations})

Join Points: Elimintation Forms for two Parallel Modalities

Parallel Product Type, Parallel Sequence Type



% --------------------------------------------------------------------
\subsection{Transparent Intensional Logic}
\label{sec:transparent_intensional_logic}
% --------------------------------------------------------------------

\emph{Constructions} (Procedures), ``Mode of Presentation'' (Frege)



% ====================================================================
\section{Term Logic}\label{sec:term_logic}
% ====================================================================

\emph{Syncategorematic Term}

\emph{Syllogistic Calculus} (\S\ref{sec:syllogistic_calculus})



\subsubsection{Square of Opposition}\label{sec:square_of_opposition}



% ====================================================================
\section{Fixed-point Logic}\label{sec:fixedpoint_logic}
% ====================================================================

allows for Inductive Definitions

\fist Infinitary Proof Theory (\S\ref{sec:infinitary_proof_theory})

Santocanale02 - \emph{A Calculus of Circular Proofs and its
  Categorical Semantics}

Fortier-Santocanale13 - \emph{Cuts for Circular Proofs: Semantics and
  Cut Elimination}

Baelde-Doumane-Saurin16 - \emph{Infinitary Proof Theory: The
  Multiplicative Additive Case}

\asterism

DeYoung-Pfenning16 - \emph{Substructural Proofs as Automata} -- Linear
Communicating Automata (\S\ref{sec:communicating_fsm}): weak
fragments of Linear Logic (\emph{Subsingleton Logic}
\S\ref{sec:subsingleton_logic} augmented with Least Fixed-points
(Baelde-Doumane-Saurin16, Fortier-Santocanale13); Proofs allowed to be
Circular with conditions to ensure they can be seen as
\emph{Coinductively Defined} (\S\ref{sec:coinduction})

Subsingleton Logic: Rules enforce that every Sequent has at most one
Antecedent and Succedent

Curry-Howard Isomorphism between \emph{Fixed-cut Proofs} in
$\oplus,\mathbf{1}$-$\mu$-subsingleton Logic and a generalization of
Deterministic Finite-state Transducers (Subsequential Finite-state
Transducers \S\ref{sec:sft}) that also ``captures'' Deterministic
Automata; relates Proofs to Automata and Proof Reduction to State
Transitions

(FIXME: Finite-state Trnsducer = Finite State Machine = Automata ???)

Well-behaved LCAs corresponding to Circular Proofs in
$\oplus$,$\mathbf{1}$-$\mu$-subsingleton Logic are free from Deadlock
and Race Conditions (analogous to how Natural Deduction in
Intuitionistic Propositional Logic defines Well-behaved
$\lambda$-terms)

Turing Machines as a special case of LCAs with a single Read/Write
Head


\asterism


% --------------------------------------------------------------------
\subsection{Modal $\mu$-calculus}\label{sec:modal_mu_logic}
% --------------------------------------------------------------------

extension of Propsitional Modal Logic (\S\ref{sec:modal_logic}) adding
a Least Fixed-point Operator $\mu$ and a Greatest Fixed-point Operator
$\nu$

\fist Linear Temporal Logic (\S\ref{sec:linear_temporal}) can be
encoded in Modal $\mu$-calculus

(wiki):

Game Semantics (\S\ref{sec:game_semantics}) of Modal $\mu$-calculus:
Two-player Games with Perfect Information, particularly Infinite
Parity Games

\asterism

$\mu$MALL (Baelde12 - \emph{Least and Greatest Fixed Points in Linear
  Logic})

\asterism

\textbf{$\oplus$,$\mathbf{1}$-$\mu$-subsingleton Logic}
(DeYoung-Pfenning16)

Least Fixed-points are treated \emph{Equirecursively}
(\S\ref{sec:equirecursive_type}) so that $\mu\alpha.A$ is identified
with its Unfoldings $[(\mu\alpha.A)/\alpha]A$ ...

Circular Proofs, \emph{Fixed-cut Circular Proofs} -- no \emph{cycle}
contains the $Cut$ Rule, but the $Cut$ Rule may appear outside of
cycles (Fortier-Santocanale13)

Curry-Howard Isomorphism between Subsequential Finite-state
Transducers (SFTs \S\ref{sec:sft}) and a Class of Cut-free
Subsingleton Proofs:
\begin{itemize}
  \item Propositions as Languages
  \item Proofs as SFTs
  \item Cut Reductions are SFT Computation Steps
\end{itemize}

\emph{Computational Interpretation of
  $\oplus$,$\One$-$\mu$-subsingleton Sequent Calculus}
%TODO

Propositions (Types):
\begin{flalign*}
  \quad\quad
  A,B,C &::=\ \oplus_{\ell\in{L}}\{\ell:A_\ell\} \ |\ \One
    \ |\ \mu\alpha.A \ | \alpha &
\end{flalign*}

Contexts:
\begin{flalign*}
  \quad\quad \Delta &::=\ \cdot \ |\ A &
\end{flalign*}

Conclusions:
\begin{flalign*}
  \quad\quad \gamma &::=\ C &
\end{flalign*}

Proof Terms:
\begin{flalign*}
  \quad\quad
  P,Q &::=\ X \ |\ P \rhd Q \ |\ \mathsf{writeR}\ k; P
    \ |\ \mathsf{readL}_{\ell\in{L}}(\ell \Rightarrow Q_\ell)
    \ |\ \mathsf{closeR} \ |\ \mathsf{waitL}; Q &
\end{flalign*}

Signatures:
\begin{flalign*}
  \quad\quad
  \Theta &::=\ \cdot \ |\ \Theta,(\Delta \vdash X = P:\gamma) &
\end{flalign*}

Logics Inference Rules become \emph{Typing Rules} for Proof Terms:
\begin{itemize}
  \item (no \emph{ID} Rule)
  \item \emph{Var}
  \item \emph{Cut} -- Types a \emph{Composition} $P \rhd Q$ of Proof
    Terms $P$ and $Q$
  \item $\oplus$\emph{L}
  \item $\oplus$\emph{R}
  \item $\One$\emph{L}
  \item $\One$\emph{R}
\end{itemize}
%TODO

Unfolding Principles -- used ``silently'' within a Proof and do not
affect Proof Terms %TODO

Well-typed $\Theta$:
\begin{itemize}
  \item \emph{Ok-E}
  \item \emph{Ok-Var}
\end{itemize}
%TODO

Sequents are annotated with Proof Terms and Signatures:
\[
  \Delta \vdash_\Theta P:\gamma
\]
``under the Definitions of Signature $\Theta$, the Proof Term $P$
consumes \emph{Input} of Type $\Delta$ and produces \emph{Output} of
Type $\gamma$''

$\mathsf{writeR}\ k;P$ -- Write Operation: emits Label $k$ and
continues (as $P$ ???) %FIXME

$\mathsf{readL}_{\ell\in{L}}(\ell \Rightarrow Q_\ell)$ -- Read
Operation: Branches on the Label that was Read

$\mathsf{closeR}$ -- signals end of Output

$\mathsf{waitL};Q$ -- Waits for Input to end and then continues
``with'' (as ???) $Q$ %FIXME

$\Theta$ is a Finite Signature of Corecursive Definitions of the form:
\[
  \Delta \vdash X = P : \gamma
\]
declaring the Variable $X$ as a Proof Term $P$ with a Type declaration
of:
\[
  \Delta \vdash_\Theta X : \gamma
\]

\emph{Propositions as Languages} over Finite Endmarked Alphabets (as
in SFTs)

the Least Fixed-point $Str_{\hat{\Sigma}} =
\mu\alpha.\oplus_{\ell\in\Sigma}\{\ell:A_\ell\}$ where $A_a = \alpha$
for all $a\in\Sigma_i$ and $A_e = \One$ for all $e \in \Sigma_e$,
unfolding to:
\[
  Str_{\hat{\Sigma}} = \oplus_{\ell\in\Sigma}\{\ell:A_\ell'\}
\]
where:
\[
  A_\ell' =
  \begin{cases}
    Str_{\hat{\Sigma}}
      & \quad \text{if $\ell\in\Sigma_i$} \\
    \One & \quad \text{if $\ell\in\Sigma_e$} \\
  \end{cases}
\]

Thm. \emph{Strings from the Language $\Sigma_i^*\Sigma_e$ are in
  Bijective correspondence with the Cut-free Proofs of $\cdot\vdash
  Str_{\hat{\Sigma}}$}

a Cut-free Proof Term $P$ of Type $\cdot\vdash Str_{\hat{\Sigma}}$
``emits'' a Finite List of Symbols from $\hat{\Sigma}$

Freely Generated Propositions correspond to Subsets of
$\Sigma_i^*\Sigma_e$


\emph{Encoding (Normal Form) SFTs as Cut-free Proofs of Types
  $Str_{\hat{\Sigma}} \vdash Str_{\hat{\Gamma}}$} %TODO

each SFT Transition is matched by a Proof Reduction

an SFT Chain $(T_i)^n_{i=1}$ is encoded as:
\[
  \llbracket{q_1}\rrbracket_{T_1} \rhd \cdots \rhd
  \llbracket{q_n}\rrbracket_{T_n}
\]


\emph{Extracting (Normal Form) SFTs from Cut-free Proofs of
  $Str_{\hat{\Sigma}} \vdash_\Theta Str_{\hat{\Gamma}}$}

* up to $\One{L}$ Commuting Conversion

each Variable becomes a State in the SFT

Fixed-cut Proofs are Isomorphic to SFT Chains by direct correspondence
of Fixed-cuts with ``chain links'' between neighboring SFTs


\textbf{SFT Composition by Cut Elimination}
%TODO

Subsequential Functions are Closed under Composition

DFA Closure under Complement and Inverse Homomorphism
%TODO


\textbf{Model of Linear Communicating Automata}

if conditions on Circular Proofs are relaxed so that $\mu$ is a
\emph{general}--not Least--Fixed Point, then Proofs are as powerful as
Turing Machines

generalization of Turing Machines:
\begin{itemize}
  \item ability to insert and delete Cells from the Tape
  \item ability to ``spawn'' multiple machine Heads that operate
    Concurrently
\end{itemize}

\emph{Linear Communicating Automata (LCA)}, $M$, as an $8$-tuple:
\[
  M = (Q,\Sigma,\delta^{rL},\delta^{rR},\sigma^{wL},\sigma^{wR},\rho,q_0)
\]
with:
\begin{itemize}
  \item $Q$ -- Finite Set of States, Partitioned into (possibly
    Empty) Sets of:
    \begin{itemize}
      \item $Q^{rL}$ and $Q^{rR}$ -- Left- and Right-reading States
      \item $Q^{wL}$ and $Q^{wR}$ -- Left- and Right-writing States
      \item $Q^s$ -- Spawn States
      \item $Q^h$ -- Halt States
    \end{itemize}
  \item $\Sigma$ -- Finite Alphabet
  \item $\delta^{rL} : \Sigma \times Q^{rL} \rightarrow Q$ -- Total
    Function on Left-reading States
  \item $\delta^{rR} : Q^{rR} \times \Sigma \rightarrow Q$ -- Total
    Function on Right-reading States
  \item $\sigma^{wL} : \Sigma \times Q^{wL} \rightarrow Q$ -- Total
    Function on Left-writing States
  \item $\sigma^{wR} : Q^{wR} \times \Sigma \rightarrow Q$ -- Total
    Function on Right-writing States
  \item $\rho : Q^s \rightarrow Q \times Q$ -- Total Function on Spawn
    States
  \item $q_0 \in Q$ -- Initial State
\end{itemize}

\emph{Configurations} of an LCA $M$ are Strings $w$ and $v$ from the Set
$(\Sigma^*Q)*\Sigma^*$

each State in the Configuration represents a Read/Write Head

$\longrightarrow$ -- Binary Relation on Configurations:
(Read-L, Read-R, Write-L, Write-R, Spawn, Halt) %TODO

\emph{Turing Completeness of LCAs}


\textbf{$\&$,$\bot$,$\oplus$,$\One$-$\mu$-subsingleton Logic}

extending $\oplus$,$\One$-$\mu$-subsingleton Logic with $\&$ and
$\bot$ Connectives

Propositions (Types):
\begin{flalign*}
  \quad\quad
  A,B,C &::=\ \cdots \ | \&_{\ell\in{L}}\{\ell:A_\ell\} \ |\ \bot &
\end{flalign*}

Proof Terms:
\begin{flalign*}
  \quad\quad
  P,Q &::=\ \cdots \ |\ \leftrightarrowtriangle
    \ |\ \mathsf{readR}_{\ell\in{L}}(\ell\Rightarrow{P_\ell})
    \ |\ \mathsf{writeL}\ k;Q \ |\ \mathsf{waitR}; P
    \ |\ \mathsf{closeL} &
\end{flalign*}

Conclusions (can now be Empty):
\begin{flalign*}
  \quad\quad \gamma &::=\ C \ |\ \cdot &
\end{flalign*}

(Contexts, and Signatures unchanged)

Inference Rules for $\&$ and $\bot$ are Dual to those for $\oplus$ and
$\One$

$Id$ added as an Inference Rule: Types $\leftrightarrowtriangle$ as a
\emph{Forwarding Operation}


\emph{Well-behaved LCAs}

$\mathsf{readL}$ and $\mathsf{readR}$ become Left- and Right-reading
States

$\mathsf{writeL}$ and $\mathsf{writeR}$ become Left- and Right-writing
States

Cuts, represented by the $\rhd$ Operation which creates a new
Read/Write Head, become Spawning States

the $Id$ Rule, represented by the $\leftrightarrowtriangle$ Operation,
becomes a Halting State

LCA Transitions are mached by Proof Reductions

corresponding LCAs cannot Deadlock becaues Cut Elimination can always
make Progress (Fortier-Santocanale13) and do not have Races because
$\mathsf{readR}$ and $\mathsf{readL}$ have different Types and as a
result cannot be neighbors


\emph{Turing Completeness}

allowing general occurrences of $Cut$ in order to simulate Turing
Machines; to allow for Non-halting Turing Machines, $\mu$ is relaxed
to be a \emph{general} Recursive Type (instead of an Inductive Type)
by dropping the requirement that every Cycle in a Circular Proof is a
Left $\mu$-trace

Turing Machines can also be simulated without $\&$ by replacing
occurrences of $\&$, $\mathsf{readR}$, and $\mathsf{writeL}$ with
$\oplus$ (and its constructs) in a Continuation-passing Style-- this
indicates that Turing Completeness depends on interaction of general
Cuts and general Recursion, not on interaction between $\oplus$ and
$\&$



% ====================================================================
\section{Logical System}\label{sec:logical_system}
% ====================================================================

A \emph{Logical System} (or \emph{System of Logic}) is a Formal System
(\S\ref{sec:formal_system}) together with a form of Semantics that
gives Meanings to the Formulas in the underlying Language.

A Structure (\S\ref{sec:structure}) that Satisfies
(\S\ref{sec:satisfaction}) the Axioms of a Logical System is called a
\emph{Model} (\S\ref{sec:model}) of the System.



% --------------------------------------------------------------------
\subsection{Classical Logic}\label{sec:classical_logic}
% --------------------------------------------------------------------

\emph{Classical Logic} is the class of Propositional and
First-order Systems of Logic characterized by the following Inference
Rules:

\begin{description}

\item [Tertium non datur] (\emph{Law of excluded middle})
  \[
    \vdash(p \vee \neg p)
  \]

\item [Double Negation]
  \[
    p \vdash \neg\neg p
  \]

\item [Law of Non-contradiction]
  \[
    \vdash \neg(p \wedge \neg p)
  \]

\item [Ex falso quodlibet] (\emph{Principle of explosion},
  \emph{Principle of Psuedo-Scotus})
  \[
    \vdash 0 \rightarrow p
  \]

%FIXME finish properties and rules

\end{description}

The intended Semantic Interpretation (\S\ref{sec:interpretation}) of
Classical Logic is subject to the Principle of Bivalence
(\S\ref{sec:bivalence_principal}) which says that every Proposition
has one Truth-value: True or False. Non-classical Logics such as
Intuitionistic Logic (\S\ref{sec:intuitionistic_logic}) does not have
this Property.

\fist $\lambda\mu$-calculus (\S\ref{sec:lambda_mu})

\fist Classical Pure Type Systems (\S\ref{sec:cpts})


Continuations (\S\ref{sec:continuation}): Classical -- Exceptions
(\S\ref{sec:exception_effect}): Intuitionistic

Classical Logic: a Term that Backtracks Witnesses Excluded Middle
$\neg A \vee A$; Proof by Contradiction as the Logical analogue of
``jumping''

Control Categories (\S\ref{sec:control_category}) are Models for
Classical Propositional Logic with Pretensor $\parr$ Modelling
Disjunction



\subsubsection{Propositional Calculus}
\label{sec:propositional_calculus}

\paragraph{Pierce's Law}\label{sec:pierces_law}\hfill

$((P \rightarrow Q) \rightarrow P) \rightarrow P$

Implies Law of Excluded Middle

$\mathtt{call-cc}$ %FIXME



% --------------------------------------------------------------------
\subsection{Intuitionistic Logic}\label{sec:intuitionistic_logic}
% --------------------------------------------------------------------

\emph{Intuitionistic Logic} (or \emph{Constructive Logic}) replaces
Truth with the concept of \emph{Constructive Provability}. This is to
say that Logical Operations in Intuitionistic Logic preserve
\emph{Justification} (\S\ref{sec:formal_proof}) rather than
Truth-value. Such systems are restrictions of Classical Logic
(\S\ref{sec:classical_logic}) without the Law of the Excluded Middle
or Double Negation Elimination.

Whereas First-order Logic (\S\ref{sec:firstorder_logic}) is a
foundation for Set Theory (Part \ref{part:set_theory}), Intuitionistic
Logic is used as a foundation for Type Theory (Part
\ref{part:type_theory}) and Constructive Set Theory
(\S\ref{sec:constructive_set_theory}).

A Formula in Intuitionistic Logic does not necessarily have a Prenex
Normal Form (\S\ref{sec:prenex_normal}).

Intuitionistic Propositional Calculus is Modelled (\S\ref{sec:model})
by Heyting Algebra (\S\ref{sec:heyting_semantics}, also a Cartesian
Closed Preorder \S\ref{sec:cartesian_preorder}) or Kripke Semantics
(\S\ref{sec:kripke_semantics}) and lacks the Principle of Bivalence
(\S\ref{sec:bivalence_principal}); thus there is no Sole-sufficient
Operator in Intuitionistic Logic. A Formula in Intuitionistic Logic is
Valid if and only if it receives the Value of the Top Element for any
Valuation on a Heyting Algebra.

Intuitionistic First-order Logic is Modelled by a Heyting Category
(\S\ref{sec:heyting_category}).

Intuitionistic-Classical Embedding corresponds to Continuation Passing
Style (\S\ref{sec:continuation}) in Programming Languages.

Functionally Complete Sets of Propositional Operators are:
\[
  \{ \vee, \leftrightarrow, \bot \}
\]
and:
\[
  \{ \vee, \leftrightarrow, \neg \}
\]

Theorem (Intuitionistic Propositional Logic does not refute the Law of
the Excluded Middle)\cite{harper12}:
\[
  \forall A, \neg (\neg (A \vee \neg A))
\]

2013 - Meredith - Monadic Design Patterns for Distributed Programming, Pt. 1 -
\url{https://www.youtube.com/watch?v=UFyhTEO2fYM}:

one can show that $\neg(\neg A) \Rightarrow A$, but \emph{cannot show} that
$A \Rightarrow \neg(\neg A)$

thinking of the ``Negation Operation'' as a type of ``Closure Operation'': if
you take a collection and apply a Closure Operation to the collection ``you may
throw more stuff in''; once it's ``Closed'' if you apply the Closure Operation
again, typically you get back that ``Closed'' entity, so everything that is in
the Closed entity includes what was in the original collection, but the other
way around may not hold-- (FIXME: clarify)

in the ``Distributed'' setting, one can give a Constructive interpretation of
the classical notion of the Law of Excluded Middle



\subsubsection{Existence Property}\label{sec:existence_property}

Proofs in a Theory (\S\ref{sec:formal_theory}), $\mathcal{T}$, based
on Intuitionistic Logic have the \emph{Existence Property}:
\[
  (\exists x)A(x) \in \mathcal{T} \rightarrow (\exists t)A(t)
\]
where $A(x)$ has $x$ as the only Free Variable and $t$ is a Term.



\subsubsection{Disjunction Property}\label{sec:disjunction_property}

\emph{Disjunction Property}:
\[
  A \vee B \in \mathcal{T}
  \rightarrow A \in \mathcal{T} \vee B \in \mathcal{T}
\]



\subsubsection{Positive Implicational Calculus}
\label{sec:positive_implicational}

the Types of the $S$, $K$, and $I$ Combinator Terms in SKI Combinator
Calculus (\S\ref{sec:ski_calculus}) correspond to the Axiom Schemata
for Positive Implicational Logic



\subsubsection{Positive Propositional Calculus}
\label{sec:positive_propositional}

Satisfiability (\S\ref{sec:satisfiability}) is Trivial

Validity (\S\ref{sec:validity}) is co-NP Complete %FIXME ref co-np



\subsubsection{Minimal Logic}\label{sec:minimal_logic}

\emph{Minimal Logic} is an Intuitionistic Logic without the Principle
of Explosion (\S\ref{sec:explosion_principle}).

(Zeroth-order) Minimal Logic corresponds with Simply-typed
$\lambda$-calculus (\S\ref{sec:simply_typed})

First-order Minimal Logic corresponds with First-order Dependently-typed
$\lambda$-calculus (\S\ref{sec:dependent_lambda})



\subsubsection{Superintuitionistic Logic}
\label{sec:superintuitionistic_logic}

A \emph{Superintuitionistic Logic} is an extended Intuitionistic
Logic. The strongest Consistent Superintuitionistic Logic is Classical
Logic (\S\ref{sec:classical_logic}).



\paragraph{Intermediate Logic}\label{sec:intermediate_logic}\hfill

\emph{Intermediate Logic} is an extended Intuitionistic Logic
(Superintuitionistic Logic) that is Consistent and still weaker than
the strongest Consistent Superintuitionistic Logic: Classical Logic.



% --------------------------------------------------------------------
\subsection{Display Logic}\label{sec:display_logic}
% --------------------------------------------------------------------

\fist Structural Proof Theory (\S\ref{sec:structural_proof})

requires extra-logical conditions to ensure Cut Admissibility

Belnap82 - \emph{Display Logic}



% --------------------------------------------------------------------
\subsection{Substructural Logic}\label{sec:substructural_logic}
% --------------------------------------------------------------------

Substructural Type Theory (\S\ref{sec:substructural_type})

DeYoung-Pfenning - \emph{Substructural Proofs as Automata}
-- Linear Communicating Automata (\S\ref{sec:lca})

Licata-Shulman-Riley17:

\fist Mode Theory (\S\ref{sec:mode_theory}) -- Substructural features
are provided by adding Structural Properties on the Context Descriptor
$\alpha$

restrictions on the allowed Proofs in standard ``Structural'' Logic,
removing Properties such as:
\begin{itemize}
  \item Exchange (Associativity ???) %FIXME
  \item Weakening -- $\frac{\Gamma \vdash \Sigma}
    {\Gamma,A \vdash \Sigma}$
  \item Contraction (\emph{Idempotency of Entailment} in Classical
    Logic; ``Factoring'' in Automated Theorem Proving systems using
    Resolution Inference Rule) -- $\frac{\Gamma,A,A \vdash \Sigma}
    {\Gamma,A \vdash \Sigma}$
    %TODO xref
\end{itemize}

Internal Languages (\S\ref{sec:internal_logic}) of various Monoidal
Categories (\S\ref{sec:monoidal_category}); cf. Modal Logic
(\S\ref{sec:modal_logic}) describing Monads (\S\ref{sec:monad}) and
Comonads (\S\ref{sec:comonad})



\subsubsection{Ordered Logic}\label{sec:ordered_logic}\hfill

no Exchange, Contraction, or Weakening -- ``used exactly once in the
order it was introduced''

\fist Ordered Type System (\S\ref{sec:ordered_type})

\fist Non-commutative Logic (\S\ref{sec:noncommutative_logic})

can be used to Model Stack-based Memory Allocation



\subsubsection{Affine Logic}\label{sec:affine_logic}

\emph{Affine Logic}

no Contraction -- ``can use at most once''

\fist see also BCK Combinatory Logic (\S\ref{sec:bck_logic})

(wiki):

Russell's Paradox cannot be Derived in a Set Theory without
Contraction (Grishin74)

cf. Affine Transformation (\S\ref{sec:affine_transformation}) on
Vector Spaces

full Linear Logic (Propositional Linear Logic with Multiplicatives,
Additives, and Exponentials) is Undecidable while full Affine Logic is
Decidable

foundation of Ludics (\S\ref{sec:ludics})



\paragraph{Direct Logic}\label{sec:direct_logic}\hfill



\subsubsection{Relevance Logic}\label{sec:relevance_logic}

\emph{Relevance Logic} (or \emph{Relevant Logic})

Anderson-Belnap75 - \emph{Entailment: the Logic of Relevance and
  Necessity, Volume I} -- \emph{Bunches} (cf. Bunched Logic
\S\ref{sec:bunched_logic})

Anderson-Belnap92 - \emph{Entailment: the Logic of Relevance and
  Necessity, Volume II}

Strict Logic

no Weakening -- ``must use at least once''

Girard: Weakening Rule introduces ``fake dependencies'', e.g. Constant
Functions

(wiki):

notion of \emph{Relevance}:
\begin{itemize}
  \item in terms of a Syntactical Constraint for a
    Propositional Calculus it is Necessary but not Sufficient that the
    Premises and Conclusion share Atomic Formulas (i.e. Formulas that do
    not contain any Logical Connectives \S\ref{sec:logical_connective})
  \item in Predicate Calculus requires ``sharing'' of Variables and
    Constants between Premises and Conclusion which can be ensured by
    placing restrictions on the Rules of a Natural Deduction system,
    i.e. no \emph{Weakening}
\end{itemize}

Relevance Logics are \emph{Paraconsistent Logics}
(\S\ref{sec:paraconsistent_logic})

Kripke Semantics (\S\ref{sec:kripke_semantics}) for Relevance Logic:
can be characterized as a Class of Formulas Valid over a Class of
Kripke Frames (\S\ref{sec:kripke_frame}); Implication Operator is a
Binary Modal Operator, and Negation is (usually) an Unary Modal
operator



\subsubsection{Linear Logic}\label{sec:linear_logic}

Dualities of Classical Logic + Constructive properties of
Intuitionistic Logic

no Weakening, no Contraction -- ``must use exactly once''

Giraud87 \emph{Linear Logic}

\fist see also BCI Combinatory Logic (\S\ref{sec:bci_logic})

(wiki):

\begin{itemize}
\item Interpretation of Intuitionistic Logic replacing Cartesian Closed
  Categories (\S\ref{sec:cartesian_closed}) with Symmetric Monoidal
  Categories (\S\ref{sec:symmetric_monoidal})
\item Interpretation of Classical Logic replacing Boolean Algebras
  (\S\ref{sec:boolean_algebra}) by C$^*$-algebras
  (\S\ref{sec:cstar_algebra}).
\end{itemize}

(FIXME: does this actually relate to linear logic ???):

given a Vector Space $V$ over a Field $R$, the Dual Space $V^*$ is just the Set
of Linear Functions into $V \mapsto R$
--\url{https://cstheory.stackexchange.com/questions/39440/algebraic-account-of-gaussian-elimination}


\asterism


Internal Language of Closed Symmetric Monoidal Categories
(\S\ref{sec:closed_symmetric_monoidal})

An Algebraic Semantics (\S\ref{sec:algebraic_semantics}) for Linear
Logic is given by Quantales (\S\ref{sec:quantale})

Game Semantics (\S\ref{sec:game_semantics}): Geometry of Interaction
(\S\ref{sec:interaction_geometry})

Classical Linear Logic (\S\ref{sec:cll})

Intuitionistic Linear Logic

Dual Intuitionistic Linear Logic \S\ref{sec:dual_linear_logic}
(Session Types \S\ref{sec:session_type}) \cite{caires-pfenning10}

\fist Non-commutative Logic (\S\ref{sec:noncommutative_logic}) is an
extension of Linear Logic that combines the Commutative Connectives of
Linear Logic with Noncommutative Multiplicative Connectives of Lambek
Calculus (\S\ref{sec:lambek_grammar})

Resources, Effects, Non-interference \cite{caires-pfenning10}

Process Calculus (\S\ref{sec:process_calculus})

Session-typed $\pi$-calculus (\S\ref{sec:sessiontyped_pi})

Interaction Nets %FIXME

Context (\S\ref{sec:sequent_context})

Exchange (\S\ref{sec:exchange_rule})

Omitted Rules: Weakening (\S\ref{sec:weakening_rule}), Contraction
(\S\ref{sec:contraction_rule})

Exponentials $!$, $?$: controlled access to Weakening and Contraction

the Additive Implication $\rightarrow$ can be recovered using the $!$
Modality: $\varphi \rightarrow \psi$ as $!\varphi \multimap \psi$

Initial Sequent (Unit for Composition)

Cut (\S\ref{sec:cut_elimination}) (Composition)

Translation from Intuitionistic Logic into Linear Logic:
G\"odel-Gentzen Negative Translation (\S\ref{sec:godel_gentzen}),
embedding Classical First-order Logic into Linear First-order Logic

Traced Monoidal Categories (\S\ref{sec:traced_monoidal}): Operational
Categorical Semantics for Linear Logic

Game Semantics (\S\ref{sec:game_semantics}): Geometry of Interactions
\S\ref{sec:interaction_geometry}) Semantics of Linear Logic
characterizes Linear Logic in terms of Linear Algebra; cf. Coherence
Space (\S\ref{sec:coherence_space})

Exponential Modality $!$ is an example of a Comonad
(\S\ref{sec:comonad}): Counit is \emph{Deriliction} $!A \rightarrow A$
and Comultiplication is \emph{Digging} $!A \rightarrow !!A$

also has the Structure of a Comonoid (\S\ref{sec:comonoid}): Weakening
$!A \rightarrow ()$, Contraction $!A \rightarrow !A \times !A$



\paragraph{Canonical Form Property}\label{sec:canonical_form_property}\hfill

\emph{Canonical Form Property}:
\begin{itemize}
  \item \emph{Completeness of Atomic Initial Sequents}: arbitrary
    Initial Sequents can be Derived from Atomic Initial Sequents
  \item \emph{Cut-elimination Theorem}: whenever a Sequent is Provable
    it can be given a Cut-free Proof
\end{itemize}

Subformula Property



\paragraph{Classical Linear Logic}\label{sec:cll} \hfill

\emph{Classical Linear Logic} (CLL)

Entailment Relation in Full CLL is Undecidable

MLL, MALL, MELL

Interaction Category (\S\ref{sec:interaction_category}) $\cat{SProc}$
of Synchronous Processes is a Model for CLL.

Two standard Translations of Intuitionistic Logic into Classical
Linear Logic (Equivalent to Translations of $\lambda$-calculus
\S\ref{sec:untyped_lambda} into Linear
$\lambda$-calculus \S\ref{sec:linear_lambda}):\cite{wadler12}
\begin{enumerate}
  \item Call-by-name (\S\ref{sec:call_by_name}) (Girard):
\[
  (A \rightarrow B)^\circ = !A^\circ \multimap B^\circ
\]
  \item Call-by-value (\S\ref{sec:call_by_value}):
\[
  (A \rightarrow B)^* = !(A^* \multimap B^*)
\]
\end{enumerate}
GV (Session-typed $\pi$-calculus \S\ref{sec:good_variation}) uses the
second Translation.

Syntax (BNF notation):
\[
\begin{split}
  A ::=& \; p \; | \; p^\bot\\
      |& \; A \otimes A \; | \; A \oplus A\\
      |& \; A \& A \; | \; A \parr A\\
      |& \; 1 \; | \; 0 \; | \; \top \; | \; \bot\\
      |& \; !A \; | \; ?A
\end{split}
\]

$p$ and $p^\bot$ ranging over Logical Atoms
(\S\ref{sec:atomic_formula})

Multiplicatives $\otimes$, $\parr$, $1$, $\bot$

Additives $\oplus$, $\&$, $0$, $\top$

Exponentials $!$, $?$

\begin{itemize}
  \item $\otimes$ Multiplicative Conjunction (``Tensor'', simultaneous
    occurrence of Resources)
  \item $\oplus$ Additive Disjunction (``Plus'', alternative occurence
    of Resources, Internal Choice, ``Choice'')
  \item $\&$ Additive Conjunction (``With'', alternative occurence of
    Resources, External Choice, ``Branch'')
  \item $\parr$ Multiplicative Disjunction (``Parr'')
  \item $1$ Unit for Multiplicative Conjunction (absence of any
    Resource)
  \item $0$ Unit for Additive Disjunction (Resource that cannot be
    created)
  \item $\top$ Unit for Additive Conjunction (unspecified alternative)
  \item $\bot$
  \item $!$ (``Bang'')
  \item $?$ (``Why Not'')
\end{itemize}

Duals for Propositions %FIXME

Linear Negation of $A$: $A^\bot$

$A^{\bot\bot} = A$

\cite{llwiki16}
$\Gamma, A \vdash \Delta$ is Provable if and only if $\Gamma \vdash
A^\bot, \Delta$ is Provable

One-sided Sequents:

$\Gamma \vdash \Delta$ is Provable if and only if $\vdash \Gamma^\bot,
\Delta$ is Provable


\textbf{Polarity}

Positive: $\otimes$, $\oplus$, $1$, $0$, $!$

Negative: $\parr$, $\&$, $\bot$, $\top$, $?$


\textbf{Linear Implication}

\[
  A \multimap B := \; A^{\bot} \parr B
\]
(Resource Interpretation: Validity of Transforming Resource $A$ into
Resource $B$)


\textbf{Intuistionistic Implication}

$!A \multimap B$


\textbf{Classical Implication}

$!A \multimap ?B$


\textbf{Equivalences}

$A \equiv B = (A \multimap B) \& (B \multimap A)$


\textbf{Distributivity}

$A \otimes (B \oplus C) \equiv (A \otimes B) \oplus (A \otimes C)$


\textbf{Linear Distribution} (Weak Distribution)

$(A \otimes (B \parr C)) \multimap ((A \otimes B) \parr C)$


\textbf{Exponential Isomorphism}

$!(A \& B) \equiv !A \otimes !B$


\textbf{LU Presentation}



\paragraph{Dual Intuitionistic Linear Logic}\hfill
\label{sec:dual_linear_logic}

\cite{andreoli92}

\emph{Dual Intuitionistic Linear Logic} (sometimes \emph{DILL})

Dyadic

Session Types (\S\ref{sec:session_type})

Session-typed $\pi$-calculus (\S\ref{sec:sessiontyped_pi})



\paragraph{Polarized Linear Logic}\label{sec:polarized_linear_logic}\hfill

2009 - Honda, Laurent - \emph{An exact correspondence between a typed
  pi-calculus and polarized proof-nets} -- corresponds to Asynchronous
Communication in $\pi$-calculus (Sender does not get conformation that a
Message has been Received)



\paragraph{Linear Multirole Logic}\label{sec:lmrl}\hfill

\begingroup

\newcommand{\msg}{\mathtt{msg}}
\newcommand{\nil}{\mathtt{nil}}

\newcommand{\channelsend}{\mathtt{channel\_send}}
\newcommand{\channelrecv}{\mathtt{channel\_recv}}
\newcommand{\channelclose}{\mathtt{channel\_close}}
\newcommand{\channelskip}{\mathtt{channel\_skip}}

\newcommand{\Chan}{\mathsf{Chan}}
\newcommand{\Int}{\mathsf{Int}}
\renewcommand{\Unit}{\mathsf{()}}

\emph{Linear Multirole Logic} (LMRL)

Xi-Wu16 -- \emph{Propositions in Linear Multirole Logic as Multiparty
  Session Types}: Session-typed Process Calculus $\pi LMRL$
(\S\ref{sec:pi_lmrl}) where Session Types are Formulas of Linear
Multirole Logic (with the addition of $1_r$ for the Unit of
$\otimes_r$)

\fist Multiparty Session Types (\S\ref{sec:multiparty_session})

\fist Communicating Systems (\S\ref{sec:communicating_system})

Multi-cut first established in Carboni-Montesi-Schurmann-Yoshida15 --
\emph{Multiparty Session Types as Coherence Proofs} introducing MCP
(\S\ref{sec:mcp}) as an extension of CLL

\fist in Danielou-Yoshida11 \emph{Dynamic Multirole Session Types} and
Neykova-Yoshida14 \emph{Multiparty Session Actors} Participants play
multiple Roles by holding Channels belonging to multiple Sessions (see
Dynamic Multirole Session Types \S\ref{sec:multirole_session}); this
could be considered a formulation of \emph{Multirole Parties} while
Xi-Wu16 is a formulation of \emph{Multirole Channels}


\asterism

Xi-Wu16

generalization of Classical Linear Logic (\S\ref{sec:cll})

\emph{Multi-cut Elimination}: any Cut between three or more Sequents
can be Eliminated (extention of Cut-elimination by Gentzen)


\textbf{Session Type Development}

\emph{Dyadic Session}: Interaction between two Concurrently Running Programs

\emph{Session Type}: Session Specification

\emph{Terms}

$\msg(i,j,T)$ -- Transfer of Value of Type $T$ from Participant
(``Party'') Implementing Role $i$ to Participant implementing Role
$j$; ``interpreted'' as a Send Operation for the Participant
implementing Role $i$ and a Receive Operation for the Participant
implementing Role $j$

$S$ -- Session Type

$\Chan(i,S)$ -- Type of Channel for Role $i$

Type Schema for $\channelsend$ (Dyadic):
\[
  (!\Chan (i, \msg(i,j,T):S) \gg \Chan(i,S), \Int(i), \Int(j), T)
    \rightarrow \Unit
\]
where $\int(x)$ is a Singleton Type for Integers equal to $x$;
$\channelsend$ called on a Channel of the Type
$\Chan(i, \msg(i,j,T):S)$ returns Unit and changes the
Type of the Channel to $\Chan(i,S)$; $\Chan$ must be a
\emph{Linear Type Constructor} (\S\ref{sec:linear_type})

Type Schema for $\channelrecv$ (Dyadic):
\[
  (!\Chan (j, \msg(i,j,T):S) \gg \Chan(j,S), \Int(i), \Int(j))
    \rightarrow T
\]
returning a Value of Type $T$ and changing the Type of the Channel to
$\Chan(j,S)$.
%FIXME is ! correct instead of ?

Type Schema for $\channelclose$ (Dyadic):
\[
  (\Chan(i, \nil)) \rightarrow \Unit
\]

a \emph{Full Channel} $CH$ has End-points (just ``\emph{Channels}'')
$CH_0$ and $CH_1$


\emph{Bidirectional Forwarding} between matching Channels corresponds
to Cut-elimination in Linear Logic (Caires-Pfenning10, Wadler12)

for $CH^a$ with Endpoints $CH^a_0 : \Chan(0,S)$ and $CH^a_1 :
\Chan(1,S)$ and $CH^b$ with Endpoints $CH^b_0 : \Chan(0,S)$ and
$CH^b_1 : \Chan(1,S)$ forms a Full Channel with Endpoints $CH^a_0 :
\Chan(0,S)$ and $CH^b_1 : \Chan(1,S)$


\emph{Multirole Channel}: $\Chan(R,S)$ where $R$ is a Set of Roles

$P = \{0, 1, \ldots, N\}$ -- Set of $N$ Roles where $N$ is a Natural
Number $2 \leq N$ and $\overline{R} = P \setminus R$

each Full Channel $CH$ specified by Session Type $S$ may have $n$
End-points $CH_{R_i}$ with Types $\Chan(R_i,S)$ for $i \in
\{1,\ldots,n\}$ where $R_1, \ldots, R_n$ form a Partition of
$\overline{\varnothing} = P$

a Value Sent into one of the Endpoints is Broadcast to all of the
other Endpoints

$\Chan(R,S)$ -- Type of a Channel of Roles $R$

for any Participant holding a Channel with Type $\Chan(R,
\msg(i,j,T)::S)$ encountering a Term $\msg(i,j,T)$ will result in one
of four possible outcomes:
\begin{itemize}
  \item if $i \in R$ and $j \in R$ then the Participant should ignore
    the Term $\msg(i,j,T)$ (no other Endpoint is expecting to Receive
    a Value Tagged with $j$)
  \item if $i \notin R$ and $j \notin R$ then the Participant should
    ignore the Term $\msg(i,j,T)$ (not expected to Send or Receive)
  \item if $i \in R$ and $j \notin R$ then the Participant should Send
    a Value of Type $T$ with Tag $j$
  \item if $i \notin R$ and $j \in R$ then the Participant should
    Receive a Value of Type $T$ with Tag $j$
\end{itemize}

Type Schema for $\channelsend$ (Multirole):
\[
  (!\Chan (R, \msg(i,j,T):S) \gg \Chan(R,S), \Int(i), \Int(j), T)
    \rightarrow \Unit
\]
assuming $i \in R$ and $j \notin R$

Type Schema for $\channelrecv$ (Multirole):
\[
  (!\Chan (R, \msg(i,j,T):S) \gg \Chan(j,S), \Int(i), \Int(j))
    \rightarrow T
\]
assuming $i \notin R$ and $j \in R$

Type Schema for $\channelclose$ (Multirole):
\[
  (\Chan(R, \nil)) \rightarrow \Unit
\]

Type Schema for $\channelskip$:
\[
  (!\Chan(R,\msg(i,j,T)::S) \gg \Chan(R,S)) \rightarrow \Unit
\]
assuming either $i,j \in R$ or $i,j \notin R$; $\channelskip$ is a
Proof Function (\S\ref{sec:proof_function}), i.e. it does nothing at
Runtime


\textbf{LMRL}

\emph{Role-based Interpretation} of Conjunction/Disjunction Duality

for $\underline{A},\underline{B}$ ranging over Sequents

\emph{Conj-R}:
\[
  \frac {\underline{A} \vdash \underline{B},A \quad\quad
    \underline{A} \vdash \underline{B},B}
  {\underline{A} \vdash \underline{B},A \wedge B}
\]
\emph{Conj-L1}:
\[
  \frac {\underline{A},A \vdash \underline{B}}
  {\underline{A},A \wedge B \vdash \underline{B}}
\]
\emph{Conj-L2}:
\[
  \frac {\underline{A},B \vdash \underline{B}}
  {\underline{A},A \wedge B \vdash \underline{B}}
\]
\emph{Disj-L}:
\[
  \frac {\underline{A},A \vdash \underline{B} \quad\quad
    \underline{A},B \vdash \underline{B}}
  {\underline{A},A \vee B \vdash \underline{B}}
\]
\emph{Disj-R1}:
\[
  \frac {\underline{A} \vdash \underline{B},A}
  {\underline{A} \vdash \underline{B}, A \vee B}
\]
\emph{Disj-R2}:
\[
  \frac {\underline{A} \vdash \underline{B},B}
  {\underline{A} \vdash \underline{B}, A \vee B}
\]

\emph{Role-based Interpretation}: for two Roles $0$ and $1$, the left
side of a Sequent Judgement ($\underline{A} \vdash \underline{B}$) is
Role $0$ and the right side is Role $1$ and there are two Logical
Connectives $\wedge_0$ and $\wedge_1$ that give a ``Conjunction-like''
Interpretation for Role $r$ and a ``Disjunction-like'' Interpretation
for the other Role

introducing more Roles

$R_N$ -- Set of Natural Numbers $\{0,\ldots,N-1\}$

$R_\omega$ -- Set of all Natural Numbers

$P$ -- Set of Roles

$R$ -- Subset of $P$

$\overline{R}$ -- Complement of $R$ in $P$

$R_1 \uplus R_2$ -- Union of Disjoint Sets of Roles


\emph{Conjunctive Multirole Logic}

$P$ -- Set of Roles

$\wedge_r$ -- Logical Connective for each $r \in P$ given a
``Conjunction-like'' Interpretation by the Participant acting as $r$
and a ``Disjunction-like'' Interpretation otherwise

$\forall$ -- Infinite form of Conjunction


\emph{Disjunctive Multirole Logic}

$P$ -- Set of Roles

$\wedge_r$ -- Logical Connective for each $r \in P$ given a
``Disjunction-like'' Interpretation by the Participant acting as $r$
and a ``Conjunction-like'' Interpretation otherwise


\emph{LMRL}

$[A]_R$ -- an \emph{I-formula} for a given Formula $A$ and Set of
Roles $R \subseteq P$ is an Interpretation of $A$ based on $R$, e.g. a
``Conjunction-like'' Interpretation of $\wedge_r$ if $r \in R$ and
``Disjunction-like'' otherwise; Interpretations are based on
\emph{Sets} of Roles rather than individual Roles, i.e. one
Participant (``Side'') is allowed to play more than one Role
simultaneously

$\Gamma$ -- Sequent of LMRL: a Sequence of I-formulas--
``Many-sided'': each $R$ appearing in $\Gamma$ is just one ``Side''

\fist \emph{Note}: two identical I-formulas can appear in the same
Sequent

$\vdash \Gamma$ -- Judgement

\fist \emph{Notation}: $(\Gamma_1;\ldots;\Gamma_n) \Rightarrow
\Gamma_c$ for an Inference Rule:
\[
  \frac{\vdash \Gamma_1 \cdots \vdash \Gamma_n}{\vdash \Gamma_c}
\]

\emph{Cut Rule}:
\[
  \frac{
    \Gamma_1,[A]_R \quad\quad \Gamma_2,[A]_{\overline{R}}
  }{
    \Gamma_1,\Gamma_2
  }
\]
can be Interpreted as Communication between two Participants in a
Distributed Computation (Abramsky94, Bellin-Scott94); has the same
form as $2$-cut Conj and $2$-cut Disj below


\emph{$n$-cut Conj} for $1 \leq n$:

\[
  \frac{
    \overline{R}_1 \uplus \cdots \uplus \overline{R}_n = P \quad\quad
      \Gamma_1,[A]_{R_1} \quad \cdots \quad \Gamma_n,[A]_{R_n}
  }{
    \Gamma_1, \ldots, \Gamma_n
  }
\]

the pre-condition $\overline{R}_1 \uplus \cdots \uplus \overline{R}_n
= P = \overline{\varnothing}$ on $R_1, \ldots, R_n$ is the same as the
requirement on $R_1, \ldots, R_n$ for ``Linking'' $n$ Matching
Channels of Types $\Chan(R_1,S), \ldots, \Chan(R_1,S)$ (see above)
%FIXME above needs clarification


\emph{$n$-cut Disj} for $1 \leq n$:

\[
  \frac{
    R_1 \uplus \cdots \uplus R_n = P \quad\quad
      \Gamma_1,[A]_{R_1} \quad \cdots \quad \Gamma_n,[A]_{R_n}
  }{
    \Gamma_1, \ldots, \Gamma_n
  }
\]


\textbf{Syntax}

$t$ -- standard First-order Terms

$\otimes_r$, $\&_r$, $!_r$, $\forall_r$ -- Logical Connectives for
each $r \in R$

Formulas:
\[
  A ::=\ a \ |\ A_1 \otimes_r A_2 \ |\ A_1 \&_r A_2 \ |\ !_r(A)
    \ |\ \forall_r(\lambda x.A)
\]
where $a$ ranges over Primitive Formulas

$[?(A)]_R$ will be written to mean $[!_r(A)]_R$ for some $r \notin R$
and $?(\Gamma)$ will mean that each I-formula in $\Gamma$ is of the
Form $[?(A)]_R$

$\{[A]_R\}$ is a Sequent consisting only of $[A]_R$ if $A$ is not of
the form $!_r(B)$ for $r \notin R$ or some repeated occurrences of
$[A]_R$ otherwise, i.e. if $A$ is of the form $!_r(B)$ for $r \notin
R$ %FIXME confusing


\textbf{LMRL$_\wedge$}

Conjunctive LMRL

\emph{Inference Rules}:
\begin{itemize}
  \item \emph{Id$_\wedge$}
  \item \emph{$\otimes_r$-Neg}
  \item \emph{$\otimes_r$-Pos}
  \item \emph{$\&_r$-NegL}, \emph{$\&_r$-NegR}
  \item \emph{$\&_r$-Pos}
  \item \emph{$!_r$-Pos}
  \item \emph{$!_r$-NegWeaken}, \emph{$!_r$-NegDerelict},
    \emph{$!_r$-NegContract}
  \item \emph{$\forall_r$-Neg}
  \item \emph{$\forall_r$-Pos}
\end{itemize}

\emph{Major I-formula} %FIXME

$|A|$ -- Number of Connectives in Formula $A$

$\mathbf{D}$ -- a Derivation Tree (\S\ref{sec:concrete_syntax})

$ht(\mathbf{D})$ -- Height of a Derivation Tree

$\mathbf{D} :: \Gamma$ -- Derivation of $\Gamma$

\emph{Substitution} %FIXME

\emph{Lemma} (Admissibility of $n$-Cut-Conj for $n = 1$) -- $(\Gamma,
     [A]_\varnothing) \Rightarrow \Gamma$ is Admissible in
     LMRL$_\wedge$

\emph{Lemma} ($\eta$-expansion) -- $\Unit \Rightarrow [A]_{R_1}, \ldots,
     [A]_{R_n}$ is Admissible in LMRL$_\wedge$ where $R_1 \uplus
     \cdots \uplus R_n = \overline{\varnothing}$

\emph{Lemma} (2-cut with Spill) -- given Disjoint $\overline{R_1}$ and
$\overline{R_2}$ the Rule:
\[
  (\Gamma_1, [A]_{R_1}; \Gamma_2,[A]_{R_2}) \Rightarrow
    \Gamma_1, \Gamma_2, [A]_{R_1 \cap R_2}
\]
is Admissible in LMRL$_\wedge$

\emph{Lemma} (2-cut):
\[
  (\Gamma_1, [A]_R : \Gamma_2, [A]_{\overline{R}})
    \Rightarrow \Gamma_1,\Gamma_2
\]
is Admissible in LMRL$_\wedge$

\emph{Lemma} ($n$-cut) -- for Subsets of $P$ $R_1,\ldots,R_n$ for some
$1 \leq n$ such that:
\[
  \overline{R_1} \uplus \cdots \overline{R_n} = \overline{\varnothing}
    = P
\]
then:
\[
  (\Gamma_1,[A]_{R_1}; \ldots; \Gamma_n,[A]_{R_n})
    \Rightarrow \Gamma_1, \ldots, \Gamma_n
\]
is Admissible in LMRL$_\wedge$

\emph{Lemma} (Splitting):
\[
  (\Gamma,[A]_{R_1 \uplus R_2}) \Rightarrow \Gamma,[A]_{R_1},[A]_{R_2}
\]
is Admissible in LMRL$_\wedge$


\textbf{LMRL$_\vee$}

Disjunctive LMRL

Dual of LMRL$_\wedge$

\emph{Inference Rules}:
\begin{itemize}
  \item \emph{Id$_\vee$}
  \item \emph{$\parr_r$-Pos}
  \item \emph{$\parr_r$-Neg}
  \item \emph{$\oplus_r$-PosL}, \emph{$\&_r$-PosR}
  \item \emph{$\oplus_r$-Neg}
  \item \emph{$?_r$-PosWeaken}, \emph{$?_r$-PosDerelict},
    \emph{$?_r$-PosContract}
  \item \emph{$?_r$-Neg}
  \item \emph{$\exists_r$-Pos}
  \item \emph{$\exists_r$-Neg}
\end{itemize}

\emph{Lemma}:
\[
  (\Gamma, [A]_{\overline{\varnothing}}) \Rightarrow \Gamma
\]
is Admissible in LMRL$_\vee$

\emph{Lemma} ($\eta$-expansion)

\emph{Lemma} (2-cut with Spill)

\emph{Lemma} (2-cut)

\emph{Lemma} (Multi-cut)

\emph{Lemma} (Co-plitting)



\textbf{Negation}

\emph{Not$_\wedge$} Rule:
\[
  \frac{
    \Gamma, [A]_R
  }{
    \Gamma, [\neg A]_{\overline{R}}
  }
\]

LMRL$_\wedge$ extended with the Not$_\wedge$ Rule is equivalent to
Classical Linear Logic when the Set $P$ of Roles is $\{0,1\}$, then:
\begin{itemize}
  \item $\wedge_0$ and $\wedge_1$ correspond to $\wedge$ and $\vee$,
    resp.
  \item $\forall_0$ and $\forall_1$ correspond to $\forall$ and
    $\exists$, resp.
\end{itemize}

Not$_\wedge$ invalidates the Admissibility of $n$-cut for any $n \neq
2$-- LMRL can be seen as a form of \emph{Negation-less Logic}: the
Negation of an I-formula $[A]_R$ is the I-formula $[A]_{\overline{R}}$
\emph{but there is not a Negation of Formula $A$ per-se}, i.e.
Negation cannot be \emph{internalized} in LMRL for $n$-cut to be
preserved


\endgroup



\paragraph{Elementary Linear Logic}\label{sec:elementary_linear_logic}\hfill

\paragraph{Classical Linear Logic}\label{sec:classical_linear_logic}\hfill

$2$-theory of $*$-autonomous Categories (\S\ref{sec:star_autonomous})

\url{https://golem.ph.utexas.edu/category/2018/05/linear_logic_for_constructive.html}:

Intuitionistic Linear Logic with Tensor Product $\otimes$ and Internal-hom
$\multimap$ corresponds to Closed Symmetric Monoidal Lattices instead of
Cartesian Closed; Star-autonomous Lattice is a Closed Symmetric Monoidal
Lattice with an Object $\bot$ (not necessarily the Bottom Element) such that $P
\equiv (P \multimap \bot) \multimap \bot$, which also has a Cotensor Product
with Internal-hom definable in terms of the Cotensor Product, $(P \multimap Q)
\equiv (P^\bot \parr Q)$, with corresponding Logic as Classical Linear Logic
having two Conjunctions $\wedge$, $\otimes$ (Additive and Multiplicative,
resp.) and two Disjunctions $\vee$, $\parr$ (Additive and Multiplicative,
resp.); Closed Symmetric Monoidal Lattices include all Heyting Algebras

Meaning Explanation for Classical Linear Logic:
\begin{itemize}
  \item a Proof of $P \wedge Q$ is a Proof of $P$ together with a Proof of $Q$
    and a Refutation of $P \wedge Q$ is either a Refutation of $P$ or a
    Refutation of $Q$
  \item a Proof of $P \vee Q$ is a Proof of $P$ or a Proof of $Q$ and a
    Refuration of $P \vee Q$ is a Refutation of $P$ together with a Refutation
    of $Q$
  \item a Proof of $P^\bot$ is a Refutation of $P$ and a Refutation of $P^\bot$
    is a Proof of $P$
  \item a Proof of $P \otimes Q$ is a Proof of $P$ together with a Proof of $Q$
    and a Refutation of $P \otimes Q$ is a Construction of a Refutation of $Q$
    from any Proof of $P$ and a Construction of a Refutation of $P$ from any
    Proof of $Q$
  \item a Proof of $P \parr Q$ is a Construction of a Proof of $Q$ from any
    Refutation of $P$ and a Construction of a Proof of $P$ from any Refutation
    of $Q$, and a Refutation of $P \parr Q$ is a Refutation of $P$ together
    with a Refutation of $Q$
\end{itemize}

(FIXME: clarify ``Construction'')

cf. Proof Clauses of $P \parr Q$ to Disjunctive Syllogism



\paragraph{Light Linear Logic}\label{sec:light_linear_logic}\hfill

Characterizing Complexity Classes (\S\ref{sec:complexity_class})

Light Affine Set Theory (\S\ref{sec:light_affine_set_theory})



\paragraph{Multiplicative Linear Logic}\hfill
\label{sec:multiplicative_linear_logic}

\cite{haghverdi-scott05}

$MLL$

Multiplicative Exponential Linear Logic $MELL$

Multiobject Geometry of Interaction (\S\ref{sec:multiobject_goi})



\paragraph{Soft Linear Logic}\label{sec:soft_linear_logic}\hfill



\subsubsection{Subsingleton Logic}\label{sec:subsingleton_logic}

fragment of Inuitionistic Linear Logic which has Sequents consisting
of at most one Antecedent (\emph{Subsingleton Context Restriction})

DeYoung-Pfenning16 -- $\oplus$,$\mathbf{1}$-subsingleton Logic

\fist $\oplus$,$\mathbf{1}$-$\mu$-subsingleton Logic
(\S\ref{sec:modal_mu_logic})

Curry-Howard Isomorphism between Subsequential Finite-state
Transducers (SFTs \S\ref{sec:sft}) and a Class of Cut-free
Subsingleton Proofs:
\begin{itemize}
  \item Propositions as Languages
  \item Proofs as SFTs
  \item Cut Reductions are SFT Computation Steps
\end{itemize}



\subsubsection{Non-commutative Logic}\label{sec:noncommutative_logic}
\hfill

\fist Ordered Logic (\S\ref{sec:ordered_logic})

combines Commutative Connectives of Linear Logic
(\S\ref{sec:linear_logic}) with Noncommutative Multiplicative
Connectives of Lambek Calculus (\S\ref{sec:lambek_grammar})



% --------------------------------------------------------------------
\subsection{Bunched Logic}\label{sec:bunched_logic}
% --------------------------------------------------------------------

\begingroup

\newcommand{\implmult}{\mathrlap{\rightarrow}*}
\renewcommand{\Id}{\mathbf{I}}

(or \emph{Logic of Bunched Implications})

Tree of Hypotheses instead of flat List

Modelled by Kripke Semantics with Worlds having a Monoidal Product
% FIXME

basis of the ``Assertion Language'' of Separation Logic
(\S\ref{sec:separation_logic})

Distributed Systems (Pym)

O'Hearn-Pym99 \emph{The Logic of Bunched Implications}:

$\textbf{BI}$

can be viewed as a merging of Intuitionistic Logic (IL) and
Multiplicative Intuistionistic Linear Logic (MILL)

Models of Bunched-implication Proofs are given by Bicartesian Doubly
Closed Categories (\S\ref{sec:bicartesian_doubly_closed}), i.e.
Categories that combine the Semantics of Propositional Intuitionistic
Logic (Cartesian Closed Categories) and Propositional Intuitionistic
Multiplicative Linear Logic (Symmetric Monoidal Categories)

Multiplicative (or Linear) Implication

Additive (or Intuitionistic) Implication

Context-forming Operations -- ``;'' (Additive-- allows Contraction and
Weakening) and ``,'' (Multiplicative-- Linear):
\[
  \frac{\Gamma,\varphi \vdash \psi}
    {\Gamma \vdash \varphi \implmult \psi}
  \quad\quad\quad
  \frac{\Gamma;\varphi \vdash \psi}
    {\Gamma \vdash \varphi \rightarrow \psi}
\]

Antecedants as Sequences are replaced by Antecedants as \emph{Trees}
with Propositions as Leaves and internal Nodes Labelled by ``;'' and
``,'', called \emph{Bunches}

cf. use of Bunches in Relevance Logic (\S\ref{sec:relevance_logic};
Anderson-Belnap75)

Predicative version of BI includes Multiplicative, \emph{Intensional}
(cf. Modal), Quantifiers $\forall_{new}$ and $\exists_{new}$ arising
from restrictions on Structural Rules of Terms as well as Propositions


\textbf{Propositional BI}

Additive Connectives: $\One$ $\wedge$ $\rightarrow$ $\bot$ $\vee$

Multiplicative Connectives: $\Id$ $*$ $\implmult$

Bunches:
\begin{flalign*}
  \Gamma ::=\ \varphi \ |\ \{\}_m \ |\ \Gamma,\Gamma \ |\ \{\}_a
    \ |\ \Gamma;\Gamma
\end{flalign*}
where $\{\}_m$ and $\{\}_a$ and Multiplicative and Additive
combination, resp.

$\Gamma(\Delta)$ -- a Bunch in which $\Delta$ appears as a Sub-tree
and $\Gamma(\Delta')$ is the Tree where $\Delta'$ replaces $\Delta$

\emph{Coherent Equivalence} -- $\Gamma \equiv \Gamma'$ is the least
Equivalence Relation on Bunches satisfying:
\begin{enumerate}
  \item Commutative Monoid Equations for $\{\}_a$ and $;$
  \item Commutative Monoid Equations for $\{\}_m$ and $,$
  \item Congruence: if $\Delta\equiv\Delta'$ then $\Gamma(\Delta)
    \equiv \Gamma(\Delta')$
\end{enumerate}

Judgements: $\Gamma \vdash \varphi$ where $\Gamma$ is a Bunch and
$\varphi$ is a Formula

Derivation Rules: TODO


\endgroup


\subsubsection{Deep Inference}\label{sec:deep_inference}

\subsubsection{Hoare Logic}\label{sec:hoare_logic}

(or \emph{Floyd-Hoare Logic})

\emph{Concurrency}

Programming: Axioms and Inference Rules for reasoning about Imperative
Programs

\emph{Hoare Triple}:
\[
  {P} C {Q}
\]
where $P$ and $Q$ are ``\emph{Assertions}'' (Formulae in Predicate
Logic) and $C$ is a \emph{Command}; $P$ is called the
\emph{Precondition} and $Q$ is called the \emph{Postcondition}

Idris $\mono{states}$ library (Brady16) -- \emph{Input State}
(Precondition), \emph{Output State} (Postcondition)

Dijkstra75 -- Guarded Command Language (GCL): Predicate Transformer
Semantics (\S\ref{sec:predicate_transformer_semantics})

\asterism

2013 - Meredith, Stay, Drossopoulou - \emph{Policy as Types} --
\emph{Capability Policies}: Language of Behavioral Types corresponding to
Hennessy-Milner Logic (\S\ref{sec:hennessy_milner}) suffices as a \emph{Security
  Policy Language};

\emph{Deniability} --
describes Policies which are \emph{Open} (i.e. apply to a ``Module'' as well as
to its ``Extensions'') and describes \emph{Necessary Conditions} for some
``Effect'' to take place; cf. classical Hoare Logic where
specifications describe \emph{Sufficient Conditions} and are
  \emph{Closed}



\paragraph{Separation Logic}\label{sec:separation_logic}\hfill

Reynolds02 \emph{Separation Logic: a logic for shared mutable data
  structures}

technique for proving the disjointness of different parts of heap memory

Caires04 - \emph{Behavioral and Spatial Observations in a Logic for the
  Pi-calculus} -- including Separation Operator makes the Logic strictly more
``observent'' than Bisimulation; adjunct to Rely-guarantee

\fist Behavioral Separation Types (\S\ref{sec:behavioral_separation})

Dinsdale-Young,Birkedal,Gardner,Parkinson,Yang - \emph{Views: Compositional
Reasoning for Concurrent Programs} - 2013

analogy of Capabilities and Formulas of Separation Logic
%FIXME xref calculus of capabilities

cf. Spatial Separation (Spatial Logic \S\ref{sec:spatial_logic}), Namespace
Logic (\S\ref{sec:namespace_logic}): a Spatial Logic with Formulae for
Separation (corresponding to the structural content of the Parallel Operator in
RHO Calculus \S\ref{sec:rho_calculus}) in addition to Action Modailities

the ``Assertion Language'' of Separation Logic is a special case of
Bunched Logic (\S\ref{sec:bunched_logic})

%FIXME the following video relates resource semantics to separation
%logic

\url{https://www.youtube.com/watch?v=SaROSWf3a1E} Pym16:

Resource Semantics, Program Verification, Abduction ???

VeriFast ???

Frama-C \emph{Jessie} plugin

Frame Rule, \fist $(ext)$ Subtype Rule in ATS/SV (\S\ref{sec:ats_sv})



\subparagraph{Concurrent Separation Logic}
\label{sec:concurrent_separation}\hfill

O'Hearn2004 \emph{Resources, Concurrency and Local Reasoning}

Brookes2004 \emph{A semantics for concurrent separation logic} --
Action Traces

Assertions as \emph{Permissions}



% --------------------------------------------------------------------
\subsection{Ordinal Logic}\label{sec:ordinal_logic}
% --------------------------------------------------------------------

Alan Turing's PhD Thesis \cite{turing38}



% --------------------------------------------------------------------
\subsection{Categorical Logic}\label{sec:categorical_logic}
% --------------------------------------------------------------------

Many-sorted Logic, Type Theory, Categorical Logic

represents both Syntax and Semantics by \emph{Categories}
(\S\ref{sec:category}), and Interpretation by a \emph{Functor}

\begin{itemize}
  \item Syntax and Symantics are given by a Category
  \item Interpretation is given by a Functor
\end{itemize}

Syntactic Category (\S\ref{sec:syntactic_category})

Internal Language (\S\ref{sec:internal_logic})

Categorical Semantics (\S\ref{sec:categorical_semantics})

Topos Theory (\S\ref{sec:topos_theory})

Categorical Algebra


\textbf{First-order Categorical Logic}

youtube: Caramello - Introduction to categorical logic, classifying
toposes

Semantics: Mathematical Structures (\S\ref{sec:structure})

Syntax: First-order Languages (\S\ref{sec:firstorder_logic}) --
Sorts, Terms, Formulas

Grothendieck Topos (\S\ref{sec:grothendieck_topos})

Sorts: Kinds of Individuals (e.g. Objects, Morphisms) %FIXME xref kinds?

Terms: Individuals

Formulas: Assertions about Individuals


First-order Signature $\Sigma$:
\begin{itemize}
  \item $\Sigma_{sort}$ -- $A,B,C,\ldots$
  \item $\Sigma_{fun}$ -- $f : A_1, \ldots, A_n \rightarrow B$
  \item $\Sigma_{rel}$ -- $R \hookrightarrow A_1 \times \cdots \times
    A_n$
\end{itemize}

Context $\overline{x}$ -- Finite Set of Free Variables

Sequent $\varphi \vdash_{\overline{x}} \psi$

$\forall \overline{x} (\varphi \Rightarrow \psi)$

Model, Interpretation

$\struct{M}$

$\llbracket \overline{x}.\varphi \rrbracket_M \hookrightarrow M(A_1)
\times \cdots \times M(A_n)$


Algebraic Theory -- Axioms of form $\top \vdash t = s$ (Equalities
between Terms)

Regular Theories -- $\varphi \vdash_{\overline{x}} \psi$ ($\varphi$,
$\psi$ Regular: $\exists$, Finitary $\wedge$)

Coherent Theories -- ($\varphi$, $\psi$ Coherent: $\exists$, Finitary
$\wedge$, $\vee$)

Geometric Logic -- ($\varphi$, $\psi$ Geometric: $\exists$, Finitary
$\wedge$, Infinitary $\vee$)

%FIXME xrefs



\subsubsection{Term-model Construction}\label{sec:term_model}

\subsubsection{Internal Logic}\label{sec:internal_logic}

or \emph{Internal Language}

Simply-typed $\lambda$ Calculus gives the Internal Logic for
Cartesian Closed Categories

Extensional Martin-L\"of Type Theories give the Internal Logic for
Cartesian Closed Quasicategories

$Lan$ -- Functor from Categories to Type Theories; Right-adjoint
(\S\ref{sec:adjoint_functor}) to Functor $Syn$ mapping Theories to
Syntactic Categories (\S\ref{sec:syntactic_category})



% --------------------------------------------------------------------
\subsection{Free Logic}\label{sec:free_logic}
% --------------------------------------------------------------------

\subsubsection{Inclusive Logic}\label{sec:inclusive_logic}



% --------------------------------------------------------------------
\subsection{Connexive Logic}\label{sec:connexive_logic}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Non-monotonic Logic}\label{sec:nonmonotonic_logic}
% --------------------------------------------------------------------

Defeasible Inference (\S\ref{sec:defeasible_inference})



\subsubsection{Default Logic}\label{sec:default_logic}

Default Inference (\S\ref{sec:default_inference})



\subsubsection{Autoepistemic Logic}\label{sec:autoepistemic_logic}



% --------------------------------------------------------------------
\subsection{Paraconsistent Logic}\label{sec:paraconsistent_logic}
% --------------------------------------------------------------------

existance of a Contradiction will not cause an ``Explosion''

Relevance Logic (\S\ref{sec:relevance_logic})--no Weakening Rule--is a
Paraconsistent Logic



\subsubsection{Discursive Logic}\label{sec:discursive_logic}

\subsubsection{Non-adjunctive Logic}\label{sec:nonadjunctive_logic}

\subsubsection{Adaptive Logic}\label{sec:adaptive_logic}

\subsubsection{Formal Inconsistency}\label{sec:formal_inconsistency}

\subsubsection{Logic of Paradox}\label{sec:logic_of_paradox}

Graham Priest



% --------------------------------------------------------------------
\subsection{Mereology}\label{sec:mereology}
% --------------------------------------------------------------------

Nominalism (\S\ref{sec:nominalism})



% ====================================================================
\section{Universal Logic}\label{sec:universal_logic}
% ====================================================================

Institutions (\S\ref{sec:institution})



% ====================================================================
\section{Metalogic}\label{sec:metalogic}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Logical Quality}\label{sec:logical_quality}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Logical Truth}\label{sec:logical_truth}
% --------------------------------------------------------------------

\emph{Interpretation} (\emph{Valuation}, \emph{Assignment})
\S\ref{sec:interpretation}

\emph{Corresponding Conditional} is \emph{Logical Truth}

\emph{Satisfiable}

\emph{Necessarily True}

\emph{Semantic Theory} (\S\ref{sec:semantic_truth})

\emph{Correspondence Theory} (\S\ref{sec:correspondence_truth})

\emph{Deflationary Theory} (\S\ref{sec:deflationary_truth})



\subsubsection{Truth-value}\label{sec:truth_value}

\emph{Truth-value} (\emph{Logical Value})

In Intuitionistic Type Theory (\S\ref{sec:intuitionistic_type}),
\emph{Types} take the place of Truth-values.

A Truth-value is the Extension (\S\ref{sec:extension}) of a Sentence
(\S\ref{sec:sentence}).

(Corfield2018): Partially Ordered Sets (\S\ref{sec:poset}) can be considered as
Categories (\S\ref{sec:category}) ``enriched'' in Truth Values (FIXME: clarify)



\paragraph{Vacuous Truth}\label{sec:vacuous_truth}\hfill

A \emph{Vacuous Truth} is a Conditional Statement with a False
Antecedent (\S\ref{sec:antecedent}).

A Sentence (\S\ref{sec:sentence}) that Asserts (\S\ref{sec:assertion})
all Members of the Empty Set have a certain Property
(\S\ref{sec:property}) is also a Vacuous Truth and may be also be
reduced to a Conditional Statement with a False Antecedent.

Used as Base Case in Proofs by Mathematical Induction
(\S\ref{sec:mathematical_induction})



\subsubsection{Truth-bearer}\label{sec:truth_bearer}

\begin{itemize}
  \item Proposition
  \item Type-token
  \item Judgement
\end{itemize}



\paragraph{Proposition}\label{sec:proposition}\hfill

A \emph{Proposition} is the Referent (\S\ref{sec:referent}) of a Propositional
Formula (\S\ref{sec:propositional_formula}) or other Content Clause
(\S\ref{sec:content_clause}).



\subsubsection{Analytic Truth}\label{sec:analytic_truth}

\paragraph{Truth Preservation}\label{sec:truth_preservation}\hfill

\emph{Truth-preserving}

\emph{False-preserving}

\emph{Non-preserving}

cf. Probabilistic Logic (\S\ref{sec:probabilistic_logic}): Probabilistic
Semantics for the Consequence Relation yields \emph{Probability Preserving}
Deductive Validity (\S\ref{sec:validity}), rather than Truth Preserving
(\url{https://plato.stanford.edu/entries/logic-probability/})



\paragraph{$n$-validity}\label{sec:n_validity}\hfill

\paragraph{$\omega$-validity}\label{sec:omega_validity}\hfill



\subsubsection{Truth Function}\label{sec:truth_function}

A \emph{Truth Function} is a Function to and from Truth-values
(\S\ref{sec:truth_value}).



\subsubsection{Soundness}\label{sec:soundness}

\emph{Sound}

A Logical Argument (\S\ref{sec:logical_argument}) is Sound if and only
if it is Valid (\S\ref{sec:validity}) and all of its Premises are
True.

A Formal System (\S\ref{sec:formal_system}) is Sound if and only if its
Inference Rules (\S\ref{sec:inference_rule}) Prove only Valid Formulas under
Semantic Interpretation (\S\ref{sec:interpretation}). This usually amounts to
the simple requirement that the \emph{Axioms are Valid} and the \emph{Inference
  Rules preserve Validity}, i.e. any Theorem Provable in the System is Valid,
thus all Provable Sentences are True.

In a Theory, $\mathcal{T}$, of Propositional
(\S\ref{sec:propositional_calculus}) or First-order Logic
(\S\ref{sec:firstorder_logic}):
\[
  \Gamma \vdash \varphi \Rightarrow \Gamma \vDash \varphi
\]
where $\Gamma$ is a Set of Sentences and $\varphi \in \mathcal{T}$.

The converse of Soundness, Completeness (\S\ref{sec:completeness}) requires
that \emph{all True Sentences are Provable}. By the Incompleteness Theorem
(\S\ref{sec:incompleteness_theorem}), not all Sound Deductive Systems are
Complete. In Propositional and First-order Logic, Soundness and Completeness
are equivalent Properties.

\emph{Weak Soundness}

\emph{Strong Soundness}

\emph{Arithmetic Soundness}



% --------------------------------------------------------------------
\subsection{Logical Inference}\label{sec:logical_inference}
% --------------------------------------------------------------------

\emph{Logical Inference} (or \emph{Logical Reasoning})

\begin{enumerate}
\item \emph{Premise} (\emph{Precondition}, \emph{Antecedent})

\item \emph{Material Conditional} (\emph{Corresponding Conditional},
  \emph{Implication Rule}, \emph{Inference Rule} (?)
  \S\ref{sec:inference_rule})

\item \emph{Logical Consequence} (\emph{Conclusion},
  \emph{Consequent}, \emph{Idiomatic})
\end{enumerate}

The Premise and Conclusion are \emph{Truth-bearers}
(\S\ref{sec:truth_bearer}).

\begin{description}
\item [Coherent] \hfill\\
  \S\ref{sec:paraconsistent_inference}
  \emph{Paraconsistent Inference}

\item [Consistent] \hfill\\
  \S\ref{sec:deductive_inference} \emph{Deductive Inference}

\item [Non-monotonic] \hfill\\
  \S\ref{sec:inductive_inference} \emph{Inductive Inference}

  \S\ref{sec:abductive_inference} \emph{Abductive Inference}

\end{description}

? \emph{Analogical Inference}



% --------------------------------------------------------------------
\subsection{Logical Consequence}\label{sec:logical_consequence}
\cite{beall-restall05}
% --------------------------------------------------------------------

\emph{Logical Consequence} (\emph{Entailment}):
\[
  S \in \mathbf{L}, D \subset \mathbf{L}, S \leftrightarrow D
\]
\begin{itemize}
  \item 1. Logical Form (\S\ref{sec:logical_form})
  \item 2. A Priori
  \item 3. Modality (\S\ref{sec:modality})
\end{itemize}

A Premise \emph{Logically Entails} a Conclusion if and only if the
negation of the Conclusion is \emph{Logically Inconsistent} with the
Premises.



\subsubsection{Formal Consequence}\label{sec:formal_consequence}

\emph{Syntactic Consequence} (\S\ref{sec:syntactic_consequence})

\emph{Semantic Consequence} (\S\ref{sec:semantic_consequence})

\emph{Validity} (\S\ref{sec:validity})



\subsubsection{Material Consequence}

\emph{Material Consequence} (\emph{Implication})



% --------------------------------------------------------------------
\subsection{Paraconsistent Inference}\label{sec:paraconsistent_inference}
\cite{priest-tanaka-weber13}
% --------------------------------------------------------------------

\subsubsection{Paraconsistent Consequence}\label{sec:paraconsistent_consequence}

A Logical Consequence Relation is a \emph{Paraconsistent Consequence
  Relation} if and only if it is not \emph{Explosive}. Such a Relation
is required to be \emph{Coherent} (\emph{Absolutely Consistent} or
\emph{Non-trivial}), meaning that no Paraconsistent Theory
(\S\ref{sec:formal_theory}) can include all Sentences.

A Consequence Relation $\vDash$ is \emph{Explosive} when:
\[
  \forall A, B. \{A, \neg A\} \vDash B
\]
which is the case with \emph{Consistent Consequence Relations}.



% --------------------------------------------------------------------
\subsection{Deductive Inference}\label{sec:deductive_inference}
% --------------------------------------------------------------------

\emph{Top-down Logic}



\subsubsection{Deductive Consequence}\label{sec:deductive_consequence}

A \emph{Deductive Consequence} is a Modally \emph{Necessary}
Conclusion drawn from given Premises and Inference Rules.

\emph{Consistency}

Deductive Consequence can be extended to provide \emph{Inductive
  Support} in \emph{Inductive Consequence}
(\S\ref{sec:inductive_consequence})



\paragraph{Principle of Explosion}\label{sec:explosion_principle}\hfill

\emph{Principle of Explosion}



\subsubsection{Mathematical Induction}\label{sec:mathematical_induction}

\emph{Mathematical Induction} as an Inference Rule is the
\emph{Implicative} process where a \emph{Base Case} is shown to extend
to the more general by means of Implication (the Inductive step).

Note that Mathematical Induction is not \emph{Inductive Reasoning}
(\S\ref{sec:inductive_inference}) which is an empirical or
Probabilistic Inference (\S\ref{sec:probabilistic_inference}) and not
a form of Deduction. The \emph{Principle of Mathematical Induction}
(\S\ref{sec:induction_principle}) is an application of Mathematical
Induction to the \emph{Natural Numbers} (\S\ref{sec:natural_number}).

The Base Case may be given as a Vacuous Truth
(\S\ref{sec:vacuous_truth}).



\subsubsection{Structural Induction}\label{sec:structural_induction}

Prove that $P(x)$ holds for all $x$ of some Recursively Defined
Structure (\S\ref{sec:recursive_definition}), Inductive Type
(\S\ref{sec:inductive_type}).

Well-founded (\S\ref{sec:well_founded}) Partial Order
(\S\ref{sec:partial_order}) implies that any Non-empty Subset must
have a Minimal Element.

Prove that $P(x)$ holds for all Minimal Structures (Base Case), and if
holding for the immediate Substructures of a Structure $S$, then it
must hold for $S$ also (Inductive Step). %FIXME expand or xref

Smallest Class of things Closed under some ``Constructor'' Operations;
Closed under Intersections \cite{shulman11}

Initial Algebra %FIXME



\paragraph{Coinduction}\label{sec:coinduction}\hfill

Dual to Structural Induction

Largest Class of things Closed under some ``Destructor'' Operations;
Closed under Unions \cite{shulman11}

Coalgebra (\S\ref{sec:coalgebra}), Terminal Coalgebra
(\S\ref{sec:terminal_coalgebra})

Describes how an Object can be ``Observed'', ``Broken Down'', or
``Destructed''

\emph{Codata} (\S\ref{sec:coinductive_type})

Prove that $P(x)$ holds for all Implementations of a Specification
%FIXME expand or xref



\subsubsection{Noetherian Induction}\label{sec:noetherian_induction}

\emph{Well-founded Relation}



\subsubsection{Transfinite Induction}\label{sec:transfinite_induction}

Extension of Mathematical Induction
(\S\ref{sec:mathematical_induction}) to Well-ordered Sets
(\S\ref{sec:well_order}), e.g. Ordinal Numbers
(\S\ref{sec:ordinal_number})

Zero Case

Successor Case

Limit Case

Transfinite Recursion (\S\ref{sec:transfinite_recursion})



% --------------------------------------------------------------------
\subsection{Inductive Inference}\label{sec:inductive_inference}
\cite{hawthorne08}
% --------------------------------------------------------------------

extension of Deductive Logic (\S\ref{sec:deductive_inference}) to
less-than-certain Inferences

\emph{Logical Induction}, \emph{Inductive Logic}, \emph{Inductive Reasoning}

Logical Uncertainty (\S\ref{sec:uncertainty})

makes extensive use of Probabilistic (Part \ref{sec:probability_theory})
notions; most work on Inductive Logic falls under the ``Probability
Preservation'' approach
\fist cf. Probabilistic Logic (\S\ref{sec:probabilistic_logic})

Garrabrant, Benson-Tilsen, Critch, Soares, Taylor - \emph{Logical
  Induction} %FIXME

\emph{Universal Inductive Inference}



\subsubsection{Inductive Consequence}\label{sec:inductive_consequence}

\emph{Inductive Consequence} (\emph{Inductive Support}) is an
extension of Deductive Consequence where the Modality of Necessity is
relaxed to that of \emph{Sufficiency}.



\subsubsection{Defeasible Inference}\label{sec:defeasible_inference}



% --------------------------------------------------------------------
\subsection{Abductive Inference}\label{sec:abductive_inference}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Structural Inference}\label{sec:structural_inference}
% --------------------------------------------------------------------

*FIXME* (Pfenning-OPLSS17-lecture)

``\emph{Saturation}'' -- any further Inference gives a ``fact already
known'' (as in Datalog-- Subset of Prolog for Queries in Deductive
Databases)

\fist cf. Structural Induction (\S\ref{sec:structural_induction})

\fist cf. Substructural Logic (\S\ref{sec:substructural_logic})



\subsubsection{Linear Inference}\label{sec:linear_inference}

Linear Exchange

Persistent Resources, Linear Resources



\subsubsection{Grammatical Inference}\label{sec:grammatical_inference}

\fist Categorial Grammar (\S\ref{sec:categorial_grammar})

\fist Simply-typed $\lambda$-calculus (\S\ref{sec:simply_typed})



% --------------------------------------------------------------------
\subsection{Default Inference}\label{sec:default_inference}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Logical Argument}\label{sec:logical_argument}
% --------------------------------------------------------------------

A \emph{Logical Argument}, \emph{Formal Argument}, or
\emph{Derivation} (see \S\ref{sec:formal_proof} \emph{Formal Proof})
is a sequence of Logical Inferences. Generally this is an Ordered Set
of Sentences (\S\ref{sec:truth_bearer} Truth-bearers).



\subsubsection{Corresponding Conditional}\label{sec:corresponding_conditional}

The \emph{Corresponding Conditional} of a Derivation is a
\emph{Material Conditional} (\S\ref{sec:material_conditional}) whose
Antecedent is the Conjunction of the Derivation's Premises and whose
Consequent is the Derivation's Conclusion.



% --------------------------------------------------------------------
\subsection{Logical Form}\label{sec:logical_form}
% --------------------------------------------------------------------

Normal Form (\S\ref{sec:normal_form})

The Logical Form of an \emph{Argument} (\S\ref{sec:logical_argument})
is Derived from the Logical Form of its constituent Sentences. When
considering Terms as \emph{Schematic Variables}
(\S\ref{sec:metavariable}), the Logical Form of the whole Argument or
\emph{Argument Form} is called the \emph{Schemata} or
\emph{Inferential Structure} of the Argument.



Logical Constant (\S\ref{sec:logical_constant})



% --------------------------------------------------------------------
\subsection{Property}\label{sec:property}
% --------------------------------------------------------------------

\emph{Properties} (or \emph{Predicables} or \emph{Attributes}
\S\ref{sec:attribute}) are Objects that can be Predicated of other
Objects. A Predicate (\S\ref{sec:predicate}) or \emph{Relation} (cf.
Set Relation \S\ref{sec:set_relation}) is not itself the Property, but
the \emph{Extension} (\S\ref{sec:extension}) of that Property.

An Extension of a Property is a Class (\S\ref{sec:class}), but not
every Property has an Extension as exemplified by Russell's Paradox
(\S\ref{sec:russells_paradox}).

\emph{Predicativity / Impredicativity} - Weyl

\emph{Vicious Circle Principle}

Circular Definition (\S\ref{sec:circular_definition})

Explicit Circularity

Circular Quantification

cf. \emph{Descriptive Predicate} (\emph{Empirical Property}
\S\ref{sec:descriptive_predicate}) (Carnap)

The Property of ``Predicability'' is Impredicative
(\S\ref{sec:impredicative_definition}), that is, it can't be defined
within a Ramified Theory of Types.\cite{kleene52}

definition of a Property in the Abstract Categorical setting: Properties
correspond to Fully Faithful Functors (\S\ref{sec:fully_faithful}), i.e.
Functors that induce Bijections on Hom-sets; cf. \emph{Structure}
(\S\ref{sec:structure}) corresponds to Faithful (\S\ref{sec:faithful_functor}),
but not Full Functors

see also:
\begin{itemize}
  \item Invariant (\S\ref{sec:invariant}) -- a Property held by a Class of
    objects which remains unchanged under Transformations of a certain type
  \item Locus (Geometry \S\ref{sec:locus}) -- Set of Points Satisfying some
    Property
  \item Local Property (Topology \S\ref{sec:local_property})
  \item Generic Property (Algebraic Geometry \S\ref{sec:generic_property})
  \item Generic Property (Measure Theory \S\ref{sec:generic_measure_property})
\end{itemize}



\subsubsection{Pointwise}\label{sec:pointwise}
