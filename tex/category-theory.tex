%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Category Theory}\label{sec:category_theory}\cite{awodey06}\cite{maclane69}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ====================================================================
\section{Metacategory}\label{sec:metacategory}
% ====================================================================

The Formal System of Category Theory consists of:
\begin{itemize}
\item two Sorts (\S\ref{sec:sort}), \emph{Objects} $A,B,C,\ldots$, and
  \emph{Arrows} (corresponding to Morphisms) $f,g,h,\ldots$
\item four Operations: $dom(f)$, $cod(f)$, $1_A$, $\circ$
\end{itemize}
and seven Axioms:
\[
  dom(1_A) = A,\quad cod(1_A) = A
\]\[
  f \circ 1_{dom(f)} = f, \quad 1_{cod(f)} \circ f = f
\]\[
  dom(g\circ f) = dom(f), \quad cod(g \circ f) = cod(g)
\]\[
  h \circ (g \circ f) = (h \circ g) \circ f
\]



% --------------------------------------------------------------------
\subsection{Abstract Category}\label{sec:abstract_category}
% --------------------------------------------------------------------

The \emph{Elementary Theory of Abstract Categories} refers to the
First-order Formulas (\S\ref{sec:predicate_logic}) of the Language
of Metacategories.

A Sentence, $\Sigma$, in the Elementary Theory of Abstract Categories
can be made into a Dual Sentence, $\Sigma^*$, by replacing instances
of $cod$ by $dom$ and $dom$ by $cod$, and $h = g \circ f$ with $h = f
\circ g$. The Double-dual is Idempotent (\S\ref{sec:idempotent}):
$\Sigma^{**} = \Sigma$.

Because the Axioms are Self-dual, if a Sentence can be derived from
them, so can its Dual by the Duality Principle
(\S\ref{sec:duality_principle}). Functors (\S\ref{sec:functor}) are
Self-dual, and so they are not reversed as are Morphisms in
Categories.



% --------------------------------------------------------------------
\subsection{Precategory}\label{sec:precategory}
% --------------------------------------------------------------------

A \emph{Precategory} (or \emph{Diagram Scheme}), $G$, is a Directed
Graph (\S\ref{sec:directed_graph}) in the context of Category
Theory. A Precategory is used to generate a \emph{Free Category}
(\S\ref{sec:free_category}). Here we will use the notation for
Categories (\S\ref{sec:category}) to equate Vertices with
Objects $G_0$ and Edges with Morphisms $G_1$. A Precategory can then
be described as a pair of Functions, $cod$ and $dom$, from the Set of
Edges to the Set of Objects:
\[
  G = \{G_1 \rightrightarrows G_0\}
\]

A Morphism $D : G \rightarrow G'$ between Precategories is a pair of
Functions:
\[
  D_0 : G_0 \rightarrow G'_0, \;\;\; D_1 : G_1 \rightarrow G'_1
\]
such that $\forall f \in G_1$:
\[
  D_0(dom(f)) = dom(D_1(f))
\]\[
  D_0(cod(f)) = cod(D_1(f))
\]
Given two Graphs, $A$ and $B$, with the same Set of Objects, $O$, the
Product $\times_O$ over $O$ is defined as:
\[
  A \times_O B = \{ (g,f) | dom(g) = cod(f), g \in A, f \in B \}
\]
the set of Composable Morphisms.

A Category can be seen as a Graph, $G$, with two Morphisms:
\begin{enumerate}
  \item Mapping Composable Morphisms to their Composite:
    \[c : G \times_{G_0} G \rightarrow G\]
  \item Mapping Objects to their Identity Functions:
    \[i: G_0 \rightarrow G_1\]
\end{enumerate}
The \emph{Underlying Graph} of a Category, $\mathbf{C}$, is denoted
$U(\mathbf{C})$ where $U$ is the \emph{Underlying Graph Functor}
(\S\ref{sec:functor}).

For a Morphism of Graphs, $D : G \rightarrow U(\mathbf{B})$, there is
a corresponding Functor of Categories: $D' : \mathbf{C}_G \rightarrow
\mathbf{B}$.

The Category of all Small Directed Graphs and Graph Morphisms is
$\mathbf{Grph}$.

The Forgetful Functor $U : \mathbf{Cat} \rightarrow \mathbf{Grph}$
Maps a Categories to their Underlying Graphs, effectively forgetting
which Morphisms are Identities and which are Composites.



% ====================================================================
\section{Category}\label{sec:category}
% ====================================================================

A \emph{Category} is an Algebraic Structure
(\S\ref{sec:algebraic_structure}) where Functions are Morphisms
(\S\ref{sec:morphism}) between Objects and each Object has a Unique
\emph{Identity Morphism} and where Composition of Morphisms is
Associative and Transitive.

A Category $\mathbf{C}$ is defined as:
\begin{itemize}
\item a Class $C_0$ of Objects
\item a Class $C_1$ of Morphisms (also called \emph{Arrows} or
  \emph{Maps}) with Identity Morphisms for each Object
\item a Binary Associative and Transitive Composition Operation on
  Morphisms
\end{itemize}
$\mathbf{C}$ is considered \emph{Small} (as opposed to \emph{Large})
if both $C_0$ and $C_1$ can be represented as Sets.

An equivalent definition of Categories can be given in terms of
\emph{Hom-sets} (\S\ref{sec:hom_set}).

Example Categories:
\begin{itemize}
\item Sets and (Set) Functions
\item Finite Sets and Injective Functions
\item Posets and Monotonic Functions
\item Monoids and Monoid Homomorphisms
\item Groups and Group Homomorphisms
\item Categories and Functors
\item Formulae and Deductions
\item Functors and Natural Transformations
\item Types and Computable Functions
\end{itemize}
The Category of all Sets and Set Mappings is denoted $\mathbf{Set}$
(and is Dual to the Category of Complete, Atomic Boolean Algebras
(\S\ref{sec:boolean_algebra}). See \emph{List of Categories}
\S\ref{sec:categories_list} for more examples of Categories.

Preorders (\S\ref{sec:preorder}) represent Categories by taking
Elements as Objects and (Single) Morphisms existing between Pairs of
Elements in the Ordering Relation which satisfies the Category Axioms
by the Reflexivity and Transitivity of the Preorder.

The Category of Posets is denoted $\mathbf{Pos}$. A special case of a
Poset Category is a Discrete Category (\S\ref{sec:discrete_category})
which is a Category of Objects with only Identity Morphisms.

A Monoid (\S\ref{sec:monoid}) is a Category with a single Object and
Morphisms for each Element in the Monoid such that Composition of
Morphisms is the Binary Operation of the Monoid. The Category
$\mathbf{Mon}$ is the Category of all Monoids and Functions that
preserve the Monoid structure.

Simplex Category (\S\ref{sec:simplex_category})



% --------------------------------------------------------------------
\subsubsection{Commutative Diagram}\label{sec:commutative_diagram}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Hom-set}\label{sec:hom_set}
% --------------------------------------------------------------------

The collection of all Morphisms between two Objects $X$ and $Y$ in a
Category $\mathbf{C}$ is called the \emph{Hom-set} and is denoted
$Hom(X,Y)$:
\[
  Hom(X,Y) = \{f \in \mathbf{C} | f : X \rightarrow Y\}
\]
This gives a Hom-functor (\S\ref{sec:hom_functor}):
\[
  Hom_\mathbf{C} : \mathbf{C^{op}} \times \mathbf{C} \rightarrow \mathbf{Set}
\]
each half of which is a Representable Functor
(\S\ref{sec:representable_functor}).
\newline
\HandRight\; Note that the Hom-set need not be a Set (it could be a
Proper Class). A Category for which all Hom-sets are Sets is called a
Locally Small Category (\S\ref{sec:locally_small}).

Some Properties of Hom-sets:
\begin{itemize}
\item $ (X,Y) \neq (X',Y') \Rightarrow
  Hom(X,Y) \cap Hom(X',Y') = \varnothing$
\end{itemize}

A definition of Categories can be given in terms of Hom-sets. %FIXME

Internal Hom-set

External Hom-set



% --------------------------------------------------------------------
\subsection{Category Equivalence}\label{sec:category_equivalence}
% --------------------------------------------------------------------

An \emph{Equivalence} between two Categories, $\mathbf{C}$ and
$\mathbf{D}$, $\mathbf{C} \simeq \mathbf{D}$, can be established by a
Pair of Functors (\S\ref{sec:functor}):
\[
  S : \mathbf{C} \rightarrow \mathbf{D}
\]\[
  T : \mathbf{D} \rightarrow \mathbf{C}
\]
and Natural Isomorphisms (\S\ref{sec:natural_transformation}):
\[
  I_\mathbf{C} \cong T \circ S
\]\[
  I_\mathbf{D} \cong S \circ T
\]
$S$ and $T$ in such an Equivalence are Fully Faithful
(\S\ref{sec:fully_faithful}).

\HandRight\;Note Equality of Categories $\simeq$ is distinct from
Isomorphism of Categories $\cong$.

$\mathbf{Set}_{fin} \simeq \mathbf{Ord}_fin$

$\mathbf{Par} \cong \mathbf{Set}$

$\mathbf{Set}^I \simeq \mathbf{Set}/I$

$\mathbf{BA}_{fin} \simeq \mathbf{Set}_{fin}^{op}$

$\mathbf{caBA} \simeq \mathbf{Set}^{op}$ Complete Atomic Boolean
Algebras %FIXME xref



% --------------------------------------------------------------------
\subsection{Subcategory}\label{sec:subcategory}
% --------------------------------------------------------------------

A \emph{Subcategory}, $\mathbf{S}$, of a Category, $\mathbf{C}$, is a
Category whose Objects and Morphisms are in $\mathbf{C}$.

For a Monomorphism in $\mathbf{Cat}$ from a Category $\mathbf{E}$ such
that $E$ is an Equalizer:
\[
  \mathbf{E} \xrightarrow{\;\;E\;\;} \mathbf{C}
  \begin{matrix}
  \xrightarrow{\;\;F\;\;}\\
  \xrightarrow[\;\;G\;\;]{}
  \end{matrix}
  \mathbf{D}
\]
$\mathbf{E}$ is a Subcategory of $\mathbf{C}$.



\subsubsection{Inclusion Functor}\label{sec:inclusion_functor}

For a Subcategory $\mathbf{S}$ of a Category $\mathbf{C}$ there is a
Monomorphic Faithful Functor (\S\ref{sec:faithful_functor}) called the
\emph{Inclusion Functor} which Maps Objects and Morphisms to
themselves:
\[
  I : \mathbf{S} \rightarrow \mathbf{C}
\]
If $I$ is a Full Functor then $\mathbf{S}$ is a \emph{Full
  Subcategory} (\S\ref{sec:full_subcategory}).



\subsubsection{Full Subcategory}\label{sec:full_subcategory}

A Subcategory $\mathbf{S}$ of a Category $\mathbf{C}$ is a \emph{Full
  Subcategory}, denoted $\mathbf{S} \rightarrowtail \mathbf{C}$ if the
corresponding Inclusion Functor is a Full Functor. A Full Subcategory
consists of some Objects and all Morphisms between them.

The Inclusion Functor $\mathbf{Set}_{fin} \rightarrowtail
\mathbf{Set}$ is Fully Faithful (\S\ref{sec:fully_faithful}).



% --------------------------------------------------------------------
\subsection{Finite Category}\label{sec:finite_category}
% --------------------------------------------------------------------

A \emph{Finite Category} has a Finite number of Morphisms and
Objects. An Infinite number of Objects Implies and Infinite number of
Morphisms because each Object has its own Identity Morphism.

A Category such as:
\[
  A
  \begin{matrix}
  \xrightarrow{\;\;f\;\;}\\
  \xleftarrow[\;\;g\;\;]{}
  \end{matrix}
  B
\]
induces an Infinite Category if $f$ and $g$ are not Isomorphisms
(\S\ref{sec:isomorphism}) because new Morphisms exist wherever the
Codomain of one Morphism is the Domain of another: $gf, gfgf, gfgfgf,
\ldots$ and $fg, fgfg, fgfgfg, \ldots$. See \emph{Finitely Presented
  Categories} \S\ref{sec:finitely_presented}.



% --------------------------------------------------------------------
\subsection{Discrete Category}\label{sec:discrete_category}
% --------------------------------------------------------------------

The Discrete Category Functor $S : \mathbf{Set} \rightarrow
\mathbf{Cat}$ is Fully Faithful (\S\ref{sec:fully_faithful}).



% --------------------------------------------------------------------
\subsection{Thin Category}\label{sec:thin_category}
% --------------------------------------------------------------------

A \emph{Thin Category} has at most one Morphism between Objects, e.g.
a Preorder.



% --------------------------------------------------------------------
\subsection{List of Categories}\label{sec:categories_list}
% --------------------------------------------------------------------

\begin{description}
\item [0] no Objects or Morphisms
\item [1] one Object with Identity Morphism
\item [2] two Objects with Identity Morphisms and one Morphism between
  them
\item [3] three Objects with Identity Morphisms in a Commutative
  Triangle
\item [$\downdownarrows$] two Objects and two parallel Morphisms
  between them
\item [$\omega$] the ordinals $\omega$ as a Poset
\item [Set] all Small Sets and Functions (Locally Small)
\item [Set$^\omega$] Sets through time: Functors from $mathbf{\omega}$
  to $\mathbf{Set}$ as Objects and Natural Transformations between
  them as Morphisms
\item [Set$^\downdownarrows$] Graph and Graph Homomorphisms
\item [Cls] all Classes and Functions between Classes
\item [Set$_*$] all Pointed Sets and Base-point preserving Functions
\item [Par] all Sets and Partial Functions
\item [Rel] all Sets and Relations
\item [Pos] all Posets and Monotonic Functions (Locally Small)
\item [Cpo] all Complete Partial Orders and Continuous Functions
\item [Finset] all Finite Sets and Functions (Full Subcategory of
  $\mathbf{Set}$)
\item [Finord] ($\mathbf{\Delta}$) all Finite Ordinal Numbers and
  Order Preserving Maps (Skeleton of $\mathbf{FinSet}$, also called
  the \emph{Simplex Category} \S\ref{sec:simplex_category})
\item [Mag] all Magmas and Homomorphisms of Operations
\item [Med] all Medial Magmas and Homomorphisms of Operations
\item [Mon] all Monoids and Monoid Homomorphisms
\item [Grp] all Groups and Group Homomorphisms (Locally Small)
\item [Ab] all Abelian Groups with Group Homomorphisms
\item [Grpd] all Groupoids and Groupoid Homomorphisms
\item [Rng] all Small Rings and Ring Morphisms
\item [Grph] all Small Graphs and Graph Morphisms
\item [Cat] all Small Categories and Functors
\item [Cat'] all Large Categories and Functors
\item [Vect$_K$] all Finite-dimensional Vector Spaces over Field $K$
  and $K$-linear Transformations
\item [Vect$_\mathbb{R}$] all Finite-dimensional Vector Spaces over
  $\mathbb{R}$ and Linear Maps
\item [Top] all Topological Spaces and Continuous Maps (Locally Small)
\item [Top$_*$] all Pointed Topological Spaces and Continuous Maps
\item [Toph] all Topological Spaces and Homotopy Classes of Continuous
  Maps
\item [Man] all Smooth Manifolds and Smooth Maps
\item [BA] all Boolean Algebras and their Homomorphisms
\item [C($\lambda$)] all Types and Closed Terms
\end{description}

Database Schema (\S\ref{sec:database_schema}): Tables and Foreign Keys



% ====================================================================
\section{Morphism}\label{sec:morphism}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Monomorphism}\label{sec:monomorphism}
% --------------------------------------------------------------------

A \emph{Monomorphism} $f$ between Objects $A$ and $B$ is denoted:
\[
  f : A \rightarrowtail B
\]
and has the property for any two Morphisms $g, h : C \rightarrow A$,
$fg = fh$ Implies $g = h$ ($f$ is Left Cancellative
\S\ref{sec:cancellative_property}). An Monomorphism in a Category
$\mathbf{C}$ is an Epimorphism in $\mathbf{C^{op}}$.

If $f$ is a Monomorphism then $gf$ and $hf$ are Idempotent
(\S\ref{sec:idempotent}). %FIXME correct ???

Functions between Sets (any Morphism in a Concrete Category
\S\ref{sec:concrete_category}) are Monomorphisms if they are Injective
Functions. In $\mathbf{Set}$ Monomorphisms are exactly the Injective
Functions between Sets. This is also true in the Categories
$\mathbf{Grp}$, $\mathbf{Rng}$, and any Abelian Category
(\S\ref{sec:abelian_category}).

Equalizers (\S\ref{sec:equalizer}) are always Monomorphisms and as
such are used to define the notion of Subobject
(\S\ref{sec:subobject}).

\HandRight\; Note not all Monomorphisms are required to be Injective.

Left-invertible Morphisms are necessarily Monomorphisms (Split
Monomorphism \S\ref{sec:split_monomorphism}).

As a representing Subobjects (\S\ref{sec:subobject}) Monomorphisms in:
\begin{itemize}
  \item $\mathbf{Set}$ are generalized Subsets
  \item $\mathbf{Grp}$ are generalized Subgroups
  \item $\mathbf{Top}$ are generalized Subspaces
\end{itemize}



\subsubsection{Split Monomorphism}\label{sec:split_monomorphism}

A Morphism with a Left Inverse or \emph{Retraction} is a Monomorphism
called a \emph{Split Monomorphism}.

The Retraction of a Split Monomorphism is a Split Epimorphism
(\S\ref{sec:split_epimorphism}).



\subsubsection{Regular Monomorphism}\label{sec:regular_monomorphism}

\subsubsection{Strong Monomorphism}\label{sec:strong_monomorphism}

\subsubsection{Extremal Monomorphism}\label{sec:extremal_monomorphism}



% --------------------------------------------------------------------
\subsection{Epimorphism}\label{sec:epimorphism}
% --------------------------------------------------------------------

An \emph{Epimorphism} $f$ between Objects $A$ and $B$ is denoted:
\[
  f : A \twoheadrightarrow B
\]
and has the property for any two Morphisms $g, h : B \rightarrow C$,
$gf = hf$ Implies $g = h$ ($f$ is Right Cancellative
\S\ref{sec:cancellative_property}). An Epimorphism in a Category
$\mathbf{C}$ is a Monomorphism in $\mathbf{C^{op}}$.

In a Concrete Category (\S\ref{sec:concrete_category}), every Morphism
corresponding to a Surjective Function is an Epimorphism.

\HandRight\; Note that being an Epimorphism doesn't imply the Morphism
is Surjective. It is more frequently True for Monomorphisms that
Injective Functions imply they are Monomorphism than the reverse for
Surjective Functions and Epimorphisms. Regular
(\S\ref{sec:regular_epimorphism}) and Strong
(\S\ref{sec:strong_epimorphism}) Epimorphisms behave closer to
Surjections than ordinary Epimorphisms.

If $f$ is an Epimorphism, then $fg$ and $fh$ are Idempotent
(\S\ref{sec:idempotent}). %FIXME correct ???



\subsubsection{Split Epimorphism}\label{sec:split_epimorphism}

A Morphism with a Right Inverse (\S\ref{sec:right_inverse}) or
\emph{Section} or \emph{Splitting} is an Epimorphism called a
\emph{Split Epimorphism}. The Section is a Split Monomorphism
(\S\ref{sec:split_monomorphism}).

The Condition that every Epimorphism be a Split Epimorphism in a
Category is a version of the Axiom of Choice
(\S\ref{sec:choice_axiom}) and implies that all Sets are Projective
Objects (\S\ref{sec:projective_object}).\cite{awodey06}



\subsubsection{Regular Epimorphism}\label{sec:regular_epimorphism}

\subsubsection{Strong Epimorphism}\label{sec:strong_epimorphism}

\subsubsection{Extremal Epimorphism}\label{sec:extremal_epimorphism}

\subsubsection{Projective Object}\label{sec:projective_object}

An Object $P$ is \emph{Projective} if for any Epimorphism $e : E
\rightarrow X$ and Morphism $f : P \rightarrow X$, then $\exists
\overline{f} : P \rightarrow E$ such that $e \circ \overline{f} = f$.



% --------------------------------------------------------------------
\subsection{Bimorphism}\label{sec:bimorphism}
% --------------------------------------------------------------------

both Epimorphism and Monomorphism

\HandRight\; Note that not all Bimorphisms are Isomorphisms



\subsubsection{Isomorphism}\label{sec:isomorphism}

A Bimorphism $f : A \rightarrow B$ is an \emph{Isomorphism} if there
exists another Morphism $g : B \rightarrow A$ such that $f \circ g =
1_Y$ and $g \circ f = 1_X$, i.e. $f$ admits a Two-sided Inverse. The
Existance of an Isomorphism between two Objects $A$ and $B$ is denoted
$A \cong B$.

\HandRight\; Note that a Bimorphism need not be an Isomorphism.

In a Concrete Category (\S\ref{sec:concrete_category}) an Isomorphism
must correspond to a Bijective Function on the underlying Sets, but
there are Concrete Categories with Bijective Morphisms that are not
necessarily Isomorphisms (e.g. in $\mathbf{Top}$) and there are also
Categories with Objects corresponding to Sets with Isomorphisms that
are not Bijections.

The Existence of an \emph{Invertible Morphism}
(\S\ref{sec:bijective_function}) between Objects also Implies their
Isomorphism. A Category in which every Morphism is an Isomorphism is a
Groupoid (\S\ref{sec:groupoid}). A Category in which every Morphism is
an Isomorphism and which has a single Object is a Group
(\S\ref{sec:group}).

In $\mathbf{Top}$ the Category of Topological Spaces and Continuous
Maps, the Isomorphisms are exactly the Homeomorphisms
(\S\ref{sec:homeomorphism}) between Topological Spaces.



% --------------------------------------------------------------------
\subsection{Endomorphism}
% --------------------------------------------------------------------

An \emph{Endomorphism} is a Homomorphism from an Object to itself.



\subsubsection{Automorphism}\label{sec:automorphism}

An \emph{Automorphism} is both an Endomorphism and an Isomorphism,
that is, an Invertible Endomorphism.



% --------------------------------------------------------------------
\subsection{Paramorphism}\label{sec:paramorphism}
% --------------------------------------------------------------------

Primitive Recursion (\S\ref{sec:primitive_recursion})



\subsubsection{Catamorphism}\label{sec:catamorphism}

Unique Homomorphism from Initial Algebra into some other Algebra

\emph{Fold}



% --------------------------------------------------------------------
\subsection{Apomorphism}\label{sec:apomorphism}
% --------------------------------------------------------------------

Primitive Corecursion (\S\ref{sec:primitive_corecursion})



\subsubsection{Anamorphism}\label{sec:anamorphism}

\emph{Unfold}

Coinduction (\S\ref{sec:coinduction})



% --------------------------------------------------------------------
\subsection{Hylomorphism}\label{sec:hylomorphism}
% --------------------------------------------------------------------

Composition of Anamorphism followed by Catamorphism

Deforestation



% --------------------------------------------------------------------
\subsection{Metamorphism}\label{sec:metamorphism}
% --------------------------------------------------------------------

Composition of Catamorphism followed by Anamorphism



% --------------------------------------------------------------------
\subsection{Heteromorphism}\label{sec:heteromorphism}
% --------------------------------------------------------------------

For Functor $L : \mathbf{C} \rightarrow \mathbf{D}$, the Set of
\emph{Heteromorphisms} of Objects $c \in \mathbf{C}$ and $d \in
\mathbf{D}$ is the Hom-set:
\[
  Het(c,d) = \mathbf{D}(L(c), d)
\]
and if $L$ has a Right Adjoint then this is equivalent to:
\[
  Het(c,d) = \mathbf{C}(c, R(d))
\]

Profunctor (\S\ref{sec:profunctor})



% --------------------------------------------------------------------
\subsection{Constant Morphism}\label{sec:constant_morphism}
% --------------------------------------------------------------------

A Morphism $f : X \rightarrow Y$ is a \emph{Constant Morphism} if for
any $g, h : W \rightarrow X$, $fg = fh$.

A Morphism $f : X \rightarrow Y$ is a \emph{Co-constant Morphism} if
for any $g, h : Y \rightarrow Z$, $gf = hf$.



\subsection{Zero Morphism}\label{sec:zero_morphism}

\emph{Zero Morphism} is a Morphism that is both Constant and
Co-constant.



% --------------------------------------------------------------------
\subsection{Subobject}\label{sec:subobject}
% --------------------------------------------------------------------

A \emph{Subobject} of an Object $X$ in $\mathbf{C}$ is a Monomorphism
into $X$:
\[
  m : M \rightarrowtail X
\]
The \emph{Inclusion Relation} between two Subobjects $m$ and $m'$ is
defined as:
\[
  m \subseteq m' \Leftrightarrow \exists f : m \rightarrow m'
\]
Two Subobjects are \emph{Equivalent} if and only if they are
Isomorphic:
\[
  m \subseteq m' \wedge m' \subseteq m \Leftrightarrow m \equiv m'
\]

A Morphism between two Subobjects is a Morphism in the Quotient
Category $\mathbf{C}/X$ giving the Category of Subobjects of $X$ in
$\mathbf{C}$ as $Sub_{\mathbf{C}}(X)$. Because there is at most one
Morphism between Subobjects, $Sub_{\mathbf{C}}(X)$ is a Preorder
Category.

A \emph{Subobject} (Slice) \emph{Category}
(\S\ref{sec:slice_category}) $Sub_\mathbf{C}(X)$ may be formed by
taking Monomorphisms into $X$ as Objects and (Mono-)Morphisms between
them in the usual Slice Category definition corresponding to
\emph{Inclusion} of Subobjects and Isomorphisms as \emph{Equivalence}
of Subobjects. $Sub_\mathbf{C}(X)$ is a Preorder Category and a Poset
Category may be obtained by factoring out the Equivalence Relation
$\equiv$ and:
\[
  Sub_\mathbf{Set}(X) \cong \mathcal{P}(X)
\]

For Subobjects $M,M'$ of $X$ related by $f : M \rightarrow M'$, there
is a Functor:
\[
  i_* : Sub (M') \rightarrow Sub (X)
\]



% ====================================================================
\section{Functor}\label{sec:functor}
% ====================================================================

A \emph{Functor} is a Homomorphism (\S\ref{sec:homomorphism}) of
Categories. A Functor $F$ between Categories $\mathbf{C}$ and
$\mathbf{D}$:
\[
  F : \mathbf{C} \rightarrow \mathbf{D}
\]
is a pair of Maps for Objects and Morphisms of $\mathbf{C}$ to Objects
and Morphisms of $\mathbf{D}$ with the following Equivalences:
\begin{itemize}
\item $F(f : A \rightarrow B) = F(f) : F(A) \rightarrow F(B)$
\item $F(g \circ f) = F(g) \circ F(f)$
\item $F(1_A) = 1_{F(A)}$
\end{itemize}
Every Category has an Identity Functor (\S\ref{sec:identity_functor})
$1_{\mathbf{C}} : \mathbf{C} \rightarrow \mathbf{C}$ and the Category
of all Small Categories and Functors is denoted $\mathbf{Cat}$. An
Identity Functor is an example of an \emph{Endofunctor}
(\S\ref{sec:endofunctor}) which is a Functor from a Category to
itself.

Note that in constructions (\S\ref{sec:category_construction}) where a
Functor appears, if that Functor is an Identity Functor, the Category
instead may be substituted.

Because Functors preserve Identities, they also perserve Split
Epimorphisms and Monomorphisms (\S\ref{sec:split_epimorphism},
\ref{sec:split_monomorphism}).

Functors may also be defined in terms of the Object Mapping and
Hom-sets:
\[
  F_{A,B} : Hom_{\mathbf{C}}(A,B) \rightarrow Hom_{\mathbf{D}}(F(A),F(B))
\]
where $F_{A,A}1_A = 1_{F(A)}$ and Composition is Commutative.

Functors between Poset Categories are Monotonic Functions
(\S\ref{sec:monotonic}).

A \emph{Forgetful Functor} (\S\ref{sec:forgetful_functor}) is one that
drops some Property of the Input Category in the Output Category.

An \emph{Inclusion Functor} is a Functor from a Subcategory to its
containing Category (\S\ref{sec:subcategory}).

A Functor on two Categories is a \emph{Bifunctor}
(\S\ref{sec:bifunctor}) and generalised to more Categories is a
\emph{Multifunctor}.

Every Functor $F$ defines a Kernel Category
(\S\ref{sec:kernel_category}) $ker(F)$.



% --------------------------------------------------------------------
\subsection{Endofunctor}\label{sec:endofunctor}
% --------------------------------------------------------------------

\subsubsection{Endofunctor Category}\label{sec:endofunctor_category}

$\mathbf{End_C}$ with Objects as Endofunctors of $\mathbf{C}$ and
Morphisms as Natural Transformations between them with Monoidal
Structure Induced by Composition of Endofunctors.



% --------------------------------------------------------------------
\subsection{Constant Functor}\label{sec:constant_functor}
% --------------------------------------------------------------------

$\Delta_X : \mathbf{C} \rightarrow \mathbf{D}$



% --------------------------------------------------------------------
\subsection{Identity Functor}\label{sec:identity_functor}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Conservative Functor}\label{sec:conservative_functor}
% --------------------------------------------------------------------

A Functor $F : \mathbf{C} \rightarrow \mathbf{D}$ is
\emph{Conservative} if it ``Reflects Isomorphisms'', i.e. if $g : A
\rightarrow B$ is a Morphism in $\mathbf{C}$ and $F(g)$ is an
Isomorphism in $\mathbf{D}$ then $g$ is an Isomorphism in
$\mathbf{C}$.



% --------------------------------------------------------------------
\subsection{Continuous Functor}\label{sec:continuous_functor}
% --------------------------------------------------------------------

A \emph{Continuous Functor} preserves Limits

Hom-functor (\S\ref{sec:hom_functor})



% --------------------------------------------------------------------
\subsection{Full Functor}\label{sec:full_functor}
% --------------------------------------------------------------------

$F$ is a \emph{Full Functor} if $F_{X,Y}$ is Surjective



% --------------------------------------------------------------------
\subsection{Faithful Functor}\label{sec:faithful_functor}
% --------------------------------------------------------------------

Given a Functor, $F : \mathbf{C} \rightarrow \mathbf{D}$, and the
Induced Function:
\[
  F_{X,Y} : \mathrm{Hom}_C(X,Y) \rightarrow \mathrm{Hom}_D(F(X),F(Y))
\]
then $F$ is a \emph{Faithful Functor} if $F_{X,Y}$ is Injective.



\subsubsection{Embedding}\label{sec:category_embedding}

A Faithful Functor may be considered an \emph{Embedding}, e.g. the
\emph{Inclusion Functor} for a Subcategory
(\S\ref{sec:subcategory}).



% --------------------------------------------------------------------
\subsection{Fully Faithful Functor}\label{sec:fully_faithful}
% --------------------------------------------------------------------

$F$ is a \emph{Fully Faithful Functor} if $F_{X,Y}$ is Bijective



% --------------------------------------------------------------------
\subsection{Forgetful Functor}\label{sec:forgetful_functor}
% --------------------------------------------------------------------

A Forgetful Functor that only removes Axioms is always Fully Faithful
(\S\ref{sec:fully_faithful}).

A Forgetful Functor that removes Predicates (Structures) are Faithful
(\S\ref{sec:faithful_functor}) but not necessarily Full
(\S\ref{sec:full_functor}).

A Forgetful Functor that removes Types (extra Sets) are not
necessarily Faithful nor Full.

The Forgetful Functor $\mathbf{Grp} \rightarrowtail \mathbf{Set}$ is
Faithful but not Full.

The Forgetful Functor $\mathbf{Grp} \rightarrow \mathbf{Cat}$ is
Fully Faithful.

The Forgetful Functor $\mathbf{Pos} \rightarrow \mathbf{Cat}$ is
Fully Faithful.



% --------------------------------------------------------------------
\subsection{Contravariant \& Covariant Functor}
\label{sec:contravariant_functor}
% --------------------------------------------------------------------

A \emph{Contravariant Functor} is from a Dual Category
(\S\ref{sec:opposite_category}) to another Category, e.g. $F :
\mathbf{C^{op}} \rightarrow \mathbf{D}$, but expressed in terms of the
original Category:
\[
  \overline{F} : \mathbf{C} \rightarrow \mathbf{D}
\]

The Dual (\S\ref{sec:abstract_category}) of a Contravariant
Functor, a \emph{Covariant Functor}.



\subsubsection{Presheaf}\label{sec:presheaf}

A \emph{Presheaf} is a Contravariant Functor from an Opposite Category
to the Category $\mathbf{Set}$. A Presheaf is an example of a
Set-valued Functor Category (\S\ref{sec:category_diagram}) and gives a
Cartesian Closed Category (\S\ref{sec:cartesian_closed}).

Sheave (\S\ref{sec:sheave})



\paragraph{Representable Presheaf}\label{sec:representable_presheaf}
\hfill \\

Limit (\S\ref{sec:limit})



% --------------------------------------------------------------------
\subsection{Hom-functor}\label{sec:hom_functor}
% --------------------------------------------------------------------

A \emph{Hom-functor} is a Functor from a Locally Small Category,
$\mathbf{C}$, to the Category $\mathbf{Set}$, and has a Covariant and
a Contravariant definition:

\begin{enumerate}
  \item \emph{Covariant Hom-functor}, for $A,f : X \rightarrow Y \in
    \mathbf{C}$:
\[
  h^A = Hom(A,-) : \mathbf{C} \rightarrow \mathbf{Set}
\]\[
  X \mapsto Hom(A,X)
\]\[
  f \mapsto Hom(A,f) : Hom(A,X) \rightarrow Hom(A,Y)
\]
  where $Hom(A,f)$ is defined for all $g \in Hom(A,X)$ as:
\[
  g \mapsto f \circ g
\]

  \item \emph{Contravariant Hom-functor} (also \emph{Functor of
    Points}, see \S\ref{sec:general_element}), for $B,f : X
    \rightarrow Y \in \mathbf{C}$:
\[
  h_B = Hom(-,B) : \mathbf{C} \rightarrow \mathbf{Set}
\]\[
  X \mapsto Hom(X,B)
\]\[
  f \mapsto Hom(f,B) : Hom(Y,B) \rightarrow Hom(X,B)
\]
  where $Hom(f,B)$ is defined for all $g \in Hom(Y,B)$ as:
\[
  g \mapsto g \circ f
\]
\end{enumerate}
The Hom-functor $Hom(-,-)$ is a Covariant Bifunctor
(\S\ref{sec:bifunctor}):
\[
  Hom_\mathbf{C}(-,-):
    \mathbf{C}^{op} \times \mathbf{C} \rightarrow \mathbf{Set}
\]
each half of which is a Representable Functor
\S\ref{sec:representable_functor}. Hom-functors are Continuous
Functors (\S\ref{sec:hom_functor}).

The Category of all Hom-functors and Natural Transformations
(\S\ref{sec:natural_transformation}) between them, $\{ h^A | A \in
\mathbf{C} \}$, is a Subcategory of the Functor Category
(\S\ref{sec:functor_category}) $\mathbf{Set^C}$, and is Isomorphic to
$\mathbf{C^{op}}$ (see \emph{Yoneda Embedding}
\S\ref{sec:yoneda_embedding}).

Every Morphism $f : A' \rightarrow A$ determines a pair of Natural
Transformations:
\[
  Hom(f,-) : h^A \rightarrow h^{A'}
\]\[
  Hom(-,f) : h_{A'} \rightarrow h_A
\]

For any pair of Morphisms, $f : A' \rightarrow A$ and $g : B
\rightarrow B'$:
\[
  Hom(A',g) \circ Hom(f,B) = Hom(f,B') \circ Hom(A,g)
\]
is a path sending
\[
  h : A \rightarrow B
\]
to
\[
  g \circ h \circ f : A' \rightarrow B'
\]



\subsubsection{Internal Hom-functor}\label{sec:internal_homfunctor}



% --------------------------------------------------------------------
\subsection{Representable Functor}\label{sec:representable_functor}
% --------------------------------------------------------------------

%FIXME definition of 'representation'
%FIXME ref Naturally Isomorphic
A Functor $F : \mathbf{C} \rightarrow \mathbf{Set}$ is a
\emph{Representable Functor} if it is Naturally Isomorphic to the
Hom-functor $h^A$ or $h_A$ for some Object $A \in \mathbf{C}$.

A \emph{Covariant Representable Functor} for an Object $A$ in a
Category $\mathbf{C}$ is defined as Naturally Isomorphic to the
Covariant Hom-functor $h^A = Hom(A,-) : \mathbf{C} \rightarrow
\mathbf{Set}$
\[
  Hom(A,-) : Hom(A,X) \xrightarrow{f_*} Hom(A,Y)
\]
A \emph{Contravariant Representable Functor} for $A$ is a Functor that
is Naturally Isomorphic to the Contravariant Hom-functor $h_A =
Hom(-,A) : \mathbf{C^{op}} \rightarrow \mathbf{Set}$
\[
  Hom(-,A) : Hom(X,A) \xrightarrow{f^*} Hom(Y,A)
\]

A \emph{Representation} of a Covariant Representable Functor, $F$, is
a pair $(A, \Phi)$ with Natural Isomorphism $\Phi : Hom(A,-)
\rightarrow F$.

Contravariant Representable Functors map all Colimits
(\S\ref{sec:colimit}) to Limits (\S\ref{sec:limit}).

A Locally Small Category has Representable Functors for all Objects.



% --------------------------------------------------------------------
\subsection{Yoneda Lemma}\label{sec:yoneda_lemma}
% --------------------------------------------------------------------

For an arbitrary Covariant Functor $F : \mathbf{C} \rightarrow
\mathbf{Set}$:
\[
  \forall A \in \mathbf{C}, Nat(h^A,F) \cong F(A)
\]
If $F$ is a Covariant Hom-functor $h^B$, then:
\[
  \forall A \in \mathbf{C}, Nat(h^A,h^B) \cong Hom(B,A)
\]

For an arbitrary Contravariant Functor $G : \mathbf{C} \rightarrow
\mathbf{Set}$:
\[
  \forall A \in \mathbf{C}, Nat(h_B,G) \cong G(A)
\]
If $F$ is a Contravariant Hom-functor $h_B$, then:
\[
  \forall A \in \mathbf{C}, Nat(h_A,h_B) \cong Hom(A,B)
\]



\subsubsection{Yoneda Embedding}\label{sec:yoneda_embedding}

The Fully Faithful Contravariant Functor $h^- : \mathbf{C} \rightarrow
\mathbf{Set^C}$ which maps each Object $A \in \mathbf{C}_0$ to the
Hom-functor $h^A$ and each $f \in \mathbf{C}_1$ to the Natural
Transformation $Hom(f,-)$ can also be interpreted as a Covariant
Functor $h^- : \mathbf{C^{op}} \rightarrow \mathbf{Set^C}$. Being a
Faithful Functor means $h^-$ gives an Embedding
(\S\ref{sec:category_embedding}) of $\mathbf{C^{op}}$ in
$\mathbf{Set^C}$.

By the Contravariant Yoneda's Lemma:
\[
  h_-: \mathbf{C} \rightarrow \mathbf{Set^{C^{op}}}
\]
called the \emph{Yoneda Embedding}.



% --------------------------------------------------------------------
\subsection{Product Functor}\label{sec:product_functor}
% --------------------------------------------------------------------

\[
  \times : \mathbf{C} \times \mathbf{C} \rightarrow \mathbf{C}
\]



\subsubsection{Coproduct Functor}\label{sec:coproduct_functor}

\[
  + : \mathbf{C} \times \mathbf{C} \rightarrow \mathbf{C}
\]



% --------------------------------------------------------------------
\subsection{Diagonal Functor}\label{sec:diagonal_functor}
% --------------------------------------------------------------------

For Functor Category (\S\ref{sec:functor_category})
$\mathbf{C}^\mathbf{J}$ with Small Index Category $\mathbf{J}$, a
\emph{Diagonal Functor} $\Delta : \mathbf{C} \rightarrow
\mathbf{C}^\mathbf{J}$ assigns to each Object $A$ of $\mathbf{C}$ the
Constant Functor $\Delta_A \in \mathbf{C}^\mathbf{J}$ with fixed $A$
and to each Morphism $f : A \rightarrow B$ of $\mathbf{C}$ the Natural
Transformation $\eta$ in $\mathbf{C}^\mathbf{J}$ given by $\eta_j =
f$.

If $\mathbf{J}$ is a Discrete Category with two Objects, the Diagonal
Functor is $\mathbf{C} \rightarrow \mathbf{C} \times \mathbf{C}$.

The Limit (\S\ref{sec:limit}) of a Functor $F : \mathbf{J} \rightarrow
\mathbf{C}$ is a Universal Morphism (\S\ref{sec:universal_morphism})
from the Diagonal Functor $\Delta$ to $F$.

If $\mathbf{C}$ is Complete (\S\ref{sec:complete_category}) then every
Functor from $\mathbf{J}$ to $\mathbf{C}$ has a Limit and the
operation of taking Limits is a Functor from $\mathbf{C}^\mathbf{J}$
to $\mathbf{C}$.

The Limit Functor is the Right-adjoint (\S\ref{sec:adjoint_functor})
of the Diagonal Functor.

A Colimit (\S\ref{sec:colimit}) is a Universal Morphism $F \rightarrow
\Delta$.

If $\mathbf{C}$ is Complete the Colimit Functor exists and is the
Left-adjoint of the Diagonal Functor.

As an example, the Diagonal Functor $\mathbf{C} \rightarrow \mathbf{C}
\times \mathbf{C}$ is the Left-adjoint of the Binary Product Functor
(\S\ref{sec:product_functor}) and the Right-adjoint of the Binary
Coproduct Functor (\S\ref{sec:coproduct_functor}).



% --------------------------------------------------------------------
\subsection{Adjoint Functor}\label{sec:adjoint_functor}
% --------------------------------------------------------------------

An \emph{Adjoint Functor} is the Categorical analog of the Existential
Quantifier in Logic (\S\ref{sec:quantifier}) and the Image Operation
along a Continuous Function in Topology (Part \ref{sec:topology}).

Adjoint (\S\ref{sec:adjoint})



\subsubsection{Monad}\label{sec:monad}

A \emph{Monad} is a Composition $G \circ F$ of Adjoint Functors $F :
\mathbf{C} \rightarrow \mathbf{D}$ and $G : \mathbf{D} \rightarrow
\mathbf{C}$. If $F$ and $G$ are Inverses then the corresponding Monad
is the Identity Functor.

Definition of a Monad as a Triple:
\[
  (T, \eta, \mu)
\]
where $T : \mathbf{C} \rightarrow \mathbf{C}$ is an Endofunctor and
$\eta : 1_\mathbf{C} \rightarrow T$ and $\mu : T^2 \rightarrow T$
(where $T^2 = T \circ T : \mathbf{C} \rightarrow \mathbf{C}$) are
Natural Transformations satisfying the Coherence Conditions
(\S\ref{sec:coherence_condition}):
\begin{enumerate}
  \item $\mu \circ T\mu = \mu \circ \mu T : T^3 \rightarrow T$
  \item $\mu \circ T\eta = \mu \circ \eta T = 1_T : T \rightarrow T$
\end{enumerate}
(1) is analogous to Associativity in Monoids and (2) gives the
existence of an Identity Element.

A Monad on $\mathbf{C}$ can be defined as a Monoid on the Endofunctor
Category (\S\ref{sec:endofunctor_category}) $\mathbf{End_C}$.



Comonad $F \circ G$ (\S\ref{sec:comonad})

Monadic Adjunction (\S\ref{sec:monadic_adjunction})

Terminal Object %FIXME terminal object required in category?

Generalization of Closure Operators on Posets (\S\ref{sec:poset}) to
arbitrary Categories (Galois Connections \S\ref{sec:galois_connection}
as Adjoint Pairs)



\textbf{Generalization of Universal Algebra}

Any Variety (\S\ref{sec:variety}) in Universal Algebra gives rise to a
Monad on $\mathbf{Set}$ and the Algebra Type can be recovered from the
Monad as the Category of Eilenberg-Moore Algebras
(\S\ref{sec:eilenberg_moore}). A Variety of Algebras is a Finitary
Algebraic Category (\S\ref{sec:finitary_algebraic_category}).

A Monad on $\mathbf{Set}$:
\[
  (\mathcal{P}, \{-\}, \bigcup)
\]
where $\mathcal{P}$ is the Powerset Operation, $\{-\}$ is the
Singleton Operation, and $\bigcup$ is the Union Operation.
% FIXME xref



\paragraph{Eilenberg-Moore Category}\label{sec:eilenberg_moore}
\hfill \\

$\mathbf{C}^T$ Category of $T$-algebras for Monad $T$ in Category
$\mathbf{C}$



\paragraph{Kleisli Category}\label{sec:kleisli_category}
\hfill \\

For Monad $T$ and Category $\mathbf{C}$, \emph{Kleisli Category}
$\mathbf{C}_T$ equivalent to the Category of Free $T$-algebras-- Full
Subcategory (\S\ref{sec:full_subcategory}) of Eilenberg-Moore Category
$\mathbf{C}^T$



\paragraph{Adjoint Category}\label{sec:adjoint_category}
\hfill \\

For a Monad $(T,\eta,\mu)$, the \emph{Adjoint Category}
$\mathbf{Adj}(\mathbf{C}, T)$ is the Category where Objects are
Adjunctions $(F,G,e,\varepsilon)$ such that $(GF,e,G \varepsilon F) =
(T,\eta,\mu)$ with Initial Object:
\[
  (F_T, G_T, \eta, \mu_T) : \mathbf{C} \rightarrow \mathbf{C}_T
\]
where $\mathbf{C}_T$ is the Kleisli Category
(\S\ref{sec:kleisli_category}) and Terminal Object:
\[
  (F^T, G^T, \eta, \mu^T) : \mathbf{C} \rightarrow \mathbf{C}^T
\]
where $\mathbf{C}^T$ is the Eilenberg-Moore Category
(\S\ref{sec:eilenberg_moore}).



\subsubsection{Comonad}\label{sec:comonad}

\subsubsection{Monadic Functor}\label{sec:monadic_functor}

A Functor $F : \mathbf{D} \rightarrow \mathbf{C}$ is Monadic if it has
a Left Adjoint $F$ forming a Monadic Adjunction.

\textbf{Beck's Monadicity Theorem}

Functor $U : \mathbf{C} \rightarrow \mathbf{D}$ is \emph{Monadic} if
and only if:
\begin{enumerate}
  \item $U$ has a Left Adjoint (\S\ref{sec:adjoint})
  \item $U$ is Conservative (\S\ref{sec:conservative_functor})
  \item $\mathbf{C}$ has Coequalizers (\S\ref{sec:coequalizer}) of
    $U$-split parallel pairs of Morphisms in $\mathbf{C}$ and $U$
    preserves those Coequalizers
\end{enumerate}

Functor $U : \mathbf{D} \rightarrow \mathbf{C}$ is Monadic if it has a
Right Adjoint and up to Equivalence $\mathbf{D}$ is the
Eilenberg-Moore Category (\S\ref{sec:eilenberg_moore}).
\cite{lambek-scott88}

Descent Theory (\S\ref{sec:descent_theory})



% ====================================================================
\section{Natural Transformation}\label{sec:natural_transformation}
% ====================================================================

A \emph{Natural Transformation} is a Morphism between Functors with
two Properties. Given a Natural Transformation, $\tau$, between two
Functors, $S$ and $T$, between two Categories, $\mathbf{C}$ and
$\mathbf{D}$:
\[
  \tau : S \rightarrow T
\]
such that:
\begin{enumerate}
  \item $\forall X \in \mathbf{C},
    \exists \tau_X : S(X) \rightarrow T(X) \in \mathbf{D}$
  \item $\forall f : X \rightarrow Y \in \mathbf{C},
    \tau_Y \circ S(f) = G(f) \circ \tau_X$
\end{enumerate}
where the Morphism $\tau_X$ is called the \emph{Component} of $\tau$
at $X$. When (2) holds, a Commutative Diagram is formed and the
Morphisms $\tau_X$ are said to be \emph{Natural} in $X$. If there is
no Morphism in $\mathbf{D}$ corresponding to $\tau_X$, then there can
be no Natural Transformation from $S$ to $T$.

When every Component in $\tau$ is Invertible in $\mathbf{D}$, $\tau$
is a \emph{Natural Isomorphism} (or \emph{Natural Equivalence}) and $S
\cong T$. Equivalently, a Natural Isomorphism is an Isomorphism in the
Functor Category $Fun(\mathbf{C},\mathbf{D})$.

Natural Isomorphisms:
\[
  Hom_\mathbf{Grp}(F_1,G) \cong U(G)
\]\[
  Hom_\mathbf{Set}(X,\mathbf{2}) \cong \mathcal{P}(X)
\]\[
  Hom_\mathbf{BA}(B,\mathbf{2}) \cong Ult(X)
\]



% --------------------------------------------------------------------
\subsection{Vertical Composition}\label{sec:vertical_composition}
% --------------------------------------------------------------------

Given Natural Transformations $\eta : F \rightarrow G$ and $\epsilon :
G \rightarrow H$ between Functors $F,G,H : \mathbf{C} \rightarrow
\mathbf{D}$, the \emph{Vertical Composition} is given as:
\[
  \epsilon \eta : F \rightarrow H
\]
Vertical Composition may be explicitly denoted with the $\cdot$
Operator, $\epsilon \cdot \eta$. Vertical Composition is Associative
and has an Identity.



% --------------------------------------------------------------------
\subsection{Horizontal Composition}\label{sec:horizontal_composition}
% --------------------------------------------------------------------

Given Functors $F,G : \mathbf{C} \rightarrow \mathbf{D}$ and $J,K :
\mathbf{D} \rightarrow \mathbf{E}$, and Natural Transformations $\eta
: F \rightarrow G$ and $\epsilon : J \rightarrow K$, the
\emph{Horizontal Composition} is given as:
\[
  \eta \epsilon : JF \rightarrow KG
\]
Horizontal Composition may be explicitly denoted with the $\circ$
Operator: $\eta \circ \epsilon$. Horizontal Composition is Associative
and has the same Identity as Vertical Composition.



% --------------------------------------------------------------------
\subsection{Interchange Law}\label{sec:interchange_law}
% --------------------------------------------------------------------

Given three Categories, $\mathbf{B}$, $\mathbf{C}$, and $\mathbf{D}$,
and six Functors, $P,Q,R : \mathbf{B} \rightarrow \mathbf{C}$ and
$S,T,U : \mathbf{C} \rightarrow \mathbf{D}$, and four Natural
Transformations, $\sigma : P \rightarrow Q$, $\tau : Q \rightarrow R$,
$\sigma' : S \rightarrow T$, and $\tau' : T \rightarrow U$, the
following \emph{Interchange Law} applies:
\[
  (\tau' \cdot \sigma') \circ (\tau \cdot \sigma) =
  (\tau' \circ \tau) \cdot (\sigma' \circ \sigma)
\]



% --------------------------------------------------------------------
\subsection{Adjunction}\label{sec:adjoint}
% --------------------------------------------------------------------

Two Functors $F$ and $G$ are \emph{Adjoints}, $F \dashv G$, when:
\[
  f : F Y \rightarrow X \cong g : Y \rightarrow G X
\]
Adjoints are Unique up to Isomorphism.

See also \emph{Adjoint Functor} \S\ref{sec:adjoint_functor}

In a Cartesian Closed Category (\S\ref{sec:cartesian_closed}), the
following Functors are Adjoints:
\[
  + \dashv \Delta \dashv \times
\]
and:
\[
  (-) \times A \dashv (-)^A
\]
In First-order Logic (Provability $\vdash$):
\[
  \exists \dashv \star \dashv \forall
\]

\textbf{Unit}:
\[
  1_{F X}: F X \rightarrow F X \cong \eta : X \rightarrow G F X
\]

\textbf{Counit}:
\[
  \epsilon: F G Y \rightarrow Y \cong 1_{G_Y} : G Y \rightarrow G Y
\]



\subsection{Monadic Adjunction}\label{sec:monadic_adjunction}

An Adjunction is \emph{Monadic} if it is equivalent to the
Eilenberg-Moore Category (\S\ref{sec:eilenberg_moore}) of its
associated Monad (\S\ref{sec:monad}).

$(F,G,\eta,\varepsilon)$ is a \emph{Monadic Adjunction} when
$\mathbf{D}$ is equivalent to the Eilenberg-Moore Category
$\mathbf{C}^T$ for Monad $T = GF$.

%FIXME keep one or the other of these definitions?





% --------------------------------------------------------------------
\subsection{Extranatural Transformation}
\label{sec:extranatural_transformation}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Dinatural Transformation}
\label{sec:dinatural_transformation}
% --------------------------------------------------------------------



% ====================================================================
\section{Universal Properties}\label{sec:universal_property}
% ====================================================================

Unique up to Unique Isomorphism



% --------------------------------------------------------------------
\subsection{Universal Mapping Property}
\label{sec:universal_mapping_property}
% --------------------------------------------------------------------

A \emph{Universal Mapping Property} is a Property in the Language of
Category Theory that defines a Mathematical Structure up to
Isomorphism. By relation to the Curry-Howard Correspondence, these
Isomorphisms are effectively two-way Rules of Inference.

\emph{Existence}

\emph{Uniqueness}



% --------------------------------------------------------------------
\subsection{Universal Morphism}\label{sec:universal_morphism}
% --------------------------------------------------------------------

Given a Functor $S: \mathbf{D} \rightarrow \mathbf{C}$, an
\emph{Universal Morphism} to $S$ or \emph{Initial Morphism}, is an
Initial Object of the form $(Y',u)$ in the Comma Category
(\S\ref{sec:comma_category}) $(X \downarrow S)$ where $X \in
\mathbf{C}_0$, $u : X \rightarrow S(Y') \in \mathbf{C}_1$ and $X' \in
\mathbf{D}_0$.
%FIXME is X' initial and/or terminal in D?

$(Y', u)$ satisfies the \emph{Initial Property}:
\[
  \forall Z' \in \mathbf{D}, \forall f : X \rightarrow S(Z') \in
  \mathbf{C}, \exists! g : Y' \rightarrow Z' : S(g) \circ u = f
\]

The Dual concept of an Initial Morphism, an Universal Morphism from
$S$ or \emph{Terminal Morphism}, is a Terminal Object of the form
$(X',v)$ in the Comma Category $(S \downarrow X)$ where $v : S(X')
\rightarrow X \in \mathbf{C}$.

$(X',v)$ satisfies the \emph{Terminal Property}:
\[
  \forall Y' \in \mathbf{D}, \forall f : S(Y') \rightarrow X \in
  \mathbf{C}, \exists! g : Y' \rightarrow X' : v \circ S(g) = f
\]

%FIXME universality in terms of Hom sets



\subsubsection{Universal Element}\label{sec:universal_element}

\emph{Representable Functor} (\S\ref{sec:representable_functor})

For a Functor $H : \mathbf{D} \rightarrow \mathbf{Set}$, an
\emph{Universal Element} of $H$ is a pair of Objects $(A,X) \in
\mathbf{D}_0 \times \mathbf{Set}_0$ such that:
\[
  \forall (A',X') \in \mathbf{D}_0 \times \mathbf{Set}_0,
  \exists! f : A \rightarrow A' \in \mathbf{D} : H(f)(X) = X'
\]



% --------------------------------------------------------------------
\subsection{Global Elements}\label{sec:global_element}
% --------------------------------------------------------------------

A \emph{Global Element}, $a$, (also \emph{Point} or \emph{Constant})
of an Object, $A$, is a Morphism from a Terminal Object, $1$, to that
Object
\[
  a: 1 \rightarrow A
\]
In $\mathbf{Set}$ this expresses an Isomorphism:
\[
  A \cong Hom_\mathbf{Set}(1,A)
\]
but is not true for all Categories in general.

In some settings Global Elements represent Closed Terms.



\subsubsection{Well-pointed Category}\label{sec:well_pointed}



% --------------------------------------------------------------------
\subsection{General Elements}\label{sec:general_element}
% --------------------------------------------------------------------

A \emph{General Element}, $x$, (also \emph{Variable}) is a Morphism
from an arbitrary Domain Object, $X$
\[
  x: X \rightarrow A
\]

In some contexts General Elements correspond to arbitrary Terms
(\S\ref{sec:term}).



% --------------------------------------------------------------------
\subsection{Category Diagram}\label{sec:category_diagram}
% --------------------------------------------------------------------

A \emph{Category Diagram} is a Covariant Functor from an \emph{Index
  Category} into another Category:
\[
  D : \mathbf{J} \rightarrow \mathbf{C}
\]
A Diagram is the Category Theory analogue of an Indexed Family of Sets
(\S\ref{sec:index_set}).

Category of Diagrams (\S\ref{sec:setvalued_functor})

$Diag(\mathbf{C},\mathbf{D})$



\subsubsection{Cone}\label{sec:category_cone}

A \emph{Cone} in a Diagram $D : \mathbf{J} \rightarrow \mathbf{C}$ is
an Object $C \in \mathbf{C}_0$ and a Unique Morphism $c_j : C
\rightarrow D_j$ for each Object in the Diagram such that any
resulting triangles Commute.

This is equivalent to a Natural Tranformation from the Constant
Functor (\S\ref{sec:constant_functor}) $\Delta_C$ to the Diagram
Functor $D$.

Cone Category $\mathbf{Cone}(D)$

Cocone (\S\ref{sec:cocone})



\paragraph{Universal Cone}\label{sec:universal_cone}
\hfill \\

Universal Object in the Cone Category

Cone Category $\mathbf{Cone}(D)$

A Limit (\S\ref{sec:limit}) is a Terminal Object in the Cone
Category.



\subsubsection{Cocone}\label{sec:cocone}

A \emph{Cocone} in a Diagram $D : \mathbf{J} \rightarrow \mathbf{C}$
is an Object $C \in \mathbf{C}_0$ and a Unique Morphism $c_j : D_j
\rightarrow C$ for each Object in the Diagram such that any resulting
triangle Commutes.




\paragraph{Universal Cocone}\label{sec:universal_cocone}
\hfill \\

Universal Object in the Cocone Category

Cocone Category $\mathbf{Cocone}(D)$

A Colimit (\S\ref{sec:colimit}) is a Initial Object in the Cocone
Category.



\subsubsection{Span}\label{sec:span}

\emph{Span} (or \emph{Roof} or \emph{Correspondence})

Diagram over $1 \rightarrow 2 \leftarrow 3$

The Colimit of a Span is a Pushout (\S\ref{sec:pushout})



\subsubsection{Cospan}\label{sec:cospan}

The Limit of a Cospan is a Pullback (\S\ref{sec:pullback})



% --------------------------------------------------------------------
\subsection{Limit}\label{sec:limit}
% --------------------------------------------------------------------

\emph{Limit} = \emph{Inverse Limit} = \emph{Projective Limit} =
\emph{Left Root}

\emph{Colimit} = \emph{Direct Limit} = \emph{Inductive Limit} =
\emph{Right Root}

Colimit (\S\ref{sec:colimit})

A \emph{Limit} is defined as a Terminal Object in the Cone Category
(\S\ref{sec:category_cone}) over a Diagram $D : \mathbf{J} \rightarrow
\mathbf{C}$:
\[
  c_i : \lim_{\xleftarrow[j]{}} D_j \rightarrow D_i
\]

A Category has all Finite Limits if and only if it has Finite Products
(\S\ref{sec:category_product}) and Equalizers (\S\ref{sec:equalizer}),
or equivalently if it has Pullbacks (\S\ref{sec:pullback}) and a
Terminal Object (\S\ref{sec:terminal_object}). Furthermore, a Category
has all Limits of som Cardinality if and only if it has all Equalizers
and Products of that Cardinality. \cite{awodey06}

A Limit is also definable as a Natural Isomorphism (a Natural
Transformation with every Component an Isomorphism) between the two
Functors:
\[
  \mathbf{C}(c, \lim_{\xleftarrow[j]{}} D) \cong Nat (\Delta_c, D)
\]

Representable Presheaf (\S\ref{sec:representable_presheaf})



\subsubsection{Terminal Object}\label{sec:terminal_object}

An Object $1$ in a Category $\mathbf{C}$ is \emph{Terminal} if for
every other Object $A$ in the Category there is a unique Morphism $A
\rightarrow 1$. A Unique, Canonical Isomorphism exists between any two
Terminal Objects in $\mathbf{C}$.

As an example, in $\mathbf{Set}$ and $\mathbf{Pos}$, all Singleton
Sets are Terminal, and as such they are all Isomorphic to each other.
Given a Set $X$:
\[
  |X| = 1 \leftrightarrow \forall Y, |Hom_{\mathbf{Set}}(Y,X)| = 1
\]

In a Poset, a Top Element is a Terminal Object.



\subsubsection{Product}\label{sec:product}

A \emph{Product} of two Objects $P = A \times B$:
\[
  A \xleftarrow{\;\;p_1\;\;} P \xrightarrow{\;\;p_2\;\;} B
\]
is a Product of $A$ and $B$ if and only if for any $A
\xleftarrow{\;\;z_1\;\;} Z \xrightarrow{\;\;z_2\;\;} B$:
\[
  \exists!u : Z \rightarrow P
\]
with $p_i \circ u = z_i$. $u$ is called a \emph{Factorization} and may
also be written as $\langle z_1, z_2 \rangle$ as it is uniquely
determined by $z_1$ and $z_2$.

A Product of two Categories is uniquiely Isomorphic to the Cartesian
Product (\S\ref{sec:cartesian_product}) of the two Sets.

In a Poset, the Product of two Elements is the Meet or Greatest Lower
Bound (\S\ref{sec:glb_lub}).

For Morphisms $f$ and $g$, a Product $f \times g$ is defined where $f
: A \rightarrow A'$, $g : B \rightarrow B'$ and:
\[
  f \times g : A \times B \rightarrow A' \times B' =
  \langle f \circ p_1, g \circ p_2 \rangle
\]
with $p_1$ and $p_2$ the Projections $p_1 : A \times B \rightarrow A$
and $p_2 : A \times B \rightarrow B$.

A Category $\mathbf{C}$ with Binary Products between any two Objects
has a \emph{Product Functor} (\S\ref{sec:product_functor}):
\[
  \times : \mathbf{C} \times \mathbf{C} \rightarrow \mathbf{C}
\]
which Maps pairs of Objects of $\mathbf{C}$ to their Product:
\[
  (A,B) \mapsto A \times B
\]
and Morphisms of $\mathbf{C}$ to their Product:
\[
  (f,g) \mapsto f \times g
\]
A Category with Binary Products and a Terminal Object is said to have
all \emph{Finite Products}. It is possible to Model the Theory of
Groups (\S\ref{sec:group_theory}) in any Category with all Finite
Products.

A Category has Finite Products and Equalizers if and only if it has
Pullbacks (\S\ref{sec:pullback}) and a Terminal Object. \cite{awodey06}

Products are unique up to Isomorphism (\S\ref{sec:isomorphism}). The
Canonical Commutative Isomorphism $A \times B \cong B \times A$ is:
\[
  \langle p_2, p_1 \rangle : A \times B \rightarrow B \times A
\]
which is the Natural Transformation $\theta$ betwen the Product
Functor and the \emph{Twisted Product Functor} $\tilde{\times} :
\mathbf{C} \times \mathbf{C} \rightarrow \mathbf{C}$ (Mapping $(A,B)
\mapsto B \times A$):
\[
  \theta : \times \rightarrow \tilde{\times}
\]

The Universal Mapping Property for Products may be stated as a two-way
Rule of Inference:
\[
  {
    \frac{X \rightarrow A \;\;\;\; X \rightarrow B}
    {X \rightarrow A \times B}
  }\times
\]

Products are also Associative:
\[
  A \times (B \times C) \cong (A \times B) \times C
\]



\paragraph{N-ary Products}\label{sec:category_nary}
\hfill \\
A Terminal Object is a \emph{Nullary Product}. A general Object is its
own \emph{Unary Product}.

By Associativity of Products, $A \times B \times C = (A \times B)
\times C$ so any Category that has Binary Products also has all
\emph{Finite N-ary Products}.



\subsubsection{Equalizer}\label{sec:equalizer}

An \emph{Equalizer} is an (Unique) Object $E$ and Morphism $e: E
\rightarrow A$ such that for a given pair of parallel Morphisms $f,g :
A \rightarrow B$:
\[
  f \circ e = g \circ e
\]
$e$ is necessarily a Monomorphism.

For a Set $X$ in $\mathbf{Set}$, every Subset $U \subseteq X$ occurs
as an Equalizer.

The Category $\mathbf{Ab}$ has all Equalizers.

If a Category has Binary Products (\S\ref{sec:category_product}) and
Equalizers then it has Pullbacks (\S\ref{sec:pullback}).



\paragraph{Kernel}\label{sec:morphism_kernel}
\hfill \\

The \emph{Kernel} of a Morphism $f : X \rightarrow Y$ is the most
general Morphism $k : K \rightarrow X$ such that $fk = 0_{KY}$ and for
any Morphism $k' : K' \rightarrow X$ such that $fk' = 0_{K'Y}$, there
exists a unique Morphism $u : K' \rightarrow K$ such that $ku = k'$.

A Kernel is a special case of an Equalizer where one of the Morphisms
is a Zero Morphism (\S\ref{sec:zero_morphism}).



\paragraph{End}\label{sec:end}
\hfill \\

\emph{End} of a Functor is a Universal Extranatural Transformation
(\S\ref{sec:extranatural_transformation})



\subsubsection{Pullback}\label{sec:pullback}

For a Category $\mathbf{C}$, a \emph{Pullback} of Morphisms $f : A
\rightarrow C$ and $g : B \rightarrow C$ are Morphisms $p_1 : P
\rightarrow A$ and $p_2 : P \rightarrow B$ with the Universal Property
that $fp_1 = g_p2$. This implies for any given $z_1 : Z \rightarrow A$
and $z_2 : Z \rightarrow B$ such that $fz_1 = gz_2$, there is a Unique
Morphism $u : Z \rightarrow P$ such that $z_1 = p_1 u$ and $z_2 = p_2
u$.

A Pullback is the Limit of a Cospan (\S\ref{sec:cospan}).

Subtyping (\S\ref{sec:subtype})

Type Inference (\S\ref{sec:type_inference}) (Unification)

generalization of Intersection (\S\ref{sec:intersection}) and Inverse
Image (\S\ref{sec:preimage})

A Category has Pullbacks and a Terminal Object if and only if it has
Finite Products (\S\ref{sec:category_product}) and Equalizers
(\S\ref{sec:equalizer}). \cite{awodey06}



\paragraph{Pullback Functor}\label{sec:pullback_functor}\cite{awodey06}
\hfill \\

For $h : C' \rightarrow C$ in a Category $\mathbf{C}$ with Pullbacks,
the \emph{Pullback Functor}:
\[
  h^* : \mathbf{C}/C \rightarrow \mathbf{C}/C'
\]
is defined as:
\[
  (A \xrightarrow{\alpha} C) \mapsto
    (C' \times_\mathbf{C} A \xrightarrow{\alpha '} C')
\]



\paragraph{Reindexed Family}\label{sec:reindexed_family}
\hfill \\
Indexed Family (\S\ref{sec:indexed_family})



\subsubsection{Cotensor Product}\label{sec:cotensor_product}

Monoidal Category (\S\ref{sec:monoidal_category})



\paragraph{Power}\label{sec:power}

Covariant Powerset Functor % FIXME

Cumulative Hierarchy (\S\ref{sec:cumulative_hierarchy})

$Hom(X,\mathbf{2}) \cong \mathcal{P}(X)$

Ultrafilters (\S\ref{sec:ultrafilter})

$Ult(B) \cong Hom_\mathbf{BA}(B,\mathbf{2})$

Adjoint Functors:

$Ult : \mathbf{BA}^{op} \rightarrow \mathbf{Set}$

$\mathcal{P}^\mathbf{BA} : \mathbf{Set}^{op} \rightarrow \mathbf{BA}$

Natural Transformations (\S\ref{sec:natural_transformation}) from
Stone Duality (\S\ref{sec:stone_duality}):
\[
  \eta_X : X \rightarrow Ult(\mathcal{P}(X))
\]\[
  \phi_B : B \rightarrow \mathcal{P}(Ult(B))
\]

$\mathcal{P}^\mathbf{BA} :
  \mathbf{Set}^{op}_{fin} \rightarrow \mathbf{BA}_{fin}$

$A : \mathbf{BA}^{op}_{fin} \rightarrow \mathbf{Set}_{fin}$
\emph{Atoms} of a Boolean Algebra:
\[
  A(\mathcal{B}) = \{ a \in \mathcal{B} \;|\;
    0 < a, (b < a \Rightarrow b = 0) \}
\]
There is an Isomorphism between Atoms $a$ of a Finite Boolean Algebra
$\mathcal{B}$ and Ultrafilters $U \subseteq \mathcal{B}$:
\[
  U \mapsto \bigwedge_{b \in U} b
\]\[
  a \mapsto \uparrow (a)
\]



\subsubsection{Inverse Limit}\label{sec:inverse_limit}

\subsubsection{Complete Category}\label{sec:complete_category}

A \emph{Complete Category} is a Category where all Small Limits exist.



% --------------------------------------------------------------------
\subsection{Colimit} \label{sec:colimit}
% --------------------------------------------------------------------

Adjoint Functor (\S\ref{sec:adjoint_functor})

Diagonal Functor (\S\ref{sec:diagonal_functor})

Small Limit

A \emph{Colimit} is defined as a Universal Cone
(\S\ref{sec:universal_cone})

A Category has Finite Colimits if and only if it has Finite Coproducts
(\S\ref{sec:coproduct}) and Coequalizers (\S\ref{sec:coequalizer}).
Likewise, a Category has all Colimits of some Cardinality $\kappa$ if
and only if it has Coequalizers and Coproducts of Cardinality
$\kappa$.



\subsubsection{Initial Object}\label{sec:initial_object}

An Object $0$ in a Category $\mathbf{C}$ is \emph{Initial} if for
every other Object $A$ in the Category there is a unique Morphism $0
\rightarrow A$. A Unique Canonical Isomorphism exists between any two
Initial Objects in $\mathbf{C}$.

An Initial Object is the Colimit of the Empty Diagram $\varnothing
\rightarrow \mathbb{C}$

In $\mathbf{Set}$ the Empty Set is Initial as the only mapping from it
to any other Set is the Empty Function.

In a Poset, the Bottom Element is an Initial Object.

All Universal Properties are Initial Objects somewhere...
%FIXME catsters



\subsubsection{Coproduct}\label{sec:coproduct}

Disjoint Union (\S\ref{sec:disjoint_union})

The Diagram $A \xrightarrow{\;\;q_1\;\;} Q \xleftarrow{\;\;q_2\;\;} B$
is a \emph{Coproduct} $A + B$ if for any $A \xrightarrow{\;\;z_1\;\;}
Z \xleftarrow{\;\;z_2\;\;} B$:
\[
  \exists!u : Q \rightarrow Z
\]
with $u \circ q_i = z_i$. $u$ may also be written as $[ z_1, z_2 ]$
and Coprojections $q_i$ may be called \emph{Injections} (although they
are not necessarily Injective Morphisms).

The Universal Mapping Property for Coproducts may be stated as a
two-way Rule of Inference:
\[
  {
    \frac{A \rightarrow X \;\;\;\; B \rightarrow X}
    {A + B \rightarrow X}
  }+
\]

An example of a Coproduct in $\mathbf{Set}$ is the Disjoint Union
(\S\ref{sec:disjoint_union}) in Set Theory or the Tagged Union
(\S\ref{sec:sum_type}) in Type Theory. The Coproduct of a Monoid of
Group is sometimes defined as a Tensor Product
(\S\ref{sec:tensor_product}). In a Poset the Coproduct of two Elements
is the Join or Leas Upper Bound (\S\ref{sec:glb_lub}).

In the Category $\mathbf{Ab}$ there is a Canonical
Isomorphism:\cite{awodey06}
\[
  A + B \cong A \times B
\]



\subsubsection{Coequalizer}\label{sec:coequalizer}

An \emph{Coequalizer} is an (Unique) Object $Q$ and Morphism $q: B
\rightarrow Q$ such that for a given pair of parallel Morphisms $f,g :
A \rightarrow B$:
\[
  q \circ f = q \circ g
\]
$q$ is necessarily an Epimorphism.

A Coequalizer in a Category $\mathbf{C}$ is an Equalizer in
$\mathbf{C}$ and \emph{vice versa}.

The Categories $\mathbf{Set}$ and $\mathbf{Pos}$ have all
Coequalizers.

Quotient (\S\ref{sec:equivalence_class})



\paragraph{Cokernel}\label{sec:cokernel}

\paragraph{Coend}\label{sec:coend}



\subsubsection{Pushout}\label{sec:pushout}

A Pushout is the Colimit of a Span (\S\ref{sec:span})

$B +_A C \cong (B + C)/~$



\subsubsection{Tensor Product}\label{sec:tensor_product}

Monoidal Category (\S\ref{sec:monoidal_category})



\paragraph{Copower}\label{sec:copower}



\subsubsection{Direct Limit}\label{sec:direct_limit}

\paragraph{$\omega$-colimit}\label{sec:omega_colimit}
\hfill \\

$\omega$-colimit $G_\infty$

Forgetful Functor $U : \mathbf{Grp} \rightarrow \mathbf{Set}$ creates
$\omega$-colimits (and all Limits). \cite{awodey06}



\subsubsection{Cocomplete Category}\label{sec:cocomplete_category}

A \emph{Cocomplete Category} is a Category where all Small Colimits
exist.



% --------------------------------------------------------------------
\subsection{Zero Object}\label{sec:zero_object}
% --------------------------------------------------------------------

An Object that is both an Initial and a Terminal Object is called a
\emph{Zero Object} (or \emph{Null Object}). A Category with a Zero
Object is called a \emph{Pointed Category}
(\S\ref{sec:pointed_category}).

For a Zero Object, $Z \in \mathbf{C}$, there is a Unique Morphism
between any two Objects, $A, B \in \mathbf{C}$ called the
\emph{Composite} in $Z$:
\[
  A \rightarrow Z \rightarrow B
\]

In $\mathbf{Grp}$, a Trivial Group ${1}$ is a Zero Object.



\subsection{Pointed Category}\label{sec:pointed_category}



% --------------------------------------------------------------------
\subsection{Exponential}\label{sec:category_exponential}
% --------------------------------------------------------------------

Given a Category $\mathbf{C}$ with Binary Products between any two
Objects:
\[
  \exists \times_{A,B} \forall A,B \in \mathbf{C}
\]
an \emph{Exponential} is an Object $B^A$ with a Universal Morphism
(\S\ref{sec:universal_morphism}) (sometimes called ``eval'' or
``apply''):
\[
  \epsilon : B^A \times A \rightarrow B
\]
such that:
\[
  \forall X, f \in \mathbf{C}, \exists ! \lambda f :
  \epsilon \circ (\lambda f \times 1_A) = f
\]
where $\lambda f \times 1_A : X \times A \rightarrow B^A \times A$ is
called the \emph{Exponential Transpose} of $f$. The Morphisms $f$ and
$\lambda f$ are called \emph{Exponential Adjoints}. The $\epsilon$
function is the Counit of the Adjunction (\S\ref{sec:adjoint}) between
the Product Functor and the Exponential Functor.

The Universal Mapping Property for Exponentials implies the two-way
Rule of Inference:
\[
  {
    \frac{X \times A \rightarrow B}
    {X \rightarrow B^A}
  }exp
\]
From this the following Two-way Inference Rule may be Derived:
\[
    \frac{1 \times A \rightarrow B}
    {1 \rightarrow B^A}
\]

An Exponential $B^A$ corresponds to the Function Space
(\S\ref{sec:function_space}) from $A$ to $B$. For $A,B \in
\mathbf{Set}_0$ in the Category of Sets, the Exponential $B^A$ is
equal to the Hom-set (\S\ref{sec:hom_set}) $Hom(A,B)$.

In a Poset such as a Propositional Calculus, the Exponential
corresponds to Implication:
\[
    \frac{x \leq b \Rightarrow a}
    {x \wedge a \leq b}
\]

Exponentials do not exists for Group Homomorphisms but they do for
Groupoids (\S\ref{sec:groupoid}).

A Category with an Exponential for any two Objects and a Terminal
Object (\S\ref{sec:terminal_object}) is a Cartesian Closed Category
(\S\ref{sec:cartesian_closed}). In a Cartesian Closed Category the
Functor sending $B$ to $B^A$ is the Right-adjoint Functor
(\S\ref{sec:adjoint_functor}) $- \times Y$ and there is a Bijection
between Hom-sets $Hom(X \times A, B)$ and $Hom(X, B^A)$:
\[
  Hom(X \times A, B) \cong Hom(X, B^A)
\]

An Exponential can also be introduced by a Morphism between Morphisms
called ``curry'' which is equivalent to $\lambda$ above:
\[
  curry : C^{A \times B} \rightarrow (C^B)^A
\]
In a Cartesian Closed Category such as Simply-typed Lambda Calculus
(\S\ref{sec:simply_typed}), all the Morphisms are Internal, so $curry$
corresponds to an Object:
\[
  curry : ((C^B)^A)^{C^{A \times B}}
\]



\subsubsection{Exponential Functor}\label{sec:exponential_functor}

$-^A : \mathbf{C} \rightarrow \mathbf{C}$



% --------------------------------------------------------------------
\subsection{Dependency Morphism}\label{sec:dependency_morphism}
% --------------------------------------------------------------------

\emph{Trace Monoid} (\S\ref{sec:trace_monoid})



% --------------------------------------------------------------------
\subsection{Kan Extension}\label{sec:kan_extension}
% --------------------------------------------------------------------



% ====================================================================
\section{Constructions}\label{sec:category_construction}
% ====================================================================

A \emph{Construction} is just a Functor (\S\ref{sec:functor}).

A Relation between Constructions is just a Natural Transformation
(\S\ref{sec:natural_transformation}).



% --------------------------------------------------------------------
\subsection{Opposite Category}\label{sec:opposite_category}
% --------------------------------------------------------------------

The \emph{Opposite} or \emph{Dual} (\S\ref{sec:abstract_category})
of a Category $\mathbf{C}$ is denoted $\mathbf{C^{op}}$ or
$\mathbf{C^*}$ and has the same Objects as $\mathbf{C}$ but the Domain
and Codomain in each Morphism is reversed. Objects and Morphisms of a
Dual Category may be written with over-lines to distinguish them from
the original Category: $\overline{f}: \overline{C} \rightarrow
\overline{D}$. With this notation the following Equalities may be
expressed:
\[
  1_{\overline{C}} = \overline{1_C}
\]\[
  \overline{f} \circ \overline{g} = \overline{g \circ f}
\]
A Terminal Object in $\mathbf{C}$ is an Initial Object in
$\mathbf{C^{op}}$ and vice-versa.

In a Dual Category the following are all Duals of eachother:
\begin{itemize}
  \item Monomorphisms and Epimorphisms (\S\ref{sec:morphism})
  \item Left and Right Inverses (\S\ref{sec:morphism})
  \item Initial and Terminal Objects (\S\ref{sec:universal_property})
\end{itemize}

The Functor $(-)^\mathbf{op} : \mathbf{Cat} \rightarrow \mathbf{Cat}$
is an Involution (\S\ref{sec:involution}) but is Contravariant so it
does not define any Isomorphisms.



% --------------------------------------------------------------------
\subsection{Category \& Functor Products}\label{sec:category_product}
% --------------------------------------------------------------------

A \emph{Product}, $\times$, is a construction (or more specifically a
Functor) on Categories or Functors:
\[
  \times : \mathbf{Cat} \times \mathbf{Cat} \rightarrow \mathbf{Cat}
\]



\subsubsection{Categorical Product}\label{sec:categorical_product}

Abstraction of Direct Product (\S\ref{sec:direct_product})



\subsubsection{Product Category}\label{sec:product_category}

A \emph{Product Category} can be constructed from two Categories,
$\mathbf{C}$ and $\mathbf{D}$, and is denoted:
\[
  \mathbf{C} \times \mathbf{D}
\]
has Objects of the form $(C,D)$ where $C \in \mathbf{C}$ and $D \in
\mathbf{D}$ and Morphisms $(f,g) : (C,D) \rightarrow (C',D')$ where $f
: C \rightarrow C' \in \mathbf{C}$ and $g : D \rightarrow D' \in
\mathbf{D}$. Composition and Identity are defined as:
\[
  (f',g') \circ (f,g) = (f' \circ f,g' \circ g)
\]\[
  1_{(C,D)} = (1_C, 1_D)
\]
$\mathbf{C} \times \mathbf{D}$ is a Product (\S\ref{sec:product}) in
$\mathbf{Cat}$.



\paragraph{Projection}\label{sec:projection_functor}
\hfill \\
A Product Category has a pair of \emph{Projections} which are Functors
from the Product Category to the original Categories:
\[
  \mathbf{C} \xleftarrow{\;\; P\;\;} \mathbf{C}\times\mathbf{D}
  \xrightarrow{\;\; Q\;\;} \mathbf{D}
\]
such that for $C,f \in \mathbf{C}, D,g \in \mathbf{D}$:
\[
  P(C,D) = C, \;\; P(f,g) = f
\]\[
  Q(C,D) = D, \;\; Q(f,g) = g
\]
Given any other Category, $\mathbf{B}$, there exists a unique Functor:
\[
  F : \mathbf{B} \rightarrow \mathbf{C} \times \mathbf{D}
\]
with:
\[
  PF = R : \mathbf{B} \rightarrow \mathbf{C}
\]\[
  QF = T : \mathbf{B} \rightarrow \mathbf{D}
\]
giving:
\[
  \forall h \in B, F(h) = (Rh,Th)
\]



\subsubsection{Bifunctor}\label{sec:bifunctor}

A \emph{Bifunctor} is a Functor of two Variables from a Product
Category to an arbitrary Category:
\[
  S : \mathbf{C} \times \mathbf{D} \rightarrow \mathbf{A}
\]

A \emph{Multifunctor} is a generalized to $n$ or more Variables.



\paragraph{Profunctor}\label{sec:profunctor}
\hfill \\

Bimodule (\S\ref{sec:bimodule})

$F : \mathbf{C} \nrightarrow \mathbf{D}$

$H_F : \mathbf{D}^{op} \times \mathbf{C} \rightarrow \mathbf{Set}$

Set of Heteromorphisms (\S\ref{sec:heteromorphism})

A Profunctor is a Bifunctor that is Contravariant in the first
argument and Covariant in the second.



\subsubsection{Functor Product}\label{sec:functor_product}

Give two Functors, $U : \mathbf{C} \rightarrow \mathbf{C'}$ and $V :
\mathbf{D} \rightarrow \mathbf{D'}$, a \emph{Functor Product} is
defined as:
\[
  U \times V : \mathbf{C} \times \mathbf{D}
  \rightarrow \mathbf{C'} \times \mathbf{D'}
\]
where:
\[
  (U \times V)(C,D) = (UC,VD), \;\; (U \times V)(f,g) = (Uf,Vg)
\]
and $(U \times V)$ is the unique Functor such that:
\[
  P'(U \times V) = UP, \;\; Q'(U \times V) = VQ
\]
%FIXME is the above correct?



% --------------------------------------------------------------------
\subsection{Functor Category}\label{sec:functor_category}
% --------------------------------------------------------------------

Given two Categories, $\mathbf{C}$ and $\mathbf{D}$, a \emph{Functor
  Category} is a Category with Objects as Functors $T : \mathbf{C}
\rightarrow \mathbf{D}$ and Morphisms as Natural Transformations
between Functors:
\[
  \mathbf{D}^{\mathbf{C}} = Fun(\mathbf{C},\mathbf{D})
\]
A Hom-set in a Functor Category may be denoted:
\[
  Nat(S,T) = \mathbf{D}^{\mathbf{C}}(S,T) =
    \{ \tau | \tau : S \rightarrow T \}
\]
With Evaluation Functor $\eta : \mathbf{D^C} \times \mathbf{C}
\rightarrow \mathbf{D}$, $\mathbf{D^C}$ is an Exponential
(\S\ref{sec:category_exponential}) in $\mathbf{Cat}$ and
$\mathbf{Cat}$ is a Cartesian Closed Category
(\S\ref{sec:cartesian_closed}).

The Functor Category $\mathbf{C^2}$ is Isomorphic to Arrow Categories
(\S\ref{sec:arrow_category}) $\mathbf{C}^\rightarrow$.

The Functor Category $\mathbf{C}^\mathrm{2}$ from the Discrete
Category $\mathrm{2}$ consisting of two Objects and no Morphisms other
than Identities is equivalent to the Product Category $\mathbf{C}
\times \mathbf{C}$.

For any Discrete Category $I$:
\[
  \mathbf{C}^I \cong \prod_{i \in I} \mathbf{C}
\]

The Functor Category $\mathbf{Set}^\downdownarrows$ where
$\downdownarrows$ is the Category with two Objects and two Morphisms
between them ($* \rightrightarrows \star$) is equivalent to the
Category of Graphs and Graph Homomorphisms $\mathbf{Graph}$. Cf.
Simplicial Sets (\S\ref{sec:simplicial_set}).

A Functor Category into the Category $\mathbf{Set}$ is called a
\emph{Category Diagram} (\S\ref{sec:category_diagram}).
%FIXME terminology doesn't match



\subsubsection{Arrow Category}\label{sec:arrow_category}

An \emph{Arrow Category} of a Category $\mathbf{C}$, written
$\mathbf{C^{\rightarrow}}$, has for its Objects the Morphisms of
$\mathbf{C}$ and as Morphisms pairs of Objects such that their
underlying Morphisms in $\mathbf{C}$ are Composable (Commutative
Squares).

The Arrow Category $\mathbf{C}^\rightarrow$ is Isomorphic to the
Functor Category $\mathbf{C^2}$.

There are two Functors defined on an Arrow Category:
\[
  \mathbf{C} \xleftarrow{\mathbf{dom}} \mathbf{C}^\rightarrow
  \xrightarrow{\mathbf{cod}} \mathbf{D}
\]



\subsubsection{Set-valued Functor Category}\label{sec:setvalued_functor}

A \emph{Set-valued Functor Category} (or \emph{Category of Diagrams})
is a Functor Category from a Category into the Category
$\mathbf{Set}$.

A Presheaf (\S\ref{sec:presheaf}) is an example of a Set-valued
(Contravariant) Functor Category from an Opposite Category into
$\mathbf{Set}$.



\paragraph{Powerset Functor}\label{sec:powerset_functor}
\hfill \\

$\mathcal{P} : \mathbf{Set} \rightarrow \mathbf{Set}$

Functions $f : X \rightarrow Y$ to the Image Mapping $img(f) :
\mathcal{P}(X) \rightarrow \mathcal{P}(Y)$



% --------------------------------------------------------------------
\subsection{Free Category}\label{sec:free_category}
% --------------------------------------------------------------------

A \emph{Free Category}, $\mathbf{C}_G$, is Generated by a Directed
Graph or Precategory (\S\ref{sec:precategory}), $G$, of Vertices
and Edges under Concatenation of Paths.

For a Graph with a single Vertex, the Free Category is the Free Monoid
on the Edges of the Graph. A Graph with no Edges generates a Discrete
Category (\S\ref{sec:category}). The Free Category on a Graph with
two Vertices and one Edge between them is the Finite Category
$\mathbf{2}$.

Any Directed Acyclic Graph generates a Partial Order as its Free
Category.



% --------------------------------------------------------------------
\subsection{Comma Category}\label{sec:comma_category}
% --------------------------------------------------------------------

A \emph{Comma Category} is formed from a pair of Functors
(\S\ref{sec:functor}) that share a common Codomain. For three
Categories, $\mathbf{A}$, $\mathbf{B}$, and $\mathbf{C}$ and Functors
$S$ (\emph{Source}) and $T$ (\emph{Target}) in the following relation:
\[
  \mathbf{A} \xrightarrow{\;\; S\;\;} \mathbf{C} \xleftarrow{\;\;
    T\;\;} \mathbf{B}
\]
one can form a Comma Category $(S \downarrow T)$ with Objects as
Triples $(\alpha, \beta, f)$ where $\alpha$ is an Object in
$\mathbf{A}$, $\beta$ is an Object in $\mathbf{B}$, and $f : S(\alpha)
\rightarrow T(\beta)$ is a Morphism in $\mathbf{C}$ and with Morphisms
between Triples $(\alpha, \beta, f)$ to $(\alpha', \beta', f')$ as
pairs $(g,h)$ where $g : \alpha \rightarrow \alpha'$ is a Morphism in
$\mathbf{A}$ and $h : \beta \rightarrow \beta'$ is a Morphism in
$\mathbf{B}$.

When $S$ is a Functor, $\mathbf{1} \xrightarrow{\;\;S\;\;}
\mathbf{C}$, to a single Object $A \in \mathbf{C}$, the resulting
Comma Category may be denoted $(A \downarrow \mathbf{C})$ and is
called the Category of Objects under $A$. Here Objects are Morphisms
with Domain of $A$, and Morphisms are Commutative triangles with top
Vertex $A$.

The Category of Objects over $A$ is likewise $(\mathbf{C} \downarrow
A)$ and has as Objects Morphisms with Codomain $A$ and Morphisms are
Commutative triangles with a bottom Vertex $A$.

When both $S$ and $T$ are Functors from $\mathbf{1}$ to Objects $A$
and $B$ respectively, the result is a Discrete Category whose Objects
are $Hom(A,B)$.

The case where $S = T = 1_\mathbf{C}$, $(\mathbf{C} \downarrow
\mathbf{C})$, is the Category of all Morphisms of $\mathbf{C}$:
$\mathbf{C}^\mathbf{2}$.



\subsubsection{Slice Category}\label{sec:slice_category}

A \emph{Slice Category} $\mathbf{C}/C$ of a Category $\mathbf{C}$ with
an Object $C$ has as Objects the Morphisms with Codomain $C$ and as
Morphisms those Morphisms in $\mathbf{C}$ between the Domains of the
underlying Morphisms of the Objects of $\mathbf{C}/C$. That is, for
Objects in the Slice Category corresonding to Morphisms $f$ and $f'$,
the Morphism in the Slice Category between the two is $g$ such that
\[
  f' \circ g = f
\]

\emph{Coslice}



% --------------------------------------------------------------------
\subsection{Quotient Category}\label{sec:quotient_category}
% --------------------------------------------------------------------

%FIXME this probably needs a rewrite

The \emph{Quotient Category} is defined for a Category $\mathbf{C}$
with Congruence Relation $\sim$ as $\mathbf{C}/\sim$:
\[
  (\mathbf{C}/\sim)_0 = \mathbf{C_0}
\]\[
  (\mathbf{C}/\sim)_1 = (\mathbf{C_1})/\sim
\]
where Morphisms are of the form $[f]$ where $f \in \mathbf{C_1}$.

For a Category $\mathbf{C}$ with Graph $G$ and relations $R$,
$\mathbf{C}/R$ is called the Category with \emph{Generators} $G$ and
\emph{Relations} $R$.



\subsubsection{Congruence Category}\label{sec:congruence_category}

\emph{Congruence} on a Category is an Equivalence Relation on
Morphisms such that for two Morphisms $f,g \in \mathbf{C_1}$, $f \sim
g$ Implies:
\begin{itemize}
  \item $dom(f) = dom(g)$
  \item $cod(f) = cod(g)$
  \item $\forall a,b \in \mathbf{C_1}, bfa \sim bga$
\end{itemize}
Such a Congruence defines a \emph{Congruence Category}
$\mathbf{C^{\sim}}$:
\[
  (\mathbf{C^{\sim}})_0 = \mathbf{C}_0
\]\[
  (\mathbf{C^{\sim}})_1 = \{\langle f,g \rangle | f \sim g\}
\]\[
  \tilde{1_\mathbf{C}} = \langle 1_\mathbf{C}, 1_\mathbf{C} \rangle
\]\[
  \langle f',g' \rangle \circ \langle f,g \rangle = \langle f'f,g'g \rangle
\]
The Categorical Congruence $~$ on a Group $G$ is a Normal Subgroup $N
\subseteq G$ and the Quotient Category $G/~$ and the Quotient Group
$G/N$ coincide. \cite{awodey06}



\subsubsection{Kernel Category}\label{sec:kernel_category}

Given a Functor $F : \mathbf{C} \rightarrow \mathbf{D}$, a Congruence
$\sim_F$ on $\mathbf{C}$ is defined as:
\[
  f \sim_F g \leftrightarrow dom(f) = dom(g) \wedge cod(f) = cod(g)
  \wedge F(f) = F(g)
\]
The \emph{Kernel Category} of $F$ is then defined as the Congruence
Category of $\sim_F$
\[
  ker(F) = C^{\sim_F}
\]



\subsubsection{Finitely Presented Category}
\label{sec:finitely_presented}

% FIXME free category notation?
A \emph{Finitely Presented Category} is given by taking the Quotient
Category of a Free Category (\S\ref{sec:free_category})
$\mathbf{C}(G)$ with the Congruence $\sim_\Sigma$:
\[
  \mathbf{C}(G) / \sim_{\Sigma} = \mathbf{C}(G,\Sigma)
\]
where $\Sigma$ is the finite Set of Relations:
\[
  (g_1 \circ \ldots \circ g_n) = (g'_1 \circ \ldots \circ g'_m)
\]
for all $g_i \in G$ such that $dom(g_n) = dom(g'_m)$ and $cod(g_1) =
cod(g'_1)$.



% --------------------------------------------------------------------
\subsection{Closed Category}\label{sec:closed_category}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Monoidal Category}\label{sec:monoidal_category}
% --------------------------------------------------------------------

\emph{Monoidal Category} (or \emph{Tensor Category}) is a Category
$\mathbf{C}$ with a Bifunctor $\otimes$:
\[
  \otimes : \mathbf{C} \times \mathbf{C} \rightarrow \mathbf{C}
\]
which is Associative up to a Natural Isomorphism, along with an Object
$I$ that is both the Left and Right Identity for $\otimes$ up to a
Natural Isomorphism.

\emph{Coherence Conditions}

$\mathbf{Set}$ is a Monoidal Category with the Cartesian Product as
the Bifunctor and the Singleton Sets as the Identity Elements.

With respect to Coproducts, $\mathbf{Set}$ is a Symmetric Monoidal
Category with the Disjoint Sum as the Bifunctor and the Empty
Set as the Identity Element.

Untyped $\lambda$-calculus (\S\ref{sec:untyped_lambda})



\subsubsection{Rigid Category}\label{sec:rigid_category}

\subsubsection{Autonomous Category}\label{sec:autonomous_category}

\subsubsection{Closed Monoidal Category}\label{sec:closed_monoidal}

Linear Type Systems (\S\ref{sec:linear_type}) are the Internal
Language of Closed Symmetric (\S\ref{sec:symmetric_monoidal}) Monoidal
Categories



\subsubsection{Braided Monoidal Category}\label{sec:braided_monoidal}

\paragraph{Symmetric Monoidal Category}\label{sec:symmetric_monoidal}
\hfill \\

Linear Type Systems (\S\ref{sec:linear_type}) are the Internal
Language of Closed (\S\ref{sec:closed_monoidal}) Symmetric Monoidal
Categories



\subsubsection{Compact Closed Category}\label{sec:compact_closed}

\paragraph{Simplex Category}\label{sec:simplex_category}

\subparagraph{Simplicial Set}\label{sec:simplicial_set}
\hfill \\

A \emph{Simplicial Set} is a Contravariant Functor from the
\emph{Simplex Category} $\Delta$ (\S\ref{sec:simplex_category}) into
$\mathbf{Set}$. An equivalent definition is in terms of Presheaves:
\[
  X: \Delta^{op} \rightarrow \mathbf{Set}
\]



\paragraph{Pro-simplicial}\label{sec:pro_simplicial}
\hfill \\

Shape Theory (\S\ref{sec:shape_theory})



\subsubsection{Cartesian Closed Category}\label{sec:cartesian_closed}

A Category is \emph{Cartesian Closed} if it has:
\begin{enumerate}
\item A Product Functor (\S\ref{sec:product})
\item An Exponential for any pair of Objects
  (\S\ref{sec:category_exponential})
\item A Terminal Object (\S\ref{sec:terminal_object})
\end{enumerate}
By these conditions and the Universal Mapping Property of
Exponentials:
\[
  \forall f : X \times A \rightarrow B \Leftrightarrow
  \exists ! \overline{f} : X \rightarrow B^A
\]

The Category of Types in the Simply Typed $\lambda$-calculus
(\S\ref{sec:simply_typed}) is a Catesian Closed Category.

For a Theory $\mathcal{F}$, the Cartesian Close Category
$\mathbf{C}(\mathcal{F})$ is built from the $\lambda$-calculus over
$\mathcal{F}$ by the Presented Generators and Relations stated in
$\mathcal{F}$ and has the Universal Mapping Property such that given
any Model $M$ of $\mathcal{F}$ in any Cartesian Closed Category
$\mathbf{D}$ there is a Unique Functor:
\[
  \llbracket - \rrbracket_M :
    \mathbf{C}(\mathcal{F}) \rightarrow \mathbf{D}
\]
preserving $[X]_M = M$ for the Basic Types and Terms of $\mathcal{F}$.
\cite{awodey06}

$\mathbf{Cat}$ is a Cartesian Closed Category.

$\mathbf{Grpd}$ is a Cartesian Closed Category.

$\lambda^{\times, \rightarrow} \simeq \mathrm{CCC}$

$\mathrm{IPC}^{\wedge, \Rightarrow, \vee} \simeq \mathrm{Heyting Algebra}$

Kripke Models: $\mathbf{Set^C}$, $\mathbf{Set}^P$ % FIXME

Equalities on a Cartesian Closed Category $\mathbf{C}$ with
$0,1,A,B,C \in \mathbf{C}_0$:
\[
  C^{A + B} \cong C^A \times C^B
\]\[
  (C^B)^A \cong C^{B \times A}
\]\[
  (A \times B)^C \cong A^C \times B^C
\]\[
  C^0 \cong 1
\]\[
  C^1 \cong C
\]\[
  A \times (B + C) \cong A \times B + A \times C
\]



\paragraph{Locally Cartesian Closed Category}
\label{sec:locally_cartesian}
\hfill \\
A \emph{Locally Cartesian Closed Category} $\mathbf{E}$ is a Category
such that all Slice Categories (\S\ref{sec:slice_category})
$\mathbf{E}/X$ are Cartesian Closed Categories.

Model for Intuitionistic Type Theory with Dependent Types
(\S\ref{sec:intuitionistic_type})



\subsubsection{Bicartesian Closed Category}\label{sec:bicartesian}

A \emph{Bicartesian Closed Category} is a Cartesian Closed Category
that also has an Initial Object and Coproducts that are distributed
over by Products.



\paragraph{Distributive Category}\label{sec:distributive_category}

If a Cartesian Closed Category $\mathbf{C}$ has Coproducts, then
Products and Coproducts are \emph{Distributive}:\cite{awodey06}
\[
  A \times (B + C) \cong (A \times B) + (A \times C)
\]



\subsubsection{Heyting Category}\label{sec:heyting_category}

Model for Intuitionistic First-order Logic
(\S\ref{sec:intuitionistic_logic})



% --------------------------------------------------------------------
\subsection{Enriched Category}\label{sec:enriched_category}
% --------------------------------------------------------------------

Replace Hom-sets with Objects from a general Monoidal Category
(\S\ref{sec:monoidal_category})



% --------------------------------------------------------------------
\subsection{Coherence Condition}\label{sec:coherence_condition}
% --------------------------------------------------------------------

%FIXME this section should probably be relocated



% ====================================================================
\section{Abelian Category}\label{sec:abelian_category}
% ====================================================================

Motivating Example $\mathbf{Ab}$ Category of all Abelian Groups with
Group Homomorphisms

Homology Theory (\S\ref{sec:homology_theory})



% ====================================================================
\section{Representable Category}\label{sec:representable_category}
% ====================================================================

A Category is \emph{Representable} if there is a Functor from that
Category into $\mathbf{Set}$.



% --------------------------------------------------------------------
\subsection{Concrete Category}\label{sec:concrete_category}
% --------------------------------------------------------------------

A \emph{Concrete Category} is pair, $(\mathbf{C},U)$, where
$\mathbf{C}$ is a Category and $U$ is a Faithful Functor $U :
\mathbf{C} \rightarrow \mathbf{Set}$.



% --------------------------------------------------------------------
\subsection{Locally Small Category}\label{sec:locally_small}
% --------------------------------------------------------------------

A Category is \emph{Locally Small} if all Hom-sets
(\S\ref{sec:hom_set}) of the Category are Sets and not Proper Classes.
% FIXME definition in terms of hom-sets

There is at least one canonical Representable Functor
(\S\ref{sec:representable_functor}) from any Locally Small Category
into $\mathbf{Set}$.



% ====================================================================
\section{Algebraic Category}\label{sec:algebraic_category}
% ====================================================================

An Category is an \emph{Algebraic Category} if it is Monadic
(\S\ref{sec:monad}) over $\mathbf{Set}$.

Variety (\S\ref{sec:variety})



% --------------------------------------------------------------------
\subsection{Finitary Algebraic Category}
\label{sec:finitary_algebraic_category}
% --------------------------------------------------------------------

Variety (\S\ref{sec:variety})

If $\mathbf{A}$ is a Finitary Algebraic Category then the Forgetful
Functor $U : \mathbf{A} \rightarrow \mathbf{Set}$ is Strictly Monadic
(\S\ref{sec:monadic_functor}) so that the Comparison Functor $K :
\mathbf{A} \rightarrow \mathbf{Set}^T$ is an Isomorphism where
$\mathbf{Set}^T$ is the Eilenberg-Moore (\S\ref{sec:eilenberg_moore})
Category on $\mathbf{Set}$.

% FIXME comparison functor



% ====================================================================
\section{$F$-algebra}\label{sec:f_algebra}
% ====================================================================

\emph{$F$-algebra}

\emph{$F$-coalgebra} (\S\ref{sec:f_coalgebra})



% --------------------------------------------------------------------
\subsection{Initial Algebra}\label{sec:initial_algebra}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Final Coalgebra}\label{sec:final_coalgebra}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{$F$-coalgebra}\label{sec:f_coalgebra}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Data Structure}\label{sec:data_structure}
% --------------------------------------------------------------------

\subsubsection{Ordered Tree}\label{sec:ordered_tree}

\paragraph{Trie}\label{sec:trie}

\paragraph{Prefix Tree}\label{sec:prefix_tree}

\paragraph{Suffix Tree}\label{sec:suffix_tree}



% ====================================================================
\section{Representation Theory}\label{sec:representation_theory}
% ====================================================================

Given a Functor $R$ from a Group $G$ to a general Category
$\mathbf{C}$:
\[
    R : G \rightarrow \mathbf{C}
\]
Such a Functor $R$ is termed a \emph{Representation} of $G$ in
$\mathbf{C}$.



% --------------------------------------------------------------------
\subsection{Linear Representation}\label{sec:linear_representation}
% --------------------------------------------------------------------

$R : G \rightarrow \mathbf{Vect}_K$



% ====================================================================
\section{Operad Theory}\label{sec:operad_theory}
% ====================================================================

% ====================================================================
\section{Institution Theory}\label{sec:institution_theory}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Institution}\label{sec:institution}
% --------------------------------------------------------------------

An \emph{Institution} consists of:

\begin{itemize}
\item a Category $\mathbf{Sign}$ of Signatures (\S\ref{sec:signature})
  and Signature Morphisms between them
\item a Functor $sen : \mathbf{Sign} \rightarrow \mathbf{Set}$ where
  $sen(\sigma)$ is a Set of Sentences and for each Signature Morphism
  $h : \sigma \rightarrow \sigma'$ there is a \emph{Sentence
  Translation Map}:
  \[
  sen(h) : sen(\sigma) \rightarrow sen(\sigma')
  \]
\item a Functor $Mod : \mathbf{Sign^{op}} \rightarrow \mathbf{Cat}$,
  giving the Category of Models $Mod (\sigma)$ for each Signature
  $\sigma$, and for each Signature Morphism $h : \sigma \rightarrow
  \sigma'$, the \emph{Reduct Functor}:
  \[
  Mod(h) : Mod(\sigma') \rightarrow Mod(\sigma)
  \]
  with $Mod(h)(\mathcal{M}')$ denoted by $\mathcal{M}'|_h$.
\item a Satisfaction Relation $\models_\sigma \subseteq |Mod(\sigma)|
  \times sen(\sigma)$ for each $\sigma \in \mathbf{Sign}$
\end{itemize}
where the following \emph{Satisfaction Condition} holds for each
Signature Morphism $h : \sigma \rightarrow \sigma'$ in
$\mathbf{Sign}$:
\[
  \mathcal{M}' \models_\sigma' h(\varphi) \Leftrightarrow
  \mathcal{M}'|_h \models_\sigma \varphi
\]
for all $\mathcal{M}' \in Mod(\sigma')$ and $\varphi \in sen(\sigma)$.
The Satisfaction Condition expresses that Truth is invariant under
change of Signature.



% ====================================================================
\section{Topos Theory}\label{sec:topos_theory}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Grothendieck Topology}\label{sec:grothendieck_topology}
% --------------------------------------------------------------------

Structure on a Category $\mathbf{C}$ that makes Objects of
$\mathbf{C}$ behave like Open Sets of a Topological Space.



\subsubsection{Site}\label{sec:site}

A \emph{Site} is a Category together with a chosen Grothendieck
Topology.

Site underlying a Topos is associated with a Pro-simplicial Set
(\S\ref{sec:pro_simplicial}) up to Homotopy



\subsubsection{Sheave}\label{sec:sheave}

Presheaf (\S\ref{sec:presheaf})



\subsubsection{Etale Topology}\label{sec:etale_topology}



% --------------------------------------------------------------------
\subsection{Topos}\label{sec:topos}
% --------------------------------------------------------------------

A \emph{Topos} is a Category with Finite Limits (\S\ref{sec:limit})
and Power Objects (\S\ref{sec:power}) for all Objects.

Category behaving like the Category of Sheaves (\S\ref{sec:sheave})
of Sets on a Topological Space

Generalization of Point-set Topology (\S\ref{sec:general_topology})



\subsubsection{Grothendieck Topos}\label{sec:grothendieck_topos}

Grothendieck Topology (\S\ref{sec:grothendieck_topology})



\subsubsection{Etale Topos}\label{sec:etale_topos}

Etale Topology (\S\ref{sec:etale_topology})

Scheme (\S\ref{sec:scheme})



\subsubsection{Elementary Topos}\label{sec:elementary_topos}

Formal Logic (\S\ref{sec:formal_logic})

Intuitionistic Type Theory (\S\ref{sec:intuitionistic_type})



\subsubsection{Effective Topos}\label{sec:effective_topos}

Effectivity (\S\ref{sec:effective_method})



% --------------------------------------------------------------------
\subsection{Geometric Morphism}\label{sec:geometric_morphism}
% --------------------------------------------------------------------



% ====================================================================
\section{Higher Category Theory}\label{sec:higher_category}
% ====================================================================

% --------------------------------------------------------------------
\subsection{$2$-category}\label{sec:2_category}
% --------------------------------------------------------------------



\subsubsection{Doctrine}\label{sec:doctrine}

$2$-category regarded as a System of Theories
(\S\ref{sec:formal_theory}).



\paragraph{Hyperdoctrine}\label{sec:hyperdoctrine}
\hfill \\

Categorical Logic: collection of Contexts with Operations of Context
Extension/Substitution and Quantification on the Categories of
Propositions as Types in each Context



% --------------------------------------------------------------------
\subsection{Quasicategory}\label{sec:quasicategory}
% --------------------------------------------------------------------

\emph{Quasicategory} (or \emph{$inf$-category})



\subsubsection{Nerve}\label{sec:nerve}

Generalization of a Classifying Space (\S\ref{sec:classifying_space})



% --------------------------------------------------------------------
\subsection{Homotopy Category}\label{sec:homotopy_category}
% --------------------------------------------------------------------

Homotopy Type Theory gives the Internal Language
(\S\ref{sec:internal_language}) of Higher Categories
(\S\ref{sec:higher_category})



% --------------------------------------------------------------------
\subsection{Comprehension Category}\label{sec:comprehension_category}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Contextual Category}\label{sec:contextual_category}
% --------------------------------------------------------------------

Dependent Type Theory (\S\ref{sec:logical_framework})



% --------------------------------------------------------------------
\subsection{Model Category}\label{sec:model_category}
% --------------------------------------------------------------------

Homotopy



\subsubsection{Weak Equivalence}\label{sec:weak_equivalence}



% --------------------------------------------------------------------
\subsection{Weak $n$-category}\label{sec:weak_ncategory}
% --------------------------------------------------------------------

\subsubsection{Bicategory}\label{sec:bicategory}
