%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Systems Theory}\label{sec:systems_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%FIXME new tex file?

Operad Theory (\S\ref{sec:operad_theory}): Systems of Systems

Operad (\S\ref{sec:operad}): compositional style

Algebra (??? \S\ref{sec:universal_algebra}): System type



% ====================================================================
\section{State Variable}\label{sec:state_variable}
% ====================================================================

% ====================================================================
\section{Steady State}\label{sec:steady_state}
% ====================================================================

``Fixed-point'', ``Equilibria'' %FIXME



% ====================================================================
\section{Closed System}\label{sec:closed_system}
% ====================================================================

%FIXME

Actor Model (\S\ref{sec:actor_model}) -- \emph{Computational
  Representation Theorem} -- Consequence: a Finite Actor can
Nondeterministically Respond with an Uncountable number of different
Outputs %FIXME



% ====================================================================
\section{Open System}\label{sec:open_system}
% ====================================================================

(2016 - Fong - The Algebra of Open and Interconnected Systems):

\fist Hypergraph (\S\ref{sec:hypergraph}), Hypergraph Category
(\S\ref{sec:hypergraph_category})

Interconnection (``Integration'') of Systems modelled by Cospans
(\S\ref{sec:cospan})

\url{https://johncarlosbaez.wordpress.com/2017/06/20/the-theory-of-devices/}

Principle of Compositionality

``Network-style Diagrammatic Languages''

Network Diagram (\S\ref{sec:network_diagram}), ``Network-style
Diagrammatic Languages'' -- Electrical Circuits

other examples: Signal Flow Graphs (\S\ref{sec:signal_flow}),
Markov Processes (\S\ref{sec:markov_process}), Automata
(\S\ref{sec:automaton}), Petri Nets (\S\ref{sec:petri_net}), Chemical
Reaction Networks
%FIXME

\emph{Terminal} -- ``point of Interconnection''; ``boundary''
``marked'' using Cospan (\S\ref{sec:decorated_cospan}), Connected to
others using Pushouts (\S\ref{sec:pushout}); having a ``marked
boundary'' in this way makes a Closed System into an Open System;
process of ``freely''  ``marking boundaries'' constructs a Hypergraph
Category (\S\ref{sec:hypergraph_category}) from a ``library'' of
Network pieces

\emph{Components} with multiple Input/Output Terminals (possibly
labelled with some Type) connected to form a larger \emph{Network}

Components form \emph{Hyperedges} between labelled Vertices

\begin{itemize}
  \item each Terminal of an Open System may make ``Measurements''
    appropriate to the ``Type'' of the Terminal
  \item given a collection of Terminals, the \emph{Universum} is the
    Set of all possible Measurement outcomes
  \item each Open System has a collection of Terminals (and a Universum)
  \item the Semantics of an Open System is the Subset of Measurement
    outcomes on the Terminals that are ``permitted'' by the System,
    known as the \emph{Behavior} of the System
\end{itemize}

%FIXME universum = phase space?

``Laws'' (e.g. Ohm's Law) are mechanisms for Partitioning Behaviors
into \emph{Possible} and \emph{Impossible} Behaviors

given a Universum $\class{U}$, a Behavior of a System is an Element
of the Power Set $\pow(\class{U})$ (representing all possible
Measurements of the System), and a Law is an Element of
$\pow(\pow(\class{U}))$ representing all possible Behaviors of a
\emph{Class} of Systems

\emph{Interconnection} of Terminals asserts the Identification of
Variables at the Identified Terminals

Algebra of Semantic Objects and Homomorphism from Syntax to Semantics
(Principle of Compositionality \S\ref{sec:compositionality})



% ====================================================================
\section{Dynamical System}\label{sec:dynamical_system}
% ====================================================================

A \emph{Dynamical System} is defined as a tuple $(T,M,\Phi)$ where \emph{Time
  Domain} $T$ is a Monoid (\S\ref{sec:monoid}), \emph{State Space} $M$ is a
Non-empty Set and $\Phi$ is an \emph{Evolution Function}:
\[
  \Phi : U \subseteq T \times M \rightarrow M
\]

In a Geometrical setting $M$ is a Manifold (locally a Banach Space or Euclidean
Space) and the Evolution Rule $\Phi(t)$ gives a \emph{Diffeomorphism} of the
Manifold to itself for every $t \in T$. %FIXME clarify

Discrete, Continuous, Hybrid

Control Theory (\S\ref{sec:control_theory})

Initial Conditions, Driving Functions

%FIXME relate to transition systems, automata ?

Open Dynamical Systems -- Double Categories (\S\ref{sec:double_category})

\url{https://www.youtube.com/watch?v=cu718EbCOPs} Spivak 16:

can't have Identities and Feedback without Partiality %FIXME

Traced Ideals %FIXME

the Integral Curves (\S\ref{sec:integral_curve}) for the Differential Equation
governing the System are referred to as \emph{Trajectories} or \emph{Orbits}

the Evolution Function is often the Solution of a Differential Equation
(\S\ref{sec:differential_equation}) of Motion $\dot{x} = v(x)$ giving the Time
Derivative of a Trajectory $x(t)$ on the Phase Space starting at some Point
$x_0$ where $v(x)$ is a Vector Field and a Smooth Function providing the
Velocity Vector of the Dynamical System at every Point of the Phase Space $M$,
with Vectors lying in the Tangent Space $T_xM$ of the Point $x$

when the Differential Equations determining the Evolution Function are Ordinary
Differential Equations (\S\ref{sec:ode}), then the Phase Space $M$ is a Finite
Dimensional Manifold



% --------------------------------------------------------------------
\subsection{Linear Dynamical System}\label{sec:linear_dynamical_system}
% --------------------------------------------------------------------

In a \emph{Linear Dynamical System} the Variation of a State Vector $\vec{x}$
is equal to a Constant Matrix $A$ multiplied by $\vec{x}$

when $\vec{x}$ Varies Continuously with Time it is a \emph{Flow}:
\[
  \frac{d}{dt}\vec{x}(t) = A\vec{x}(t)
\]
otherwise if $\vec{x}$ Varies in Discrete steps it is a \emph{Map}
(\S\ref{sec:discrete_dynamical_system}):
\[
  \vec{x}_{m+1} = A\vec{x}_m
\]
(FIXME: clarify)

If $\vec{x}(t)$ and $\vec{y}(t)$ are two valid Solutions, then so is any Linear
Combination of $\vec{x}(t)$ and $\vec{y}(t)$.

\emph{Superposition Principle}: if $u(t)$ and $w(t)$ satisfy the Differential
Equation for the Vector Field (but not necessarily the Initial Condition) then
so will $u(t) + w(t)$

(wiki): Linear Dynamical Systems have ``exact'' (FIXME: Closed-form ???)
Solutions



% --------------------------------------------------------------------
\subsection{Discrete-time Dynamical System}\label{sec:discrete_dynamical_system}
% --------------------------------------------------------------------

\emph{Discrete-time Dynamical System}, \emph{Map}



% --------------------------------------------------------------------
\subsection{Dissipative System}\label{sec:dissipative_system}
% --------------------------------------------------------------------

Thermodynamics



% --------------------------------------------------------------------
\subsection{Complex Dynamics}\label{sec:complex_dynamics}
% --------------------------------------------------------------------

Analytic Functions (\S\ref{sec:analytic_function})



\subsubsection{Julia Set}\label{sec:julia_set}

\subsubsection{Fatou Set}\label{sec:fatou_set}



% --------------------------------------------------------------------
\subsection{Time-invariant System}\label{sec:time_invariant_system}
% --------------------------------------------------------------------

\subsubsection{Linear Time-invariant System}\label{sec:lti}

for a Linear Time-invariant System, when taking the Laplace Transform
(\S\ref{sec:laplace_transform}) and if the Poles (\S\ref{sec:complex_pole}) in
the Complex Plane are:
\begin{itemize}
  \item in the Right Half Plane (positive Real component) then the System is
    \emph{Unstable}
  \item in the Left Half Plane (negative Real component) then it will be
    \emph{Stable}
  \item on the Imaginary Axis, it will have \emph{Marginal Stability}
\end{itemize}


% ====================================================================
\section{Communicating System}\label{sec:communicating_system}
% ====================================================================

Denielou-Yoshida13 -- arises from a Choreographed collection of
Communicating Finite State Machines (CFSMs
\S\ref{sec:communicating_fsm}) in the context of Multiparty Session
Types (\S\ref{sec:multiparty_session})

Linear Multirole Logic (LMRL \S\ref{sec:lmrl})

\fist Process Calculus (\S\ref{sec:process_calculus})

Lange-Tuosto-Yoshida15:

\emph{Generalized Multiparty Compatibility} (GMC) -- Decidable
Condition characterizing a Set of Communicating Systems for which
questions of Safety (Deadlock-freedom, Orphan Messages, and
Unspecified Reception Configuration) can be Decided

\emph{Communicating System}:
\[
  \class{S} = (M_p)_{p \in \class{P}}
\]
where $M_p = (Q_p, q_{0p}, \Sigma, \delta_p)$ are CFSMs for each
Participant $p \in \class{P}$

\emph{Configuration} of $\class{S}$ %FIXME



% --------------------------------------------------------------------
\subsection{Choreography}\label{sec:choreography}
% --------------------------------------------------------------------

\emph{Choreographies}: ``Models of Interactions among Software
Components from a \emph{Global} point of view'' --
Lange-Tuosto-Yoshida15

\fist Global Types (\S\ref{sec:global_type}) give \emph{Choreographic
  Specifications} of Interactions (\S\ref{sec:interaction_geometry})



\subsubsection{Graphical Choreography}\label{sec:graphical_choreography}

or \emph{Global Graphs}

\fist Labelled Graph (\S\ref{sec:labelled_graph})

\begingroup

\newcommand{\party}{\mono}

\emph{From Communicating Machines to Graphical Choreographies} \\
Lange-Tuosto-Yoshida 2015

includes a Haskell prototype

Ng-Yoshida16 \emph{Static Deadlock Detection for Concurrent Go by
  Global Session Graph Synthesis} builds on this work: tool extracts
Communication Operations as Session Types, converts into CFSMs, and
then applies the Choreography Synthesis to generate a Global Graph
representing the overal Communication pattern

\fist Communicating Finite State Machines (CFSMs
\S\ref{sec:communicating_fsm})

\begin{itemize}
\item CFSMs as \emph{Behavioral Specifications} of \emph{Distributed
  Components} from which a \emph{Choreography} can be built
\item Sound and Complete characterization of ``safe'' CFSMs from which
  Global Graphs can be constructed
\item CFSM model based on Asynchronous FIFO Message-passing
  Communication
\end{itemize}

presented Algorithm produces a Choreography expressed as a Global Graph
(closely related to BPMN 2.0 Choreography) given a Set of CFSMs (a Set
of Behavioral Specifications of components Interacting through
Asynchronous FIFO Message Passing)

\fist an example implementation for Golang in Ng-Yoshida16

TODO: could a Categorization be given in terms of Decorated Cospan
Categories (\S\ref{sec:decorated_cospan_category}) ?

\asterism

\emph{Note on notation}: Lange-Tuosto-Yoshida15 uses $A$ for
Alphabet and $Act$ for Actions, here we use $\Sigma$ for Alphabet and
$A$ for Actions

detailed Proofs can be found in the full version of
Lange-Tuosto-Yoshida15 (36pp.):
\url{http://www.doc.ic.ac.uk/~jlange/papers/lty15.pdf}

Haskell code:

\url{https://bitbucket.org/julien-lange/gmc-synthesis}


\textbf{CFSMs}

$\Sigma = \{ a,b,c,d,\ldots \}$ -- Finite Alphabet (Messages) \\
$\class{P} = \{ \party{p, q, r, s},\ldots\}$
-- Finite Set of \emph{Participants} \\
$C \defeq \{ \party{pq}
  \ |\ \party{p,q} \in \class{P}, \party{p \neq q} \}$
-- Set of \emph{Channels} \\
$A \defeq C \times \{!,?\} \times \Sigma$ -- Set of \emph{Actions} \\
$\ell$ -- ranges over Actions \\
$\Sigma^*$, $A^*$ -- Set of Finite Words on $\Sigma$, $A$ \\
$\varphi$ -- ranges over $\Sigma^*$, $A^*$ \\

\emph{CFSM} $M$ as a $4$-tuple:
\[
  M = (Q, q_0, \Sigma, \delta)
\]
$Q$ -- Finite Set of \emph{States} \\
$q_0 \in Q$ -- \emph{Initial State} \\
$\delta \subseteq Q \times A \times Q$ -- Set of \emph{Transitions}
that are \emph{Labelled} by Actions \\

$\party{pq}!a$ -- Action Label representing Sending a Message $a$ from
$\party{p}$ to $\party{q}$ \\
$\party{pq}?a$ -- Action Label representing Receiving a Message $a$ by
$\party{q}$ from $\party{p}$

$\class{L}(M) \subseteq A^*$ -- Language on $A$ Accepted by the
Automaton corresponding to CFSM $M$ where each State of $M$ is an
Accepting State %TODO explain accepting state

For $q \in Q$:
\begin{itemize}
  \item $q$ is a \emph{Final State} if $q$ has no Outgoing Transitions
  \item $q$ is a \emph{Sending State} if $q$ has all Outgoing
    Transitions that are Labelled by Send Actions
  \item $q$ is a \emph{Receiving State} if $q$ has all Outgoing
    Transitions that are Labelled by Receive Actions
  \item $q$ is a \emph{Mixed State} if $q$ has both Send and
    Receive Actions as Outgoing Transitions
\end{itemize}

\emph{Deterministic CFSMs}

CFSM $M$ is \emph{Deterministic} if for all States $q \in Q$ and all
Actions $\ell \in A$:
\begin{itemize}
  \item if $(q,\ell,q'),(q,\ell,q'') \in \delta$ then $q = q''$
\end{itemize}

\emph{Minimal CFSMs}

CFSM $M$ is \emph{Minimal} if there are no other CFSMs $M'$ with fewer
States and Transitions such that $\class{L}(M) = \class{L}(M')$


\textbf{Communicating Systems}

\emph{Communicating System}:
\[
  \class{S} = (M_p)_{p \in \class{P}}
\]
where $M_p = (Q_\party{p}, q_{0\party{p}}, \Sigma, \delta_\party{p})$
are CFSMs for each Participant $\party{p} \in \class{P}$

\emph{Configurations}

$s = (\vec{q};\vec{w})$ -- a \emph{Configuration} of $\class{S}$
where:
\begin{itemize}
  \item $\vec{q} = (q_\party{p})_{\party{p} \in \class{P}})$ with
    $q_\party{p} \in Q_\party{p}$ is the \emph{Control State} and
    $q_\party{p} \in Q_\party{p}$ is the \emph{Local State} of CFSM
    $M_\party{p}$
  \item $\vec{w} = (w_\party{pq})_{\party{pq} \in C}$ with
    $w_\party{pq} \in \Sigma^*$
\end{itemize}
$s_0 = (\vec{q}_0;\vec{\varepsilon})$ -- \emph{Initial Configuration}
of $\class{S}$ with $\vec{q}_0 = (q_{0\party{p}})_{\party{p} \in
  \class{P}}$

\emph{Configuration Reachability}

$s \xrightarrow{\ell} s'$ -- Configuration $s' = (\vec{q}',\vec{w}')$
is \emph{Reachable} from Configuration $s = (\vec{q},\vec{w})$ by
Transition $\ell$ if there is a Symbol (Message) $a \in \Sigma$ such
that either:
\begin{itemize}
  \item $\ell = \party{sr}!a$ and $(q_\party{s},\ell,q_\party{s}') \in
    \delta_\party{s}$
  \item $q_\party{p}' = q_\party{p}$ for all $\party{p \neq s}$
  \item $w_\party{sr}' = w_\party{sr}.a$ and $w_\party{pq}' =
    w_\party{pq}$ for all $\party{pq \neq sr}$
\end{itemize}
or:
\begin{itemize}
  \item $\ell = \party{sr}?a$ and $(q_\party{r},\ell,q_\party{r}') \in
    \delta_\party{r}$
  \item $q_\party{p}' = q_\party{p}$ for all $\party{p \neq r}$
  \item $w_\party{sr} = a.w_\party{sr}'$ and $w_\party{pq}' =
    w_\party{pq}$ for all $\party{pq \neq sr}$
\end{itemize}
%TODO some explanation

$Rc(\class{S}) = \{ s \ |\ s_0 \rightarrow^* s \}$ -- Set of
\emph{Reachable Configurations} of Communicating System $\class{S}$
where $\rightarrow^*$ is the Reflexive and Transitive Closure of the
Reachability Relation $\rightarrow$

\emph{$k$-bounded Transition Sequences}

A Sequence of Transitions is \emph{$k$-bounded} if no Channel of any
intermediate Configuration in the Sequence contains more than $k$
Messages.

$Rc_k(\class{S})$ -- the \emph{$k$-reachability Set} of Communicating
System $\class{S}$ is the largest Subset of $Rc(\class{S})$ within
which each Configuration $s$ can be reached by a $k$-bounded Sequence
from $s_0$


\textbf{Safe Communicating Systems}

\emph{Deadlock Configurations}

Configuration $s = (\vec{q},\vec{w})$ is a \emph{Deadlock
  Configuration} when:
\begin{itemize}
  \item $\vec{w} = \vec{e}$
  \item there exists an $\party{r} \in \class{P}$ such that
    $(q_\party{r},\party{sr}?a,q_\party{r}') \in \delta_\party{r}$
  \item for all $\party{p} \in \class{P}$ and $q_\party{p}$ is a
    Receiving or Final State
\end{itemize}
i.e. all Buffers are empty, there is at least one Machine waiting for
a Message, and all the other Machines are either in a Final or
Receiving State

\emph{Orphan Message Configurations}

Configuration $s = (\vec{q},\vec{w})$ is an \emph{Orphan Message
  Configuration} if all $q_\party{p} \in \vec{q}$ are Final but
$\vec{w} \neq \vec{\varepsilon}$, i.e. there is at least one non-empty
Buffer and all Machines are in a Final State

\emph{Unspecified Reception Conrigurations}

Configuration $s = (\vec{q},\vec{w})$ is an \emph{Unspecified
  Reception Configuration} if there exists an $\party{r} \in
\class{P}$ such that $q_\party{r}$ is a Receiving State and
$(q_\party{r},\party{sr}?a,q_\party{r}') \in \delta_\party{r}$ Implies
$0 < |w_\party{sr}|$ and $w_\party{sr} \notin aA^*$, i.e.
$q_\party{r}$ is prevented from Receiving any Messages from any of its
Buffers %TODO better explanation ?


Def. (\emph{Safe Communicating System}) A Communicating System
$\class{S}$ is \emph{Safe} if each $s \in Rc(\class{S})$ is not a
Deadlock, Orphan Message, or Unspecified Reception Configuration.


\textbf{Concurrent Actions}

The following definitions are provided as a means of specifying a
Subset of Safe Communicating Systems from which \emph{Global Graphs}
can be constructed, namely by identifying Sets of \emph{Concurrent
  Actions}, i.e. Actions that can be \emph{Interleaved}.

Communicating Systems that are amenable for being transformed into
Global Graphs will be identified through their \emph{Synchronous
  Transition System} (see below).


\emph{Equivalence Classes on CFSM Transitions}

$act(q,q') \defeq \{ \ell \ |\ (q,\ell,q') \in \delta \}$ -- Set of
Labels for all Transitions between two given States $q,q' \in Q$

$\lozenge,\blacklozenge \subseteq \delta \times \delta$ -- smallest
Equivalence Relations on Transitions that respectively contain the
Relations $\underline{\lozenge}$:
\begin{flalign*}
\quad (q_1,\ell,q_2)\underline{\lozenge} (q_1',\ell,q_2')
  \Longleftrightarrow
  \ell \notin act(q_1,q_1') = act(q_2,q_2') \neq \varnothing &
\end{flalign*}
and $\underline{\blacklozenge}$:
\begin{flalign*}
\quad (q_1,\ell,q_2)\underline{\blacklozenge} (q_1',\ell,q_2')
  \Longleftrightarrow &
  (q_1,\ell,q_2)\underline{\lozenge}(q_1',\ell,q_2') \wedge
   \forall(q,\ell,q') \in [(q_1,\ell,q_2)]^\lozenge . & \\
   & act(q_1,q) = act(q_2,q') \wedge act(q_1',q) = act(q_2',q') &
\end{flalign*}
where $[(q,\ell,q')]^\lozenge$ is the Equivalence Class of
$(q,\ell,q')$ with respect to $\lozenge$

Intuitively, two Transitions are $\blacklozenge$-related if they refer
to the same Action up to Interleaving.
%TODO more explanation

\emph{note on the above $\underline{\blacklozenge}$ definition}: what
is being stated can more easily be worked out on paper; essentially
two ``parallel'' Labelled Transitions $A$, $B$ sharing the same Label
$\ell$ are $\underline{\blacklozenge}$-related when for every
Transition $C$ in the $\lozenge$-equivalence Class of $A$ (note all
$C$ are also $\ell$-labelled by the definition of $\lozenge$), the Set
of Transition Labels from the Source and Target State of $A$ into the
Source and Target State of each $C$, resp., are \emph{equal} Sets, and
the same is true for the Set of Transitions Labels from the Source and
Target State of $B$ into the Source and Target State of each $C$,
resp., are also \emph{equal} Sets

TODO: if one pair of such Transitions are $\underline{\blacklozenge}$,
does that imply that all pairs in the $\lozenge$-equivalence Class are
\emph{also} $\underline{\blacklozenge}$ ?

%FIXME what does this relation allow for ???


\textbf{Synchronous Transition Systems}

\emph{Synchronous Transition Systems} (see below) are used to identify
Communicating Systems which can be transformed into Global Graphs. A
Synchronous Transition System has:
\begin{itemize}
\item \emph{Nodes} each consisting of a Vector of Local CFSM States
\item \emph{Transitions} (Edges) Labelled by Elements in the \emph{Set
  of Events} (taken up to $\blacklozenge$-equivalence):
\[
  \class{E} \defeq \bigcup_{\party{s,r\in\class{P}}} Q_\party{s} \times
    Q_\party{r} \times \{(\party{s,r})\} \times \Sigma \}
\]
where Events are Tuples
$(q_\party{s},q_\party{r},\party{s},\party{r},a) \in \class{E}$, also
written:
\[
  (q_\party{s},q_\party{r},\party{s}\rightarrow\party{r}:a)
\]
indicating that Participants $\party{s}$ and $\party{r}$ can exchange
a Message $a$ when they are in States $q_\party{s}$ and $q_\party{r}$,
respectively
\end{itemize}

The \emph{indexing} of Events by Local (CFSM) States (i.e.
$q_\party{s}, q_\party{r}$) distinguishes Communication of the same
Message at different points in the Global Graph.


\textbf{Event Equivalence}

Def. \emph{$\class{E}$-equivalence} (\emph{Event Equivalence}):
\[
  \bowtie \defeq \bowtie_\party{s} \cap \bowtie_\party{r}
    \subseteq \class{E} \times \class{E}
\]
where:
\begin{flalign*}
& \quad (q_1,q_2, \party{s}\rightarrow\party{r} : a) \bowtie_\party{s}
    (q_1',q_2', \party{s}\rightarrow\party{r} : a)
  \Longleftrightarrow \\
& \quad\quad\quad \forall(q_1,\party{sr}!a,q_3),(q_1',\party{sr}!a,q_3')
      \in \delta_\party{s}
    . (q_1,\party{sr}!a,q_3)\blacklozenge(q_1',\party{sr}!a,q_3') \\
& \quad (q_1,q_2, \party{s}\rightarrow\party{r} : a) \bowtie_\party{r}
  (q_1',q_2', \party{s}\rightarrow\party{r} : a)
  \Longleftrightarrow \\
& \quad\quad\quad \forall(q_2,\party{sr}?a,q_4),(q_2',\party{sr}?a,q_4')
      \in \delta_\party{s}
    . (q_2,\party{sr}?a,q_4)\blacklozenge(q_2',\party{sr}?a,q_4')
\end{flalign*}
is an Equivalence Relation over Events that identifies Events with
underlying Local Transitions that are $\blacklozenge$-equivalent

$[e]$ -- Equivalence Class of Event $e$


\emph{Concurrent Interactions}

Squares in the Synchronous Transition System with Equivalent
Sender/Receiver/Message Events (but not the same Local States) on
opposite parallel sides (both ``horizontal'' and ``vertical'')
identify pairs of \emph{Concurrent Interactions}.


\textbf{Synchronous Transitions}

A \emph{Synchronous Transition System} is the Labelled Transition
System generated by the possible interleavings of \emph{Synchronous
  Transitions} (Send/Receive pairs) of the Local CFSMs.

$\vec{n}, \vec{n}', \ldots$ -- Vectors of Local States \\
$\vec{n}[\party{p}]$ -- the State of $\party{p} \in \class{P}$ in
$\vec{n}$ \\
$\hat{\delta} \defeq \{ (\vec{n},e,\vec{n}')
\ |\ (\vec{n};\vec{\varepsilon})
    \xrightarrow{\party{sr}!a} \xrightarrow{\party{sr}?a}
     (\vec{n}';\vec{\varepsilon}) \wedge
    e = (\vec{n}[\party{s}],\vec{n}[\party{r}],
      \party{s}\rightarrow\party{r}:a)
\}$ -- Set of Synchronous Transitions \\
%TODO is this the correct description?

$STS(\class{S})$ is the \emph{Synchronous Transition System} of
Communicating System $\class{S} =
(M_\party{p})_{\party{p}\in\class{P}}$ is a $4$-tuple:
\[
  STS(\class{S}) = (N,\vec{n}_0,E/\bowtie,\rightrightarrows)
\]
$N \defeq \{ \vec{q} \ |\ (\vec{q};\vec{\varepsilon}) \in
Rc_1(\class{S}) \}$ %FIXME explain this definition

$\vec{n}_0 = \vec{q}_0$ -- Initial State

$E \defeq \{ e \ |\ \exists\vec{n},\vec{n}' \in N :
  (\vec{n},e,\vec{n}') \in \hat{\delta} \} \subseteq \class{E}$
-- Set of Synchronous Events %TODO is this the correct description?

$\vec{n} \stackrel{[e]}{\rightrightarrows} \vec{n}'
  \Longleftrightarrow (\vec{n},e,\vec{n}') \in \hat{\delta}$ --
Synchronous Transition Relation %TODO is this the correct description?

note: original paper uses a representative Set $\hat{E}$ of Events for
each $\bowtie$-equivalence Class but here we will just continue
writing $[e]$

in $\hat{\delta}$, Events are $\bowtie$-equivalent if they have the
same Interaction $\party{s}\rightarrow\party{r} : a$
%TODO explain

$\pi$ -- ranges over Sequences of Events and $\rightrightarrows$ is
extended to Sequences of Events (as with the Reachibility Relation
$\rightarrow$ for Configurations above)


\emph{Projections}

$e\downharpoonright_\party{p}$ -- Projection of Event $e$ onto
Participant $\party{p}$:
\[
  (q_\party{s},q_\party{r},\party{s}\rightarrow\party{r}:a)
    \downharpoonright_\party{p}
  \defeq \begin{cases}
    \party{pr}!a &\ \text{if}\ \party{s = p} \\
    \party{sp}?a &\ \text{if}\ \party{r = p} \\
    \varepsilon  &\ \text{otherwise} \\
  \end{cases}
\]

$STS(\class{S})\downharpoonright_\party{p}$ -- Projection of
Synchronous Transition System onto Participant $\party{p}$ is the
Automaton $(Q, \vec{q}_0, \Sigma, \delta)$ where $Q = N$, $\vec{q}_0 =
\vec{n}_0$ and $\delta \subseteq Q \times A \cup \{\varepsilon\}
\times Q$ is such that $(\vec{n}_1, e\downharpoonright_\party{p},
\vec{n}_2) \in \delta \Leftrightarrow \vec{n}_1
\stackrel{e}{\rightrightarrows} \vec{n}_2$


\textbf{Generalized Multiparty Compatibility} (GMC)

a Sound and Complete condition for constructing Global Graphs

Def. (\emph{Generalized Multiparty Compatibility}) A Communicating
System $\class{S}$ is \emph{Generalized Multiparty Compatible (GMC)}
if it is \emph{Representable} and has the \emph{Branching Property}

\emph{Representability} -- for each CFSM, each Trace and each Choice
are ``\emph{represented}'' in $STS(\class{S})$; guarantees that
$STS(\class{S})$ contains enough information to decide \emph{Safety
  Properties} of any Asynchronous Execution of $\class{S}$

\emph{Branching Property} -- for each Choice in $STS(\class{S})$ a
unique CFSM makes the decision and each other Participant is either
notified of the Choice or else is not involved in the Choice; ensures
that if a ``\emph{branching}'' in $STS(\class{S})$ represents a
\emph{Choice}, then the Choice is ``Well-formed''


$\class{L}$ -- Language

$hd(\class{L})$ -- \emph{First Actions} of $\class{L}$:
\begin{align*}
  hd(\class{L}) \defeq& \{ \ell \ |\ \exists\varphi \in A^*
    : \ell\cdot\varphi \in \class{L} \} & \\
  hd(\{\varepsilon\}) \defeq& \{ \varepsilon \} &
\end{align*}

$STS(\class{S})<\vec{n}>$ -- Synchronous Transition System
$STS(\class{S})$ where Initial State $\vec{n}_0$ is replaced by
$\vec{n}$

$LTS(\class{S},\vec{n},\party{p})$ -- the Language
$\class{L}(STS(\class{S})<\vec{n}>\downharpoonright_p)$ obtained by
setting the Initial State (Node) of $STS(\class{S})$ to $\vec{n}$ and
then Projecting the resulting Synchronous Transition System onto
Participant $\party{p}$


\emph{Representability}

Def. (\emph{Representability}) Communicating System $\class{S}$ is
\emph{Representable} if for all $\party{p} \in \class{P}$:
\begin{enumerate}
  \item $\class{L}(M_\party{p}) = LTS(\class{S},\vec{n}_0,\party{p})$ and
  \item $\forall q \in Q_\party{p} \exists \vec{n} \in N :
    \vec{n}[\party{p}] = q \wedge
      \bigcup_{(q,\ell,q')\in\delta_\party{p}} \{ \ell \}
        \subseteq hd(LTS(\class{S},\vec{n},\party{p}))$
\end{enumerate}
(1) guarantees that each Trace of each CFSM is represented in
$STS(\class{S})$ and (2) is necessary to ensure that every Choice in
each CFSM is represented in $STS(\class{S})$

checking the Representability Condition for a Communicating System
$\class{S}$ has Exponential worst-case Time Complexity


\emph{Branching Property}

(auxiliary definitions for specifying Branching Property follow)

for $\vec{n},\vec{n}' \in N$, $\vec{n} \prec \vec{n}'$ if and only if:
\begin{enumerate}
  \item $\vec{n}\rightrightarrows^*\vec{n}'$ and
  \item for all Paths
    $\vec{n}_0\rightrightarrows\cdots\rightrightarrows\vec{n}_k =
    \vec{n}$ in $STS(\class{S})$ such that
    $\vec{n}_0,\ldots,\vec{n}_k$ are pairwise distinct,
    $\vec{n}'\neq\vec{n}_h$ for all $0 \leq h \leq k$
\end{enumerate}
i.e. $\vec{n} \prec \vec{n}'$ holds if $\vec{n}'$ is Reachable from
$\vec{n}$ and no ``simple'' Path from $\vec{n}_0$ to $\vec{n}$ goes
through $\vec{n}'$; note $\prec$ is not a Preorder in general

$ln(\vec{n},[e_1],[e_2])$ -- the \emph{Last Nodes} Reachable from
$\vec{n} \in N$ with $[e_1] \neq [e_2] \in E/\bowtie$ and $i,j \in
\{1,2\}$:
\begin{align*}
  ln(\vec{n},[e_1],[e_2]) \defeq \{ (\vec{n_1},\vec{n_2}) \ |\ &
    \exists\vec{n}' \in N : \vec{n}\rightrightarrows^*\vec{n}'
        \stackrel{[e_i]}\rightrightarrows\vec{n}_i \\
    \wedge & \forall\vec{n}'' \in N . \vec{n}'\rightrightarrows\vec{n}''
        \Longrightarrow
          \neg(\vec{n}'\prec\vec{n}''\stackrel{[e_i]}\rightrightarrows
  \}
\end{align*}
i.e. if $(\vec{n}_1,\vec{n}_2) \in ln(\vec{n},[e_1],[e_2])$ then
$\vec{n}_i$ is an $\stackrel{[e_i]}\rightrightarrows$-successor of a
Node $\vec{n}'$ on a Path from $\vec{n}$ whose Successors are either
not able to fire both $[e_1]$ and $[e_2]$ or else not $\prec$-related
to $\vec{n}'$

TODO why are ``last nodes'' here defined for a pair of events, instead
of a single ``last node'' for a single event-- branching ???

for Event $e =
(q_\party{s},q_\party{r},\party{s}\rightarrow\party{r}:a) \in
\class{E}$, let $\iota(e) = \party{s}\rightarrow\party{r}:a$ and
define a Dependency Relation $\lhd \subseteq \class{E}\times\class{E}$
on Events:
\[
  e \lhd e' \Leftrightarrow
    \iota(e) = \party{s}\rightarrow\party{r}:a \wedge
    (\iota(e') = \party{s}\rightarrow\party{r}:a' \vee
      \iota(e') = \party{r}\rightarrow\party{t}:a')
\]
i.e. $e$ and $e'$ are $\lhd$-related if there is a Dependency Relation
(\S\ref{sec:dependency_relation}) between the two Interactions from
the point of view of the \emph{Receiver} %TODO explain further

the Relation $e \blacktriangleleft_\pi e'$ in a Sequence of Events
$\pi$ is defined when there is a $\lhd$-relation between $e$ and $e'$
``in'' $\pi$:
\[
  e \blacktriangleleft_\pi e' \Leftrightarrow \begin{cases}
    (e \lhd e'' \wedge e'' \blacktriangleleft_{\pi'} e') \vee
      e \blacktriangleleft_{\pi'} e' & \text{if }\pi = e''\cdot\pi' \\
    e \lhd e' & \text{otherwise}
  \end{cases}
\]
%TODO explain

$dep(\iota(e),\pi,\iota(e'))$ if and only if:
\[
  (\pi = \pi_1\cdot{e}\cdot\pi_2\cdot{e'}\cdot\pi' \wedge
    (-,-,\iota(e)) \notin \pi_1 \wedge (-,-,\iota(e'))\notin \pi_2)
  \Longrightarrow e \blacktriangleleft_{\pi_2}
\]
checks whether there is a Dependency between two Interactions on a
Path $\pi$ (if these Interactions appear in $\pi$)
%TODO explain

Def. (\emph{Branching Property}) A Communicating System $\class{S}$
has the \emph{Branching Property} if for all $\vec{n} \in N$ and for
all $[e_1] \neq [e_2] \in E/\bowtie$ such that $\vec{n}
\stackrel{[e_1]}\rightrightarrows \vec{n}_1$ and $\vec{n}
\stackrel{[e_2]}\rightrightarrows \vec{n}_2$, then either:
\begin{enumerate}
  \item $\exists\vec{n}' \in N :
    \vec{n}_1\stackrel{[e_2]}\rightrightarrows\vec{n}' \wedge
    \vec{n}_2\stackrel{[e_1]}\rightrightarrows\vec{n}'$ \\ or
  \item for each $(\vec{n}_1',\vec{n}_2') \in ln(\vec{n},[e_1],[e_2])$,
    the following conditions hold:
    \begin{enumerate}
      \item \emph{Choice-awareness} -- $\forall\party{p}\in\class{P}$,
        either:
        \begin{itemize}
          \item $L_\party{p}^1 \cap L_\party{p}^2 \subseteq
            \{\varepsilon\}$ and $\varepsilon \in L_\party{p}^1
              \Longleftrightarrow \varepsilon \in L_\party{p}^2$ \\
            or
          \item $\exists\vec{n}'\in{N},\pi_1,\pi_2 :
            \vec{n}_1'\stackrel{\pi_1}\rightrightarrows\vec{n}' \wedge
            \vec{n}_2'\stackrel{\pi_2}\rightrightarrows\vec{n}' \wedge
            (e_1\cdot\pi_1)\downharpoonright_\party{p} =
            (e_2\cdot\pi_2)\downharpoonright_\party{p} = \varepsilon$
        \end{itemize}
      \item \emph{Unique Selector} -- $\exists!\party{s}\in\class{P} :
        L_\party{s}^1 \cap L_\party{s}^2 = \varnothing \wedge
        \exists\party{sr}!a \in L_\party{s}^1 \cup L_\party{s}^2$
      \item \emph{No Race} -- $\forall\party{r}\in\class{P} .
        L_\party{r}^1 \cap L_\party{r}^2 = \varnothing \\
        \Longrightarrow
          \forall\party{s}_1\party{r}?a_1\in{L_\party{r}^1},
          \forall\party{s}_2\party{r}?a_2\in{L_\party{r}^2} .
          \vec{n}'_i\stackrel{\pi_i}\rightrightarrows \\
        \Longrightarrow
          dep(\party{s}_i\rightarrow\party{r}:a_i,e_i\cdot\pi_i,
            \party{s}_j\rightarrow\party{r}:a_j)$ \\
    \end{enumerate}
    where:
    \[
      L_\party{p}^i \defeq
        hd(\{ e_i\downharpoonright_\party{p}\cdot\varphi
        \ |\ \varphi \in LTS(\class{S},\vec{n}_i',\party{p}) \})
    \]
    for $\party{p} \in \class{P}$ and $i,j \in \{1,2\}$
\end{enumerate}

checking the Branching Property is of Factorial Computation Complexity
in the size of $STS(\class{S})$


\textbf{Soundness Theorem}

Thm. (Soundness) \emph{If $\class{S}$ is GMC then it is
  \emph{Safe} (no Orphan Message, Deadlock, or Unspecified Reception
  Configurations).}

Soundness Theorem states that no (Asynchronous) execution of
$\class{S}$ will result in an Orphan Message, Deadlock, or Unspecified
Reception Configuration

with Representability (every Transition and Branching in each CFSM is
``represented'' in $STS(\class{S})$), Proof shows that for each
Branching Node $\vec{n}$, the Function $ln(\vec{n},[e_1],[e_2])$
allows enough Branches to be verified against the Branching Property
and then shows that any Sent Message is eventually Received and that a
CFSM in a Receiving State \emph{eventually} Receives a Message it
expected (by the Branching Property)


\textbf{Amending non-GMC Communicating Systems}

(Prop.) \emph{If Communicating System $\class{S}$ satisfies all but
condition (1) of the Representability Property, then the System
consisting of the (Minimized) Projections of $STS(\class{S})$ is GMC}

if the Projections of $STS(\class{S})$ do not have viable alternatives
then Language Equivalence check can be used to highlight which
Transitions (or Paths) of each CFSM are \emph{not} represented in
$STS(\class{S})$, and Local States and Transitions violating it can be
identified according to condition (2) of the Representability Property
%TODO explain

when the Branching Property is violated, one can give a Vector of
Local States and the two Branching Events for which a violation
occurs, as well as a witnessing Execution that leads to the offending
Configuration

suggestions for violating conditions:
\begin{itemize}
\item (2a) \emph{Choice-awareness} -- list the CFSMs for which the
  condition is not satisfied and:
  \begin{itemize}
    \item if the CFSM has a first same Receiving Action in both
      Branches, then it may be corrected by renaming some Messages
    \item if the CFSM Terminates in one Branch but not the other, then
      suggest to add a new Label and a Transition to the Final State
      in the Terminated Branch as well as a Dual Transition in a
      Sending Machine
  \end{itemize}
\item (2b) \emph{Unique Selector} -- highlight the Set of CFSMs
  Sending Messages at the Branching Node and suggest the
  identification of a ``genuine selecting Machine'' and add
  Communication from this CFSM to the others
\item (2c) \emph{No Race} -- highlight for each violating CFSM the
  Messages on which a Race Condition may occur and suggest adding an
  acknowledgement Message between the two corresponding Actions
\end{itemize}


\textbf{Global Graph Construction Algorithm}

\fist Petri Nets (\S\ref{sec:petri_net})

Communicating System $\longrightarrow$ Synchronous Transition System
  $\longrightarrow$ GMC check \\
\-\ \-\ \-\ $\longrightarrow$ Petri Net
  $\longrightarrow$ One-source Net $\longrightarrow$ Joined Net
  $\longrightarrow$ Pre-global Graph \\
\-\ \-\ \-\
  $\longrightarrow$ Global Graph

\begin{align*}
  & \class{S} = (M_\party{p})_{\party{p}\in\class{P}}
    \longrightarrow STS(\class{S})
    \longrightarrow assert(GMC(STS(\class{S}))) \\
  & \longrightarrow \mathbf{N}_1 \longrightarrow \mathbf{N}_2
    \longrightarrow \mathbf{N}_3 \longrightarrow G_{pre}
    \longrightarrow G
\end{align*}

\begin{enumerate}
  \item Petri Net $\mathbf{N}_1$ -- Safe and Extended Free-choice
    Petri Net with a Reachability Graph that is Bisimilar to the
    original Transition System; construction from
    [Cortadella-Kishinevsky-Lavagno-Yakovlev98]: transforms Events of
    $STS(\class{S})$ into Transitions of $\mathbf{N}_1$ with Places
    built out of \emph{Regions} (Sets of States having uniform
    Behavior with regard to Events)
  \item One-source Net $\mathbf{N}_2$ -- transform Petri Net
    $\mathbf{N}_1$ so that its ``Initial Markings'' consist of exactly
    ``one place'' %FIXME explain
  \item Joined Net $\mathbf{N}_3$ -- Join Transitions wherever
    possible to make explicit Join and Fork points of the work-flow
  \item Pre-global Graph -- create a Vertex in the Global Grpah for
    each Place, Transition, and Element of the Flow Relation in the
    Joined Net $\mathbf{N}_3$, then Vertices are connected via
    ``Gates''
  \item Global Graph -- ``clean up'' Pre-global Graph of unnecessary
    Vertices
\end{enumerate}

(Prop) \emph{(2)-(4) is Computable in Polynomial Time on the size of
  $\mathbf{N}_1$.}

$\approx$ -- Weak Bisimilarity Relation on Reachability Graphs

Lemma (\emph{Weak Bisimilarity}) The Reachability Graphs $T_1$, $T_2$,
$T_3$ of $\mathbf{N}_1$, $\mathbf{N}_2$, $\mathbf{N}_3$, respectively,
are Weakly Bisimilar: $T_1 \approx T_2 \approx T_3$


\textbf{Global Graph Definition}

Def. (\emph{Global Graph}) A \emph{Global Graph} $G$ over Participants
$\class{P}$ and Messages (Alphabet) $\Sigma$ is a \emph{Labelled
  Graph} (\S\ref{sec:labelled_graph}):
\[
  G = \langle{V,D,\Lambda}\rangle
\]
with:

$V$ -- Vertices \\
$D\subseteq{V \times V}$ -- Edges \\
$\Lambda : V \rightarrow
  \{ \ocircle, \ocirc, \diamondplus, \boxvert \} \cup
  \{ \party{s}\rightarrow\party{r}:a
    \ |\ \party{s,r}\in\class{P} \wedge a \in \Sigma \}$
-- Labelling Function mapping Vertices to \emph{Interactions}
$\party{s}\rightarrow\party{r}:a$ and \emph{Gates} $\{ \ocircle,
\ocirc, \diamondplus, \boxvert \}$

$\party{s}\rightarrow\party{r}:a$ -- an Interaction where $\party{s}$
Sends a Message $a$ to $\party{r}$

$\ocircle$ -- Initial (Source) Vertex Gate: Source of a Global Graph

$\ocirc$ -- Terminal Vertex Gate: Termination of a Branch or Thread

$\boxvert$ -- Fork or Join Threads Gate

$\diamondplus$ -- Branch or Merge points, or entry points of Loops
Gate

$\Lambda^{-1}(\ocircle)$ is a Singleton

if $\Lambda(v) = \ocirc$ then $v$ has no outgoing Edges

if $\Lambda(v) \in \{\diamondplus, \boxvert\}$ then $v$ has at least
one incoming and one outgoing Edge

if $\Lambda(v) = \party{s}\rightarrow\party{r}:a$ then $v$ has
\emph{unique} incoming and \emph{unique} outgoing Edges


\textbf{Transformation from $\mathbf{N}_3$ to $G_{pre}$ to $G$}

$G_{pre}$ is obtained from $\mathbf{N}_3$ by:
\begin{enumerate}
  \item create a Vertex in the Global Graph for each Place,
    Transition, and Element of the Flow Relation in $\mathbf{N}_3$
  \item connect above Vertices via Gates:
    \begin{itemize}
      \item connect an Initial (Source) Vertex $\ocircle$ to the
        Vertex without a Predecessor
      \item connect Terminal (Sink) Vertex $\ocirc$ to any Vertex
        without Successors
      \item connect $\boxvert$-gates to Transitions if they have more
        than one Predecessor or Successor
      \item connect $\diamondplus$-gates Places if they have more than
        one Predecessor or Successor
    \end{itemize}
  \item connect each ``component'' of the Graph by merging ``Ports''
    corresponding to Elements in the Flow Relation %TODO clarify
\end{enumerate}

the Global Graph $G$ is obtained from $G_{pre}$ by removing all
``unnecessary'' Nodes (i.e. former Places and Transitions) and
Re-labelling Events into \emph{Interactions}-- Event $e$ is replaced
by $\iota(e)$ (i.e. the Local States are ``forgotten'')


\textbf{Global Graph Projection}

Global Graph $G$ can be Projected to Local CFSMs by either:
\begin{enumerate}[label=(\alph*)]
  \item transform $G$ into a Petri Net and Project the Reachability
    Graph of the Petri Net (cf. Projection of $LTS(\class{S})$)
  \\ or:
  \item \begin{itemize}
    \item transform $G$ into an Automaton with States as Nodes of $G$
      and each Transition Labelled by
      $(\party{s}\rightarrow\party{r}:a)\downharpoonright_\party{p}$
      if the Source State corresponds to a Vertex with Label
      $\party{s}\rightarrow\party{r}:a$ and by $\varepsilon$ otherwise
    \item take the Parallel Composition of the Automata resulting from
      the Projectin of each Successor of a $\boxvert$-gate
      %TODO explain
    \item minimize the resulting Automata with respect to Language
      Equivalence
  \end{itemize}
\end{enumerate}

$G\downharpoonright_\party{p}$ -- Projection of Global Graph $G$ onto
Participant $\party{p}\in\class{P}$ (Formal definition given in the
extended version of Lange-Tuosto-Yoshida15)


\textbf{Completeness Theorem}

a Synchronous Transition System $STS(\class{S}) =
(N,\vec{n}_0,E/\bowtie,\rightrightarrows)$ is \emph{Self-loop Free} if
$\forall\vec{n},\vec{n}'\in{N} . \vec{n}\rightrightarrows\vec{n}'
\Longrightarrow \vec{n}\neq\vec{n}'$

Thm. (Completeness) \emph{For GMC Communicating System $\class{S} =
  (M_\party{p})_\party{p\in\class{P}}$ and Global Graph $G$ built from
  $\class{S}$ with $STS(\class{S}) =
  (N,\vec{n}_0,E/\bowtie,\rightrightarrows)$, if $STS(\class{S})$ is
  Self-loop Free then $\class{S}$ is Isomorphic to the Projected
  Communicating System
  $(G\downharpoonright_\party{p})_{p\in\party{P}}$}

the Completeness Theorem relies on the fact that each CFSM is
\emph{preserved} during the construction:
\begin{enumerate}
  \item Projection of $STS(\class{S})$ onto each $\party{p}$ is
    Language Equivalent with $M_\party{p}$
  \item the Petri Net $\mathbf{N}_1$ obtained from $STS(\class{S})$ is
    Bisimilar to $STS(\class{S})$
  \item each transformation preserves (Weak) Bisimilarity with the
    Derived Petri Net (cf. Weak Bisimilarity Lemma)
  \item transformation to a Global Graph is \emph{Sound} since the
    Petri Net is ``Extended Free Choice'' %TODO clarify
\end{enumerate}


\textbf{Haskell Prototype Tool}

takes as Input a textual representation of a Communicating System
$\class{S}$, builds $STS(\class{S})$, checks Representability
Condition and Branching Property--uses HKC (Bonchi-Pous13) to check
for Language Equivalence--and constructs Petri Net from
$STS(\class{S})$ using Petrify tool:
\url{http://www.lsi.upc.edu/~jordicf/petrify/}


\endgroup


\asterism


Ng-Yoshida16 \emph{Static Deadlock Detection for Concurrent Go by
  Global Session Graph Synthesis}:

approach uses Sets of CFSMs to represent (Communicating) Systems of
Concurrent Processes

uses Haskell GMC tool from Lange-Tuosto-Yoshida15

introduces Dingo static analysis tool: analyzes Go source code to
derive a Set of Local Session Types by abstracting Concurrent
Interaction Patterns amongst Goroutines (Green Threads)

Synchronous Communication Model (Unbuffered ``Rendezvous'' Channels,
i.e. Channels with $0$-sized Buffers)

a \emph{Program} is a Closed Communicating System called a
\emph{Session}

each Local Session Type represents a single \emph{Participant} of the
Session, i.e. corresponds to a single instance of a Goroutine
($\mono{main}$ is an implicit Goroutine)

extracts Communication Operations in source code as a Local
Session Type-- a Control-flow Graph with Session Primitives where
each Node is one of:
\begin{itemize}
  \item $Channel\ ch\ T$ -- Create a new Channel named $ch$ of Type
    $T$
  \item $Send\ ch$ -- Send to a Channel $ch$:
    $ch!\langle{T}\rangle; T'$ where $T'$ is the Continuation
    (Child Node)
  \item $Recv\ ch$ -- Receive from a Channel $ch$:
    $ch?\langle{T}\rangle; T'$ where $T'$ is the Continuation
    (Child Node)
  \item $Close\ ch$ -- Close a Channel $ch$
  \item $Label$ -- a named Jump Label %TODO explain
\end{itemize}

Static Single Assignment (SSA) Intermediate Representation --
constructed by $\mono{go/ssa}$ package in the Go Standard Library:
simplifies Syntax of Go program into a limited Set of Instructions and
flattens the Control Flow of the Program as Jumps between Blocks of
Instructions for analysis

\emph{Communication Instructions} and \emph{Control Flow Instructions}
are sufficient to infer Local Types from Go Programs; \emph{Memory
  Access Instructions} do not affect Control Flow, nor perform any
Communication with other Goroutines, but they will be required to
track where Channels have been stored (e.g. in other Data Structures)

\begin{enumerate}
  \item analysis starts from Program Main Entry Point ($\mono{main}$)
    and interprets SSA instructions following the Program Control
    Flow:
    \begin{itemize}
      \item instructions related to Communications are converted to
        Nodes of the Local Session Type Graph
      \item instructions related to Control Flow are converted to
        Edges of the Local Session Type Graph
    \end{itemize}
  \item a Set of Local Session Type Graphs is generated to represent
    the Set of Goroutines in the Program
\end{enumerate}

SSA Communication Instructions:
\begin{itemize}
  \item $\mathsf{MakeChan\{Size\}}$ -- $Channel\ ch\ T$ \\
    -- creates a Channel with $\mathsf{Size}$-sized Buffer, in
    Ng-Yoshida16 this is always $\mathsf{Size = 0}$
  \item $\mathsf{Send\{Chan=ch, X\}}$ -- $Send\ ch$ \\
    -- Send a Value $\mathsf{X}$ to a Channel $\mathsf{Chan})$
  \item $\mathsf{UnOp\{Op=ARROW, X=ch\}}$ -- $Recv\ ch$ \\
    -- Receive from a Channel $X$ %TODO returns received?
  \item $\mathsf{Select\{States, Blocking\}}$ -- the Local Type of
    each Case in a $\mono{select}$ is appended as a Child to the
    Parent Local Graph Node of $\mathsf{Select}$ \\
    -- Non-deterministic Choice on Channel Communication: each Case is
    guarded by a Communication Operation and a Case is \emph{chosen}
    if it does not Block; $\mathsf{Blocking}$ is a Boolean indicating
    whether a $\mono{default}$ Case exists (chosen if all the
    Communication Cases are Blocking), which is given an $EmptyLabel$
    to denote no Communication Operations
  \item $\mathsf{Builtin\{Name=close, Arg=[ch]\}}$ -- $Close\ ch$ \\
    -- use of built-in Function $\mathsf{close}$ that Closes the given
    Channel
\end{itemize}
(??? Cases are tried in order FIXME)

Function Bodies in SSA IR are Segmented into \emph{Blocks} with
\emph{Jumps} between Blocks following the Control Flow of the Program

SSA Control Flow Instructions:
\begin{itemize}
  \item $\mathsf{Call\{Func, Method, Args\}}$ -- Edge is added in
    Local Type Graph from Caller to the Subgraph representing the
    Local Types of the Callee Body \\
    -- dual of $\mathsf{Return}$: Control Flow leaves the Caller and
    enters called Function
  \item $\mathsf{Go\{Func, Method, Args\}}$ -- add a new Local Type
    Graph to Session \\
    -- Spawns a Goroutine with Initial Node pointing to the Subgraph
    representing the Local Types of the Callee Body
  \item $\mathsf{Jump}$ -- Edge in Local Type Graph from the Local
    Types of the current Block to the Local Types of the next Block \\
    -- unconditional Jump from the current Block to a Successor Block:
    Sequential Transition from the end of the current Block to the
    next Block in the same Scope
  \item $\mathsf{Return}$ -- Edge in Local Type Graph joining the last
    Node of a Function to the Continuation of the Caller \\
    -- dual of $\mathsf{Call}$: Control Flow continues at the Caller
    of the called Function
  \item $\mathsf{If\{Cond\}}$ -- two Edges pointing to the Local Types
    for the ``Then'' and ``Else'' Blocks as Child Subgraphs\\
    -- Conditional Jump based on the Boolean $\mathsf{Cond}$
  \item $\mathsf{Defer\{Func, Method, Args\}}$, $\mathsf{RunDefers}$
    -- Edge in Local Type Graph at end of Caller pointing to the Local
    Type Subgraph of the Deferred Function \\
    -- pair of Instructions that \emph{Defer} a Call to a Function to
    the end of the current Function; this pushes the Deferred Function
    onto a special Stack of Deferred Function Calls which are
    guaranteed to be run with $\mathsf{RunDefers}$ once in each
    Control Flow Path per Function
\end{itemize}


\textbf{Global Graph Synthesis}

uses Haskell GMC tool from Lange-Tuosto-Yoshida15: takes Set of
Communicating Finite State Machines (CFSMs) as input and produces a
Global Graph of Transitions


\emph{Goroutine CFSMs}

Models the Communication Behavior of Goroutines: represents Control
Flows of the Inferred Local Types

\begin{enumerate}
  \item covert Local Session Graphs obtained from Go source code
    (``Inferred Local Types'') into CFSMs -- each Local Session Graph
    is translated to a single Goroutine CFSM

    Nodes in the Local Session Graph are \emph{Events} represented as
    State Transitions in the CFSM Model with Labels determined by the
    Type of the Local Type Node:
    \begin{itemize}
      \item Node $Send\ ch$ becomes Transition with Label $ch!T$ where
        $T$ is the Type of Channel $ch$
      \item Node $Recv\ ch$ becomes Transition with Label $ch?T$ where
        $T$ is the Type of Channel $ch$
      \item Node $Close\ ch$ becomes Transition with Label
        $ch!\mathsf{STOP}$
    \end{itemize}
\end{enumerate}


\emph{Channel CFSMs}

Channels between CFSMs are \emph{fixed} between two Machines: a CFSM
can use multiple Channels, but the Endpoints are always the same

Go Channels are \emph{Shared Names} which can be used by multiple
Goroutines as a \emph{Shared Location} for two or more Goroutines to
\emph{Synchronize} on Send and Receive Operations

this is \emph{preserved} when translated from Local Types to CFSMs:
CFSMs Communicate with Channels which are \emph{Variables} and
\emph{not} ``Endpoint Machines''

Channels connect to CFSMs as ``\emph{proxies}'': CFSMs do not
Communicate directly but Go Channels resemble \emph{Switches} or
\emph{Multiplexors} between CFSMs

Go Channels are Modelled as CFSMs themselves--\emph{Channel CFSMs}--to
represent all possible transitions that a Go Channel is allowed (such
as connecting multiple Goroutines dynamically)

\begin{enumerate}
  \setcounter{enumi}{1}
  \item construct a Channel CFSM for each identified Channel where the
    first outgoing Transition from the Initial State is a Receive
    Action and the second is a Send Action matched to the Initial
    Action, returning to the Initial State
\end{enumerate}

\emph{Global Graph Synthesis}: given both Goroutine CFSMs and Channel
CFSMs, Synthesize Global Graph from the CFSMs by procedure involving
generating \emph{all possible combinations} of Synchronous Labelled
Transitions of the composed CFSMs

\emph{For-loops}: translated as two Branches of Transitions from a
State: one for \emph{Exit Loop} and another for \emph{Continue Loop}
that loops back to the starting State
(FIXME is this in the CFSM or Global Graph ???)

Limitations:

allowing for ``flexible range of Program Control Flow patterns'', e.g.
For-loops (above), results in limited support for \emph{Dynamic
  Concurrency}, e.g. creating Channels in a Loop or \emph{conditional}
creation of Goroutines for ``Error Handling'', corresponding to
\emph{Runtime Spawning} of new Channel CFSMs and new Goroutine CFSMs,
respectively

to overcome limitations, in the Inference technique outlined above:
\begin{itemize}
\item if a condition inthe Control Flow of a Program decides if a
  Goroutine will be Spawned, then a \emph{Subset} of all generated
  CFSMs -- ``which (are ???) translated from Goroutines that are
  Spawned under the same condition'' (???) -- are \emph{selected} for
  Global Graph Synthesis to check that the System is Safe under the
  condition
\end{itemize}
(FIXME clarify)


\textbf{Generalized Multiparty Compatibility (GMC)}

Global Graph Nodes are \emph{Interactions} (matched Send/Receive
Actions) between two Participants (CFSMs)

Generalized Multiparty Compatibility (GMC -- Lange-Tuosto-Yoshida15):
\begin{enumerate}[label=(\roman*)]
  \item \emph{Representability} -- each Trace and Choices in the CFSMs
    are represented in the Global Graph: ensures no information is
    lost in the construction of the Global Type
  \item \emph{Branching Property} -- for all Choices in the Global
    Graph, a \emph{unique} CFSM takes (FIXME makes ???) the decision
    and the decision is \emph{propagated} to ``other'' CFSMs (FIXME to
    *all* other CFSMs ???) (the \emph{Unique Machine Condition}):
    ensures that all Branches are ``Well-formed''
\end{enumerate}

Representability only applies to Goroutine CFSMs: Channel CFSMs do not
give any influence on the Communication Behavior of Goroutine CFSMs


\textbf{Mixed Choices}

(TODO examples, clarify)

original Theory in Lange-Tuosto-Yoshida15 does not allow a CFSM to
have a \emph{Mixed Choice}, i.e. a Choice which has both Sending and
Receiving Actions from the same State

Go $\mono{select}$ allows writing Mixed Choices

in Lange-Tuosto-Yoshida15 the Branching Property requires unique
Senders (i.e. a unique Participant initiates Sending Actions)-- with
the Synchronous Model in Ng-Yoshida16 (as opposed to an Asynchronous
Model in Lange-Tuosto-Yoshida15), this condition can be relaxed by
replacing the unique Sender by the \emph{Unique Machine Condition}
(see above)


\textbf{Case Studies}

\begin{itemize}
  \item \emph{Pipeline} -- only safe if the Main Loop is
    \emph{Bounded} (cannot be Statically Verified unless Loops are
    ``Unrolled'')
  \item \emph{Fan-in}
\end{itemize}



% ====================================================================
\section{Phase Space}\label{sec:phase_space}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Attractor \& Repeller}\label{sec:attractor_repeller}
% --------------------------------------------------------------------



% ====================================================================
\section{Self-organized Criticality}\label{sec:self_organized_criticality}
% ====================================================================

Property of Dynamical Systems with a Critical Point as an Attractor

%FIXME



% ====================================================================
\section{Reaction-diffusion System}\label{sec:reaction_diffusion}
% ====================================================================

% ====================================================================
\section{Hamiltonian System}\label{sec:hamiltonian_system}
% ====================================================================

Scott Aaronson (\url{http://www.scottaaronson.com/blog/?p=3294}):

``\emph{the [Physical] Universe is ultimately made of Quantum Fields
  evolving by some Hamiltonian}''

Symplectic Integrator (\S\ref{sec:symplectic_integrator})



% ====================================================================
\section{Ergodic Theory}\label{sec:ergodic_theory}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Normal Number}\label{sec:normal_number}
% --------------------------------------------------------------------



% ====================================================================
\section{Chaos Theory}\label{sec:chaos_theory}
% ====================================================================

% ====================================================================
\section{Control Theory}\label{sec:control_theory}
% ====================================================================

Properties of possible Trajectories of Dynamical Systems
(\S\ref{sec:dynamical_system}) with certain Initial Conditions and
Driving Functions:

\emph{Observability}

\emph{Controllability} -- Property of Vector-valued Coupled
Differential Equations; \fist Cf. Information Theoretic \emph{Channel
  Capacity Theorem} (\S\ref{sec:channel_capacity})
%FIXME xref

Backpropagation ?


for a Linear Time-invariant System (\S\ref{sec:lti}), when taking the Laplace
Transform (\S\ref{sec:laplace_transform}) and if the Poles
(\S\ref{sec:complex_pole}) in the Complex Plane are:
\begin{itemize}
  \item in the Right Half Plane (positive Real component) then the System is
    \emph{Unstable}
  \item in the Left Half Plane (negative Real component) then it will be
    \emph{Stable}
  \item on the Imaginary Axis, it will have \emph{Marginal Stability}
\end{itemize}



% --------------------------------------------------------------------
\subsection{Signal Flow}\label{sec:signal_flow}
% --------------------------------------------------------------------

(\emph{SFG} or \emph{Mason Graph})

Nodes represent ``System Variables'' and Edges represent Functional
Connections between pairs of Nodes

%FIXME: move to information theory or control theory?

Semantics given by Corelation Categories
(\S\ref{sec:corelation_category})

Signal Flow Graph (\S\ref{sec:flow_graph})



% --------------------------------------------------------------------
\subsection{Controller}\label{sec:controller}
% --------------------------------------------------------------------

%FIXME

monitors and physically alters the operating conditions of a given
Dynamical System (\S\ref{sec:dynamical_system})



% --------------------------------------------------------------------
\subsection{Process Control}\label{sec:process_control}
% --------------------------------------------------------------------

\subsubsection{Model Predictive Control}\label{sec:model_predictive_control}



% --------------------------------------------------------------------
\subsection{Control Strategy}\label{sec:control_strategy}
% --------------------------------------------------------------------

TODO



\subsubsection{Optimal Control Theory}\label{sec:optimal_control}

\fist Calculus of Variations (\S\ref{sec:calculus_of_variations})



\paragraph{Linear Quadratic Regulator (LQR)}\label{sec:lqr}\hfill

dual of Linear Quadratic Estimation (LQE or \emph{Kalman Filtering}
\S\ref{sec:lqe})
