%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Type Theory}\label{part:type_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Type Theory} is the study of Classes of Formal Systems
(\S\ref{sec:formal_system}) where each Term (\S\ref{sec:term}) has a
\emph{Type} (\S\ref{sec:type}) and Operations are restricted to Terms
of specific Types.

A Type Theory may have two Signatures: $\sigma_\tau$ for Type Symbols
and $\sigma_o$ for Object (Term) Symbols. From this one may construct
a Monad $R = R_{\sigma_o}$, a Module over $R$: $LM =
LM_{\sigma_\tau,\sigma_o}$, and a Contextual Category
(\S\ref{sec:contextual_category}) $CC(R,LM)$ describing a Class of
Sub-quotients of $CC(R,LM)$ in terms of Objects Constructed from $R$
and $LM$. \cite{voevedsky14}

For Multi-sorted Type Theory see Pure Type Systems
(\S\ref{sec:pts})

As a Formal Theory (\S\ref{sec:formal_theory}), Judgements
(\S\ref{sec:judgement}) in Type Theory are of three
kinds\cite{hott13}:
\begin{enumerate}

\item \emph{Well-formed Context} (\S\ref{sec:type_context}):
  \[
    (\Gamma) \ctx
  \]
  ``$\Gamma$ is a Well-formed Context''

\item \emph{Propositional Equality} (Typing Judgement
    \S\ref{sec:typing_judgement}):
  \[
    \Gamma \vdash a : A
  \]
  ``Given Contex $\Gamma$, $a$ is a Term of Type $A$''

\item \emph{Definitional (Judgemental) Equality}:
  \[
    \Gamma \vdash a \equiv b : A
  \]
  ``Given Context $\Gamma$, $a$ and $b$ are Definitionally Equal Terms
  of Type $A$''

\end{enumerate}
with a Deductive Apparatus (\S\ref{sec:deductive_apparatus})
consisting of Inference Rules (\S\ref{sec:type_inference}) only and no
Axioms. Judgemental Equality is an Equivalence Relation respected by
Typing.

every Type Theory gives rise to a Cartesian Multicategory
(\S\ref{sec:cartesian_multicategory}) with Objects as Types and
Multimorphisms as Terms



\textbf{Intensional \& Extensional Type Theory}

\begin{itemize}
\item \emph{Extensional Type Theory} (\S\ref{sec:extensional_type}):
  Definitional (Computational) Equality is not distinguished from
  Propositional (Proof) Equality (Strict Equivalence) but Type Checking
  (\S\ref{sec:type_checking}) is Undecidable

\item \emph{Intensional Type Theory}: Type Checking is Decidable but
  Extensional Reasoning must be carried out using Setoids
  (\S\ref{sec:setoid}); (Weak Equivalence)

\item \emph{Observational Type Theory}
  (\S\ref{sec:observational_type}): Definitional (Intensional)
  Equality and Type Checking are Decidable, Propositional Equality is
  Extensional and Substitutive; a first-approximation of Homotopy Type
  Theory where OTT Propositions are $h$-propositions
  (\S\ref{sec:h_proposition}) and OTT Types are $h$-sets
  (\S\ref{sec:h_set})

\item \emph{Homotopy Type Theory} (\S\ref{sec:hott}):
  Higher Inductive Types (\S\ref{sec:higher_inductive_type}) allow
  definition of Higher-order Constructors
\end{itemize}

Term Rewrite System (\S\ref{sec:term_rewriting})

\emph{Conversion Rules}

\emph{Canonical Form} (\S\ref{sec:canonical_form})

\emph{Normal Form}


Meaning Explanation (\S\ref{sec:meaning_explanation})


\asterism


Intuitionistic Type Theory (\S\ref{sec:intuitionistic_type}): Agda

Calculus of Constructions (\S\ref{sec:coc}): Coc



% ====================================================================
\section{Expression}\label{sec:type_expression}
% ====================================================================

An \emph{Expression} (Syntactic Expression \S\ref{sec:expression}) is
an Equivalence Class of Syntactic Forms which differ in the Names of
\emph{Bound Variables}. That is, changing the Name of a Bound Variable
everywhere within an Expression (\emph{$\alpha$-conversion}
\S\ref{sec:alpha_conversion}) does not change the Expression.

some Expressions:
\begin{itemize}
  \item Term (\S\ref{sec:term})
  \item Type (\S\ref{sec:type})
  \item Proposition (\S\ref{sec:proposition})
  \item Context (\S\ref{sec:context})
\end{itemize}

\fist See also $\lambda$-expression (\S\ref{sec:lambda_expression})

A Variable is Bound in an Expression by an \emph{Abstraction} (e.g.
$\lambda$-abstraction \S\ref{sec:lambda_abstraction}) expressing that
the Variable is \emph{Local} to the Expression:
\[
  \lambda x.B
\]
or:
\[
  x.B
\]

\emph{Substitution} (e.g. $\lambda$-substitution
\S\ref{sec:lambda_substitution}):
\[
  [a \backslash x]B
\]
or:
\[
  B[a/x]
\]

Substitute Term $a$ for Free occurrences of Variable $x$ in the Term
$B$. Generalized:
\[
  B[x_1,\ldots,x_n / a_1,\ldots,a_n]
\]

\fist See also Substitution (Logic \S\ref{sec:substitution})


\asterism

nLab:

$\beta$-reduction (\S\ref{sec:beta_reduction}) -- how to Simplify a Term
that involves an Eliminator Applied to a Constructor, e.g.
$\lambda$-application (Eliminator) Applied to $\lambda$-abstraction
(Constructor):
\[
  (\lambda x.b)(a):B
\]
$\beta$-reduces (or Evaluates or Computes) to:
\[
  b[a/x]
\]
where $b : A \rightarrow B$, $a:A$

$\eta$-reduction (\S\ref{sec:eta_reduction}) -- how to Simplify a Term
that involves a Constructor applied to an Eliminator, e.g.
$\lambda$-abstraction (Constructor) Applied to $\lambda$-application
(Eliminator):
\[
  \lambda x.f(x)
\]
$\eta$-reduces to:
\[
  f
\]



% --------------------------------------------------------------------
\subsection{Term Constant}\label{sec:term_constant}
% --------------------------------------------------------------------

A \emph{Term Constant} is a Term that is a Base Type
(\S\ref{sec:type_constant})
% FIXME ???



% --------------------------------------------------------------------
\subsection{Well-typed Term}\label{sec:well_typed}
% --------------------------------------------------------------------

A \emph{Well-typed Term} (or \emph{Typable Term}) is a Term for which
a Typing Derivation (\S\ref{sec:typing_derivation}) exists.



% --------------------------------------------------------------------
\subsection{Term Constructor}\label{sec:term_constructor}
% --------------------------------------------------------------------

(or \emph{Data Constructor})

\fist Cf. Type Constructor (\S\ref{sec:type_constructor})



% --------------------------------------------------------------------
\subsection{$\alpha$-conversion}\label{sec:alpha_conversion}
% --------------------------------------------------------------------

\emph{$\alpha$-conversion} (or \emph{$\alpha$-renaming}) is a renaming
of Bound Variables in a Term that results in an $\alpha$-equivalent
(\S\ref{sec:alpha_equivalence}) Term:
\[
  \lambda x.x =_\alpha \lambda y.y
\]

\emph{Variable Convention}:
\begin{enumerate}
  \item Bound Variables are distinct from Free Variables
  \item ``Binders'' only Bind Variables not already in Scope % FIXME
\end{enumerate}

When represented as De Bruijn Indices (\S\ref{sec:debruijn_index}),
$\alpha$-equivalent Expressions are Syntactically identical.

\fist See also Nominal Logic (\S\ref{sec:nominal_logic})



\subsubsection{$\alpha$-equivalence}\label{sec:alpha_equivalence}

\subsubsection{De Bruijn Index}\label{sec:debruijn_index}

\emph{De Bruijn Indices} ``name-free''

Higher-order Abstract Syntax (\S\ref{sec:hoas})



% --------------------------------------------------------------------
\subsection{$\beta$-conversion}\label{sec:beta_conversion}
% --------------------------------------------------------------------
\cite{seldin03}

A \emph{$\beta$-conversion} is a Sequence of Zero or more
\emph{$\beta$-reductions} (Contractions \S\ref{sec:contraction}) or
\emph{$\beta$-expansions} (reverse Contractions). A $\beta$-conversion
from Term $M$ to Term $N$ is denoted $M =_\beta^* N$.

$\beta$-reduction (\S\ref{sec:beta_reduction}):
\[
  (\lambda x.b)(a) \rightarrow_\beta b[a/x]
\]

$\beta$-expansion (\S\ref{sec:beta_expansion}):
\[
  b[a/x] \rightarrow_\beta (\lambda x.b)(a)
\]




\subsubsection{$\beta$-reduction}\label{sec:beta_reduction}

A \emph{$\beta$-reduction} is a Sequence of Zero or more Contractions
(\S\ref{sec:contraction}). A Term $M$ that Reduces to a Term $N$ is
written $M \rhd N$. $\beta$-reduction may not Terminate but
$\beta$-reduction is Confluent (\S\ref{sec:rewrite_confluence}).

Dual to $\eta$-expansion (\S\ref{sec:eta_expansion})

As a Semantics for Functional Programming, a $\beta$-reduction
corresponds to a Computational Step.

for Function Types (\S\ref{sec:function_type})

for Inductive Types (\S\ref{sec:inductive_type}): $\iota$-reduction
(\S\ref{sec:iota_reduction})

Synchronization in Session Calculus (\S\ref{sec:session_calculus})
\cite{orchard-yoshida16}



\paragraph{$\iota$-reduction}\label{sec:iota_reduction}\hfill

analogous reduction for Inductive Types (\S\ref{sec:inductive_type})



\subsubsection{$\beta$-expansion}\label{sec:beta_expansion}



% --------------------------------------------------------------------
\subsection{$\eta$-conversion}\label{sec:eta_conversion}
% --------------------------------------------------------------------

\emph{$\eta$-abstraction} ($\eta$-expansion \S\ref{sec:eta_expansion}):
\[
  y \rightarrow_\eta \lambda x.y(x)
\]
\emph{$\eta$-reduction} (\S\ref{sec:eta_reduction}):
\[
  \lambda x.y(x) \rightarrow_\eta y
\]

Extensional (\S\ref{sec:extension}) Equivalence of Expressions



\subsubsection{$\eta$-expansion}\label{sec:eta_expansion}

Dual to $\beta$-reduction (\S\ref{sec:beta_reduction})

introducing a Constructor/Eliminator Pair



\subsubsection{$\eta$-reduction}\label{sec:eta_reduction}



% ====================================================================
\section{Type}\label{sec:type}
% ====================================================================

Formula (\S\ref{sec:formula})

Proposition (\S\ref{sec:proposition})

%FIXME move dependent types?

Dependent Types (\S\ref{sec:dependent_type})

\emph{Proper Type}, Inhabited Type (\S\ref{sec:inhabited_type}) a Type
which has Values (Terms?)

\fist Cf. Kind (\S\ref{sec:kind})



% --------------------------------------------------------------------
\subsection{Type Variable}\label{sec:type_variable}
% --------------------------------------------------------------------

Type Operator (\S\ref{sec:type_operator})

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism}):
Universally Quantified Type Variables

Abstract (Existential) Types (\S\ref{sec:abstract_type}):
Existentially Quantified Type Variables



% --------------------------------------------------------------------
\subsection{Type Constant}\label{sec:type_constant}
% --------------------------------------------------------------------

\emph{Type Constant} (also \emph{Primitive Type} or \emph{Base Type}
or \emph{Atomic Type})

Uninterpreted (\S\ref{sec:uninterpreted_function}) % FIXME



% --------------------------------------------------------------------
\subsection{Composite Type}\label{sec:composite_type}
% --------------------------------------------------------------------

Algebraic Types (\S\ref{sec:algebraic_type})



% --------------------------------------------------------------------
\subsection{Type Order}\label{sec:type_order}
% --------------------------------------------------------------------

In Simply-typed $\lambda$-calculus ($\lambda^\rightarrow$
\S\ref{sec:simply_typed})), the \emph{Order} of a Type $\tau$, denoted
$o(\tau)$, is defined Inductively as:
\begin{itemize}
\item $o(T) = 0$ if $T$ is a Base Type (\S\ref{sec:type_constant})
\item $o(\sigma \rightarrow \tau) = \text{max}(o(\sigma) + 1,
  o(\tau))$
\end{itemize}



% --------------------------------------------------------------------
\subsection{Type Polarity}\label{sec:type_polarity}
% --------------------------------------------------------------------

Constructors (\S\ref{sec:constructor})

Deconstructors (\S\ref{sec:deconstructor})


\asterism


Data Constructor

A \emph{Constructor} Introduces a Data Type on the right-hand side of
a definition.

A \emph{Destructor} Eliminates a Data Type on the left-hand side of a
definition.

Elimination for (Finite) Data corresponds to (Well-founded)
Recursion.

Introduction for Codata corresponds to Corecursion.

%FIXME



\subsubsection{Constructor}\label{sec:constructor}

Term Constructor (\S\ref{sec:term_constructor})

Type Constructor (\S\ref{sec:type_constructor})



\subsubsection{Deconstructor}\label{sec:deconstructor}

(or \emph{Eliminator})



\subsubsection{Positive Type}\label{sec:positive_type}

nLab:

\emph{Constructors} regarded as ``primary'': Eliminators are Derived
from Constructors by the Rule that to ``Use'' (Eliminate) an Element
of a Positive Type it is necessary and sufficient to specify what
should be done for all possible ways the Element could have been
Constructed

e.g. Inductive Types (\S\ref{sec:inductive_type}): Sum Type, Product
Type$^*$, Dependent Sum Type, Empty Type, Unit Type, Identity Type
%FIXME

Categorical Semantics: ``From the left'' Universal Properties, i.e.
``Mapping out'' ???

Denotational Semantics: well-behaved with respect to Strict Evaluation
Strategies (\S\ref{sec:strict_evaluation})



\subsubsection{Negative Type}\label{sec:negative_type}

nLab:

\emph{Eliminators} regarded as ``primary'': Constructors are Derived
from Eliminators by the Rule that to Construct an Element of a
Negative Type it is necessary and sufficient to specify how that
Element ``behaves'' when Applying all of the Eliminators to it

e.g. Coinductive Types (\S\ref{sec:coinductive_type}), Dependent
Product Types (\S\ref{sec:dependent_product}): Function Type
%FIXME

Categorical Semantics: ``From the right'' Universal Properties, i.e.
``Mapping in'' ???

Denotational Semantics: well-behaved with respect to Non-strict
Evaluation Strategies (\S\ref{sec:nonstrict_evaluation})



% --------------------------------------------------------------------
\subsection{Inhabited Type}\label{sec:inhabited_type}
% --------------------------------------------------------------------

\emph{Inhabited}

$\Gamma \vdash A\;\mathrm{true}$

$\Gamma \vdash a:A \Rightarrow \Gamma \vdash A\;\mathrm{true}$

In Simply-typed $\lambda$-calculus (\S\ref{sec:simply_typed}), a Type
is Inhabited if and only if its corresponding Proposition is a
Tautology of Minimal Implicative Logic (\S\ref{sec:minimal_logic}).

In Second-order $\lambda$-calculus (\S\ref{sec:system_f}), a
Type is Inhabited if and only if its corresponding Proposition is a
Tautology of Second-order Logic (\S\ref{sec:secondorder_logic}).

Empty Type (\S\ref{sec:empty_type})



% --------------------------------------------------------------------
\subsection{Finite Type}\label{sec:finite_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Infinite Type}\label{sec:infinite_type}
% --------------------------------------------------------------------

Infinite Data Type (\S\ref{sec:infinite_datatype})



% --------------------------------------------------------------------
\subsection{Universe Type}\label{sec:universe_type}
% --------------------------------------------------------------------

A \emph{Universe Type} contains all other Types, see Type Universe
(\S\ref{sec:type_universe}).



% --------------------------------------------------------------------
\subsection{Empty Type}\label{sec:empty_type}
% --------------------------------------------------------------------

Type with no Terms

\[
  \frac{}
  {\emptyset:\Type}
\]

%FIXME

Positive Type (\S\ref{sec:positive_type}): no Constructors

Negative Type (\S\ref{sec:negative_type}): Eliminator for any Term of
any Type ???

since the Empty Type contains no Elements, there are no Constructor
Rules; given an Element of $\emptyset$ one can Construct an Element of
any Type

the Positive and Negative definitions are Provably Equivalent, but
only using Contraction and Weakining Rules; therefore in Linear Type
Systems (\S\ref{sec:linear_type}) they are distinct with the Positive
Empty Type $0$ and Negative Empty Type $\bot$.



% --------------------------------------------------------------------
\subsection{Unit Type}\label{sec:unit_type}
% --------------------------------------------------------------------

``the'' Type with a Unique Term; special case of Product: Nullary
Product

\[
  \frac{}
  {():\Unit}
\]

Positive Type (\S\ref{sec:positive_type}): single Constructor $()$

Negative Type (\S\ref{sec:positive_type}): no Eliminators

Equivalence of Positive and Negative definitions uses Contraction and
Weakening Rules; therefore in Linear Type Systems
(\S\ref{sec:linear_type}) they are distinct with the Positive Unit
Type $1$ and Negative Unit Type $\top$.

Homotopy, Contractible Type %FIXME



% --------------------------------------------------------------------
\subsection{Equality Type}\label{sec:equality_type}
% --------------------------------------------------------------------

The \emph{Equality Type} (or \emph{Identity Type}), denoted
\emph{Propositional Equality}, represents Equality of Types and Terms.

$a =_A b$: ``$a$ and $b$ are Equal Objects of Type $A$''

Martin-L\"of Notation $I(A,a,b)$

For $a,b:A$, the Term $a = b : I(A,a,b)$ Denotes the Type of Equality
Proofs for ``$a$ is Equal to $b$''. If the Type $I(A,a,b)$ is
Inhabited (a Proof exists), then $a$ is Equal to $b$.

There is one Canonical Inhabitant of $I(A,a,a)$ (Proof of
Reflexivity):
\[
  \text{refl}: \prod_{a:A} (a=a)
\]



\subsubsection{Congruence Type}\label{sec:congruence_type}

%FIXME equality type?



% --------------------------------------------------------------------
\subsection{Quotient Type}\label{sec:quotient_type}\hfill
% --------------------------------------------------------------------

Set Theoretic Quotients

Categorical Semantics: Quotient Object (\S\ref{sec:quotient_object}) /
Coequalizer (\S\ref{sec:coequalizer})



% --------------------------------------------------------------------
\subsection{Algebraic Type}\label{sec:algebraic_type}
% --------------------------------------------------------------------

Trees (\S\ref{sec:tree})

All standard Algebraic Data Types are Functors (\S\ref{sec:functor}).
A Parametrically Polymorphic (\S\ref{sec:parametric_polymorphism})
Function between two such Functors is a Natural Transformation
(\S\ref{sec:natural_transformation}).

Algebraic Types form a Semiring (\S\ref{sec:semiring})



\subsubsection{Product Type}\label{sec:product_type}

(or \emph{Record Type})

(Cartesian) Product Types: Structs, Tuples

several Values called \emph{Fields}

If $\sigma$ and $\tau$ are Types, then $\sigma \times \tau$ is a Type

$x : \sigma$, $y : \tau$, $(x,y) : \sigma \times \tau$

$fst_{\sigma,\tau} : (\sigma \times \tau) \Rightarrow \sigma$

$snd_{\sigma,\tau} : (\sigma \times \tau) \Rightarrow \tau$

Corresponds to Cartesian Product (\S\ref{sec:cartesian_product})

Product Type $A \times B$ is a special case of Dependent Sum Type
(\S\ref{sec:sigma_type}) $(\Sigma x:A)B$ with a Constant Codomain
Type $B$:
\[
  (\Sigma x:A) B \equiv A \times B
\]
where $\equiv$ is Judgemental Equality.



\subsubsection{Sum Type}\label{sec:sum_type}

(also \emph{Coproduct Type} or \emph{Variant Type} or \emph{Tagged
  Union})

several Classes of Values called \emph{Variants}

Corresponds to Disjoint Union (\S\ref{sec:disjoint_union})

Coproduct (\S\ref{sec:coproduct})

Choices, Multiple ``Classes'' of Data



% --------------------------------------------------------------------
\subsection{Inductive Type}\label{sec:inductive_type}
% --------------------------------------------------------------------

\emph{Inductive Type} (or \emph{Recursive Type})

W-type

Monotonic Type Operators $\Theta : \sigma \Rightarrow \tau$

``Tree-like''

Initial Algebras (\S\ref{sec:initial_algebra})

Type Constructor (\S\ref{sec:type_constructor})

Structural Recursion (\S\ref{sec:structural_recursion})

Streams between interacting processes in Programming Languages
Recursive Data Type


\asterism


Recursive Data Type

Values may contain Values of the same Type

Well-founded (\S\ref{sec:well_founded})

general form:
\[
  \mu\alpha.T
\]

$\alpha$ -- Type Variable: may appear in the Type $T$ and stands for
the entire Type itself

$roll : T[\mu\alpha.T/\alpha] \rightarrow \mu\alpha.T$

$unroll : \mu\alpha.T \rightarrow T[\mu\alpha.T/\alpha]$

Isorecursive (\S\ref{sec:isorecursive_type}): $roll$ and $unroll$
are Inverses

Equirecursive (\S\ref{sec:equirecursive_type}): $unroll$ is the
Identity



\subsubsection{Induction Induction}\label{sec:induction_induction}

\emph{Induction Induction}



\subsubsection{Induction Recursion}\label{sec:induction_recursion}

\emph{Induction Recursion}

Dybjer-Setzer99



\subsubsection{Initial \& Final Type}\label{sec:initial_final_type}

\emph{Initial Data Types} are defined by the Least Fixed Point
(\S\ref{sec:least_fixedpoint}), up to Isomorphism given by an Initial
Algebra (\S\ref{sec:initial_algebra}), of a Type Operator
(\S\ref{sec:type_operator}). Ordinary Recursion
(\S\ref{sec:recursion}) defines Recursive Functions with an Initial
Data Type for a Domain.

\emph{Final Data Types} are defined, up to Isomorphism given by a
Final Coalgebra (\S\ref{sec:terminal_coalgebra}) by the Greatest
Fixpoint. Corecursion (\S\ref{sec:corecursion}) defines Recursive
Functions with a Final Data Type as a Codomain.

Initial (\S\ref{sec:initial_object}) \& Terminal
(\S\ref{sec:terminal_object}) Objects

In $\mathbf{Set}$, the Final Data Types may have Infinite,
Non-well-founded (\S\ref{sec:non_wellfounded}) Values.

In $\mathbf{Cpo}$ (the Category of Complete Partial Orders
\S\ref{sec:complete_partialorder} and Continuous Functions), Final
Types coincide with Initial Types and the corresponding Initial
Algebra and Final Coalgebras are Isomorphic.



\subsubsection{Isorecursive Type}\label{sec:isorecursive_type}

$roll$ and $unroll$ are Inverse Functions



\subsubsection{Equirecursive Data Type}\label{sec:equirecursive_type}

$unroll$ is an Identity



\subsubsection{Mutually Recursive Type}
\label{sec:mutually_recursive}\hfill

a Forest (\S\ref{sec:forest_type}) is a Mutually Recursive Definition
of a Tree (\S\ref{sec:tree_type})



\subsubsection{Infinite Data Type}\label{sec:infinite_datatype}

(Proof Object) Definition by Recursion: Proof by Induction



\subsubsection{Tree}\label{sec:tree_type}

Tree (Graph Theory \S\ref{sec:tree})

Mutally Recursive Definition: Forest (\S\ref{sec:forest_type})



\subsubsection{Forest}\label{sec:forest_type}

Mutually Recursive Definition of a Tree (\S\ref{sec:tree_type})



% --------------------------------------------------------------------
\subsection{Coinductive Type}\label{sec:coinductive_type}
% --------------------------------------------------------------------

\emph{Coinductive Type} (\emph{Codata}), Coinduction
(\S\ref{sec:coinduction})

Terminal Coalgebras (\S\ref{sec:terminal_coalgebra})



% --------------------------------------------------------------------
\subsection{Concrete Type}\label{sec:concrete_type}
% --------------------------------------------------------------------

\fist Cf. Abstract (Existential) Type (\S\ref{sec:abstract_type})



% --------------------------------------------------------------------
\subsection{Abstract Type}\label{sec:abstract_type}
% --------------------------------------------------------------------

\emph{Abstract Type} (or \emph{Existential Type})

Type in a Nominal Type System (\S\ref{sec:nominal_type_system}) that
cannot be Instantiated (\S\ref{sec:instantiation}) directly.

Existentially Quantified Type Variable

Programming: Module Interfaces

Second-order Typed $\lambda$-calculus with Existential Quantification
(whereas System $F$ is Second-order Typed $\lambda$-calculus with
Universal Quantification.

a Type that is not Abstract is a Concrete Type
(\S\ref{sec:concrete_type})

Abstract Type with no Implementation: Protocol, Interface, etc.


\asterism


Abstract Data Type

Type defined by certain Properties %FIXME

Type (with associated Operations) whose Representation is hidden

Co-algebra (\S\ref{sec:coalgebra})

\begin{itemize}
  \item Primitive (Base) Types (\S\ref{sec:type_constant}) -- in
    certain Programming Languages (e.g. Haskell)
  \item Parameterized (Generic) Types (\S\ref{sec:generic_type}) -- a
    weak form of Abstract Type; an instance of Parametric Polymorphism
    \S\ref{sec:parametric_polymorphism})
  \item Type Class (Constrained Type \S\ref{sec:constrained_type})
\end{itemize}

Monads (\S\ref{sec:monad}) give the Interface to the Abstract Data
Type of ``Program Fragments'' (\fist Cf. Algebraic Effects
\S\ref{sec:algebraic_effect})



\subsubsection{Generic Type}\label{sec:generic_type}

\emph{Generic Type} (also \emph{Parameterized} or \emph{Parametric
  Type})

Weak form of Abstract Data Type

Universally Quantified Type Variable

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism})



\subsubsection{Constrained Type}\label{sec:constrained_type}

%FIXME type class section?

(or \emph{Type Class})

Existentially Quantifid Type Variable

Ad-hoc Polymorphism (\S\ref{sec:adhoc_polymorphism}), Function
Overloading

Type Classes are used to define Overloaded Functions, Type Families
(\S\ref{sec:type_family}) are used to defined Overloaded Data

A Type Family declared in the definition of a Type Class is called an
\emph{Associated Type} (\S\ref{sec:associated_type}).

Type Classes define Partial Functions from Types to a collection of
Named Values by Pattern Matching on the Input Types

\fist Type Families define Partial Functions from Types to Types by
Pattern Matching on the Input Types

\fist Type Constructors (\S\ref{sec:type_constructor}) define
Injective Functions from all Types of a particular Kind
(\S\ref{sec:kind}) to a new Set of Types

\fist Type Synonyms (\S\ref{sec:type_synonym}) define Functions from
all Types of a particular Kind to another Set of Types using a single
``Case'' (???) %FIXME



\paragraph{Functional Dependency}\label{sec:functional_dependency}\hfill

used to Constrain the Parameters (dependcies between the Parameters)
of a (Multi-parameter) Type Class

%FIXME xref relational database theory



% --------------------------------------------------------------------
\subsection{Generalized Algebraic Data Type}\label{sec:gadt}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Logically Qualified Data Type}
\label{sec:logically_qualified}
% --------------------------------------------------------------------

\cite{rondon-kawaguchi-jhala08}

\emph{Liquid Type}

Predicate Abstraction (\S\ref{sec:predicate_abstraction})

Logical Qualifier: Boolean Predicate

Dependent Type where the Refinement Predicate
(\S\ref{sec:refinement_type}) is a Conjunction of Logical Qualifiers.

Value Variable

Base Refinement:
\[
  \{ v : B | e \}
\]
where $e$ is a Boolean-valued Expression constraining $v$ called a
\emph{Refinement Predicate}.



% --------------------------------------------------------------------
\subsection{Partial Type}\label{sec:partial_type}
% --------------------------------------------------------------------

\cite{thompson99}

Non-terminating Computations

Total Objects are Identified at Simple Types

Undefined Object ``Bottom'' $\uparrow$ is a Member of every Type

\[
  \sigma \rightarrow \tau \quad
  \sigma \rightarrow \overline{\tau} \quad
  \overline{\sigma} \rightarrow \overline{\tau} \quad
  \overline{\sigma \rightarrow \tau} \quad
  \overline{\sigma \rightarrow \overline{\tau}} \quad
  \overline{\overline{\sigma} \rightarrow \overline{\tau}} \quad
\]



% --------------------------------------------------------------------
\subsection{Type Synonym}\label{sec:type_synonym}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Type Conversion}\label{sec:type_conversion}
% --------------------------------------------------------------------

\subsubsection{Type Promotion}\label{sec:type_promotion}

Special case of Implicit Type Conversion



% ====================================================================
\section{Polymorphic Type}\label{sec:polymorphic_type}
% ====================================================================

Adding Polymorphic Types to Simply-typed $\lambda$-calculus
($\lambda\kern-5pt\rightarrow$ \S\ref{sec:simply_typed}) results in
\emph{Second-order $\lambda$-calculus} ($\lambda2$
\S\ref{sec:secondorder_lambda})

Terms depending on Types


Ad-hoc Polymorphism (\S\ref{sec:adhoc_polymorphism})

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism})

Subtype Polymorphism (\S\ref{sec:subtype_polymorphism})

Bounded Polymorphism (\S\ref{sec:bounded_polymorphism})


\asterism

%FIXME

$\tau \mapsto \sigma$

Introduction:
\[
  {
  \frac{
    \begin{matrix}
      x : \sigma \\
      \vdots \\
      b : B
    \end{matrix}
  }
  {b : \sigma \mapsto \tau}
  }(\mapsto I)
\]


\asterism


Restricted Rank

Rank-1 \emph{Prenex Polymorphism}: Type Variables may not be
instantiated with Polymorphic Types.

Rank-$k$: Quantifier may not appear to the left of $k$ or more Arrows;
Type Inference is decidable for Rank-2 but Rank-3 and above is not

Rank-$n$: Quantifier may appear to the left of arbitrarily many Arrows

Predicative: a Type $\tau$ containing a Type Variable $\alpha$ may not
have $\alpha$ Instantiated to a Polymorphic Type (Martin-L\"of Type
Theory \S\ref{sec:intuitionistic_type} and NuPRL).

Impredicative \emph{First-class Polymorphism}: Self-referential
(System F \S\ref{sec:system_f})

Parametric (\S\ref{sec:parametric_polymorphism}): Universal
Quantification

Abstract (Existential) Type (\S\ref{sec:abstract_type}): Existential
Quantification

The Type $(\exists x : A).B$ is inhabited by Pairs $(a,b)$ with $a:A$
and $b:B[a/x]$, i.e. the Sum of the Types $B(x)$ as $x$ ranges over
$A$ \emph{or} the Subset of $A$ consisting of those $a \in A$ with the
Property $B[a/x]$.

Bounded Quantification (\S\ref{sec:bounded_polymorphism})

\fist See also Polymorphic Kinds (\S\ref{sec:polymorphic_kind})



% --------------------------------------------------------------------
\subsection{Ad-hoc Polymorphism}\label{sec:adhoc_polymorphism}
% --------------------------------------------------------------------

\emph{Function Overloading}, \emph{Operator Overloading}

Polymorphic Functions (\S\ref{sec:polymorphic_function}) applied to
Terms of different Types

Ad-hoc Polymorphism is contrasted with Parametric Polymorphism by
supporting a limited number of distinct Types rather than any Type
whatsoever

Constrained Type (Type Class \S\ref{sec:constrained_type})



% --------------------------------------------------------------------
\subsection{Parametric Polymorphism}\label{sec:parametric_polymorphism}
% --------------------------------------------------------------------

Universally Quantified Type Variable

\emph{Parametricity}: Abstract Uniformity Property; captures the
intuition that all instances of a Polymorphic Function
(\S\ref{sec:polymorphic_function}) behave the same way for all Types
(``for all''); used to define Natural Transformations
(\S\ref{sec:natural_transformation}) in Programming Languages

Parametric (Generic) Type (\S\ref{sec:generic_type}): a weak form of
Abstract Type (\S\ref{sec:abstract_type})

Parametric (Generic) Function (\S\ref{sec:generic_function})

Example:
\[
  x:\tau \vdash id(x):\tau
\]
where the Type of the Term $id(x)$ is $\tau$, which is dependent on
the Type $\tau$ of $x$, where the Type of $id$:
\[
  id:\sigma \rightarrow \sigma
\]
is Universally Quantified ``$\forall \sigma$'':
\[
  id:\forall \sigma.\sigma \rightarrow \sigma
\]


having Pattern Matching on Types in a Type System would break
Parametricity (idris stackoverflow user Xash) %FIXME link

Type-level Function Abstraction $\Lambda$ (\S\ref{sec:type_operator})

Second-order $\lambda$-calculus (System F \S\ref{sec:system_f})

Bounded Polymorphism (\S\ref{sec:bounded_polymorphism}): Bounded
Quantification; Polymorphism restricted to Subtypes


\asterism


$\forall a.a \rightarrow a$ -- $id$

$\forall a.(a \rightarrow a) \rightarrow a$ -- $fix$

$\forall a.a \rightarrow (a \rightarrow a) \rightarrow a$ -- $eval$


$\forall a.a \rightarrow a \times a$ -- $\delta$

$\forall a.a \times a \rightarrow a$ -- $\pi_1$, $\pi_2$

$\forall a.a \times a \rightarrow a \times a$ -- $id$, $swap$


$\forall a.a \rightarrow a + a$ -- $inl$, $inr$

$\forall a.a + a \rightarrow a$ -- $match$

$\forall a.a + a \rightarrow a + a$ -- $id$, $retag$


$\forall a.a \rightarrow (a \rightarrow a)$ -- $true$, $false$


$\forall a.(a \rightarrow a) \rightarrow (a \rightarrow a)$ -- $f^n$
for $n \in \nats$


\asterism


\emph{Higher-rank Impredicative Polymorphism} (Impredicative
\S\ref{sec:impredicative_polymorphism}) -- most general

\emph{Predicative Prenex Polymorphism} (Restricted Rank and
Predicative \S\ref{sec:predicative_polymorphism}) --
``\emph{Let-polymorphism}''



\subsubsection{Predicative Polymorphism}
\label{sec:predicative_polymorphism}

Type $\tau$ containing Type Variable $\alpha$ may not be used such
that $\alpha$ is instantiated to a Polymorphic Type.



\subsubsection{Impredicative Polymorphism}
\label{sec:impredicative_polymorphism}

(or \emph{First-class Polymorphism})

most powerful



% --------------------------------------------------------------------
\subsection{Subtype Polymorphism}\label{sec:subtype_polymorphism}
% --------------------------------------------------------------------

\subsubsection{Subtype}\label{sec:subtype}

\emph{Intersection Type}

\emph{Subtype Polymorphism}

$S <: T$

System $F_{<:}$ (\S\ref{sec:system_fsub})

Bounded Polymorphism (\S\ref{sec:bounded_polymorphism})

Subtyping Judgement:
\[
  \Gamma \vdash \tau_1 \preceq \tau_2
\]

Power Type (\S\ref{sec:power_type}) $P A$: Type of all Subtypes of $A$

Coherence



\paragraph{Conjunctive Type}\label{sec:conjunctive_type}\hfill

$\lambda$-calculus with Conjunctive Types
(\S\ref{sec:conjunctive_lambda})

System F$_{<:}$ (\S\ref{sec:system_fsub})

System F$_{<:}^\omega$ (\S\ref{sec:system_fsub}) -- Higher-order
Bounded Quantification



\subsubsection{Variance}\label{sec:type_variance}

\emph{Variance} describes how Type Constructors either preserve,
reverse, or ignore Subtyping on input Types.

\begin{itemize}
  \item \emph{Covariant}: Preserves Subtyping
  \item \emph{Contravariant}: Reverses Subtyping
  \item \emph{Bivariant}: Both Subtypes
  \item \emph{Invariant}: No Subtyping
\end{itemize}

$(\rightarrow)$ is Contravariant on the Input Type and Covariant on
the Output Type.



\subsubsection{Power Type}\label{sec:power_type}

$P A$ the Type of all Subtypes of $A$



\subsubsection{Intersection Type}\label{sec:intersection_type}

\paragraph{Refinement Type}\label{sec:refinement_type}\hfill

Predicate assumed to hold for any Element of Refined Type

\fist Cf. Behavioral Subtyping (\S\ref{sec:behavioral_subtype})

Type Targeted Testing, Liquid Types (Logically Qualified Types
\S\ref{sec:logically_qualified})


\asterism


\cite{mcbride13}:

Ornaments (\S\ref{sec:ornament}): Refinements as a ``Decoration'' with
``Logical Data''? %FIXME

Algebraic Ornament (\S\ref{sec:algebraic_ornament}): Type Refinement
Induced by Algebras over a Datatype's Structure



\paragraph{Predicate Subtype}\label{sec:predicate_subtype}\hfill



\subsubsection{Behavioral Subtype}\label{sec:behavioral_subtype}

\emph{Substitutability}



\subsubsection{Principal Type}\label{sec:principal_type}

Type System with Principal Type Property

given a Term, all other Types are instances of the Principal Type

Type Inference

%FIXME xref
Robinson's Unification Algorithm, used by Hindley-Milner Type
Inference

Polymorphic Recursion makes Inference of the Principal Type Undecidable

Generalized Algebraic Data Types negates the Principal Type Property



% --------------------------------------------------------------------
\subsection{Bounded Polymorphism}\label{sec:bounded_polymorphism}
% --------------------------------------------------------------------

\emph{Bounded Quantification} (or \emph{Bounded Polymorphism} or
\emph{Constrained Genericity})

Bounds on Type Parameters to range only over Subtypes
(\S\ref{sec:subtype}) of a particular Type

Type Class (\S\ref{sec:constrained_type})

Conjunctive Type (\S\ref{sec:conjunctive_type})



% --------------------------------------------------------------------
\subsection{Value Polymorphism}\label{sec:value_polymorphism}
% --------------------------------------------------------------------

Polymorphism restricted to \emph{Values}: a Subclass of Expressions
that can have no Computational Effects
(\S\ref{sec:computational_effect})



% --------------------------------------------------------------------
\subsection{Polymorphic Function}\label{sec:polymorphic_function}
% --------------------------------------------------------------------

A Polymorphic Function has a Dependent Product Type
(\S\ref{sec:pi_type}):
\[
  (\Pi A:\class{U}) F(A)
\]



\subsubsection{Polymorphic Recursion}\label{sec:polymorphic_recursion}

Recursive Parametrically Polymorphic Function

Type Inference under Polymorphic Recursion is Undecidable (equivalent
to Semi-unification) %FIXME



\subsubsection{Free Theorem}\label{sec:free_theorem}



% ====================================================================
\section{Type Operator}\label{sec:type_operator}
% ====================================================================

\emph{Type Operator} (or \emph{Type-level Function})

Adding additional Type Operators to Simply-typed $\lambda$-calculus
($\lambda\kern-5pt\rightarrow$ \S\ref{sec:simply_typed}) results in
\emph{Higher-order $\lambda$-calculus} ($\lambda\underline{\omega}$
\S\ref{sec:higherorder_lambda})

The Type Operators themselves can be viewed as forming a Simply-typed
$\lambda$-calculus with only one Base Type (\S\ref{sec:type_constant})
denoted `$\ast$' representing the Type of all Types in the underlying
Language which are called \emph{Proper Types} to distinguish from the
Type of the Type Operators which are called \emph{Kinds}
(\S\ref{sec:kind}).

A Type Operator is an Endofunctor on the Category of Types.

$\Lambda$ -- Type-level Function Abstraction

Monotonic Type Operators: Inductive Types (\S\ref{sec:inductive_type})



% --------------------------------------------------------------------
\subsection{Kind}\label{sec:kind}
% --------------------------------------------------------------------

A \emph{Kind} is the Type of a Type Operator
(\S\ref{sec:type_operator}), or the Type of a Higher-order Type
Operator \S\ref{sec:higherorder_typeoperator}).

\fist Proper Type (\S\ref{sec:type})

Super-kind

Pure Type System (\S\ref{sec:pts})



\subsubsection{Polymorphic Kind}\label{sec:polymorphic_kind}



% --------------------------------------------------------------------
\subsection{Higher-order Type Operator}
\label{sec:higherorder_typeoperator}
% --------------------------------------------------------------------

Allowing for the Type Operators to form a Simply-typed
$\lambda$-calculus with the single Base Type `$*$' allows for
Higher-order Type Operators.



% --------------------------------------------------------------------
\subsection{Function Type}\label{sec:function_type}
% --------------------------------------------------------------------

A \emph{Function Type} (or \emph{Arrow Type}) is Type formed by the
Higher-kinded Type Constructor $\rightarrow$

The Function Type $A \rightarrow B$ is a special case of Dependent
Product Type (\S\ref{sec:pi_type}) $(\Pi a:A)B$ with a Constant
Codomain Type $B$:
\[
  (\Pi a:A)B \equiv A \rightarrow B
\]
where $\equiv$ is Judgemental Equality.

In a Category without Products, the Function Type can't be defined.

Function Types are Covariant Functors on the Return Type and
Contravariant Functors on the Argument Type. Cf. Hughes Arrows
(\S\ref{sec:hughes_arrow}).



\subsubsection{Exponential Type}\label{sec:exponential_type}

Higher-order Functions

Function Space

Function Type (\S\ref{sec:function_type})



\subsubsection{Generic Function}\label{sec:generic_function}

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism})



% --------------------------------------------------------------------
\subsection{Type Constructor}\label{sec:type_constructor}
% --------------------------------------------------------------------

A \emph{Type Constructor} (or \emph{Type Schema}) is an Injective Type
Function: maps all Types of a particular Kind to a new Set of Types
and Type Synonyms



% --------------------------------------------------------------------
\subsection{Type Family}\label{sec:type_family}
% --------------------------------------------------------------------

A \emph{Type Family} is a Partial Type Operator that allows Types to
be defined by matching Terms.

%FIXME

Type Classes (Constrained Type \S\ref{sec:constrained_type}) are used
to define Overloaded Functions, Type Families are used to defined
Overloaded Data.

Type Classes define Partial Functions from Types to a collection of
Named Values by Pattern Matching on the Input Types

Type Families define Partial Functions from Types to Types by Pattern
Matching on the Input Types

Generalization of Predicates (Relations) over Domains



\subsubsection{Associated Type}\label{sec:associated_type}

A Type Family declared inside a Type Class is an \emph{Associated
  Type}



% ====================================================================
\section{Dependent Type}\label{sec:dependent_type}
% ====================================================================

A \emph{Dependent Type} depends on a Term or another Type.

\[
  x : A \vdash B(x):\mathrm{Types}
\]

A Dependent Product Type (\S\ref{sec:pi_type}) is defined by
a Dependent Function (\S\ref{sec:dependent_function}).

Logical Quantifiers (\S\ref{sec:quantifier})

Intuitionistic Type Theory (\S\ref{sec:intuitionistic_type})

Categorically, Dependent Types correspond to Morphisms regarded as
Indexed Families (Bundle or Fibration), represented by a \emph{Display
  Map} (\S\ref{sec:display_map}) which is a Morphism $p : B
\rightarrow A$ where $B(x)$ is the Fiber (\S\ref{sec:fiber}) of $p$
over $x:A$.

Classifying Morphism (\S\ref{sec:classifying_morphism}),
Classifying Space (\S\ref{sec:classifying_space})

A Dependent Type is the Type of a Dependent Function
(\S\ref{sec:dependent_function}).

Dependent Pairs (Dependent Sum Type \S\ref{sec:sigma_type})


\textbf{First-order Dependent Type Theory} ($\lambda \Pi$):
\emph{Logical Framework} (\S\ref{sec:logical_framework}), adding the
Dependent Product Type (\S\ref{sec:pi_type}) to Simply-typed
$\lambda$-calculus.


\textbf{Second-order Dependent Type Theory} ($\lambda \Pi 2$):
allowing Quantification over Type Constructors
(\S\ref{sec:type_constructor}), $\Pi$ operator Subsumes both
$\rightarrow$ of Simply-typed $\lambda$-calculus and $\forall$ of
System F (\S\ref{sec:system_f})


\textbf{Higher-order Dependently Typed Polymorphic $\lambda$-calculus}
($\lambda \Pi \omega$): corresponds to \emph{Calculus of
  Constructions} (\S\ref{sec:coc}); extends $\lambda \Pi 2$ to all
abstractions of the $\lambda$-cube (\S\ref{sec:lambda_cube})


\asterism


$x:A \vdash B(x):\Type$

$B : A \rightarrow \Type$

$B : (\Pi X:\Type) A \rightarrow X$



% --------------------------------------------------------------------
\subsection{Dependent Function}\label{sec:dependent_function}
% --------------------------------------------------------------------

A \emph{Dependent Function} is a Function from Terms to Types
(Codomain varies depending on Argument). The Type of a Dependent
Function is a \emph{Dependent Product Type}
(\S\ref{sec:pi_type}).

Dependent Function Space: if $f:(\forall x: A).B$ then $f a : B[a/x]$

Functionality (respect for Definitional Equality
\S\ref{sec:proof_equality}):
\[
  x : A \vdash B_x \;\text{type}
\]\[
  m : A \mapsto B[m/x] \;\text{type}
\]\[
  m \equiv n : A \mapsto B[m/x] \equiv B[n/x] \;\text{type}
\]

Doubly-indexed Type:
\[
  x : A, y : B_x \vdash C_{x,y} \;\text{type}
\]

Example: Family of Types Indexed by $\mathbb{N}$:
\[
  x : \mathbb{N} \vdash even(x) \;\text{type}
\]
is a Propositional Function (takes a Natural Number and yields a
Proposition). For each Natural Number, either $even(x)$ is Inhabited
(if $x$ is Even) or Uninhabited (if $x$ is Odd).\cite{harper12}



% --------------------------------------------------------------------
\subsection{Dependent Sum Type ($\Sigma$-type)}\label{sec:sigma_type}
% --------------------------------------------------------------------

\emph{$\Sigma$-type} (or \emph{Dependent Sum Type} or \emph{Dependent
  Pair Type})

Dependent Sum (\S\ref{sec:dependent_sum})

\[
  (\Sigma x:A) B(x)
\]

If $B$ is Constant, then $(\Sigma x:A)B$ is Judgementally Equal to
the Product Type (\S\ref{sec:product_type}) $A \times B$:
\[
  (\Sigma x:A) B \equiv A \times B
\]

By Curry-Howard, $\Sigma$-types model Conjunction and Existential
Quantification.

Analagous to Coproduct or Disjoint Union.



% --------------------------------------------------------------------
\subsection{Dependent Product Type ($\Pi$-type)}\label{sec:pi_type}
% --------------------------------------------------------------------

The \emph{$\Pi$-type} (or \emph{Dependent Product Type} or
\emph{Dependent Function Type}) is the Type of a Dependent Function.
By Curry-Howard, $\Pi$-types model Implication and Universal
Quantification.

Dependent Product (\S\ref{sec:dependent_product})

For a Type $A : \class{U}$ in Type Universe
(\S\ref{sec:type_universe}) $\class{U}$, a Family of Types:
\[
  B : A \rightarrow \class{U}
\]
can be defined by a Dependent Function which assigns a Type $B(a) :
\class{U}$ to Each Term $a : A$. The Type of this Function is a
Dependent Product Type:
\[
  (\Pi x:A)B(x)
\]

If $B$ is Constant, then $(\Pi x:A)B$ is Judgementally Equal to the
Function Type (\S\ref{sec:function_type}) $A \rightarrow B$:
\[
  (\Pi x:A)B \equiv A \rightarrow B
\]

Generalizes the idea of a Polymorphic Function
(\S\ref{sec:polymorphic_function})

\cite{hott13}:

Example $id$:
\[
  id : (\Pi A:\class{U}) A \rightarrow A
\]

Example 2 $swap$:
\[
  swap : (\Pi A:\class{U}) (\Pi B:\class{U}) (\Pi C:\class{U})
  (A \rightarrow B \rightarrow C) \rightarrow (B \rightarrow A
  \rightarrow C)
\]
Type arguments may be written as subscripts: $id_A$, $swap_{A,B,C}$

A Polymorphic Function returning elements of Type $C$ has Polymorphic
Type (\S\ref{sec:polymorphic_type}):
\[
  (\Pi A:\class{U}) A \rightarrow C
\]



% --------------------------------------------------------------------
\subsection{Dependent Equality Type}\label{sec:dependent_equality}
% --------------------------------------------------------------------



% ====================================================================
\section{Type Universe}\label{sec:type_universe}
% ====================================================================

A \emph{Type Universe} is a Type whose Elements are Types.

Type of (Small) Types

Type Theory analogue of Inaccessible Cardinal
(\S\ref{sec:inaccessible_cardinal})

Reflection Principle (???)

$\class{U}_0$ is the Universe of all Small Types. Every Name
(\S\ref{sec:name}) $a:\class{U}_0$ has an associated Type $El(a)$
giving its Extension or Meaning ($El$ is a Dependent Type
\S\ref{sec:dependent_type} that maps each Object to its corresponding
Type).

A Predicative Cumulative Hierarchy (\S\ref{sec:cumulative_hierarchy}):
\[
  \class{U}_0, \class{U}_1, \class{U}_2, \ldots
\]
is such that any Type in $\class{U}_n$ is also in
$\class{U}_{n+1}$:
\[
  u_n:\class{U}_n+1
\]
with (Cumulative Property):
\[
  El(u_n) \equiv \class{U}_n
\]

\fist See $\class{U}-INTRO$ and $\class{U}-CUMUL$
\S\ref{sec:homotopy_rules}.



% --------------------------------------------------------------------
\subsection{Girard's Paradox}\label{sec:girards_paradox}
% --------------------------------------------------------------------



% ====================================================================
\section{Context}\label{sec:type_context}
% ====================================================================

A \emph{Context} (or \emph{Typing Environment} or \emph{Variable
  Assignment}), $\Gamma$, is a list of \emph{Typing Assumptions}
(\S\ref{sec:typing_assumption}) of the form:
\[
  \Gamma = x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n
\]
where each Element $x_i : A_i$ is an Assumption that the distinct
Variable $x_i$ has type $A_i$.

\emph{Typing Judgements} (\S\ref{sec:typing_judgement}) are formulated
under the Assumptions of a particular Context, $\Gamma$:
\[
  \Gamma \vdash a : A
\]
For an empty Context:
\[
  \vdash a : A
\]
or:
\[
  . \vdash a : A
\]

Closed Terms are those Terms that are Typable
(\S\ref{sec:typing_derivation}) in an Empty Context, e.g. the I, S,
and K Combinators (\S\ref{sec:combinator}).



% --------------------------------------------------------------------
\subsection{Typing Assumption}\label{sec:typing_assumption}
% --------------------------------------------------------------------

\emph{Typing Assumption})

\[
  e : \tau
\]
``Term $e$ has Type $\tau$''



% --------------------------------------------------------------------
\subsection{Type Annotation}\label{sec:type_annotation}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Type Erasure}\label{sec:type_erasure}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Reification}\label{sec:reification}
% --------------------------------------------------------------------

* opposite of Type Erasure
* see Type Inference (\S\ref{sec:type_inference})

Abstract idea about a computer program turned into an explicit Data
Model or Object

(Hypostatize) %FIXME

Monadic Reification (\S\ref{sec:monadic_reification})



% ====================================================================
\section{Typing Judgement}\label{sec:typing_judgement}
% ====================================================================

A \emph{Typing Judgement} is an instance of a \emph{Typing Relation}
(\S\ref{sec:typing_relation}).

A Typing Judgement expresses Propositional Equality. % FIXME

The Validity of a Typing Judgement is given by a Typing Derivation
(\S\ref{sec:typing_derivation}).

Constant Type % FIXME empty context



% --------------------------------------------------------------------
\subsection{Typing Relation}\label{sec:typing_relation}
% --------------------------------------------------------------------

\emph{Typing Relation} between Terms and Types

\[
  \Gamma \vdash e : \tau
\]
``$e$ is a (Well-typed \S\ref{sec:well_typed}) Term of Type $\tau$ in
Context $\Gamma$'',

Terms that are Well-typed in the Empty Context are Closed Terms.

Under a Proof Theoretic Interpretation, $p : P$ may be read as ``$p$
is a Proof of Proposition $P$''



% --------------------------------------------------------------------
\subsection{Typing Rule}\label{sec:typing_rule}
% --------------------------------------------------------------------

A \emph{Typing Rule} (or \emph{Type Rule}) describes how a Type is
assigned to a Syntactic Construction.

Corresponding to Introduction and Elimination Rules of Proof Theory
(\S\ref{sec:structural_rule}).

Introduction and Elimination corresponds to Constructors
(\S\ref{sec:constructor}).

The notation for Type Rules is that of Sequent Notation
(\S\ref{sec:sequent}):
\[
  {
    \frac
    { \Gamma_1 \vdash e_1:\tau_1 \quad \cdots
      \quad \Gamma_n \vdash e_n:\tau_n }
    { \Gamma \vdash e:\tau }
  }
\]
where $\Gamma$ are Typing Environments and $e:\tau$ are Typing
Judgements.



% --------------------------------------------------------------------
\subsection{Typing Derivation}\label{sec:typing_derivation}
% --------------------------------------------------------------------

A \emph{Typing Derivation} shows the Validity of a Typing Judgement
and is constructed from Typing Rules (\S\ref{sec:typing_rule}).

Derivation (\S\ref{sec:formal_proof})

Undischarged Assumptions in Formal Proofs correspond to Free Variables
in Typing Derivations, Discharged Assumptions to Bound Variables

A Rewrite Rule maps a Valid Typing Derivation to another Valid Typing
Derivation (\emph{Subject Reduction} \S\ref{sec:subject_reduction},
\emph{Type Soundness}) \cite{wadler14}

A Term for which a Typing Derivation exists is called a
\emph{Well-typed Term} (\S\ref{sec:well_typed}).



\subsubsection{Type Witness}\label{sec:type_witness}

\emph{Witnessing Information} gives verification of a Typing
Assumption



\subsubsection{Subject Reduction}\label{sec:subject_reduction}

A Type System has \emph{Subject Reduction} (or \emph{Type
  Preservation}) if Evaluation (\S\ref{sec:evaluation_strategy}) of
Expressions leaves their Types unchanged.



% ====================================================================
\section{Type Inference}\label{sec:type_inference}
% ====================================================================

% ====================================================================
\section{Type System}\label{sec:type_system}
% ====================================================================

\emph{Type System} (or \emph{Typing Discipline})



% --------------------------------------------------------------------
\subsection{Type Checking}\label{sec:type_checking}
% --------------------------------------------------------------------

\subsubsection{Bi-directional Type Checking}
\label{sec:bidirectional_checking}

\emph{Checking}

\emph{Synthesis}



\subsubsection{Extended Static Checking}\label{sec:extended_static}



% --------------------------------------------------------------------
\subsection{Nominal Type System}\label{sec:nominal_type_system}
% --------------------------------------------------------------------

Names



% --------------------------------------------------------------------
\subsection{Unified Type System}\label{sec:unified_type_system}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Structural Type System}\label{sec:structural_type_system}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Substructural Type System}
\label{sec:substructural_type}
% --------------------------------------------------------------------

Substructural Logic (\S\ref{sec:substructural_logic})

Substructural Type Systems are categorized by allowing or disallowing
Structural rules of Exchange (\S\ref{sec:exchange_rule}), Weakening
(\S\ref{sec:weakening_rule}), or Contraction
(\S\ref{sec:contraction_rule}):

\begin{itemize}
  \item Linear Type Systems (\S\ref{sec:linear_type}): Allow Exchange,
    not Weakening or Contraction; Every Variable used exactly once
  \item Affine Type Systems (\S\ref{sec:affine_type}): Allow Exchange
    and Weakening, not Contraction; Every occurrence of a Variable
    used at most once
  \item Relevant Type System (\S\ref{sec:relevant_type}): Allow
    Exchange and Contraction, not Weakening; Every variable used at
    least once
  \item Ordered Type System (\S\ref{sec:ordered_type}): Disallow
    Exchange, Contraction and Weakening; Every Variable is used
    Exactly once in the order it was introduced
\end{itemize}



\subsubsection{Linear Type System}\label{sec:linear_type}

Values used exactly once

Linear Type Theory -- Co-modality (???) %FIXME

Linear Logic (\S\ref{sec:linear_logic}) allows safe Deallocation
(Objects used exactly once)

Distribution and Concurrency (Session Types \S\ref{sec:session_type})

Linear $\lambda$-calculus (\S\ref{sec:linear_lambda})

Internal Language (\S\ref{sec:internal_logic}) of Closed Symmetric
Monoidal Categories (\S\ref{sec:closed_symmetric_monoidal})

Allows References but not Aliases

Modelling of Heap-based Memory Allocation

No-cloning Theorem (Quantum States):
\begin{itemize}
  \item No Diagonal Functor (\S\ref{sec:diagonal_functor})
    which could duplicate States
  \item No $K$-combinator which can destroy States
  \item A Variable $x$ can appear at most once in a $\lambda$-term
\end{itemize}



\paragraph{Affine Type System}\label{sec:affine_type}\hfill

Values used at most once

Affine Logic (\S\ref{sec:affine_logic})



\paragraph{Session Type}\label{sec:session_type}\hfill

\emph{Session Types} are a Typing Discipline (\S\ref{sec:type_system})
for Heterogenous Bidirectional Communication Channels defining the
possible Sequences of Messages (\S\ref{sec:message}) determined by the
Channel's Session Type (e.g. Stream-based Internet Protocols)
\cite{neubauer-thiemann04}

An Embedding of Simply-typed $\lambda$-calculus
(\S\ref{sec:simply_typed}) into Session-typed $\pi$-calculus (Session
Calculus \S\ref{sec:sessiontyped_pi}) is given in
Toninho-Caires-Pfenning12 \cite{caires-pfenning-toninho12}

\cite{orchard-yoshida16} -- ``(Intensional) Behavioral Types'': Effect
Types and Session Types; two-way Embedding: Effect Systems
(\S\ref{sec:effect_system}) Embedded in Session Calculus
(\S\ref{sec:session_calculus}) and vice versa--Processes as Effect
Handlers (\S\ref{sec:effect_handler}), Session Types as Effects
(\S\ref{sec:computational_effect})
%FIXME behavior type theory?

Dominic Orchard (youtube) -- Simple Types (\S\ref{sec:simply_typed}):
``What'', Effect Systems (\S\ref{sec:effect_system}): ``How'', Session
Types: ``What \& How''

\cite{orchard-yoshida16}: Communication Effects
(\S\ref{sec:communication_effect}) can be encoded in Session Types,
but there is no reverse encoding of Session Types into Communication
Effects because Session Types do not describe the relative
``Causality'' between Channels (recorded by Communication Effects).
Session Types are more expressive with respect to Higher-order
Communication (Delegation \S\ref{sec:delegation}).

Message Sequences are Described by a Regular Language
(\S\ref{sec:regular_language}) on Atomic Communication Actions
(\S\ref{sec:communication}); Channel Type (\S\ref{sec:channel_type})
specifies the Language with a Fix-point Expression ($\mu$). Operations
peel off the ``outermost'' Action (???) of the Channel Type and change
the Channel Type (Linearity). \cite{neubauer-thiemann04}

Implementation requirements: \cite{neubauer-thiemann04}
\begin{itemize}
  \item Type Constraints (Type Classes \S\ref{sec:constrained_type})
    with Functional Dependencies (\S\ref{sec:functional_dependency}):
    modelling the progression of the current state of the Channel
  \item Functions with Polymorphic Parameters
    (\S\ref{sec:parametric_polymorphism}): models Client and Server
    side of a Communication with one specification
\end{itemize}

Static Analysis of the Communication Behavior (???) of Agents (???) in
a Distributed System \cite{gay-vasconcelos10}

(Communication) Protocol

Distribution and Concurrency

$\parr$

$\otimes$

Curry-Howard (\S\ref{sec:curry_howard}) for Process Calculi
(\S\ref{sec:process_calculus}):
\begin{itemize}
  \item Propositions as Session Types
  \item Proofs as Processes (\S\ref{sec:process})
  \item Cut-elimination (\S\ref{sec:cut_elimination}) as Communication
    (\S\ref{sec:communication})
\end{itemize}

Linear Propositions (\S\ref{sec:linear_logic})

Dual Intuitionistic Linear Logic \cite{caires-pfenning10} (Shared ???,
Linear)

Multiparty Asynchronous Session Types (Honda-Yoshida-Carbone08)

% FIXME ???
Session: a ``unit'' of a Communication

Session Type: ``structure'' of a Communication

Only Processes with Dual Protocols can Interact

Cotype


\cite{honda-vasconcelos-kubo98}:

Session: a Sequence of Dyadic Interactions

Program: a Collection of Dyadic Interactions in a Session \emph{or} a
Process with no Free Variables % FIXME

Channel: Private Port Designating a Session (cf. Information Theory
\S\ref{sec:channel} Channels)

Session Protocol (\S\ref{sec:session_protocol})


\cite{orchard-yoshida15}: foundation for reasoning about Concurrent
Side-effects using Sessions


\cite{neubauer-thiemann04}:
\begin{enumerate}
  \item First-order Base Type Values
  \item Functions
  \item Labels (cf. Labels in Record (\S\ref{sec:product_type}) or
    Variant Types (\S\ref{sec:sum_type})
\end{enumerate}


\textbf{Primitives}

\begin{itemize}
  \item \emph{Send}
  \item \emph{Receive}
  \item \emph{Sequence}
  \item \emph{Choice}
  \item \emph{Recursion}
\end{itemize}



\paragraph{Channel Type}\label{sec:channel_type}\hfill

\subparagraph{Label}\label{sec:channel_label}\hfill



\subsubsection{Relevant Type System}\label{sec:relevant_type}

Relevant Logic (\S\ref{sec:relevance_logic})



\subsubsection{Ordered Type System}\label{sec:ordered_type}

Noncommutative Logic (\S\ref{sec:noncommutative_logic})

modelling Stack-based Memory Allocation

only Objects on top of modelled Stack may be used, after which it is
popped off



% --------------------------------------------------------------------
\subsection{Hindley-Milner Type System}\label{sec:hindley_milner}
% --------------------------------------------------------------------

$\lambda$-calculus with Parametric Polymorphism



\subsubsection{Algorithm W}\label{sec:algorithm_w}



% ====================================================================
\section{Effect System}\label{sec:effect_system}
% ====================================================================

Dominic Orchard (youtube) -- Simple Types (\S\ref{sec:simply_typed}):
``What'', Effect Systems: ``How'', Session Types
(\S\ref{sec:session_type}): ``What \& How''

\cite{orchard-yoshida16} -- ``(Intensional) Behavioral Types'': Effect
Types and Session Types; two-way Embedding: Session Types
(\S\ref{sec:session_type}) to and from Effect Systems--Processes as
Effect Handlers (\S\ref{sec:effect_handler}), Session Types as Effects
%FIXME behavioral type theory?

Effect System for Session Types is Partial: some Operations may not be
defined for all Arguments, Modelling the Program-logic Behavior of
Session Types \cite{orchard-yoshida16} %FIXME

\fist Orchard-Yoshida16 \cite{orchard-yoshida16} distinguishes the
Effect Systems of Nielson-Nielson99 \cite{nielson-nielson99} from
``traditional'' Effect Systems by distinguishing Sequential Control
Flow from Branching Control Flow (Alternation). See FPCF
(\S\ref{sec:fpcf}) for the \emph{Effect Algebra} of this type defined
there.

Effect Systems: general Class of Static Program Analysis for
collecting information on Effects (e.g. State, Exceptions, Resource
Use, etc.) \cite{orchard-yoshida16}

Control-flow Algebra/Semantics (Mycroft-Orchard-Petricek16
\cite{mycroft-orchard-petricek16})

``Impure'' Effects

subsumed by Monads: ``Lazy State'' and ``Lazy Writer'' cannot be
captured by any Effect System (E. Kmett)

\cite{mycroft-orchard-petricek16} -- Graded Joinads (???): Effect
Control-flow Algebras \& Types

wiki:

in addition to simple Value/Type Pairs, a \emph{Region} of Code is
associated with an \emph{Effect Component} describing ``what'' is
being done ``with what''


\asterism


\cite{wadler-thiemann03}:

Types $\tau$, $\tau'$


\textbf{Monad Language}

$T \tau$ represents a Computation that yields a Value
of Type $\tau$ and may have Side-effects

Call-by-value (\S\ref{sec:call_by_value}) Translation of $\tau$ is
$\tau^\dag$.

$(\tau \rightarrow \tau')^\dag$ where $\rightarrow$ represents a
Function that may have Side-effects is equal to $\tau^\dag \rightarrow
T \tau'^\dag$ where $\rightarrow$ is a Pure Function (no Side-effects).

Effects appear in two places:
\begin{enumerate}
  \item Unit ($\mathsf{return}$) of the Monad -- Labelled with the
    Empty Effect
  \item Bind Operation ($T^\sigma\tau \bindop (\tau \rightarrow
    T^{\sigma'}\tau')$) of the Monad -- Labelled with the Union of two
    Effects: %FIXME union
    \begin{enumerate}
      \item $\sigma$: the Effect of $T^\sigma\tau$
      \item $\sigma'$: the Effect of $\tau \rightarrow
        T^{\sigma'}\tau'$
    \end{enumerate}
\end{enumerate}

Translation of Variables and $\lambda$-abstractions introduce Unit, so
they are Labelled with the Empty Effect

Translation of Application introduces two occurrences of Bind, so it
is Labelled with the Union of three Effects: $\sigma \cup \sigma' \cup
\sigma''$ %FIXME union


\textbf{Effect System}

Effect $\sigma$

$\tau \xrightarrow{\sigma} \tau'$ -- a Function that may have
Side-effects delimited by $\sigma$

Variables and $\lambda$-abstractions are Labelled with the Empty
Effect

%FIXME union
Applications are Labelled with the ``Union'' (???) of three Effects:
\begin{enumerate}
  \item Effects of Evaluating the Function
  \item Effects of Evaluating the Argument
  \item Effects of Evaluating the Function Body
\end{enumerate}
%FIXME clarify


\textbf{Effects + Monads}

$T^\sigma\tau$ -- Computation that yields a Value in $\tau$ and may
have Effects delimited by $\sigma$

$(\tau \xrightarrow{\sigma} \tau')^\dag$
$\rightsquigarrow$
$\tau^\dag \rightarrow T^\sigma \tau'^\dag$


\asterism


Effect (\S\ref{sec:computational_effect}): Monads (\S\ref{sec:monad});
how a Program \emph{Influences} its Environment

\emph{Coeffect System} (\S\ref{sec:coeffect_system}):
Context-dependent Computations

Coeffect (\S\ref{sec:coeffect}): Comonads (\S\ref{sec:comonad});
\emph{Requirements} of a Program with respect to its Environment

Term $M$, Type $A$, Effect $e$
\[
  \vdash M :(A,e)
\]

$T_e A$ -- Effect-graded Monad (\S\ref{sec:graded_monad}), $e$ Element
of an Effect Preordered Monoid (???)

``Indexing''

Coeffect-graded Comonad (???)



% --------------------------------------------------------------------
\subsection{Effect}\label{sec:effect}
% --------------------------------------------------------------------

\subsubsection{Subeffect}\label{sec:subeffect}

Layered Monad (\S\ref{sec:layered_monad}) \cite{filinski99}

allows Effects of an Expression to be ``over-approximated''
\cite{orchard-yoshida16}

\fist Cf. (traditional) Subtyping in Session Types allows an
approximation on Branch and Select \cite{orchard-yoshida16}



\subsubsection{Layered Monad}\label{sec:layered_monad}
\cite{filinski99}

each Effect specified independently by a Formal Monadic Translation

Proto-operations: Monadic Reflection (\S\ref{sec:monadic_reflection}),
Monadic Reification (\S\ref{sec:monadic_reification})

\fist Cf. Algebraic Effects (\S\ref{sec:algebraic_effect}):
\emph{Effect Constructors} (Algebraic Operations
\S\ref{sec:algebraic_operation}) and \emph{Effect Deconstructors}
(Effect Handlers \S\ref{sec:effect_handler})


establishes a (Trivial) Bijection between ``Opaque'' and
``Transparent'' Representations of an Effectful Computation

Effect Operations defined using the Transparent Representation

General Programs written using the Opaque Abstraction

each Monadic Translation can be simulated by a Continuation-passing
(\S\ref{sec:continuation}) Translation: original Transparent
Representation but with a different Opaque Representation substituted

$e ::= \mathfrak{n} | \mathfrak{p} | \cdots$ Effect Names

$E$ Expressions

$\tau$ Types

$\Gamma$ Context (Assumptions)

Typing Judgement:
\[
  \Gamma \vdash E : \tau / e
\]
Expression $E$ has Type $\tau$ and possible Effects $e$

$\mathfrak{n}$: \emph{None}: Evaluation of $E$ has no Effects

$\mathfrak{p}$: \emph{Partiality} (\S\ref{sec:partiality_effect};
Evaluation of $E$ may Diverge (\S\ref{sec:divergence}); all
Recursively Defined Functions (\S\ref{sec:recursive_function}) have
Partiality

$\mathfrak{ex}$: \emph{Exceptions} (\S\ref{sec:exception_effect}

$\mathfrak{st}$: \emph{State} (\S\ref{sec:state_effect}

Effect-layering Relation $e_1 \prec e_2$: typically $e_2$ was defined
by a Formal Translation into a Language with $e_1$-effects; Subeffect
(\S\ref{sec:subeffect})

$\preceq$ Reflexive, Transitive Closure of $\prec$

$\tau_1 \xrightarrow{\mathfrak{n}} \tau_2$ may be written $\tau_1
\rightarrow \tau_2$

$\Gamma \vdash E : \tau / \mathfrak{n}$ may be written as

$\Gamma \vdash E : \tau$ may be written as

\emph{Complete Program}: Closed Term of Base Type

``Escaping'' Effects (disallowed)

Signature $\Sigma$ assigns (potentially Polymorphic) Types to the Base
Constants of the Language (e.g. standard Arithmetic Functions,
Call-by-value Fix-point Operators, etc.)

Implicit Subtyping (\S\ref{sec:subtype}), Implicit Subeffect
(\S\ref{sec:subeffect})

Coercion Terms

Chain-complete Posets (CPO \S\ref{sec:cpo})

Monad (\S\ref{sec:monad}) $T$ Maps a CPO $A$ to a CPO of
$A$-computations

Elements of $T A$ are Effectful Computations yielding Values in $A$

\emph{Layering} of Monad $(T,\eta,\mu)$ Over another Monad
$(\overline{T}, \overline{\eta}, \overline{\mu})$ is a Family of
Functions:
\[
  \zeta_A : \overline{T}(T A) \rightarrow T A
\]
such that each $(T A, \zeta_A)$ is a $\overline{T}$-algebra
(\S\ref{sec:t_algebra}) %FIXME

Any Monad can be Layered over itself %FIXME

For Monad $T$ Layered over Monad $\overline{T}$, a Family of
\emph{Computation-inclusion} (or \emph{Lifting}) Functions:
\[
  i_A = \zeta_A \circ \overline{T} \eta_A :
    \overline{T} A \rightarrow T A
\]

For Monad Morphism (\S\ref{sec:monad_morphism}) $i : \overline{T}
\rightarrow T$, a Layering is obtained by:
\[
  \zeta_A = id^*_{T A} \circ i_A
\]

(Trivial) Layering of a Monad $T$ over the Identity Monad
(\S\ref{sec:identity_monad}) by taking $\zeta_A t = t$

Semantics $\class{L}$ of Effect-language $L$:
\begin{itemize}
  \item Base Types $b$: CPO $\class{B}(b)$
  \item Effects $e$: Monad $\class{E}(e) = (T^e,\eta^e,\mu^e)$
    \begin{itemize}
      \item if $e' \prec e$ then $\class{E}(e)$ is Layered over
        $\class{E}(e')$ by $\zeta^e$
    \end{itemize}
\end{itemize}

$\class{E}(\mathfrak{n})$ Identity Monad $I$

$\class{E}(\mathfrak{p})$ Lifting Monad $L$

Definitional Translation: ``explaining away'' and Effect

Syntactic Extension: \emph{Formal Monad} $\mathsf{T}$ over Effect
$\bar{e}$ in $L$ is a Type Constructor with 3 ``Polymorphic Terms''
(???):
\begin{align*}
  \mathsf{T} - &: Type \rightarrow Type \\
  glue_\alpha &: (1 \xrightarrow{\bar{e}} \mathsf{T} \alpha)
    \rightarrow \mathsf{T} \alpha \\
  unit_\alpha &: \alpha \rightarrow \mathsf{T} \alpha \\
  bind_{\alpha_1,\alpha_2} &: \mathsf{T} \alpha_1 \times (\alpha_1
    \rightarrow \mathsf{T} \alpha_2) \rightarrow \mathsf{T} \alpha_2
\end{align*}
denotes an (actual) Monad:
\[
  \class{L}\llbracket \mathsf{T} \rrbracket^m = (T,\eta,\mu,\zeta)
\]
Layered over $\class{E}(\bar{E})$ in a Semantics $\class{L}$ of
Effect-language $L$ if: %FIXME
\begin{enumerate}
  \item
  \item
  \item
  \item
\end{enumerate}

\fist $\mathsf{T}$ does not necessarily denote a Monad for all
Interpretations of the Effect $\bar{e}$, e.g. the List Monad can only
be properly Layered over a Commutative Monad (???) such as Partiality
%FIXME

Given $\mathsf{T}$, $L^\mathsf{T}$ is an (Proper) Extension of $L$
with new Effect $t$ and new Proto-operations \emph{Monadic Reflection}
(\S\ref{sec:monadic_reflection}) and \emph{Monadic Reification}
(\S\ref{sec:monadic_reification}):
\begin{align*}
  \mono{reflect}_\alpha^t &: \mathsf{T} \alpha \xrightarrow{t} \alpha \\
  \mono{reify}_\alpha^t &: (1 \xrightarrow{t} \alpha) \rightarrow
    \mathsf{T} \alpha
\end{align*}

\fist Cf. Algebraic Effects (\S\ref{sec:algebraic_effect}):
\emph{Effect Constructors} (Algebraic Operations
\S\ref{sec:algebraic_operation}) and \emph{Effect Deconstructors}
(Effect Handlers \S\ref{sec:effect_handler})

Any $L$-program is still a Valid $L^\mathsf{T}$-program with the same
Meaning: Semantics of $L^\mathsf{T}$ can be defined by a Formal
Monadic Translation $|-|_\mathsf{T}$ back into $L$ by expanding only
the new Type and Term Constructors into their $L$-definitions

Explicit Effect-passing (???)

Effect-ordering: Hierarchical, Translation-based Definition

different orderings correspond to different intended Semantics

Example ordering:
\[
\mathfrak{p} \prec \mathfrak{st} \prec \mathfrak{ex}
\]
with State persistent across Exceptions, corresponds to Effect Type:
\[
  ||\alpha / \mathfrak{ex}|_{EX}|_{ST} = |1
  \xrightarrow{\mathfrak{st}} \alpha + exn|_{ST} = 1 \rightarrow state
  \xrightarrow{\mathfrak{p}} (\alpha + exn) \times state
\]
$\mathfrak{st}$-computations always Implicitly Coercible (with
Subtyping Definitions) into an
$\mathfrak{ex}$-computation

Each individual Monadic Translation can be uniformly simulated by a
Layer of Continuation-passing

Any hierarchy of Continuation-passing Layers can be simulated by a
single Effect comprising First-class Continuations and Mutable State

$\mono{shift}$

$\mono{reset}$

$T$-$K$ Simulation Theorem

$K$-$CS$ Simulation Theorem

$T^*$-$CS^*$ Simulation Theorem

Metacontinution (???)

Resumption-computation (\S\ref{sec:resumption})

Effect-recursive Monads (???): new Effect being defined is implicitly
used in its own Specification



\paragraph{Monadic Reflection}\label{sec:monadic_reflection}\hfill
\[
  \mono{reflect}_\alpha^t : \mathsf{T} \alpha \xrightarrow{t} \alpha
\]

\emph{Effect Deconstructor}: Algebraic Effects
(\S\ref{sec:algebraic_effect}), Effect Handler
(\S\ref{sec:effect_handler})



\paragraph{Monadic Reification}\label{sec:monadic_reification}\hfill
\[
  \mono{reify}_\alpha^t : (1 \xrightarrow{t} \alpha) \rightarrow
    \mathsf{T} \alpha
\]

\emph{Effect Constructor}: Algebraic Effects
(\S\ref{sec:algebraic_effect}), Algebraic Operation
(\S\ref{sec:algebraic_operation})



\subsubsection{Graded Monad}\label{sec:graded_monad}

(or \emph{Effect-graded Monad})

%FIXME equivalent to a parametric effect monad?

\cite{orchard-yoshida16}:

\fist Note the following uses a Haskell-like notation, an actual
implementation is available in the hackage $\mono{effect-monad}$ package
\url{http://hackage.haskell.org/package/effect-monad}

carry Effect information as a Type Index

\fist See Session Effects (\S\ref{sec:session_effect}) for an
implementation of Session Effects using the following Effect-graded
Monad

Effect-graded Monad:
\begin{flalign*}
  & \quad\mono{class}\;\mathsf{Effect}
    (m : \eff \rightarrow * \rightarrow *)
    \;\mono{where} & \\
  & \quad\quad
    \mono{type}\;\mathsf{Unit}\;m : \eff & \\
  & \quad\quad
    \mono{type}\;\mathsf{Plus}\;m\;(f : \eff)
      \;(g : \eff) : \eff & \\
  & \quad\quad
    \mathsf{return} : a \rightarrow
      m\;(\mathsf{Unit\;m})\;a & \\
  & \quad\quad
    (\bindop) : m\;f\;a \rightarrow (a \rightarrow m\;g\;b)
        \rightarrow m\;(\mathsf{Plus}\;m\;f\;g)\;b &
\end{flalign*}

$\eff$ -- Domain, \emph{Kind} of Effects, i.e. $\eff$ Models a Set of
Effect Annotations $\class{F}$

$\mathsf{Plus}\;m$ -- Type-level Binary Function implementing $\bullet$
of the Effect Algebra for $\class{F}$

$\mathsf{Unit}\;m$ -- Constant providing the Unit Element $I$

$\mathsf{return}$ -- Lifts a Value to a Trivially Effectful
Computation marked with $I$

$(\bindop)$ -- Sequential Composition of Effectful Computations;
(\emph{Bind}) Rule Models the $\lett$-binding of FPCF
(\S\ref{sec:fpcf})

an FPCF Judgement:
\[
  \Gamma \vdash M:\tau,F
\]
Maps to a ``Monadic Metalanguage Judgement'': %FIXME
\[
  \Gamma \vdash [M]:m\;[F]\;\tau
\]
Embedding Effects into Types. \cite{wadler-thiemann03}




\paragraph{Parametric Effect Monad}
\label{sec:parametric_effect_monad} \hfill

(or \emph{Indexed Monad})

Katsumata14, Orchard-Petricek-Mycroft14

Semantic ``marriage'' of Effects and Monads

Indexed Joinad (\S\ref{sec:indexed_joinad})

Type-level Sets (???): Implementation in Haskell using ``data kinds''
and ``closed type families'' (Orchard-Petricek14) %FIXME

intermediate between Monads and Effect Handlers (Orchard-Petricek14)



\subsubsection{Joinad}\label{sec:joinad}

Extending Monads with Operations for Modelling Alternation
(Conditionals) and Parallelism



\paragraph{Graded Joinad}\label{sec:graded_joinad}\hfill

Effect Control-flow Algebras \& Types



\paragraph{Indexed Joinad}\label{sec:indexed_joinad}\hfill

Indexed Monad (Parametric Effect Monad
\S\ref{sec:parametric_effect_monad})



% --------------------------------------------------------------------
\subsection{Computational Effect}\label{sec:computational_effect}
% --------------------------------------------------------------------

Computational Effects

e.g. Exceptions, Non-determinism, Interactive Input/Output,
Concurrency, State, Time, Continuations, etc. \cite{plotkin-pretnar09}

Monad (\S\ref{sec:monad})

Computation (Monad) $T$ Returning Value of Type $A$:
\[
  T A
\]

Return

Bind

Value Polymorphism (\S\ref{sec:value_polymorphism})

\cite{plotkin-pretnar13}:

In the Category $\cat{Set}$, a Computation that Returns Values from a
Set $A$ is Modelled by an Element $T A$ for a ``suitable'' Monad $T$.

E.g. Exceptions, State, Non-determinism, Interactive Input/Output,
Time, Continuations, etc. (and combinations thereof)

Algebraic Effects (\S\ref{sec:algebraic_effect}):
\begin{itemize}
  \item Set of Operations representing Sources of Effects
  \item Equational Theory describing Properties of the Operations
\end{itemize}



\subsubsection{Partiality Effect}\label{sec:partiality_effect}

an Effect that all Recursively Defined Functions have
(\S\ref{sec:recursive_function})

possible Semantics:

Lifting Monad (\S\ref{sec:lifting_monad})

Continuation-based (\S\ref{sec:continuation})



\subsubsection{Exception Effect}\label{sec:exception_effect}

\cite{plotkin-pretnar13}:

Finite Set of Exceptions $\mathbf{exc}$

Exception Monad

\begin{align*}
     T A & \defeq A + \mathbf{exc} \\
  \eta_A & \defeq in_1 : A \rightarrow A + \mathbf{exc}
\end{align*}

Computations:

$\mono{return}\; V$ Interpreted by $\eta_A(V) = in_1(V)$

$\mono{raise}_e()$ Interpreted by $in_2(e)$

Effect Handler (\S\ref{sec:effect_handler})

Exception Handling

Computation $M \in A + \mathbf{exc}$
\[
  M \;\mono{handled\;with}\;
    \{\mono{raise}_e \mapsto M_e \}_{e\in\mathbf{exc}}
\]
where $\{\cdots\}_{e\in\mathbf{exc}}$ is a Set of Computations, one
for each Exception $e \in \mathbf{exc}$

carries out $M$, ``Intercepting'' Exceptions $e \in \mathbf{exc}$ by
carrying out predefined Computations $M_e \in A + \mathbf{exc}$
instead

Un-handled Exceptions take $M_e$ to be $\mono{raise}_e()$

Handling Construct Satisfies two Equations:
\begin{enumerate}
  \item $\mono{return}\; V \;\mono{handled\;with}\;
    \{\mono{raise}_e \mapsto M_e\}_{e \in \mathbf{exc}}
    = in_1(V)$
  \item $\mono{raise}_{e'}() \;\mono{handled\;with}\;
    \{\mono{raise}_e \mapsto M_e\}_{e \in \mathbf{exc}}
    = M_{e'}$
\end{enumerate}

the Computations $M_e$ give a new Model $\mathcal{M}$ for the Theory
of Exceptions with same Carrier (i.e. Domain \S\ref{sec:domain}) $A +
\mathbf{exc}$ and for each $e$, each $\mono{raise}_e ()$ is instead
Interpreted by $M_e$

\[
  h(M) \defeq M \;\mono{handled\;with}\;
    \{\mono{raise}_e \mapsto M_e\}_{e \in \mathbf{exc}}
\]
is a Unique Homomorphism (Preserving Operations) from $A +
\mathbf{exc}$ to $\mathcal{M}$ that Extends $in_1 : A \rightarrow A +
\mathbf{exc}$, i.e. such that:
\[
  A \xrightarrow{in_1} \mathcal{M} =
    A \xrightarrow{\eta_A} A + \mathbf{exc} \xrightarrow{h} \mathcal{M}
\]

Extended Handling Construct:
\[
  M \;\mono{handled\;with}\;
    \{\mono{raise}_e() \mapsto M_e \}_{e\in\mathbf{exc}}
    \;\mono{to}\; x : A.N(x)
\]

\begin{enumerate}
  \item $\mono{return}\; V \;\mono{handled\;with}\;
    \{\mono{raise}_e() \mapsto N_e\}_{e \in \mathbf{exc}}
    \;\mono{to}\; x:A.N(x)
    = N(V)$
  \item $\mono{raise}_{e'}() \;\mono{handled\;with}\;
    \{\mono{raise}_e() \mapsto N_e\}_{e \in \mathbf{exc}}
    \;\mono{to}\; x:A.N(x)
    = N_{e'}$
\end{enumerate}
\[
  A \xrightarrow{N} \mathcal{M} =
    A \xrightarrow{\eta_A} A + \mathbf{exc} \xrightarrow{h} \mathcal{M}
\]

Homomorphisms from the Free Model to a Model on a given Carrier

Effect Handler (\S\ref{sec:effect_handler}): Exceptions replaced by
Handling Computations



\subsubsection{State Effect}\label{sec:state_effect}

\subsubsection{Communication Effect}\label{sec:communication_effect}

Communication \S\ref{sec:communication}

Jouvelot-Gifford89

\cite{nielson-nielson99}

\cite{orchard-yoshida16}: Communication Effects can be encoded in
Session Types (\S\ref{sec:session_type}), but there is no reverse
encoding of Session Types into Communication Effects because Session
Types do not describe the relative ``Causality'' between Channels
(recorded by Communication Effects).



\subsubsection{Session Effect}\label{sec:session_effect}

Session (\S\ref{sec:session})

Session Type (\S\ref{sec:session_type})

Embedding of Session Calculus (\S\ref{sec:session_calculus}) into FPCF
(\S\ref{sec:fpcf})

\[
  \begin{tabular}{|l r|l r|}
    \hline \textbf{Effects} & & \textbf{Sessions} & \\
    \hline \hline
      $\bullet$ & \emph{sequential}
        & $?[\tau].-$ \quad $![\tau].-$ & \emph{prefixing} \\
    \hline
      $I$ & \emph{pure} & $\mathsf{end}$ & \emph{inaction} \\
    \hline
      $\oplus$ & \emph{conditional}
        & $\oplus[l_1:S_1, \ldots, l_n:S_n]$ & \emph{selection}/ \\
      \hfill & \hfill
        & $\&[\l_1:S_1, \ldots, l_n:S_n]$ & \emph{branching} \\
    \hline
      $*$ & \emph{repetition}
        & $\mu a.S$ \quad $a$ & \emph{fixed points} \\
      \hfil & \hfill
        & $*![\tau]$ \quad $*?[\tau]$ & \emph{replication} \\
    \hline
      $\sqsubseteq$ & \emph{sub-effecting}
        & $\leqq$ & \emph{sub-typing} \\
    \hline
      $\&$ & \emph{parallelism} & $\odot$ & \emph{balancing} \\
    \hline
  \end{tabular}
\]


\textbf{Implementation}

\fist Note the following uses a Haskell-like notation, an actual
Haskell implementation is available at
\url{http://dorchard.co.uk/popl16}

Effect-graded Monad (\S\ref{sec:graded_monad}):
\begin{flalign*}
  \quad & \quad\mono{class}\;\mathsf{Effect}
    (m : \eff \rightarrow * \rightarrow *)
    \;\mono{where} & \\
  & \quad\quad
    \mono{type}\;\mathsf{Unit}\;m : \eff & \\
  & \quad\quad
    \mono{type}\;\mathsf{Plus}\;m\;(f : \eff)
      \;(g : \eff) : \eff & \\
  & \quad\quad
    \mathsf{return} : a \rightarrow
      m\;(\mathsf{Unit\;m})\;a & \\
  & \quad\quad
    (\bindop) : m\;f\;a \rightarrow (a \rightarrow m\;g\;b)
        \rightarrow m\;(\mathsf{Plus}\;m\;f\;g)\;b &
\end{flalign*}

\emph{Session Effects} (\S\ref{sec:session_effect}) are Modelled by
the $\mathsf{Session}$ Datatype:
\begin{align*}
  \mono{data}\;\mathsf{Session}
    =\; & \mono{forall}\;a . a :! \;\mathsf{Session}
      \quad\quad\quad & \text{\emph{send}} \\
    \mid\; & \mono{forall}\;a . a :? \;\mathsf{Session}
      \quad\quad\quad & \text{\emph{receive}} \\
    \mid\; & \mono{forall}\;a . a :\kern-2pt*! \;\mathsf{Session}
      \quad\quad\quad & \text{\emph{output}} \\
    \mid\; & \mathsf{Session} \altop \mathsf{Session}
      \quad\quad\quad & \text{\emph{alternation}} \\
    \mid\; & \mathsf{Bal\;Session}
      \quad\quad\quad & \text{\emph{balanced}} \\
    \mid\; & \mathsf{End}
      \quad\quad\quad & \text{\emph{end}} \\
    \mid\; & \mathsf{Fix\;Session\;Session}
      \quad\quad\quad & \text{\emph{-* prefix}}
\end{align*}

Explicit Subtyping Class: \textturnt
\begin{flalign*}
  \quad\quad &
  \mono{class}\;\mathsf{Sub}\;m\;f\;g\;\mono{where}\;
    \mathsf{sub} : \mathsf{Sub}\;f\;g \Rightarrow
      m\;f\;a \rightarrow m\;g\;a &
\end{flalign*}

Graded Monad Instance for $\mathsf{Process}$ (\S\ref{sec:process})
Datatype:
\begin{flalign*}
  \quad\quad
  & \mono{data}\;\mathsf{Process}\;(s:[\mathsf{Map\;Name\;Session}])\;a
    = \mathsf{Proc}\;(\mathsf{IO}\;a) & \\
  \quad\quad & \hfill & \\
  \quad\quad
  & \mono{instance}\;\mathsf{Effect\;Process}\;\mono{where} & \\
  \quad\quad
  & \quad \mono{type}\;\mathsf{Plus\;Process}\;f\;g
    = \mathsf{SeqUnion}\;f\;g & \\
  \quad\quad
  & \quad \mono{type}\;\mathsf{Unit\;Process} = '[] & \\
  \quad\quad & \hfill & \\
  \quad\quad
  & \mono{instance}\;\mathsf{Sub\;Process}\;f\;g \Rightarrow & \\
  \quad\quad
  & \quad \mathsf{Sub\;Process}\;((c :\rightarrow s) \hastypef f)\;
    ((c :\rightarrow s \altop t) \hastypef g) & \\
\end{flalign*}

$s$ -- Type-level Finite Map Modelling an Environment of Session Type
information of the form:
\[
  '[c :\rightarrow s, d :\rightarrow t, \ldots]
\]
describing an Environment where a Channel $c$ has Session Type $s$, a
Channel $d$ has Session Type $t$, etc.

Session Environments are Composed Sequentially via the
$\mathsf{SeqUnion}$ Type-level Function (Modelling $\bullet$ for
Effect Algebras \S\ref{sec:effect_system})

Operations from Embedding of Session Calculus in FPCF: %FIXME

$\mathsf{send}$

$\mathsf{rsend}$

$\mathsf{chSend}$

$\mathsf{recv}$

$\mathsf{chRecv}$

$\mathsf{new}$

(duality type-class)

\fist Haskell does not have Equirecursive Types
(\S\ref{sec:equirecursive_type}) so the Implementation restricts
Recursion to only definitions that Induce an \emph{Affine Effect
  Equation} (???). %FIXME

(specialized affineFix combinator) %FIXME



% --------------------------------------------------------------------
\subsection{Algebraic Effect}\label{sec:algebraic_effect}
% --------------------------------------------------------------------

\cite{nielson-nielson99}
\cite{plotkin-pretnar09}
\cite{plotkin-pretnar13}
\cite{pretnar15}

\fist The paper \emph{Handlers of Algebraic Effects}
\cite{plotkin-pretnar09} (Plotkin, Pretnar 2009) is a preliminary
version of \emph{Handling Algebraic Effects} \cite{plotkin-pretnar13}
(Plotkin, Pretnar 2013). In \cite{plotkin-pretnar09}, there are
restricted facilities for defining Handlers (the \emph{Minimal}
approach). Two levels of Language are considered: in the first there
are no Handlers but it is used to define Handlers, and if they give
Models then they are used in Handling Constructs in the second level
(with no facilities for further definition of Handlers). In
\cite{plotkin-pretnar13} Handlers and Handling may be nested
arbitrarily deeply (the \emph{Maximal} approach).


\fist Orchard-Yoshida16 \cite{orchard-yoshida16} distinguishes the
Effect Systems of Nielson-Nielson99 \cite{nielson-nielson99} from
``traditional'' Effect Systems by distinguishing Sequential Control
Flow from Branching Control Flow (Alternation).


(Countable) Equational Theories (Algebraic Theory
\S\ref{sec:algebraic_theory})

Algebraic Operation (\S\ref{sec:algebraic_operation})


as an alternative to using Monads (\S\ref{sec:monad}) to Model
Side-effects, most often seen in Strict Languages

Continuations (\S\ref{sec:continuation}) are not representable as
Algebraic Effects


Call-by-value, Call-by-push-value %FIXME


\cite{plotkin-pretnar08}:

Effectful Programs (1) cause Effects (Computation Terms combined by an
Operation), (2) Return Values (Returned Value Terms), (3) have an
Evaluation Order (Computations Sequenced with a $\mono{let}$ Binding)

$a$-calculus: Values, Effects, Computations

Operations: ``sources'' of Effects

Value Theory $\thy{V}$

$\Sigma_{\mathrm{fun}}$

Value Contex $\Gamma$

Effect Theory $\thy{E}$

$\Sigma_{\mathrm{op}}$

Effect Contex $\Xi$

Computations Returning Value of Type $\sigma$: $F \sigma$

Evaluation of Computation $\mono{let}\; x \;\mono{be}\; \mono{op}(t_1,
\ldots, t_n) \;\mono{in}\; t'$ begins with Occurrence of Effect
represented by $\mono{op}:n$ and then based on the Outcome (???) of an
Effect, proceeds by Evaluating one of the Computation Terms $t_1,
\ldots, t_n$ and Binding its Result to $x$ in Computation Term $t'$

Effect Theory $\thy{E}$ gives rise to a Lawvere Theory
(\S\ref{sec:lawvere_theory}) $\cat{L}$

\textbf{Semantics}

Value Terms Interpreted in $\cat{Set}$

Effect Terms Interpreted in a Lawvere Theory $\cat{L}$

Computation Terms Interpreted in the Category of Models
(\S\ref{sec:category_of_models}) $\cat{Mod}_\cat{L}(\cat{Set})$ of
Models of $\cat{L}$ in $\cat{Set}$.



\cite{plotkin-pretnar13}:

Algebraic Effects (\S\ref{sec:algebraic_effect}):
\begin{itemize}
  \item Set of Operations representing Sources of Effects
  \item Equational Theory (\S\ref{sec:equational_theory}) describing
    Properties of the Operations
\end{itemize}

Each Computation either Returns a Value, or performs an Operation with
an Outcome that determines a Continuation (\S\ref{sec:continuation})
of the Computation with Arguments of the Operation representing
possible Continuations (possible Computations after the occurrence of
an Effect).



\cite{plotkin-pretnar09}:

$T X$: Computations $T$ that Return Values in $X$, for ``suitable''
Monad (\S\ref{sec:monad}) $T$

Subclass of Computational Effects (\S\ref{sec:computational_effect}):
Effects that allow Representation by Operations and Equations.

Equational Logic (\S\ref{sec:equational_logic})

Computational Effects representable by an Algebraic Theory:
Nondeterminism, Interactive Input/Output, Concurrency, State, Time,
Stream Redirection, Backtracking, Co-operative Multi-threading,
Delimited Continuations, etc.

Sets of Operations

Operations give rise to Effects

Arguments of an Operation represent possible Computations after an
Occurrence (???) of an Effect

Example Non-deterministic Boolean $\mono{or}$ Operator:
\[
  \mono{or}(\mono{return}\;true, \mono{return}\;false)
  : F \mathrm{Bool}
\]

$F \sigma$: Type of Computations with Return Values of Type $\sigma$

Computation Monad: Free-model Monad (???, Free Monad
\S\ref{sec:free_monad}) of the Algebraic Theory; Equations of the
Theory Generate the Free-model Functor (exactly the corresponding
Monad for the Effect, Modulo the Forgetful Functor): used to Interpret
the Type $F \sigma$.

Operations Interpreted by the Model Structure

Family of Functions Parametric in $X$ (Algebraic Operation),
characterized by a Naturality Condition %FIXME

Example Parametric Operation:
\[
  \mono{or}_X : T X^2 \rightarrow T X
\]

Algebraic Operations \S\ref{sec:algebraic_operation} (\emph{Effect
  Constructors}) and Effect Handlers \S\ref{sec:effect_handler}
(\emph{Effect Destructors}) are Dual

\fist Cf. Monadic Reflection (\S\ref{sec:monadic_reflection})
and Monadic Reification (\S\ref{sec:monadic_reification})

Handlers (\S\ref{sec:effect_handler}) correspond to a Model of the
Algebraic Theory

Handling a Computation is Composing it with a Unique Homomorphism
(defined Universally) with Domain a Free Model
(\S\ref{sec:free_model}) of the Algebraic Theory of the Effects ``at
hand'', and Range the Programmer-defined Model (???) of the Algebraic
Theory, Extending a Programmer-defined Map on Values.

Instances of Handlers: Exception Handling, Stream Redirection,
Renaming and Hiding, Timeout, Rollback, etc.

\fist Note that some Handlers (e.g. for Backtracking) do not
respect the Equations of an Algebraic Theory. \cite{pretnar15}

\cite{plotkin-pretnar09}:

Parts of an Effect System detailed below:
\begin{itemize}
  \item Base Signature $\Sigma_\mathrm{base}$:
    \begin{itemize}
      \item Base Types
      \item Function Symbols
      \item Relation Symbols
    \end{itemize}
  \item Base Terms
  \item Base Formulas
  \item Effect Signature $\Sigma_\mathrm{eff}$:
    \begin{itemize}
      \item Operations
    \end{itemize}
  \item Effect Terms
  \item (Conditional) Effect Theory (\S\ref{sec:effect_theory})
    $\thy{E}$:
    \begin{itemize}
      \item Conditional Equations
    \end{itemize}
  \item Handler (\S\ref{sec:effect_handler}) Signature
    $\Sigma_\mathrm{hand}$:
    \begin{itemize}
      \item Handler Symbols
    \end{itemize}
  \item Handler Types
  \item Handler Terms
  \item Computation Types
  \item Computation Terms
\end{itemize}


\emph{Base Signature} $\Sigma_{\mathrm{base}}$:
\begin{itemize}
  \item Base Types $\beta_1, \beta_2, \ldots$
  \begin{itemize}
    \item Arity Types $\alpha_1, \alpha_2, \ldots$
  \end{itemize}
  \item Function Symbols $f : (\vec{\beta}) \rightarrow \beta$
  \item Relation Symbols $R : (\vec{\beta})$
\end{itemize}

Variables $x,y,z,\ldots$

Function Symbols $f,g,h,\ldots$

\emph{Base Terms}:
\begin{flalign*}
  \quad v ::=& x \; | \; f (\vec{v}) &
\end{flalign*}

\emph{Base Formulas} $\varphi$: Equations $v_1 = v_2$, Relation
Symbols $R (\vec{v})$, Logical Connectives, Quantifiers
applied to Base Types

\emph{Context} $\Gamma$: Variables Bound to Base Types

A Context $\Gamma$ Types Base Terms as $\Gamma \vdash v:\beta$ and
Base Formulas as $\Gamma \vdash \varphi : \mathbf{form}$

\emph{Interpretation} of the Base Signature:
\begin{itemize}
  \item Sets $\llbracket \beta \rrbracket$ for each Base Type
    (Countable when $\beta$ is an Arity Type)
  \item Maps $\llbracket f \rrbracket : \llbracket \vec{\beta}
    \rrbracket \rightarrow \llbracket \beta \rrbracket$ for each
    Function Symbol
  \item Subsets $\llbracket R \rrbracket \subseteq \llbracket
    \vec{\beta} \rrbracket$ for each Relation Symbol
  \item Maps $\llbracket v \rrbracket : \llbracket \Gamma \rrbracket
    \rightarrow \llbracket \beta \rrbracket$ for Terms
  \item Subsets $\llbracket \varphi \rrbracket \subseteq \llbracket
    \Gamma \rrbracket$ for Formulas
\end{itemize}
where $\llbracket \vec{\beta} \rrbracket = \llbracket \beta_1
\rrbracket \times \cdots \times \llbracket \beta_n \rrbracket$

\emph{Effect Signature} $\Sigma_{\mathrm{eff}}$:
\begin{itemize}
  \item Operation Symbols $\mono{op} : \vec{\beta}; \vec{\alpha}_1,
    \ldots, \vec{\alpha}_n$ where $\vec{\beta}$ is a list of Parameter
    Base Type and $\vec{\alpha}_1, \ldots, \vec{\alpha}_n$ are Lists
    of Argument Arity Types (``;'' is ommitted if the List of Base
    Types is Empty and $n$ is used if all $\vec{\alpha}_i$ Lists of
    Argument Arities are Empty)
\end{itemize}

\emph{Effect Variables} $w$

\emph{Effect Terms}:
\begin{flalign*}
  \quad T ::=& w(\vec{v}) \; | \; \mono{op}_{\vec{v}}
  (\vec{x}_1:\vec{\alpha}_1.T_1, \ldots, \vec{x}_n:\vec{\alpha}_n.T_n)
  &
\end{flalign*}
where $\vec{x}_i:\vec{\alpha}_i$ are Lists of Base Terms of Arity
Types.

$\Delta$ is a Set of Effect Variables $w:(\vec{\alpha})$ with rules:
\begin{enumerate}
  \item $(w:(\vec{\alpha}) \in \Delta)$:
  \[
    {\Gamma \vdash \vec{v}:\vec{\alpha}}
    \over{\Gamma;\Delta \vdash w(\vec{v})}
  \]
  \item $(\mono{op} : \vec{\beta}; \vec{\alpha}_1, \ldots,
    \vec{\alpha}_n \in \Sigma_\mathrm{eff})$:
    \[
      {\Gamma \vdash \vec{v}:\vec{\beta} \quad\quad
        \Gamma, \vec{x}_i:\vec{\alpha}_i;
        \Delta \vdash T_i \quad (i = 1, \ldots, n)}
      \over{\Gamma; \Delta \vdash
        \mono{op}_{\vec{v}(\vec{x}_i:\vec{\alpha}_i.T_i)_i}}
    \]
\end{enumerate}

Typing Effect Terms: $\Gamma; \Delta \vdash T$

\emph{Conditional Equations}: $\Gamma; \Delta \vdash T_1 = T_2
(\varphi)$ given that $\Gamma; \Delta \vdash T_1$, $\Gamma; \Delta
\vdash T_2$, and $\Gamma \vdash \varphi:\mathbf{form}$

\emph{Conditional Effect Theory} (\S\ref{sec:effect_theory}):
$\thy{E}$ is a collection of Conditional Equations

Equational Theory (\S\ref{sec:equational_theory}) given by Effect
Theory:
\begin{itemize}
  \item For each Operator $\mono{op}:\vec{\beta}; \vec{\alpha}_1,
    \ldots, \vec{\alpha}_n \in \Sigma_\mathrm{eff}$ and $\vec{b} \in
    \llbracket \vec{\beta} \rrbracket$ take an Operation Symbol
    $\mono{op}_{\vec{b}}$ of (Countable) Arity $\sum_{i}|\llbracket
    \vec{\alpha}_i \rrbracket|$
  \item Each Effect Term $\Gamma; \Delta \vdash T$ and each $\vec{c}
    \in \llbracket \Gamma \rrbracket$ gives rise to a Term $\Delta'
    \vdash T_{\vec{c}}$ with $\Delta'$ consisting of Effect Variables
    $w_{\vec{a}}$ for each $w:(\vec{\alpha}) \in \Delta$ and $\vec{a}
    \in \llbracket \vec{\alpha} \rrbracket$
  \item Equations:
    \[
      \Delta' \vdash T_{\vec{c}} = T_{\vec{c'}}
    \]
    for any Conditional Equations $\Gamma; \Delta \vdash T =
    T'(\varphi)$ in $\thy{E}$ and any $\vec{c} \in \llbracket \varphi
    \rrbracket$
\end{itemize}

Model of the Effect Theory:
\begin{itemize}
  \item Set $M$
  \item Family of Maps $\{ \mono{op}_M : \llbracket \vec{\beta}
    \rrbracket \times \prod_i M^{\llbracket \vec{\alpha}_i
      \rrbracket} \rightarrow M \}_{\mono{op}:\vec{\beta};
      \vec{\alpha}_1, \ldots, \vec{\alpha}_n \in
      \Sigma_{\mathrm{eff}}}$
\end{itemize}
such that the corresponding Maps $\mono{op}_M(\vec{b})$ (where
$\vec{b} \in \llbracket \vec{\beta} \rrbracket$) Satisfy
(\S\ref{sec:satisfaction}) the Equations of the Induced Infinitary
Effect Theory.

A Homomorphism between Models $M$ and $N$ is a Map $f : M \rightarrow
N$ such that $\mono{op}_N \circ (id_{\llbracket \vec{\beta}
  \rrbracket} \times \prod_i f^{\llbracket \vec{\alpha}_i \rrbracket})
= f \circ \mono{op}_M$

Category of Models and Homomorphisms $\cat{Mod}_\thy{E}$

Forgetful Functor $U : \cat{Mod}_\thy{E} \rightarrow \cat{Set}$

Left-adjoint to $U$ Free-model Functor $F$: constructs the Free Model
(\S\ref{sec:free_model}) $F A$ on a Set of Generators $A$.

$U F A$: Set of Computations Returning Values in $A$

$U F$: Monad used to Model the corresponding Effect

\emph{Handler Types}:
\begin{flalign*}
  \quad \chi &::= X \; | \; F \sigma \; | \; 1 \;
    | \; \chi_1 \times \chi_2 \; | \; \sigma \rightarrow \chi &
\end{flalign*}

\emph{Handler Terms}:
\begin{flalign*}
  \quad h ::=& \; z(\vec{v}) \;
    | \; \mono{op}_{\vec{v}}
      (\vec{x}_1:\vec{\alpha}_1.h_1, \ldots, \vec{x}_n:\vec{\alpha}_n.h_n) & \\
    |&\; \mono{if}\; \varphi \;\mono{then}\; h_1
      \;\mono{else}\; h_2 \; | \; \mono{return}\; u \;
    | \; \mono{let}\; x \;\mono{be}\; h \;\mono{in}\; h' & \\
    |&\; \star \;
    | \; \langle h_1, h_2 \rangle \; | \; \mono{fst}\; h \;
    | \; \mono{snd}\; h \; | \; \lambda x:\sigma.h \;
    | \; h u &
\end{flalign*}

Typing Handlers

Handler (\S\ref{sec:effect_handler}) Signature $\Sigma_\mathrm{hand}$:
Set of Handler Symbols $H$

\emph{Computation Type}:
\begin{flalign*}
  \quad \underline{\tau} &::= F \sigma \; | \; 1 \;
    | \; \underline{\tau}_1 \times \underline{\tau}_2 \;
    | \; \sigma \rightarrow \underline{\tau} &
\end{flalign*}

\emph{Computation Term}:
\begin{flalign*}
  \quad t ::=& \; \mono{op}_{\vec{v}}
      (\vec{x}_1:\vec{\alpha}_1.t_1, \ldots \vec{x}_n:\vec{\alpha}_n.t_n) & \\
    |&\; \mono{if}\; \varphi \;\mono{then}\; t_1
      \;\mono{else}\; t_2 \; | \; \mono{return}\; u \;
    | \; \mono{let}\; x \;\mono{be}\; t \;\mono{in}\; t' & \\
    |&\; \mono{try}\; t \;\mono{with}\; H(\vec{u};
      \vec{t}) \;\mono{as}\; x \;\mono{in}\; t' \\
    |&\; \star \; | \; \langle t_1, t_2 \rangle \;
    | \; \mono{fst}\; t \;
    | \; \mono{snd}\; t \; | \; \lambda x:\sigma.t \;
    | \; t u &
\end{flalign*}

\fist Note that Computation Types mirror Handler Types (except
for Type Variables), and Computation Terms mirror Handler Terms
(except for Handler Variables and the addition of the
$\mono{try}\ldots\mono{with}$ Construct)

The syntax:
\[
  \mono{handle}\; t \;\mono{with}\;
  H(\vec{u};\vec{t})
\]
can be used in place of:
\[
    \mono{try}\; t \;\mono{with}\; H(\vec{u};
      \vec{t}) \;\mono{as}\; x \;\mono{in\;return}\; x
\]

When the Handler Signature consists of a single Handler Symbol $H$ it
may be ommitted:
\[
    \mono{try}\; t \;\mono{with}\; \vec{u};
      \vec{t} \;\mono{as}\; x \;\mono{in}\; t'
\]

Typing Computation Terms

a Handler:
\[
  H : (\vec{\sigma}; \vec{\chi})
    \rightarrow \chi \;\mathbf{handler} \in \Sigma_\mathrm{hand}
\]

Typing Handling Constructs

Examples: \cite{plotkin-pretnar09}

CCS (Calculus of Communicating Systems \S\ref{sec:ccs})

%FIXME



\cite{plotkin-pretnar13}:

Free Model (\S\ref{sec:free_model}) $F A$ Generated by the Equational
Theory (\S\ref{sec:equational_theory})

Computation Returning Values from a Set $A$ is an Element of the Free
Model $F A$

(Modulo the Forgetful Functor) the Free-model Functor $F$ is the Monad
(\S\ref{sec:monad}) used to Model the corresponding Effect; an
Algebraic Effect. Continuations (\S\ref{sec:continuation}) are an
example of a Non-algebraic Effect (does not arise from an Equational
Presentation).

\emph{Handlers} correspond to (not-necessarily Free) Models of the
Equational Theory

Semantics of Handling given using Universal Property of the Free Model
(it Induces Unique Homomorphisms to the Models)

Exception Handling Construct: Application of Unique Homomorphism that
Preserves Returned Values

\emph{or}

(generalizing to all Algebraic Effects, e.g. Stream Redirection,
Renaming and Hiding, Timeout, Rollback, etc.): Returned Values are
passed to a user-defined Continuation (Application of an arbitrary
Homomorphism to a Computation)

Algebraic Operations \S\ref{sec:algebraic_operation} (\emph{Effect
  Constructors}: giving rise to the Effects) are Dual to Effect
Handlers \S\ref{sec:effect_handler} (\emph{Effect Deconstructors}:
proceeding according to Effects already created)

\fist Cf. Layered Monads (\S\ref{sec:layered_monad}): Monadic
Reflection (\S\ref{sec:monadic_reflection}) and Monadic Reification
(\S\ref{sec:monadic_reification})


\textbf{Types}

\emph{Signature Types}:
\[
  \alpha, \beta ::= b \;|\; 1 \;|\; \alpha \times \beta \;|\;
    \Sigma_{\ell \in L} \alpha_\ell
\]

(Type) Signature: Base Types, Typed Function Symbols, Typed Operation
Symbols

Syntax Parameterized by choice of Signature

Base Types $b$

Labels $\ell$

$Lab$ all possible Labels

$L$ Finite Subsets of Labels

Arity Base Types

Arity Signature Type: a Signature Type that contains only Arity Base
Types

\emph{Function Symbols} $f : \alpha \rightarrow \beta$

\emph{Operation Symbols} $op : \alpha \rightarrowtriangle \beta$

\emph{Effect Theory} (\S\ref{sec:effect_theory}) $\thy{T}$

Operations: Sources of Effects

Effect Theory: Properties of Effects

Operation $op : \alpha \rightarrowtriangle \beta$:
\begin{enumerate}
  \item accepts Parameter of Type $\alpha$
  \item performs relevant Effect
  \item outcome of Type $\beta$ determines its Continuation
\end{enumerate}
%FIXME

$op$ is:
\begin{itemize}
  \item Parameterized on $\alpha$
  \item has Arity $\beta$ ($\beta$-ary)
\end{itemize}

When $\alpha = 1$, $op$ may be written $op:\beta$

\emph{Value Types} $A,B,\ldots$:
\begin{flalign*}
  \quad A,B ::=&\; b \;|\; 1 \;|\; A \times B
    \;|\; \sum_{\ell \in L}A_{\ell} \;|\; U \underline{C} &
\end{flalign*}

\emph{Computation Types} $\underline{C},\ldots$:
\begin{flalign*}
  \quad \underline{C} ::=&\; F A
    \;|\; \prod_{\ell \in L} \underline{C}_{\ell}
    \;|\; A \rightarrow \underline{C} &
\end{flalign*}

Value Types extend Signature Types by addition of Type Constructor $U
-$ classifying Computations of Type $\underline{C}$ that have been
Thunked (???) into Values (later Forced back into Evaluation).
%FIXME xref Thunk, Forced

Computation Type $F A$ classifies Computations that Return Value of
Type $A$

$\prod_{\ell \in L} \underline{C}_{\ell}$ classifies Finite Indexed
Products of Computations

$A \rightarrow \underline{C}$ Computations of Type $\underline{C}$
Parametric on Values of Type $A$


\textbf{Terms}

Value Terms, Computation Terms, Handler Terms

(``Value'', ``Computation'', or ``Handler'' may be used instead of
``Value Term'', ``Computation Term'', or ``Handler Term'')

Value Variables $x,y,\ldots$

\emph{Value Terms} $V,W,\ldots$:
\begin{flalign*}
  \quad V,W ::=&\; x \;|\; f(V) \;|\; \langle \rangle
    \;|\; \langle V,W \rangle \;|\; \ell (V) \;|\; \mono{thunk}\; M &
\end{flalign*}


Continuation Variables $k,\ldots$

\emph{Computation Terms} $M,N,\ldots$:
\begin{flalign*}
  \quad M,N ::=&\; \mono{match}\; V \;\mono{with}\;
      \langle x,y \rangle \mapsto M
    \;|\; \mono{match}\; V \;\mono{with}\; \{\ell(x_\ell) \mapsto
      M_\ell\}_{\ell \in L}
    \;|\; \mono{force}\; V & \\
    \;|\;& \mono{return}\; V \;|\; M \;\mono{to}\; x:A.N
    \;|\; \langle M_\ell \rangle_{\ell \in L} \;|\; \mono{prj}_\ell M
    \;|\; \lambda x:A.M \;|\; M V & \\
    \;|\;& op_V(x:\beta.M) \;|\; k(V)s
    \;|\; M \;\mono{handled\;with}\; H \;\mono{to}\; x:A.N &
\end{flalign*}


\emph{Handler Terms} $H,\ldots$:
\begin{flalign*}
  \quad H ::=&\; \{ op_{x:\alpha}
    (k:\beta \rightarrow \underline{C}) \mapsto
    M_{op} \}_{\mono{op:\alpha \rightarrowtriangle \beta}} &
\end{flalign*}


$\{\cdots\}_{\ell \in L}$ Set of Computations, one for each Label
$\ell \in L$

$\{\cdots\}_{op: \alpha \rightarrowtriangle \beta}$ Set of
Computations, one for each Operation Symbol $op: \alpha
\rightarrowtriangle \beta$

Value Terms involve only Constructors; corresponding Destructor Terms
are Computations

Constructor, Destructor Terms for Computation Types

For Type $F A$:
\begin{itemize}
  \item Return $\mono{return}\; V$
  \item Sequencing Construct $M \;\mono{to}\; x:A.N$
\end{itemize}

Operation Application (Computation Term):
\[
  op_V(x:\beta.M)
\]
first triggers Operation $op$ with Parameter $V$, then binds
Outcome to $x$ and Proceeds as Continuation $M$.

Handler Term:
\[
  \{ op_{x:\alpha}
    (k:\beta \rightarrow \underline{C}) \mapsto
    M_{op} \}_{\mono{op:\alpha \rightarrowtriangle \beta}}
\]
is given by a Finite Set of \emph{Handling Operation Definitions}:
\[
  op_{x:\alpha}
    (k:\beta \rightarrow \underline{C}) \mapsto
    M_{op}
\]
one for each Operation Symbol $op$

Handling Terms $M_{op}$ are dependent on their Parameters
(captured in their Parameter Values $x$) and on the Continuations of
the Handled Operations (captured in their Continuation Variables $k$)

\fist Note Continuation Variables always appear applied to a Value
$k(V)$

Handling Computation Term:
\[
  M \;\mono{handled\;with}\; H \;\mono{to}\; x:A.N
\]
Evaluates Computation $M$, Handling all Operation Application
Computations according to $H$, Binds result to $x$ and proceeds as $N$

Sequencing is a special case of Handling where $H$ Handles all
Operations ``by themselves''

Example: if $M$ triggers an Operation Application $op_V(y.M')$
and the corresponding Handling Term is $op_z(k) \mapsto
M_op \in H$, then the Operation is Handled by Evaluating
$M_op$ instead with Parameter Variable $z$ bound to $V$ and
each occurrence of a Term $k(W)$ in $M_op$ replaced by:
\[
  M'[W/y] \;\mono{handled\;with}\; H \;\mono{to}\; x:A.N
\]
and the Continuation $k$ receives an outcome $W$, determined by
$M_op$ and is Handled in the same way as $M$.

\fist Note that while Continuations are Handled by $H$, the Handling
Term $M_op$ is not; any Operations it triggers or Values it
Returns escape the Handler.

$\mono{let}$-binding abbreviation:
\[
  \mono{let}\; x:A \;\mono{be}\; V \;\mono{in}\; M
    \defeq (\lambda x:A.M)V
\]


\textbf{Typing Judgements}

\emph{Value Context}:
\[
  \Gamma = x_1:A_1, \ldots,x_m:A_m
\]
of Value Variables $x_i$ Bound to Value Types $A_i$

\emph{Continuation Context}:
\[
  K = k_1:\alpha_1 \rightarrow \underline{C}_1, \ldots,
    k_n:\alpha_n \rightarrow \underline{C}_n
\]
of Continuation Variables $k_j$ Bound to Continuation Types $\alpha_j
\rightarrow \underline{C}_j$

A Continuation Type $\alpha \rightarrow \underline{C}$ with an Arity
Signature Type $\alpha$ Types a Continuation $k$ that accepts a Value
of Type $\alpha$ and proceeds as a Computation of Type
$\underline{C}$.

Values are Typed:
\[
  \Gamma | K \vdash V:A
\]

Computations are Typed:
\[
  \Gamma | K \vdash M : \underline{C}
\]

Handlers are Typed:
\[
  \Gamma | K \vdash H : \underline{C} \;\mathbf{handler}
\]

Value Typing Rules, Computation Typing Rules, Handler Typing Rules
%FIXME

$K$ may contain more than one Continuation Variable when the Handler
being Defined is used in Handling Definitions of other Handlers

Handlers for a Subset $\Theta$ of Operation Symbols %FIXME

Handler with Identity Continuation:
\[
  M \;\mono{handled\;with}\; H
    \defeq M \;\mono{handled\;with}\; H \;\mono{to}\;
      x:A.\mono{return}\; x
\]

Binary Deconstructor (Unix Pipe, Parallel Combinator in CCS
\S\ref{sec:ccs}) %FIXME

Simple Handlers (\S\ref{sec:simple_handler})

Parameter-passing Handlers (\S\ref{sec:parameter_passing_handler})


\textbf{CCS Example}

Effect Constructors (Operations):
\begin{enumerate}
  \item Deadlock $\mono{nil} : 1 \rightarrowtriangle 0$
  \item Action Prefix $\mono{prefix} : Act \rightarrowtriangle 1$
  \item Sum $\mono{choose} : 1 \rightarrowtriangle 2$
\end{enumerate}

Effect Deconstructors (Handlers):
\begin{enumerate}
  \item Renaming $P[b/a]$
  \item Hiding $P \backslash a$
  \item Parallel $P | Q$
\end{enumerate}


\asterism


\textbf{Semantics}

Denotational Semantics (\S\ref{sec:denotational_semantics})

Cartesian-closed Category (\S\ref{sec:cartesian_closed})

First-class Functions, Finite Products and Finite Sums (Coproducts)

Free Model (\S\ref{sec:free_model}) Construction (Functor ???)

Parametric Lifting (??? Lifting Monad \S\ref{sec:lifting_monad}) of
Maps to Homomorphisms from the Free Model

Sets, $\omega$-cpos (\S\ref{sec:omega_cpo})

Lawvere Theories (\S\ref{sec:lawvere_theory})

Lawvere $\cat{V}$-theories (???)


\asterism


Template Variables $z$

\emph{Templates} $T,\ldots$:
\begin{flalign*}
  \quad T ::=& \; z(V) \;|\; \mono{match}\; V
    \;\mono{with}\; \langle x,y \rangle \mapsto T
    \;|\; \mono{match}\; V \;\mono{with}\; \{\ell(x_\ell) \mapsto
    T_\ell\}_{\ell \in L} \;|\; op_V(x:\beta.T)
\end{flalign*}
Templates describe Common Properties of Computations; they are not
Typed, but Well-formed relative to a Value Context and a Template Context

Templates are limited to Signature Values (e.g. can be Typed as
$\Gamma \vdash V:\alpha$); Typing Rules are the same as the Typing
Rules for Values with the omission of Continuation Contexts and the
Rule for Typing Thunks.

\emph{Template Context}:
\[
  Z = z_1:\alpha_1, \ldots, z_n:\alpha_n
\]
of Template Variables $z_j$ Bound to Arity Signature Types $\alpha_j$.

$z_j:\alpha_j$ represents a Computation dependent on a Value of Type
$\alpha_j$

Typing Judgements for being a Well-formed Template $\Gamma | Z \vdash
T$, given by Rules:
%FIXME


\emph{Effect Theory} $\thy{T}$ is a Finite Set of Equations:
\[
  \Gamma | Z \vdash T_1 = T_2
\]
where $T_1$ and $T_2$ are Well-formed relative to $\Gamma$ and $Z$

Effect Theories for: Exceptions, State, Read-only State,
Nondeterminism, Input/Output %FIXME

Combining Theories:
\begin{enumerate}
  \item \emph{Sum} simple Union assuming disjoint Sets of Operation
    Symbols

  \item \emph{Tensor} Commuting combinations of two Effects, e.g. two
    Independent States; given by Union again assuming disjoing Sets of
    Operation Symbols plus the Equation:
    \[
    \begin{split}
      y:\alpha,y':\alpha' | z:\beta \times \beta' \vdash
        op_y(x:\beta.op'_{y'}(x':\beta'.z(x.x'))) \\
        \quad = op'_{y'}(x':\beta'.op_y(x:\beta.z(x,x')))
    \end{split}
    \]
    for each Operation Symbol $op : \alpha \rightarrowtriangle \beta$
    from the first Theory and Operation Symbol $op' : \alpha'
    \rightarrowtriangle \beta'$ from the second Theory.
\end{enumerate}

More example Theories:
\begin{itemize}
  \item Explicit Nondeterminism
  \item CCS: Sum of Theories for Nondeterminism and Explicit
    Nondeterminism
  \item Time
  \item Destructive Exceptions (``Rollback''): Tensor Product of
    Theories for State and Exceptions
\end{itemize}


\textbf{Interpretation of an Effect Theory}

Model $\struct{M}$ for an Effect Theory $\thy{T}$

Carrier Set $|\struct{M}|$

An Operation:
\[
  op_\struct{M} : \llbracket \alpha \rrbracket \times
    |\struct{M}|^{\llbracket \beta \rrbracket} \rightarrow |\struct{M}|
\]
for each Operation Symbol $op:\alpha \rightarrowtriangle \beta$, such
that $\llbracket T_1 \rrbracket = \llbracket T_2 \rrbracket$ for all
the Equations $\Gamma | Z \vdash T_1 = T_2$ in $\thy{T}$

Homomorphism of Models $h : \struct{M}_1 \multimap \struct{M}_2$ is a
Map $h : |\struct{M}_1| \rightarrow |\struct{M}_2|$ such that:
\[
  h \circ op_{\struct{M}_1} = op_{\struct{M}_2} \circ
    (id_{\llbracket \alpha \rrbracket}
      \times h^{\llbracket \beta \rrbracket})
\]
holds for all Operation Symbols $op:\alpha \rightarrowtriangle \beta$

Category $\cat{Mod}_\thy{T}$ of Models of $\thy{T}$ and Homomorphisms
between them

Forgetful Functor $U : \cat{Mod}_\thy{T} \rightarrow \cat{Set}$ where:
\[
  \begin{split}
    U \struct{M} \defeq & |\struct{M}| \\
    U h \defeq & h
  \end{split}
\]
Left-adjoint to the Forgetful Functor is the Free-model Functor $F :
\cat{Set} \rightarrow \cat{Mod}_\thy{T}$

$F A$ Free Model over Set $A$

Homomorphism Induced by $f : A \rightarrow U \struct{M}$: Adjoint
Homomorphism $\bar{f} : F A \multimap \struct{M}$

Unit $\eta_A : A \rightarrow F A$


\textbf{Interpretation of Values and Computation Types}

given a Signature, an Effect Theory $\thy{T}$ over the Signature, and
an Interpretation of the Effect Theory

Product Models, Exponent Models (???) %FIXME

An Interpretation $\llbracket V \rrbracket$ of a Well-typed Value
$\Gamma | K \vdash V:A$ is a Map $\llbracket \Gamma \rrbracket \times
\llbracket K \rrbracket \rightarrow \llbracket A \rrbracket$

Kleene Equality $\simeq$: Equal if both sides are Defined and Equal or
both sides are Undefined %FIXME xref

\emph{Parameterized Lifting} $f^{\dagger_\struct{M}} : A
\times U F B \rightarrow U \struct{M}$ of a Map $f : A \times B
\rightarrow U \struct{M}$ given by:
\[
  f^{\dagger_\struct{M}} \defeq U \bar{f} \circ st
\]
where $\bar{f}$ is the Homomorphism Induced by $f$ and $st : A \times
U F B \rightarrow U F (A \times B)$ is the Strength
(\S\ref{sec:strong_monad}) of Monad $U F$.


\emph{Interpretation of Handlers}

Handler Correctness: for an Empty Effect Theory, any Handler is
Correct, but in general Correctness is Undecidable

Correctness of Simple Handlers (\S\ref{sec:simple_handler}) is
$\Pi_2$-complete %FIXME xref


\asterism


Equivalence of Computations

Weak Equality Judgement $\bumpeq$

Definedness Judgement $\downarrow$

Template Substitution

Capture-avoiding Substitution

Inheritance Rule

Equations for the Handling Construct state the Universal properties of
the Induced Homomorphism:
\begin{enumerate}
  \item Extends the Inducing Map on Values
  \item acts Homomorphically on Operations
\end{enumerate}

Rule for showing Handler Correctness: %FIXME
states that a Handler is Correct when its Operation Definitions
respect the Equations of the Effect Theory

\emph{Simple Handler} (\S\ref{sec:simple_handler})

\emph{Parameter-passing Handler}
(\S\ref{sec:parameter_passing_handler})

\emph{Simple Signature}: no Base Types or Function Symbols, Implies a
Unique (Trivial) Interpretation

Simple Signatures and Theories are equivalent to ones with all
Operation Symbols are $n$-ary for some $n$

Simple Signatures: Exceptions over a Finite Set, Read-only State,
Input/Output, and Nondeterminism

\emph{Uniformly Simple} Family of Handlers: Exception Handler,
Temporary-state Handler, Stream Redirection Handler

A Family of Handlers is Correct if each Handler in the Family is
Correct

Deciding whether a Uniformly Simple Family of Closed Handlers is
$\Sigma_1$-complete (Semidecidable) %FIXME xref

Effect Theories with a Simple Signature corresond to ordinary Finite
Equational Theories (i.e. Finitely many Finitary Function Symbols and
Finitely many Axioms)

For a Simple Signature, Decidable Effect Theory, and a Uniformly
Simple Family of Handlers, Correctness of the Family of Handlers is
Decidable


\textbf{Recursion}

Nondeterminism Operator:
\[
  \Omega : 1 \rightarrowtriangle 0
\]

Fixed-point Constructor $\rec\; x : U \underline{C}.M$, Typed
by:
\[
  \frac{\Gamma,x:U \underline{C} | K \vdash M : \underline{C}}
  {\Gamma | K \vdash \rec\; x : U \underline{C}.M : \underline{C}}
\]

Effect Theories become \emph{Inequations} $\Gamma | Z \vdash T_1 \leq
T_2$

always contains the Inequation:
\[
  \cdot | z:1 \vdash \Omega() \leq z
\]
stating that $\Omega$ is the Least Element

$\omega\cat{Cpo}$ Category of $\omega$-cpos and Continuous Functions
(instead of $\cat{Set}$)

Flat $\omega$-cpo

$U : \cat{Mod}_\thy{T} \rightarrow \omega \cat{Cpo}$

$F : \omega\cat{Cpo} \rightarrow \cat{Mod}_\thy{T}$

both $U$ and $F$ have Continuous Strengths and are Locally Continuous

Carriers of Models are Pointed $\omega$-cpos and Model Homomorphisms
are Strict Continuous Functions (Preserving Least Elements)

\emph{Lifting} $Q_\bot$ is the $\omega$-cpo obtained from $Q$ by
adding a new Least Element %FIXME xref?

Nondeterminism: Convex Powerdomain Monad (???)

Continuously Parameterised Countably Infinitary Inequational Theories:
equivalent to Discrete Countable Lawvere $\omega\cat{Cpo}$-theories

Value Types: Interpreted by $\omega$-cpos

Computation Types: Interpreted by Models whose Carriers are Pointed
$\omega$-cpos

Values, Computations, and Handlers are Interpreted by Continuous Maps
(such Interpretations may not be defined)

Fixed-point Constructor is Interpreted using the Least Fixed-point
Interpretation %FIXME

Correct Handlers cannot redefine $\Omega$ as the Theory of $\Omega$
fixes it Uniquely

Open question: Parallel Computations (Binary Deconstructors)



\cite{pretnar15}:

Occurence of an Effect can been seen as a Branching in the Execution
of a Program (number of Branches equal to the number of possible
outcomes of an Effect)

``Source'' of an Effect is represented by an Operation with Arity
equal to the number of outcomes and Arguments represent Branches


\textbf{Language}

\cite{pretnar15}:

\emph{Values}:
\begin{flalign*}
  \quad v ::=&\; x \; | \; \true \; | \; \false \;
            | \; \lambda x \mapsto c &\\
      \; |&\; \mono{handler}\; \{ \mono{return}\; x
              \mapsto c_r, \mono{op}_1(x;k) \mapsto c_1, \ldots,
              \mono{op}_n(x;k) \mapsto c_n \}&
\end{flalign*}

\emph{Computations}:
\begin{flalign*}
  \quad c ::=&\; \mono{return}\; v \; | \; \mono{op}(v;y.c) \;
            | \; \mono{do}\; x \leftarrow c_1 \;\mono{in}\; c_2 &\\
      \; |&\; \mono{if}\; v \;\mono{then}\; c_1
              \;\mono{else}\; c_2 \;
            | \; v_1 v_2 \; | \; \;\mono{with}\; v
              \;\mono{handle}\; c&
\end{flalign*}

Sequencing:
\[
  \mono{do}\; x \leftarrow c_1 \;\mono{in}\; c_2
\]
first Evaluate $c_1$, Bind result Value to $x$, and proceed as $c_2$;
if $x$ does not appear in $c_2$, then abbreviate to $c1; c2$.

Operation Call:
\[
  \mono{op}(v;y.c)
\]
Parameter Value $v$ (e.g. Memory Location to be Read) passed to
$\mono{op}$, $\mono{op}$ performs Effect, Result Value (e.g.
Contents of Memory Location) is Bound to $y$ and Evaluation of
Continuation $c$ resumes. (Handlers \S\ref{sec:effect_handler}) may
override this behavior).

Generic Effect (\S\ref{sec:generic_effect}):
\[
  \mono{op}\; \defeq \;\mono{fun}\; x \mapsto
    \mono{op}(x; y.\mono{return}\; y)
\]
Parameter Value $x$ passed to Operation with the Trivial Continuation;
specific Operations $\mono{op}(v;y.c)$ can be recovered by
Evaluating:
\[
  \mono{do}\; y \leftarrow \mono{op}\; v \;\mono{in}\; c
\]


\textbf{Denotational Semantics} \cite{pretnar15}

Computations as Trees:

Returned Values (or Bottom $\bot$ for Divergent Computation that does
not call any Operations) are Leaves and Branching Points are
Operations

Operation Calls create a ``Branching Point'' in the Evaluation with as
many Branches as there are possible Results that can be Yielded to the
Continuation. \cite{pretnar15}

A Divergent Computation that repeatedly Calls Operations gives a
Non-well-founded Tree. \cite{pretnar15}


\emph{Denotational Semantics Returning First-order Values and no
  Recursion}:

Value Type $A$: Set $\llbracket A \rrbracket$

Computation Type $\llbracket A!\Delta \rrbracket$: Set of Trees with
Leaves (Values) in $\llbracket A \rrbracket$ and Nodes (Operations) in
$\Delta$

Handlers: Functions between Trees defined by Structural Recursion on
Tree of the Handled Computation and Handling is Interpreted by
Application of such Functions

A \emph{Model} of $\Delta$ is a Set $M$ with Maps:
\[
  \mono{op}_M : \llbracket A \rrbracket
    \times M^{\llbracket B \rrbracket} \rightarrow M
\]
for each Operation $\mono{op} : A \rightarrow B$ in $\Delta$

\emph{Homomorphism} between Models $M$, $N$ is a Map $h : M
\rightarrow N$ such that:
\[
  (h \circ \mono{op}_M)(x,k) = \mono{op}_N(x,h \circ k)
\]

$\llbracket A ! \Delta \rrbracket$ is the \emph{Free Model}
(\S\ref{sec:free_model}) of $\Delta$ over $A$ with Universal Property
(\S\ref{sec:universal_property}):

For any Model $M$ of $\Delta$ and Map $f : \llbracket A \rrbracket
\rightarrow M$ there exists a Unique Homomorphism $h : \llbracket A !
\Delta \rrbracket \rightarrow M$ that agrees with $f$ on Leaves.
\cite{pretnar15}

Operation Clauses define a Model of Operations and the Return Clause
provides a Function $f$ that can be extended to a Homomorphism.
\cite{pretnar15}

\fist With General Recursion and Higher-order Results then
Domains (\S\ref{sec:order_domain}) are used instead of Sets.

Comodel: Set $W$ of possible World States and Map $\mono{op}^W : W
\times \llbracket A \rrbracket \rightarrow W \times \llbracket B
\rrbracket$ for each Operation $\mono{op} : A \rightarrow B$ in
$\Sigma$

when Operation Call $\mono{op}(v; y.c)$ escapes all Handlers, pass
current State $w \in W$ and Parameter $v$ to $\mono{op}^W$ and get
back new State and Result, assigning Result to $y$ and continue
Evaluating $c$. \cite{pretnar15}


\textbf{Operational Semantics} \cite{pretnar15}

Small-step Operational Semantics

Operation Calls do not perform Effects: they behave as ``Signals''
that propagate outwards until they reach a Handler with a matching
Clause. \cite{pretnar15}

An Operation that escapes all Handlers is treated as a Terminating
Computation (no further Reductions). \cite{pretnar15}

``Actual'' Effectful behavior simulated by an Outermost Handler.
\cite{pretnar15}



\subsubsection{Effect Theory}\label{sec:effect_theory}
\cite{plotkin-pretnar09}

$\thy{E}$

Conditional Effect Theory: collection of Conditional Equations:
\[
  \Gamma; \Delta \vdash T_1 = T_2(\varphi)
\]
given that $\Gamma; \Delta \vdash T_1$, $\Gamma; \Delta \vdash T_2$,
and $\Gamma \vdash \varphi : \mathbf{form}$

An Effect Theory $\thy{E}$ gives rise to a standard (possibly
Infinitary) Equational Theory (\S\ref{sec:equational_theory}).
\cite{plotkin-pretnar09}



\subsubsection{Effect Handler}\label{sec:effect_handler}

\cite{orchard-yoshida16}: Processes as Effect Handlers, Session Types
(\S\ref{sec:session_type}) as Effects

Homomorphism from Free Algebras
\cite{bauer-pretnar12}

\cite{plotkin-pretnar13}:

Homomorphisms from the Free Model to a Model on a given Carrier

Model of an Equational Theory: Carrier Set, Set of Handling Maps (one
for each Operation) Satisfying Equations

Computations Interpreted in the Free Model

Handling Constructs Interpreted by Induced Homomorphisms

Operations replaced by Operation Maps

\fist Cf. Exception Handlers (\S\ref{sec:exception_effect}) where
Exceptions are replaced by Handling Computations

\danger\; Note that note all Families of Maps yield a Model of the
Theory, for some Families it is Undecidable given their Definitions
whether they yield a Model or not; if allowing complete freedom in the
Language (all possible Definitions allowed), not all Handlers will
have Interpretations


\asterism


An Algebraic Effect Handler that is Linear in its Continuation gives
rise to the notion of Linear Control-flow Effects
\cite{orchard-yoshida16}. Non-linear Effects such as Exceptions
(Interrupted Control-flow) and Non-determinism (Branching
Control-flow) may be captured via Session-typed
(\S\ref{sec:session_type}) Encodings that explicitly include their
Continuation. \cite{orchard-yoshida16} %FIXME



\cite{plotkin-pretnar09}:

Handling corresponds to Model of the Algebraic Theory
(\S\ref{sec:algebraic_theory}) of the Effects

Handling a Computational Effect: Homomorphically Mapping the Handled
Computation into another Computation

Well-formed-ness, Correctness (redefinition of Operations yields a
Model of the Effect Theory)

\cite{plotkin-pretnar09}:

Type Variables $X$

Value Types $\sigma$

Handler Variables $z$

Value Terms $u$

Quantifier-free Formulas $\varphi$

\emph{Handler Types}:
\begin{flalign*}
  \quad \chi &::= X \; | \; F \sigma \; | \; 1 \;
    | \; \chi_1 \times \chi_2 \; | \; \sigma \rightarrow \chi &
\end{flalign*}

\emph{Handler Terms}:
\begin{flalign*}
  \quad h ::=& \; z(v_1, v_2, \ldots) \;
    | \; \mono{op}_{v_1, v_2, \ldots}
      (X_1:A_1.h_1, X_2:A_2.h_2, \ldots) & \\
    |&\; \mono{if}\; \varphi \;\mono{then}\; h_1
      \;\mono{else}\; h_2 \; | \; \mono{return}\; u \;
    | \; \mono{let}\; x \;\mono{be}\; h \;\mono{in}\; h' & \\
    |&\; \star \;
    | \; \langle h_1, h_2 \rangle \; | \; \mono{fst}\; h \;
    | \; \mono{snd}\; h \; | \; \lambda x:\sigma.h \;
    | \; h u &
\end{flalign*}

Typing Handler Terms:
\begin{itemize}
  \item Context $\Gamma$ of Value Types
  \item Context $Z$ of Handler Variables $z : (\alpha_1, \alpha_2,
    \ldots) \rightarrow \chi$ (written $z:\chi$ if the List of Arity
    Types is Empty), according to rules:
    \begin{enumerate}
      \item $(z:(\alpha_1, \alpha_2, \ldots) \rightarrow \chi \in Z)$
        %FIXME
      \item $(\mono{op}:\beta_1, \ldots, \beta_m; A_1, \ldots, A_n \in
        \Sigma_\mathrm{eff})$
        %FIXME
      \item %FIXME
      \item %FIXME
    \end{enumerate}
\end{itemize}

Handler Signature $\Sigma_\mathrm{hand}$: Set of Handler Symbols $H$

a Handler:
\[
  H : (\sigma_1, \sigma_2, \ldots; \chi_1, \chi_2, \ldots)
    \rightarrow \chi \mathbf{handler} \in \Sigma_\mathrm{hand}
\]

Computation Types

Computation Terms

Typing Computation Terms

Typing Handling Constructs

Uniform Handler, Parametrically Uniform Handler
\cite{plotkin-pretnar09}


\cite{pretnar15}:
\[
  \mono{handler}\; \{ \mono{return}\; x
          \mapsto c_r, \mono{op}_1(x;k) \mapsto c_1, \ldots,
          \mono{op}_n(x;k) \mapsto c_n \}
\]


\asterism


Timeout Handler



\paragraph{Shallow Handler}\label{sec:shallow_handler}\hfill

only Handle the first call of an Operation

more ``elementary'': can be used to simulate Deep Handler through
Recursion \cite{pretnar15}



\paragraph{Deep Handler}\label{sec:deep_handler}\hfill

continue Handling Operations in the Continuation
(\S\ref{sec:continuation})



\paragraph{Simple Handler}\label{sec:simple_handler}\hfill
\cite{plotkin-pretnar13}

Simple Handlers define Handling Computations in terms of Polymorphic
Constructs only.

Examples: Exception Handler, Temporary-state Handler, Stream
Redirection Handler, CCS Renaming and Hiding Handlers, etc.

No Parameter-passing Handlers
(\S\ref{sec:parameter_passing_handler})are Simple

\emph{Uniformly Simple} Family of Handlers



\paragraph{Parameter-passing Handler}\hfill
\label{sec:parameter_passing_handler}
\cite{plotkin-pretnar13}

contains $\lambda$-abstraction in the Handling Terms



\subsubsection{Generic Effect}\label{sec:generic_effect}

\cite{pretnar15}:
\[
  \mono{op}\; \stackrel{\mathrm{def}}{=} \;\mono{fun} x \mapsto
  \;\mono{op}(x; y.\mono{return}\; y)
\]
Parameter $x$ passed to Operation with the Trivial Continuation



\subsubsection{Extensible Effect}\label{sec:extensible_effect}

van Laarhoven Free Monad (\S\ref{sec:vanlaarhoven_free_monad})



% ====================================================================
\section{Coeffect System}\label{sec:coeffect_system}
% ====================================================================

Context-dependent Computation (Petricek, Orchard, Mycroft)

Effect: how a Program \emph{Influences} its Environment

Coeffect: \emph{Requirement} of a Program with respect to its
Environment

(ICFP video):

Types in Contexts paired with a Coeffect:
$x : T_r A \vdash M : B$

$r$ Element of a Coeffect Preordered Semiring (???) %FIXME

Interaction

(Graded case):

$i : \text{Coeffect} \times \text{Effect} \rightarrow \text{Coeffect}$

$k : \text{Coeffect} \times \text{Effect} \rightarrow \text{Effect}$

Zappa-Szep Product (\S\ref{sec:zappa_szep})



% --------------------------------------------------------------------
\subsection{Coeffect}\label{sec:coeffect}
% --------------------------------------------------------------------

Implicit Parameters in a Programming Language like Haskell is a
Coeffect System (Orchard-Petricek14)

$\mono{codo}$ Notation



% ====================================================================
\section{Curry-Howard Correspondence}\label{sec:curry_howard}
% ====================================================================

\emph{Curry-Howard Correspondence}

Type Theory, Proof Theory, Algebra (Preorders: $\leq$ is a Reflexive
and Transitive Relation), Category Theory

Syntactic Category (\S\ref{sec:syntactic_category}) %FIXME

``Computational Trinitarianism''
\\
\begin{tabular}{| l | l | l |}
\hline
\textbf{Logic} & \textbf{Type Theory} & \textbf{Category Theory}\\ \hline \hline
Proposition & $A$ (Type) & $A \in \cat{C}_0$ \\ \hline
Proof & $a : A$ (Term) & $a:U \rightarrow A \in \cat{C}_1$ \\
\hline
\end{tabular}
\\
\cite{harper12}
\\
\begin{tabular}{| p{2cm} | p{3cm} | p{4.5cm} | p{3cm} |}
\hline
& \textbf{Logic} & \textbf{Type} & \textbf{Algebra}\\ \hline \hline
Trivial Proposition
  & \begin{center} $\overline{A \vdash \top}$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $\overline{A \leq \top}$ \end{center} \\ \hline
Bottom
  & \begin{center} $\overline{\bot \vdash A}$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $\overline{\bot \leq A}$ \end{center} \\ \hline
Reflexivity
  & \begin{center} $A \vdash A$ \end{center}
  & \begin{center} $x : A \vdash x : A$ \end{center}
  & \begin{center} $A \leq A$ \end{center} \\ \hline
Negation Elimination
  & \begin{center} $\neg A \vdash A \rightarrow \bot$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $A \wedge \neg A = \bot$ \end{center} \\ \hline
Negation Introduction
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\underline{C \wedge A \leq \bot}$\newline
      $C \leq \overline{A}$
    \end{center} \\ \hline
Elimination Rules
  & \begin{center}
      $\overline{A \wedge B \vdash A}$,\newline\newline
      $\overline{A \wedge B \vdash B}$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\overline{A \wedge B \leq A}$,\newline\newline
      $\overline{A \wedge B \leq B}$
    \end{center} \\ \hline
Introduction Rules
  & \begin{center}
      $\overline{A \vdash A \vee B}$,\newline\newline
      $\overline{B \vdash A \vee B}$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\overline{A \leq A \vee B}$,\newline\newline
      $\overline{B \leq A \vee B}$
    \end{center} \\ \hline
Conjunction
  & \begin{center}
    $\underline{C \vdash A \quad C \vdash B}$\newline
    $C \vdash A \wedge B$
    \end{center}
  & \begin{center}
    $\underline{x:C \vdash m:A \quad x:C \vdash n:B}$\newline
    $x:C \vdash (m,n):A \times B$
    \end{center}
  & \begin{center}
    $\underline{C \leq A \quad C \leq B}$\newline
    $C \leq A \wedge B$
    \end{center} \\ \hline
Disjunction
  & \begin{center}
    $\underline{A \vdash C \quad B \vdash C}$\newline
    $A \vee B \vdash C$
    \end{center}
  & \begin{center}
    ???
    \end{center}
  & \begin{center}
    $\underline{A \leq C \quad B \leq C}$\newline
    $A \vee B \leq C$
    \end{center} \\ \hline
Transitivity
  & \begin{center}
      $\underline{A \vdash B \quad B \vdash C}$\newline
      $A \vdash C$
    \end{center}
  & \begin{center}
    $\underline{x:A \vdash m:B \quad y:B \vdash n:C}$\newline
    $x:A \vdash [m/y]n:C$
    \end{center}
  & \begin{center}
    $\underline{A \leq B \quad B \leq C}$\newline
    $A \leq C$
    \end{center} \\ \hline
\hline
\end{tabular}
\\
\begin{tabular}{| p{2cm} | p{3cm} | p{4.5cm} | p{3cm} |}
\hline
& \textbf{Logic} & \textbf{Type} & \textbf{Algebra}\\ \hline \hline
Implication Elimination
  & \begin{center} $A, (A \rightarrow B) \vdash B$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Implication Introduction
  & \begin{center}
      $\underline{A \wedge C \vdash B}$\newline
      $C \vdash A \rightarrow B$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Weakening
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Contraction
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Exchange
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
\hline
\end{tabular}

Proofs and Propositions form the Object Language; Derivations are used
to infer Judgements about the Object Language


\asterism


$P\type$ -- $P\prop$

$p : P$ -- ``$p$ is a Proof of Proposition $P$''

A Proof of $A \wedge B$ is a Pair of Proofs $p : A$ and $q : B$ (holds
in both Classical and Constructive Systems)

A Proof of $A \vee B$ is a Proof $p : A$ or a Proof $q : B$ with an
indication of which Formula is Proved (differs from Classical Logic)

A Proof of $A \Rightarrow B$ is a Function that Transforms a Proof $p
: A$ into a Proof $q : B$.

No Proof for the Contradictory Proposition $\bot$

$(\exists x : A).P$ where $P$ is a Witness (\S\ref{sec:type_witness})
$w : A$ with a Proof that $P$ holds of $w$, i.e. $[w/x]P$

$(\forall x : A).P$ implies that $[a/x]P$ is Valid for every $a$ in
$A$; a Function mapping any Proof of $A$ to a Proof of $P$.

Introduction Rule for $\forall$:
\[
  {
    \frac{
      \begin{matrix}
        [x : A]\\
        \vdots\\
        p : P
      \end{matrix}
    }{
      (\lambda x : A).p : (\forall x : A).P
    }
  } (\forall I)
\]

Computation Rule for $\forall$:
\[
  ((\lambda x : A).p) \rightarrow [a/x]p
\]

Introduction Rule for $\exists$:
\[
  {
    \frac{
      a : A \quad\quad p : [a/x]P
    }{
      (a,p) : (\exists x : A).P
    }
  } (\exists I)
\]

Computation Rules for $\exists$:
\[
  fst (p,q) \rightarrow p
\]\[
  snd (p,q) \rightarrow q
\]

The Formation Rule for Equality Types (\S\ref{sec:equality_type})
requires other Judgements (Type Assumptions) in addition to
Well-typing Judgements:
\[
  {
    \frac{ A \mathsf{ Type} \quad\quad a : A \quad\quad b:A }
    { I (A,a,b) \mathsf{ Type}}
  } (I F)
\]

Introduction Rule for $I$:
\[
  {
    \frac{ a : A }
    { r(a) : I(A,a,a)}
  } (II)
\]

Elimination Rule for $I$:
\[
  {
    \frac{ c : I (A, a, b) \quad\quad d : C(a,a,r(a)) }
    { J(c,d) : C(a,b,c) }
  } (I E)
\]

Computation Rule for $I$:
\[
  J (r(a), d) \rightarrow d
\]

Leibniz Law


\asterism


Formation Rules : Defines what the Types of the System are (Syntax)

Introduction \& Elimination Rules : Define which Terms are Members of
which Types; Typing Rules (\S\ref{sec:typing_rule})

Computation Rules : How Objects can be Reduced, i.e. Evaluated
(Computation)

Natural Deduction -- Typed $\lambda$-calculus
(\S\ref{sec:typed_lambda})

(Zeroth-order) Minimal Logic -- Simple Types (Simply-typed
$\lambda$-calculus \S\ref{sec:simply_typed})

(First-order) Predicate Logic -- Dependent Types (Dependent Type
Theory \S\ref{sec:dependent_type_theory})

Classical/Intuitionistic Embedding -- Continuation-passing Style
(\S\ref{sec:continuation})

Modal Logic -- Monads (\S\ref{sec:monad})

Linear Logic -- Session Types (\S\ref{sec:session_type})

Linear Temporal Logic -- Reactive Types (\S\ref{sec:reactive_type})

Subset Type $(\exists x:A).B$ (Pairs of Objects and the Proofs that
they have Property): $\{ x : A | B \}$ consisting of those $a$ in $A$
with Property $[a/x]B$, i.e. $[a/x]B$ is Inhabited.



% ====================================================================
\section{Lambda Cube}\label{sec:lambda_cube}
% ====================================================================

All Strongly Normalizing

$\lambda\kern-5pt\rightarrow$: Simply-typed $\lambda$-calculus
(\S\ref{sec:simply_typed}); Terms depending on Terms (Function Type
\S\ref{sec:function_type})--Types can appear on both sides of the
Function Constructor $\rightarrow$:
\[
  f:A \rightarrow B
\]
or:
\[
  f:(\Pi a:A)B
\]

$\lambda2$: Polymorphic (Second-order) $\lambda$-calculus
(\S\ref{sec:secondorder_lambda}, System F (\S\ref{sec:system_f});
Terms depending on Types (Polymorphism
\S\ref{sec:polymorphic_type})--Kinds appear to the left of Types as
Parameters mapping to instances of Polymorphic Functions (Terms):
\[
  f:(\Pi A:\Type) C
\]
where:
\[
  f_A : C
\]
is the Instance of $f$ for Type $A$.

$\lambda\underline{\omega}$: Higher-order $\lambda$-calculus
(\S\ref{sec:higherorder_lambda}); Types depending on Types (Type
Operators \S\ref{sec:type_operator})--Kinds (\S\ref{sec:kind}) can
appear on both sides of the Type-level Function Constructor
$\Rightarrow$:
\[
   F:\Type \Rightarrow \Type
\]
or:
\[
  F:(\Pi A:\Type) \Type
\]

$\lambda\Pi$: Dependently-typed $\lambda$-calculus
(\S\ref{sec:dependent_lambda}); Types depending on Terms (Dependent
Types \S\ref{sec:dependent_type})--Kinds can appear to the right of
Types in Dependent Types $a:A \vdash B(a)$:
\[
  B : A \rightarrow \Type
\]
or equivalently a Polymorphic Function:
\[
  B : (\Pi X:\Type) X \rightarrow A
\]
or:
\[
  B : (\Pi X:\Type) (\Pi x:X) A
\]
allowing the definition of Dependent Product Types
(\S\ref{sec:pi_type}) and Dependent Sum Types
(\S\ref{sec:sigma_type}):
\[
  f : (\Pi a:A) B(a) \quad\quad (a,b) : (\Sigma a:A) B(a)
\]
where $a:A$, $b:B(a)$, $(f x):B(a)$

\[
  f : (\Pi a:A) (\Pi X:\Type) (\Pi x:X) A
\]

$\lambda\omega$ -- System F$_\omega$ (\S\ref{sec:system_fomega}): $\lambda2$

\fist The Systems in the $\lambda$ Cube are limited to Sorts
$\{\star,\square\}$, i.e. Kinds and the Kind of Kinds; Pure Type
Systems (\S\ref{sec:pts}) for Multi-sorted Type Systems %FIXME



% ====================================================================
\section{Typed $\lambda$-Calculus}\label{sec:typed_lambda}
% ====================================================================

\emph{Typed $\lambda$-Calculus} allows for Lambda Terms to be assigned
Types (\S\ref{sec:type}).

Simply-typed $\lambda$-calculus (\S\ref{sec:simply_typed}) has only
one Type Constructor (\S\ref{sec:type_constructor}), $\rightarrow$
(see Function Type \S\ref{sec:function_type}).

Untyped $\lambda$-calculus (\S\ref{sec:untyped_lambda}) may be
considered a Typed $\lambda$-calculus with only one Type.

Extension to Untyped $\lambda$-calculus may be achieved by
considering Recursive Types with Recursion in Negative Positions;
Untyped $\lambda$-calculus can be Modelled by a Solution to the
Recursion Equation $X \simeq X \rightarrow X$. \cite{wadler12}

A Denotational Semantics can be given by a \emph{B\"ohm Tree}
(\S\ref{sec:bohm_tree}).

$\lambda$-cube (\S\ref{sec:lambda_cube}):
\begin{itemize}
  \item $\lambda\kern-5pt\rightarrow$ -- Simply-typed
    $\lambda$-calculus (\S\ref{sec:simply_typed}); Function Types
    (\S\ref{sec:function_type})
  \item $\lambda2$ -- Second-order $\lambda$-calculus
    (\S\ref{sec:secondorder_lambda}); Polymorphic Types
    (\S\ref{sec:polymorphic_type})
  \item $\lambda\underline{\omega}$ -- Higher-order $\lambda$-calculus
    (\S\ref{sec:higherorder_lambda}); Type Operators
    (\S\ref{sec:type_operator})
  \item $\lambda\Pi$ -- Dependently-typed $\lambda$-calculus
    (\S\ref{sec:dependent_lambda}); Dependent Types
    (\S\ref{sec:dependent_type})
\end{itemize}

Linear $\lambda$-calculus (\S\ref{sec:linear_lambda})



% --------------------------------------------------------------------
\subsection{$\kappa$-calculus}\label{sec:kappa_calculus}
% --------------------------------------------------------------------

First-order fragment of Typed $\lambda$-calculus



% --------------------------------------------------------------------
\subsection{Simply-typed $\lambda$-calculus}\label{sec:simply_typed}
% --------------------------------------------------------------------

\emph{Simply-typed $\lambda$-calculus} ($\lambda^\rightarrow$) is a
Typed Interpretation of $\lambda$-calculus with one Type Constructor
(\S\ref{sec:type_constructor}) for Function Types
(\S\ref{sec:function_type}): $\rightarrow$

Strongly Normalizing, not Turing Complete: addition of $fix_\alpha$
Operator or Recursive Types (\S\ref{sec:inductive_type}) gives
Turing Completeness

``Simply-typed'' is to distinguish from $\lambda$-cube
(\S\ref{sec:lambda_cube}) Extensions and other variations such as:
\begin{itemize}
  \item Polymorphic Types (\S\ref{sec:polymorphic_type}): Second-order
    $\lambda$-calculus ($\lambda2$ \S\ref{sec:secondorder_lambda})
  \item Type Operators (\S\ref{sec:type_operator}):
    ($\lambda\underline{\omega}$ \S\ref{sec:higherorder_lambda})
  \item Dependent Types (\S\ref{sec:dependent_type}):
    Dependently-typed $\lambda$-calculus ($\lambda\Pi$
    \S\ref{sec:dependent_lambda})
  \item Conjunctive Types (\S\ref{sec:conjunctive_type}):
    $\lambda$-calculus with Conjunctive Types
    (\S\ref{sec:conjunctive_lambda})
  \item Linear Types (\S\ref{sec:linear_type}): Linear
    $\lambda$-calculus (\S\ref{sec:linear_lambda})
\end{itemize}
because Polymorphism and Dependency cannot be encoding using only
$\rightarrow$ and Type Variables (\S\ref{sec:type_variable}). Adding
Record Types (\S\ref{sec:product_type}) to Simply-typed
$\lambda$-calculus allows for Subtyping
(\S\ref{sec:subtype_polymorphism}), and the resulting System
(\S\ref{sec:conjunctive_lambda}) is no longer ``Simply-typed'' because
it allows for Terms to have more than one Type.

Dominic Orchard (youtube) -- Simple Types: ``What'', Effect Systems
(\S\ref{sec:effect_system}): ``How'', Session Types
(\S\ref{sec:session_type}): ``What \& How''

\fist An Embedding of Simply-typed $\lambda$-calculus into
Session-typed $\pi$-calculus (\S\ref{sec:sessiontyped_pi}) is given in
Toninho-Caires-Pfenning12 \cite{caires-pfenning-toninho12}; for the
analogous Embedding of Untyped $\lambda$-calculus
(\S\ref{sec:untyped_lambda}) into $\pi$-calculus see Milner92
\cite{milner92}

The following extensions are still considered ``Simply-typed''
systems:
\begin{itemize}
  \item System T (\S\ref{sec:system_t}): Products, Coproducts, Natural
    Numbers
  \item PCF (\S\ref{sec:pcf}): Full Recursion
\end{itemize}

Simply-typed $\lambda$-calculus has the same Equational Theory of
$\beta\eta$-equivalence (\S\ref{sec:beta_reduction},
\S\ref{sec:eta_conversion}) as Untyped $\lambda$-calculus, subject to
Type restrictions.

$\beta$-reduction:
\[
  (\lambda x:s.t)u =_\beta t[x := u]
\]
holds in Context $\Gamma$ when $\Gamma$, $x:\sigma \rightarrow t:\tau$
and $\Gamma \vdash u:\sigma$.

$\eta$-reduction:
\[
  \lambda x:\sigma .t x =_\eta t
\]
holds when $\Gamma \vdash t : \sigma \rightarrow \tau$ and $x$ is not
Free in $t$.

With the Function Type Constructor $\rightarrow$ and the Base Types
$B$, the Types of a Simply-typed $\lambda$-calculus are defined (with
BNF Notation):
\[
  \tau ::= \tau \rightarrow \tau \;|\; T \in B
\]

\emph{Term Constant}

That is, Expressions of Simply-typed $\lambda$-calculus are defined
as:
\[
  e ::= x \;|\; \lambda x:t.e \;|\; e e \;|\; c
\]
where $x$ is a Variable and $\tau$ is a Type, and $c$ is a Term
Constant. These Expressions are, in order:
\begin{itemize}
  \item Variable Reference
  \item Abstraction
  \item Application
  \item Constant
\end{itemize}

Abstraction corresponds to Existential Quantification in Second-order
Logic (\S\ref{sec:secondorder_logic}).



\textbf{Intrinsic Interpretation}: \emph{Church-style}

* Only Well-typed Terms have Meaning (Meaning assigned to Typing
Derivations), therefore equivalent Terms having different Annotations
may have different Meanings, cf. Reification
(\S\ref{sec:reification}):



\textbf{Extrinsic Interpretation}: \emph{Curry-style}

* Terms Interpreted as in an Untyped Language, cf. Type Erasure
(\S\ref{sec:type_erasure})



\subsubsection{Simply-typed $\lambda$-calculus Typing Rules}
\label{sec:simplytyped_rules}

Typing Rules (\S\ref{sec:typing_rule}):
\begin{enumerate}
\item
  \[
    {
      \frac
      {x : \tau \in \Gamma}
      {\Gamma \vdash x : \tau}
    }
  \]
\item
  \[
    {
      \frac
      {c \;\text{is a constant of Base Type}\; T}
      {\Gamma \vdash c:T}
    }
  \]
\item
  \[
    {
      \frac
      {\Gamma, x:\sigma \vdash e:\tau}
      {\Gamma \vdash (\lambda x:\sigma.e):(\sigma \rightarrow \tau)}
    }
  \]
\item
  \[
    {
      \frac
      {\Gamma \vdash e_1:\sigma \rightarrow \tau \quad
        \Gamma \vdash e_2:\sigma}
      {\Gamma \vdash e_1 e_2 : \tau}
    }
  \]
\end{enumerate}



\textbf{Operational Semantics}

\textbf{Categorical Semantics}

Simply-typed $\lambda$-calculus is the Internal Language
(\S\ref{sec:internal_logic}) of the Cartesian Closed Categories
(\S\ref{sec:cartesian_closed}).



\textbf{Proof-theoretic Semantics}

Simply-typed $\lambda$-calculus is Isomorphic by Curry-Howard
(\S\ref{sec:curry_howard}) to Minimal Logic
(\S\ref{sec:minimal_logic}):
\begin{itemize}
  \item Terms correspond to Proofs in Natural Deduction
    (\S\ref{sec:natural_deduction})
  \item (Inhabited) Types correspond to Tautologies in Minimal Logic
\end{itemize}



Minimal Logic $\leftrightarrow$ Simply-typed $\lambda$-calculus:
\[
  \supset \leftrightarrow \rightarrow
\] \[
  \wedge \leftrightarrow \times
\] \[
  \vee \leftrightarrow +
\] \[
  False \leftrightarrow \bot
\]



\emph{Type Assignment}:
\[
  \frac{
    f:A \rightarrow B \quad x:A
  }{
    f x : B
  }(\rightarrow e)
\]\[
  \frac{
    x:A \quad y:B
  }{
    \lambda x.y : A \rightarrow B
  }(\rightarrow i)
\]



\subsubsection{System T}\label{sec:system_t}

G\"odel

Proof Interpretation of Heyting Arithmetic into a Finite-type
Extension of Primitive Recursive Arithmetic
(\S\ref{sec:primitive_recursive})

All Recursive Functions in Peano Arithmetic are definable



\subsubsection{PCF}\label{sec:pcf}

\emph{Programming Computable Functions} (\emph{PCF}) is an extended
version of Simply-typed Lambda Calculus with Natural Numbers,
Conditionals, and Recursion.

Geometry of Interaction (\S\ref{sec:interaction_geometry})

Denotational Semantics (\S\ref{sec:denotational_semantics}):
\emph{Scott Model} (???)

Scott-continuous Function (\S\ref{sec:scott_continuity})



\paragraph{FPCF}\label{sec:fpcf}\hfill

Orchard-Yoshida16 \cite{orchard-yoshida16}

\emph{Effectful PCF} (\emph{FPCF})

Call-by-value PCF with an Effect System (\S\ref{sec:effect_system})

\fist Type-and-Effect System following Nielson-Nielson99
\cite{nielson-nielson99}; distinguishes Sequential Control Flow from
Branching Control Flow (Alternation)

\fist \cite{orchard-yoshida16} presents an Embedding of FPCF into a
Session Calculus (\S\ref{sec:session_calculus}) and a reverse
Embedding of Session Calculus into FPCF.

\fist Cf. GV (\S\ref{sec:good_variation}) a Linear Functional Language
with Session Types \cite{wadler12} -- FPCF is not fundamentally
Linear, but Linearity for Sessions is implemented via an Effect
Algebra and Typing.

\textbf{Syntax}

\begin{align*}
  V &::= x \mid \lambda x.M \mid \rec(\lambda f.\lambda x.M)
    \mid C_V \\
  M,N &::= V \mid M N \mid \case\; M \;\of\; 0 \mapsto N,
    (\suc\; x) \mapsto N' \mid C
\end{align*}

$V$ -- Values

$M,N$ -- Computations

$x$ -- Variables

$C$ -- Constants: can be Instantiated to give application-specific
(possibly Effectful) Operations %FIXME instantiated

$C_V$ -- Value Constants--Subset $C_V \subset C$, including
``Pure Constructors'': %FIXME clarify pure constructors
\begin{itemize}
  \item $0$ -- Zero
  \item $\suc$ -- Successor
  \item $\unit$ -- Unit
\end{itemize}

$\case$ -- Pattern Matches on Natural Number Constructors


\textbf{Effect Algebra}

$\class{F}$ -- Set of Effects $F,G,H \in \class{F}$

$\sqsubseteq$ -- Partial Order (\S\ref{sec:partial_order}) with
Structure:
\begin{itemize}
  \item $(\class{F},\bullet,I)$ -- Monoid (\S\ref{sec:monoid}) where
    $\bullet$ corresponds to Sequential Composition and $I$ is the
    Trivial Effect for Pure Computation
  \item $(\class{F},\oplus)$ -- Commutative Semigroup
    (\S\ref{sec:commutative_semigroup}) where $\oplus$ corresponds to
    Branching with Distributivity $(F \oplus G) \bullet H = (F \bullet
    H) \oplus (G \bullet H)$
  \item $(\class{F},-^*)$ -- Closure Operation for Effect Fixed-points
    with Axioms $F^* = 1 \oplus (F^* \bullet F) = 1 \oplus (F \bullet
    F^*)$
\end{itemize}
For some Systems, $\oplus$ is the Least Upper-bound with respect to
$\sqsubseteq$. %FIXME


\textbf{Types and Effects}

Type Syntax:
\[
  \sigma,\tau ::= \sigma \xrightarrow{F} \tau \mid \Nat \mid \Unit
\]
where $F$ is the Effect Annotation for the \emph{Latent Effect} of a
Function. %FIXME latent effect

$\Gamma \vdash M:\tau,F$ -- Judgement: Term $M$ has Type $\tau$ in the
Context $\Gamma$ of Free-variable Typing Assumptions and performs
Effect $F$

Typing Rules:
\[
  \frac{}{\varnothing \vdash C : C_\tau,C_F} \mathrm{Const}
\]\[
  \frac{}{\Gamma \vdash x:\tau,I} \mathrm{Var}
\]\[
  \frac{\Gamma, x:\sigma \vdash M:\tau,F}
  {\Gamma \vdash \lambda x.M:\sigma \xrightarrow{F} \tau,I}
  \mathrm{Abs}
\]\[
  \frac{\Gamma \vdash M:\sigma \xrightarrow{H} \tau,F
    \quad\quad\quad \Gamma \vdash N:\sigma,G}
  {\Gamma \vdash M N:\tau, F \bullet G \bullet H}
  \mathrm{App}
\]\[
  \frac{\Gamma \vdash M:\Nat,F \quad\quad
    \Gamma \vdash N_1:\tau,G \quad\quad
    \Gamma,x:\Nat \vdash N_2:\tau,H}
  {\Gamma \vdash \case\; M \;\of\; 0 \mapsto N_1,
    (\suc\;x) \mapsto N_2:\tau, F \bullet(G \oplus H)}
  \mathrm{Case}
\]\[
  \frac{\Gamma \vdash M:\tau,F \quad\quad\quad F \sqsubseteq G}
  {\Gamma \vdash M:\tau,G} \mathrm{Sub}
\]\[
  \frac{\Gamma, f:\tau \xrightarrow{F} \tau, x:\tau \vdash M:\tau,F}
  {\Gamma \vdash
    \rec(\lambda f.\lambda x.M):\tau \xrightarrow{F} \tau,I}
  \mathrm{Rec}
\]

$\lett$-binding (``Syntactic sugar''):
\[
  \lett\; x = M \;\inn\; N := (\lambda x.N) M
\]
with Let Rule Typing:
\[
  \frac{\Gamma \vdash M:\sigma,F \quad\quad\quad
    \Gamma,x:\sigma \vdash N:\tau,G}
  {\Gamma \vdash \lett\; x = M \;\inn\; N:\tau, F \bullet G}
  \mathrm{Let}
\]

$\beta\eta$-equality, $\equiv$:
\[
\begin{aligned}[r c r l]
  (\beta) & \quad & (\lambda x.M) V
    & \equiv M[V/x] \\
  (\rec\beta) & \quad & \rec(\lambda f.\lambda x.M)
    & \equiv \lambda x.M[\rec(\lambda f.\lambda x.M)/f] \\
  (\case\beta1) & \quad & (\case\; 0 \;\of\; 0 \mapsto M,
    (\suc\; x) \mapsto N) & \equiv M \\
  (\case\beta2) & \quad & (\case\; (\suc\; V) \;\of\; 0 \mapsto M,
    (\suc\; x) \mapsto N) & \equiv N[V/x] \\
\end{aligned}
\]

additional $\lett$ Equations:
\[
\begin{aligned}[r c r l]
  (\lett\text{-id}) & \quad & (\lett\; x = M \;\inn\; x)
    & \equiv M \\
  (\lett\text{-assoc}) & \quad & \lett\; y =
      (\lett\; x = M \;\inn\; N) \;\inn\; N'
    & \equiv \lett\; x = M \;\in\; (\lett\; y = N \;\inn\; N')
      \quad (\text{if}\; x \notin fv(N'))\\
\end{aligned}
\]


$\eta$-equality is Type-dependent and holds only when $M$ is Pure,
i.e.:
\[
  \Gamma \vdash M \equiv (\lambda x.M x):\sigma \xrightarrow{F} \tau,I
\]


\textbf{Operational Semantics}

Paramtereized Operational Semantics

$\rightarrow$ -- Reduction Relation between Effect-specific
Configurations $\mathbb{C}$

$\mathcal{C},\mathcal{D} : M \rightarrow \mathbb{C}$ -- Maps from
Terms to Configurations

($\beta$-equality as Pure Reductions) %FIXME

Subject Reduction:
\[
  \varnothing \vdash M:\tau,F \wedge \mathcal{C}[M]
    \rightarrow \mathcal{D}[N]
  \Rightarrow \varnothing \vdash N:\tau,G \wedge G \sqsubseteq F
\]


\textbf{Parallel Composition}

Extending the Effect Algebra of FPCF with Semigroup $(F,\diamond)$ for
Parallel Computation where $I$ (Purity) is the Unit of $\diamond$ with
Typing:
\[
  \frac{\Gamma \vdash M:\Unit,F \quad\quad\quad \Gamma \vdash N:\Unit,G}
  {\Gamma \vdash M\|N:\Unit,F \diamond G}
\]
and Equality:
\[
  M\|\Unit \equiv M \quad\quad M\|N \equiv N\|M
    \quad\quad M\|(N\|P) \equiv (M\|N)\|P
\]

completed Parallel Composition Reduces by: $\unit\|\unit
\rightarrow \unit$


\textbf{Linear Control-flow Effects}

Linearity of Control Flow: equivalent to Algebraic Effect Handler
(\S\ref{sec:effect_handler}) that is Linear in its Continuation;
Non-linear Effects such as Exceptions (Interrupted Control-flow) and
Non-determinism (Branching Control-flow) may be captured via
Session-typed (\S\ref{sec:session_type}) Encodings that explicitly
include their Continuation. %FiXME


\asterism


\textbf{Session Calculus Embedding}

Session Calculus (\S\ref{sec:session_calculus}) Embedded into FPCF
with a notion of \emph{Session Effect} (\S\ref{sec:session_effect}):
Session Types and \emph{Causal} (Non-commutative) Effects have the
same structure--both give an Ordered Analysis of the Operational
Behavior of a Program.

Effect System for Sessions is Partial: some Operations may not be
defined for all Arguments, Modelling the Program-logic Behavior of
Session Types.

Prefixing style of Session Types is replaced by Monoidal Style of
Effect Systems \newline
\fist Cf. Difference List (Prefixing) vs. normal
Concatenation of Lists. %FIXME

Branching/Selection via Alternation $\oplus$

Replication via Recursion and $-^*$


\textbf{Types}

\begin{flalign*}
  \quad\quad \tau & ::= \Nat \mid \Unit \mid [S] &
\end{flalign*}


\emph{Effect Session Types} (variant of Session Types):
\begin{flalign*}
  \quad\quad S,T & ::= ![\tau].S \mid ?[\tau].S \mid *![\tau].S \mid \End
    \mid S + S \mid \mu\alpha.S \mid \alpha \mid \tilde{\odot}S &
\end{flalign*}

$+$ -- Alternation Operator: replaces Select $\oplus$ and Branch $\&$

$\tilde{\odot}S$ -- Intermediate representation for the Session Type
of Channels being Composed via $\odot$ (Balanced Composition)

assuming Equirecursive Equations on $S$, e.g. $\mu\alpha.S =
S[\mu\alpha.S/\alpha]$


\textbf{Session Effects} (\S\ref{sec:session_effect})

$\mathbf{c,d,e,\overline{c},\overline{d},\overline{e}}
\in \class{C}$ -- Channel Values (and Dual Endpoints)

Channel Values belong to Singleton Types corresponding to the Channel
Name:
\[
  \mathbf{c} : Ch\;c
\]
provides ``simple Value Dependency''. %FIXME

$\class{F} = (\class{C} \rightarrow S) \cup \{\bot\}$ -- Maps from
Channel Names $\class{C}$ to Effect Session Types with Algebra:
\begin{itemize}
  \item $(\class{F},\bullet,\varnothing)$ -- $I = \varnothing$ is the
    Empty Mapping, $\bullet$ is Point-wise Sequential Composition of
    Effect Session Types (via $\blacklozenge$ Partial Sequential
    Operator for Session Types) where:
    \[
      \forall c:S \in F \wedge c:T \in G
        \Rightarrow c:S \blacklozenge T \in (F \bullet G)
    \]
    with additional Equations for Balancing Composition triggered by
    $\tilde{\odot}$ Types %FIXME
  \item $\oplus$:
    \[
      \Delta_1 \oplus \Delta_2 =
      \begin{cases}
        \Delta_1 \cup \Delta_2 & \;\text{if}\;
          \forall c:S \in \Delta_i
          \Rightarrow c:S \in \Delta_j \vee c \notin dom(\Delta_j) \\
        \bot & \;\text{otherwise} \\
      \end{cases}
    \]
  \item $\sqsubseteq$ -- Preorder (\S\ref{sec:preorder}) where
    $\forall\Delta,c$ and $c \notin dom(\Delta)$:
    \[\begin{aligned}
        \Delta &\sqsubseteq (\Delta,c:\End) \\
        \Delta &\sqsubseteq (\Delta,c:*![S]) \\
      \end{aligned}
      \quad\quad
      \begin{aligned}
        (\Delta,c:S) &\sqsubseteq (\Delta,c:S + T) \\
        (\Delta,c:S) &\sqsubseteq (\Delta,c:T + S) \\
    \end{aligned}\]
  \item $\diamond = \odot$ -- for Parallel Effects takes the Union of
    two Mappings if they are Balanced in their Channels, otherwise
    $\bot$ %FIXME
  \item $F^*$:
    \[
      \forall c:S \in F
        \Rightarrow c:\mu\alpha.(\End + S \blacklozenge \alpha) \in F^*
    \]
\end{itemize}

\fist $\oplus$ is not the Least Upper-bound with respect to
Subeffecting $\sqsubseteq$: defining Subeffecting as Subset Inclusion
instead of the above definition is Unsound as arbitrary Session Types
could be introduced without a corresponding implementation.


\textbf{Send, Receive, Restriction}

Operations for Sending/Receiving Values and Channels, and Restricting
Channels are added to Constants $C$ of FPCF:
\begin{align*}
  send_{c,\tau} &:
    Ch\;c \rightarrow \tau \xrightarrow{\{c:![\tau]\}} \Unit \\
  rsend_{c,d,s} &:
    Ch\;c \rightarrow
      Ch\;d \xrightarrow{\{c:*![s],d:\tilde{\odot}s\}} \Unit \\
  chSend_{c,d,s} &:
    Ch\;c \rightarrow
      Ch\;d \xrightarrow{\{c:![s],d:\tilde{\odot}s\}} \Unit \\
  recv_{c,\tau} &: Ch\;c \xrightarrow{\{c:?[\tau]\}} \tau \\
  chRecv_{c,d,s,F,\tau} &:
    Ch\;c \xrightarrow{\{c:?[s]\}}
      (Ch\;d \xrightarrow{F \bullet \{d:s\}} \tau)
    \xrightarrow{F} \tau \\
  new_{c,s,F,\tau} &:
    (Ch\;c \rightarrow Ch\;\overline{c}
      \xrightarrow{F \bullet \{c:s,\overline{c}:\overline{s}\}} \tau)
    \xrightarrow{F} \tau
\end{align*}
Each is a Family of Operations Indexed by the Types shown as Subscripts
and has Latent Effects which give the Session Environment Induced by
the Operation.

$send_{c,\tau}$, $recv_{c,\tau}$ -- correspond to Session Send/Receive
Prefixes with Effect Types describing the single Action on their
Channel

$chSend_{c,d,s}$ -- second Channel Parameter $d$ is Sent over $c$
where $d$ must be Balanced with the rest of the Environment when
Composing (due to the $\tilde{\odot}$ Operator)

$rsend_{c,d,s}$ -- identical to $chSend$ but with the
$*!$ Session Type

$chRecv_{c,d,s,F,\tau}$ -- Higher-order Operation taking a Channel $c$
over which a Session Type $s$ is Received and passed to the Parameter
Function which Maps a Channel $d$ to a Value $\tau$ with the Effect $F
\bullet \{d:s\}$ and from this a Computation is Returned with $F$
Channels where $d,c \notin F$; important for the Typability of
Replicated Input

$new_{c,s,F,\tau}$ -- Higher-order Operation where the resulting
Effect is the Effect of the Paramter Function but with the Session
Types $c:s$, $\overline{c}:\overline{s}$ deleted from the Environment
(they are in Scope only for the Parameter Function) %FIXME clarify


\textbf{Operational Semantics}

$\langle M,s \rangle$ -- Configuration

$M$ -- Term

$s$ -- Store, Mapping Channel Endpoint Names $\class{C}$ to
(Unbounded) Queues of Values

$enq$, $deq$ %FIXME


allows Asynchronous Communication

Stable Reduction Relation, Synchronous Subset

Extension of $\equiv$ with $\eta$-expansion for $new$ over Pure Values
%FIXME


\textbf{Encoding Types}

For $\Gamma;\Delta \vdash P$:
\[
  \exists M.\llbracket \Gamma;\Delta \vdash P \rrbracket
    = \llbracket \Gamma \rrbracket \vdash M:\Unit,
      \llbracket \Delta \rrbracket
\]

Value Contexts are Encoded $\llbracket\Gamma\rrbracket$ with $\Unit$
and $\Nat$ Mapped to their corresponding FPCF Value Types.

Session Environments are Mapped to Effects $\class{F}$ by:
\[
  \llbracket\Delta\rrbracket
    = \llbracket c_1:S_1, \ldots, c_n:S_n \rrbracket
    = c:\llbracket S_1 \rrbracket, \ldots, c_n:\llbracket S_n \rrbracket
\]
and the following Interpretation Mapping Session Types to Effect
Session Annotations:
\[
  \begin{aligned}
    \llbracket ![\tau].S \rrbracket
      &= !\llbracket\tau\rrbracket.\llbracket S \rrbracket \\
    \llbracket ?[\tau].S \rrbracket
      &= ?\llbracket\tau\rrbracket.\llbracket S \rrbracket \\
    \llbracket\End\rrbracket &= \End
  \end{aligned}
  \quad\quad
  \begin{aligned}
    \llbracket *![\tau].S \rrbracket
      &= *!\llbracket\tau\rrbracket.\llbracket S \rrbracket \\
    \llbracket *?[\tau] \rrbracket
      &= \mu\alpha.?\llbracket\tau\rrbracket.\alpha \\
    \llbracket \mu\alpha.S \rrbracket
      &= \mu\alpha.\llbracket S \rrbracket
  \end{aligned}
\]
\begin{align*}
  \llbracket \oplus[l_1:S,l_2:T] \rrbracket
    &= ![\Nat].(\llbracket S \rrbracket + \llbracket T \rrbracket) \\
  \llbracket \&[l_1:S,l_2:T] \rrbracket
    &= ?[\Nat].(\llbracket S \rrbracket + \llbracket T \rrbracket)
\end{align*}

\fist Natural Numbers are used in the Encoding to administer
Control-flow for Branching and Selection: for Selection Type $\oplus$
corresponds to Sending a $\Nat$ to Select a Branch prior to
Alternation, and for $\&$ corresponds to Receiving a $\Nat$ then
Alternating.


\textbf{Encoding Processes}

$\llbracket\Gamma;\Delta \vdash P\rrbracket$ -- Encoding of Typed
Processes by Induction over Data Derivations

\fist Types are included only when the Encoding has a
(Non-syntactically Implied) Type-dependence; types are elided when the
Syntax has a single corresponding Typing Rule

Encoding of Linear Send and Receive into FPCF:
\begin{align*}
  \llbracket{c!\langle{V}\rangle.P}\rrbracket
    & = send\;c \llbracket{V}\rrbracket ; \llbracket{P}\rrbracket \\
  \llbracket{c?(x).P}\rrbracket
    & = \lett\; x = recv\;c \;\inn\; \llbracket{P}\rrbracket \\
  \llbracket{c?(d).P}\rrbracket
    & = \lett\; k = chRecv\; c \;\inn\;
      k\;(\lambda d.\llbracket{P}\rrbracket) \\
  \llbracket{\Delta \vdash c!\langle{d}\rangle.P}\rrbracket
    & = chSend\;c\;d ; \llbracket{P}\rrbracket
      \quad\quad (\text{if}\;c : ![S].T \in \Delta)
\end{align*}
where $M ; N$ is used for $\lett\;x = M \;\inn\; N$ when the Bound
Variable $x$ is Free in $N$ (i.e. unused, wildcard).

Encoding of Output and Replicated Output:
\begin{align*}
  \llbracket{\Delta \vdash c!\langle{d}\rangle.P}\rrbracket
    & = rsend\;c\;d ; \llbracket{P}\rrbracket \quad\quad
      (\text{if}\;c : *![S].T \in \Delta) \\
  \llbracket{*c?(d).P}\rrbracket
    & = \rec\;(\lambda f.\lambda x.\lett\;k = chRecv\;c \;\inn\;
      (k\;(\lambda d.\llbracket{P}\rrbracket)) \| f\;\unit)\;\unit
\end{align*}

\fist Note that the Syntax $c!\langle{d}\rangle.P$ uses $chSend$ when
$c$ is a Linear Send in $\Delta$, and $rsend$ if $c$ is Replicated
Output in $\Delta$.

$rsend\;c\;d ; \llbracket{P}\rrbracket$ -- Output: $rsend$ Send $d$
before Continuing with $\llbracket{P}\rrbracket$

$\rec\;(\lambda f.\lambda x.\lett\;k = chRecv\;c \;\inn\; (k\;(\lambda
d.\llbracket{P}\rrbracket)) \| f\;\unit)\;\unit$ -- Replicated Input:
repeatedly Receives a Channel on $c$ which is Bound as $d$ in the
Scope of $\llbracket{P}\rrbracket$ in Parallel (via Continuation $k$)
with the Recursive Call.

Restricted, Parallel, and Empty Proceses:
\begin{align*}
  \llbracket{P|Q}\rrbracket
    & = \llbracket{P}\rrbracket \| \llbracket{Q}\rrbracket \\
  \llbracket{\nu c.P}\rrbracket
    & = new\;(\lambda c.\lambda \overline{c}.\llbracket{P}\rrbracket) \\
  \llbracket{0}\rrbracket & = \unit
\end{align*}

Branching, Selection, Conditionals:
\[
\begin{split}
  \llbracket{c \lhd l_1.P}\rrbracket
    = send\;c\;0; \llbracket{P}\rrbracket
  \quad\quad\quad
  \llbracket{c \lhd l_2.P}\rrbracket
    = send\;c\;1; \llbracket{P}\rrbracket \\
  \begin{split}
    \llbracket{c \rhd [l_1:P,l_2:Q]}\rrbracket
      & = \lett\; x = recv\;c \;\inn\;
        (\case\; x \;\of\; 0 \mapsto \llbracket{P}\rrbracket,
        \suc\;n \mapsto \llbracket{Q}\rrbracket) \\
    \llbracket{\mono{if}\;[V=0]\;\mono{then}
        \;P\;\mono{else}\;Q}\rrbracket
      & = \case\; V \;\of\; 0 \mapsto \llbracket{P}\rrbracket,
        \suc\;n \mapsto \llbracket{Q}\rrbracket
  \end{split}
\end{split}
\]
may be generalized to any Finite Set of Labels (Isomorphic to $\Nat$).

Subeffecting %FIXME


\textbf{Value Encoding}

PCF has the same Constructors as Session Calculus (Modulo $\pred$):
\[
  \begin{split}
    \llbracket{\unit}\rrbracket = \unit \quad\quad
    \llbracket{0}\rrbracket = 0 \quad\quad
    \llbracket{v}\rrbracket = v \\
    \begin{split}
      \llbracket{\suc\;V}\rrbracket & = \suc\;\llbracket{V}\rrbracket \\
      \llbracket{\pred\;V}\rrbracket & =
        \case\;\llbracket{V}\rrbracket\;\of\;
          0 \mapsto 0, (\suc\;x) \mapsto x
    \end{split}
  \end{split}
\]
Context-preserving Embedding of Variables


\textbf{Correctness}

\emph{Top-level Contexts}

$\Rightarrow$ -- Relation of \emph{Stable Reductions} between a Term
and a Store; characterizes the equivalent of $\beta$-reductions
(\S\ref{sec:beta_reduction}) (Synchronization) in the Session
Calculus:

$(\beta\Rightarrow)$

$(\text{ch}\beta\Rightarrow)$

$(\text{new}\Rightarrow)$

$(\equiv\Rightarrow)$

$(\rightarrow)$

\textbf{Thm.} \emph{Operational Correspondence}


\textbf{Termination and Replicated Input}

Replicated Input is Encoded as a Recursive Function that becomes
Blocked once therare no more Outputs ($rsend$).

\emph{Garbage Collection Property} (???) shows this is Observationally
Equivalent to the Empty Process:
\[
  \nu c.(*c?(d).P) \cong 0
\]

Property holds for the Encoding up to Non-termination Effects %FIXME



\subparagraph{metaFPCF}\label{sec:meta_fpcf}\hfill

\cite{orchard-yoshida16}

Monadic Metalanguage - Moggi91 %FIXME

Monadic Type Constructor $T$ augmented with an Effect Annotation
\cite{wadler-thiemann03}



\subsubsection{Reflexive Domain}\label{sec:reflexive_domain}

Dana Scott %FIXME



% --------------------------------------------------------------------
\subsection{Second-order $\lambda$-calculus}
\label{sec:secondorder_lambda}
% --------------------------------------------------------------------

$\lambda2$ -- Second-order (Polymorphic) $\lambda$-calculus

Polymorphic Types (\S\ref{sec:polymorphic_type})

Quantification over Propositional Variables in Second-order Logic
corresponds to Type Abstraction in Second-order $\lambda$-calculus.
\cite{wadler14}

System F (\S\ref{sec:system_f}) is the canonical $\lambda2$-calculus



\subsubsection{System F}\label{sec:system_f}

$\lambda2$

\emph{System F} (or \emph{Second-order $\lambda$-calculus})

(\emph{Girard-Reynolds}) \emph{Polymorphic $\lambda$-calculus})

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism}):
Type-level Function Abstraction $\Lambda$

By Curry-Howard Isomorphism, System F corresponds to the fragment of
Second-order Intuitionistic Logic using only Universal Quantification;
can describe all Functions that are Provably Total in Second-order
Logic (\S\ref{sec:secondorder_logic})

Universal Quantification over all Types (cf. Existential Type Theory
\S\ref{sec:abstract_type}) %FIXME



System F$_\omega$ ($\lambda\omega$ \S\ref{sec:system_fomega}) --
  Higher-order System F (Type Operators \S\ref{sec:type_operator})

System F$_{<:}$ (\S\ref{sec:system_fsub}) -- System F with
  Conjunctive Types (\S\ref{sec:conjunctive_type})



% --------------------------------------------------------------------
\subsection{Higher-order $\lambda$-calculus}
\label{sec:higherorder_lambda}
% --------------------------------------------------------------------

$\lambda\underline{\omega}$ -- Higher-order $\lambda$-calculus:
Simply-typed $\lambda$-calculus with Type Operators
(\S\ref{sec:type_operator})

Types depending on Types



\subsubsection{System F$_\omega$}\label{sec:system_fomega}

$\lambda\omega$ -- System F ($\lambda2$ \S\ref{sec:system_f}) with
Type Operators



% --------------------------------------------------------------------
\subsection{Dependently-typed $\lambda$-calculus}
\label{sec:dependent_lambda}
% --------------------------------------------------------------------

$\lambda\Pi$ -- First-order Dependently-typed $\lambda$-calculus:
correspondence with First-order Minimal Logic
(\S\ref{sec:minimal_logic})

Calculus of Constructions ($\lambda\Pi\omega$ \S\ref{sec:coc}) --
Higher-order Dependently-typed $\lambda$-calculus

$\lambda\Pi$ is the Meta-language of LF (\S\ref{sec:lf}) Logical
Framework (\S\ref{sec:logical_framework})

Objects of $\lambda\Pi$:
\begin{enumerate}
  \item (Proof) Objects
  \item Types (Propositions)
  \item Families of Types (Type Families ???)
\end{enumerate}

Well-typing (Judgement) is Decidable %FIXME judgement?

Well-typed Terms are Strongly Normalizing

Church-Rosser Property

\fist Type-inference is Undecidable %FIXME

Dependently-typed $\lambda$-calculus with a Type of all Types (the
simplest Pure Type System \S\ref{sec:pts}) is not
Strongly Normalizing due to Girard's Paradox
(\S\ref{sec:girards_paradox})



\subsubsection{Calculus of Constructions}\label{sec:coc}

$\lambda\Pi\omega$ -- Higher-order Dependently-typed
$\lambda$-calculus

Intuitionistic Type Theory (\S\ref{sec:intuitionistic_type})

Intuitionistic (\S\ref{sec:intuitionistic_logic}) Predicate Calculus
(\S\ref{sec:predicate_logic})


\textbf{Terms}

\begin{flalign*}
  \quad\quad & A,B ::= \class{T} \mid \class{P} \mid x
    \mid (A\;B) \mid (\lambda x:A.B) \mid (\forall x:A.B) &
\end{flalign*}

$\class{T}$ -- Type of all Large Types

$\class{P}$ -- Type of all Propositions (a Type of Predicate, i.e. a
Large Type $\class{P}:\class{T}$)

$x,y,\ldots$ -- Variables


\textbf{Objects}

\begin{enumerate}
  \item Proofs -- Terms whose Types are Propositions
  \item Propositions -- Small Types
  \item Predicates -- Functions that return Propositions
  \item Types of Predicates -- Large Types, e.g. $\class{P}$
  \item $\class{T}$ -- Type of Large Types
\end{enumerate}


\asterism


(scratch)

$x:(A:(\Type:(\class{P}:\class{T})))$

or

$x:(A:(\class{P}:\class{T}))$

$x:(A:(\Type:(\class{U})))$

?


$\exists x:A.B$

$(\Pi C:\Type).(\Pi (\Pi x:A).(\Pi b:B).C).C$



% --------------------------------------------------------------------
\subsection{$\lambda$-calculus with Conjunctive Types}
\label{sec:conjunctive_lambda}
% --------------------------------------------------------------------

Subtyping (\S\ref{sec:subtype_polymorphism})

Conjunctive Type (\S\ref{sec:conjunctive_type})



\subsubsection{System F$_{<:}$}\label{sec:system_fsub}

System F ($\lambda2$ \S\ref{sec:system_f}) with Conjunctive Types
(\S\ref{sec:conjunctive_type})



\paragraph{System F$_{<:}^\omega$}\label{sec:fsub_omega}\hfill

Higher-order Bounded Quantification



% --------------------------------------------------------------------
\subsection{Linear $\lambda$-calculus}\label{sec:linear_lambda}
% --------------------------------------------------------------------

Substructural Type System (\S\ref{sec:substructural_type})

Linear Type System (\S\ref{sec:linear_type})



\subsubsection{Good Variation}\label{sec:good_variation}
\cite{wadler12}

Gay-Vasconcelos 2010 (Semantics: Asynchronous Buffered
Communication) %FIXME

Linear Functional Language for Session Types

Session Types $\subset$ Types

\fist See \emph{Classical Processes} (CP
\S\ref{sec:classical_processes}) for a Session-typed $\pi$-calculus
Translation

Encoding CP into GV: Operational Correspondence (Lindley-Morris15)

\fist Cf. FPCF (\S\ref{sec:fpcf}) \cite{orchard-yoshida16} -- FPCF is
not fundamentally Linear, but Linearity for Sessions is implemented
via an Effect Algebra and Typing.

No Deadlock

Extensions:
\begin{itemize}
  \item $Mix$ (Girard):
\[
  \frac{P \vdash \Gamma \quad Q \vdash \Delta}
  {P | Q \vdash \Gamma, \Delta} (Mix)
\]
    No Channels in Common between $P$ and $Q$ (rather than one Channel
    in common as in $Cut$); Equivalent to Provability of the
    Proposition:
\[
  A \otimes B \multimap A \parr B
\]
    Still no Deadlock but allows Independent Concurrent Components.
  \item $BiCut$ (\cite{abramsky-gay-nagarajan96}; special case of
    $MultiCut$):
\[
  \frac{P \vdash \Gamma, x:A, y:B \quad
    Q \vdash \Delta, x:A^\bot, y:B^\bot}
  {\nu x:A.y:B.(P|Q) \vdash \Gamma, \Delta} (BiCut)
\]
    Two Channels in common between $P$ and $Q$ (rather than one
    Channel in common as in $Cut$); Equivalent to Provability of the
    Proposition:
\[
  A \parr B \multimap A \otimes B
\]
    Allows for systems where Communication forms a loop and may
    Deadlock
\end{itemize}

Systems with both $Mix$ and $BiCut$ are Compact: from either of $A
\otimes B$ and $A \parr B$ one may derive the other;
Compact Linear Systems (\S\ref{sec:compact_linear_system}),
Interaction Categories (\S\ref{sec:interaction_category})

\emph{Types}:
\begin{flalign*}
  \quad T,U,V &::= S \;|\; T \otimes U \;|\; T \multimap U
    \;|\; T \rightarrow U \;|\; Unit &
\end{flalign*}

$S$ -- (Linear) Session Type

$T \otimes U$ -- (Linear) Tensor Product

$T \multimap U$ -- (Linear) Function

$T \rightarrow U$ -- (Unlimited) Function

$Unit$ -- (Unlimited) Unit

\emph{Unlimited Types} support Weakening and Contraction,
\emph{Linear Types} do not

Unlimited Types correspond to Types written with $!$ in CP
(\S\ref{sec:classical_processes})

\emph{Session Types}:
\begin{flalign*}
  \quad S &::= \;!T.S \;|\; ?T.S \;|\; \oplus\{l_i:S_i\}_{i \in I}
    \;|\; \&\{l_i:S_i\}_{i \in I} \;|\; end_! \;|\; end_? &
\end{flalign*}

$!T.S$ -- Output Value of Type $T$ then Behave as $S$

$?T.S$ -- Input Value of Type $T$ then Behave as $S$

$\oplus\{l_i:S_i\}_{i \in I}$ -- Select from Behaviors $S_i$ with
Label $l_i$

$\&\{l_i:S_i\}_{i \in I}$ -- Offer Choice of Behaviors $S_i$ with
Label $l_i$

$end_!$ -- Terminator for use with Output

$end_?$ -- Terminator for use with Input


Session Type Duals:
\begin{align*}
  \overline{!T.S} &= ?T.\overline{S} \\
  \overline{?T.S} &= !T.\overline{S} \\
  \overline{\oplus\{l_i:S_i\}_{i \in I}} &=
    \&\{l_i:\overline{S_i}\}_{i \in I} \\
  \overline{\&\{l_i:S_i\}_{i \in I}} &=
    \oplus\{l_i:\overline{S_i}\}_{i \in I} \\
  \overline{end_!} &= end_? \\
  \overline{end_?} &= end_!
\end{align*}

$\overline{\overline{S}} = S$

Duality on Session Types in GV leaves the Types of Sent and Received
Values unchanged, i.e.:
\begin{align*}
  \overline{!T.S} &= ?T.\overline{S} \\
  \overline{?T.S} &= !T.\overline{S}
\end{align*}


\emph{Environments} $\Phi, \Psi$ associating Values to Types

$un(\Phi)$ -- Each Type in $\Phi$ is Unlimited


\emph{Terms}:
\begin{flalign*}
  \quad L,M,N &::= x \;|\; \mono{unit} \;|\; \lambda x.N \;|\; L M
    \;|\; (M,N) \;|\; \mono{let}\; (x,y) = M \;\mono{in}\; N & \\
    & \;|\; \mono{send}\; M N \;|\; \mono{receive}\; M
    \;|\; \mono{select}\; l M
    \;|\; \case\; M \;\of\; \{l_i:x.N_i\}_{i\in I} & \\
    & \;|\; \mono{with}\; x \;\mono{connect}\; M \;\mono{to}\; N
    \;|\; \mono{terminate}\; M &
\end{flalign*}

Linear $\lambda$-calculus:

$x$ -- Identifier

$\mono{unit}$ -- Unit Constant

$\lambda x.N$ -- Function Abstraction

$L M$ -- Function Application

$(M,N)$ -- Pair Construction

$\mono{let}\; (x,y) = M \;\mono{in}\; N$

Communication on a Channel:

$\mono{send}\; M N$ -- Send Value $M$ on Channel $N$

$\mono{receive}\; M$ -- Receive on Channel $M$

$\mono{select}\; l M$ -- Select Label $l$ on Channel $M$

$\case\; M \;\of\; \{l_i:x.N_i\}_{i\in I}$ -- Offer Choice
on Channel $M$

$\mono{with}\; x \;\mono{connect}\; M \;\mono{to}\; N$ -- Connect $M$
to $N$ by Channel $x$

$\mono{terminate}\; M$ -- Terminate Input


Type Rules

Function Abstraction may produce an Unlimited Function if and only if
all of its Free Variables are of Unlimited Type.

Each Term is not required to have a Unique Type, e.g. a
$\lambda$-expression where all Free Variables have Unlimited Type may
be given either a Linear or Unlimited Function Type.

Possibly Subtyping could be added to arrange for giving each Term a
Unique Smallest Type.


\asterism


\emph{Output} -- $\mono{send}\; M N$: \\
Outputs the Value $M$ of Type $T$ on Channel $N$ of Session Type
$!T.S$ \\
Returns the updated Channel after which the Output has Session Type
$S$

\emph{Input} -- $\mono{receive}\; M$: \\
Inputs a Value from Channel $M$ of Session Type $?T.S$ \\
Returns a (Linear) Pair of the Input Value of Type $T$ and the updated
Channel after which the Input has Session Type $S$

\emph{New Channel} ($Connect$) -- $\mono{with}\; x \;\mono{connect}\;
M \;\mono{to}\; N$ \\
Creates a new Channel $x$ with Session Type $S$ where $x$ is used at
Type $S$ in Term $M$ and Dual Type $\overline{S}$ in Term $N$ \\
$M$ and $N$ are Evaluated Concurrently \\
Left Subterm returns exhausted Channel of Type $end_!$ %FIXME

\emph{Terminate Channel} ($Terminate$) -- $\mono{terminate}\; M$: \\
Evaluates Term $M$ which Returns a Pair of an Exhausted Channel of
Type $end_?$ and a Value of Type $T$ \\
Deallocates the Channel and Returns the Value

Constructs for $Connect$ and $Terminate$ Deallocate two ends of a
Channel between them.

Alternative designs %FIXME


\asterism


\textbf{Translation of GV into CP}

CP (\S\ref{sec:classical_processes})

Translation of Session Types:
\begin{align*}
  \llbracket !T.S \rrbracket &=
    \llbracket T \rrbracket^\bot \parr \llbracket S \rrbracket \\
  \llbracket ?T.S \rrbracket &=
    \llbracket T \rrbracket \otimes \llbracket S \rrbracket \\
  \llbracket \oplus \{l_i : S_i\}_{i \in I} \rrbracket &=
    \llbracket S_1 \rrbracket \& \cdots \& \llbracket S_n \rrbracket,
    \quad I = \{1,\ldots,n\} \\
  \llbracket \& \{l_i : S_i\}_{i \in I} \rrbracket &=
    \llbracket S_1 \rrbracket \oplus \cdots \oplus
    \llbracket S_n \rrbracket, \quad I = \{1,\ldots,n\} \\
  \llbracket end_! \rrbracket &= \bot \\
  \llbracket end_? \rrbracket &= 1
\end{align*}

\fist Note that Input/Output are translated into their Duals. This is
explained by Send and Receive in GV taking Channels as
\emph{Arguments}, while in the Interpretations in CP Channels are
\emph{Results}.
\begin{itemize}
  \item \emph{Send}: takes a Value and a Channel and Sends the Value
    on that Channel (the Channel must \emph{Input} the Value)
  \item \emph{Receive}: takes a Channel and Returns a Value (the
    Channel must \emph{Output} the Value)
\end{itemize}
Since Duality on Session Types in GV leaves Types of Sent and Received
Values unchanged, the Translation of these Operations takes the Dual
of the Sent Value, but not the Received Value, i.e.:
\begin{align*}
  \llbracket !T.S \rrbracket &=
    \llbracket T \rrbracket^\bot \parr \llbracket S \rrbracket \\
  \llbracket ?T.S \rrbracket &=
    \llbracket T \rrbracket \otimes \llbracket S \rrbracket
\end{align*}
and following the equality in Linear Logic, $A \multimap B = A^\bot
\parr B$, $\llbracket T \rrbracket^\bot \parr \llbracket S \rrbracket$
could alternatively be written $\llbracket T \rrbracket \multimap
\llbracket S \rrbracket$.

Translation Preserves Duality:
\[
  \llbracket \overline{S} \rrbracket = \llbracket S \rrbracket^\bot
\]

Translation of Types:
\begin{align*}
  \llbracket T \multimap U \rrbracket &=
    \llbracket T \rrbracket^\bot \parr \llbracket U \rrbracket \\
  \llbracket T \rightarrow U \rrbracket &=
    \;!(\llbracket T \rrbracket^\bot \parr \llbracket U \rrbracket) \\
  \llbracket T \otimes U \rrbracket &=
    \llbracket T \rrbracket \otimes \llbracket U \rrbracket \\
  \llbracket Unit \rrbracket &= \;!\top
\end{align*}

$\llbracket T \rrbracket^\bot \parr \llbracket U \rrbracket$ could
alternatively be written:
\[
  \llbracket T \rrbracket \multimap \llbracket U \rrbracket
\]

$!(\llbracket T \rrbracket^\bot \parr \llbracket U \rrbracket)$ could
alternatively be written:
\[
  !(\llbracket T \rrbracket \multimap \llbracket U \rrbracket)
\]

$!T$ could alternatively be written $1$ (Unit for $\otimes$)

This Translation follows the Call-by-value Translation of Classical
Linear Logic (\S\ref{sec:cll})

Translation of Terms:

Linear $\lambda$ Terms:
\begin{itemize}
  \item Variable Translates to an $Axiom$
  \item $Weaken$ and $Contract$ Translate to $Weaken$ and $Contract$
  \item Function Abstraction and Product Deconstruction Translate to
    Input
  \item Function Application and Product Construction Translate to
    Output
  \item Translation of Elimination Rules ($\multimap-E$,
    $\rightarrow-E$, $\times-E$) require use of $Cut$
\end{itemize}

Communication Operation Terms:
\begin{itemize}
  \item Send: Output Operation $x[y].(P|Q)$
  \item Select: Select Operation $x[in_j].P$
  \item Case: Choice Operation $\case(Q_1, \ldots, Q_n)$
  \item $end_!$ in Connect: Empty Output $y[].0$
  \item Terminate: Empty Input $x().P$
  \item Receive (Trivial): $x(y).R$ (???)
  \item Connect: $Cut$ corresponds to introducing a Channel for
    Communication between two Subterms
\end{itemize}
Each of these Communication Translations involve a $Cut$ corresponding
to Communication with given Channel.

Term $M$ of Type $T$ is Translated $\llbracket M \rrbracket_z$ where
$z$ is a Channel of Type $\llbracket T \rrbracket$ where $\llbracket M
\rrbracket_z$ Sends the ``Answer'' it Computes on $z$, as expressed by
the Theorem:

Th. \textbf{Translation Preserves Types}

\[
  \text{If } \Phi \vdash M : T \text{ then }
  \llbracket M \rrbracket z \vdash \llbracket \Phi \rrbracket^\bot,
  z : \llbracket T \rrbracket
\]



% --------------------------------------------------------------------
\subsection{B\"ohm Tree}\label{sec:bohm_tree}
% --------------------------------------------------------------------

A \emph{B\"ohm Tree} is a Possibly Infinite Directed Acyclic Graph
where some Vertices are Labelled by $\lambda$-terms and all Vertices
besides the Root have exactly one Parent, every Vertex has a finite
number of Children, and every Unlabelled Vertex has no Children.



% ====================================================================
\section{Logical Framework}\label{sec:logical_framework}
% ====================================================================

%FIXME

Automath, Isabelle

Dependently-typed $\lambda$-calculus (\S\ref{sec:dependent_lambda})

\begin{enumerate}
  \item Class of Object-logics (???)
  \item Meta-language (\S\ref{sec:metalanguage})
  \item Representation Mechanism for Object-Logics
\end{enumerate}

``Framework = Language + Representation''



% --------------------------------------------------------------------
\subsection{LF}\label{sec:lf}
% --------------------------------------------------------------------

LF (Edinburgh Logical Framework)

Twelf


wiki:

Meta-language -- $\lambda\Pi$ (First-order Dependently-typed
$\lambda$-calculus \S\ref{sec:dependent_lambda}): First-order Minimal
Logic (\S\ref{sec:minimal_logic})

\fist Type-inference is Undecidable %FIXME

Objects of $\lambda\Pi$:
\begin{enumerate}
  \item (Proof) Objects
  \item Types (Propositions)
  \item Families of Types (Type Families ???)
\end{enumerate}

Representation Mechanism: Judgements-as-types (cf. Intuitionistic
Type-theory \S\ref{sec:intuitionistic_type})

Judgements are Represented as the Types of their Proofs

a Logical System (\S\ref{sec:logical_system}) $\class{L}$ is
Represented by its Signature assigning Kinds and Types to a Finite Set
of Constants that Represent its Syntax, Judgements, and Rule Schemes
%FIXME

Object-logic Rules and Proofs are Represented as Primitive Proofs of
Hypothetico-general Judgements:
\[
  \Lambda x:C.J(x) \vdash K
\]

$J \vdash K$ -- Hypothetical (ordinary Function Space
\S\ref{sec:function_type})

$\Lambda x:J.K(x)$ -- General (Dependent Function Space
\S\ref{sec:dependent_function})



% ====================================================================
\section{Pure Type System}\label{sec:pts}
% ====================================================================

(Roorda00) %FIXME

PTS (or \emph{Generalized Type System})

Multi-sorted Type System

Arbitrary number of Sorts and Dependencies

Generalization of the \emph{Lambda Cube} (\S\ref{sec:lambda_cube}) to
more Sorts than Terms and Types

Not necessarily Strongly Normalizing (\S\ref{sec:normalization})

Dependently-typed $\lambda$-calculus (\S\ref{sec:dependent_lambda})
with a Type of all Types (\S\ref{sec:type_universe})--the simplest
Pure Type System--is not Strongly Normalizing due to Girard's Paradox
(\S\ref{sec:girards_paradox})

Barendregt-Geuvers-Klop Conjecture: a Weakly Normalizing PTS always
has the Strong Normalization Property

Programming Languages: SAGE, Yarrow, Henk 2000


\asterism


$(S,A,R)$

$S$ -- Set of \emph{Sorts} (all Constants)

$A \hookrightarrow S \times S$ -- Set of \emph{Axioms} of the form $c:s$ of
Constants $c$ and Sorts $s$

$R \hookrightarrow S \times S \times S$ -- Set of Rules
$(s_1,s_2,s_3)$ on Sorts



% --------------------------------------------------------------------
\section{$\lambda\mu$-calculus}\label{sec:lambda_mu}
% --------------------------------------------------------------------

Classical Logic (\S\ref{sec:classical_logic})

Classical Natural Deduction (\S\ref{sec:natural_deduction})

Operators corresponding to Continuations (\S\ref{sec:continuation})

Reduction Rules:
\begin{itemize}
  \item Logical Reduction
  \item Structural Reduction
  \item Renaming
  \item $\eta$-reduction
\end{itemize}

Confluent (\S\ref{sec:rewrite_confluence}) by the above Rules



% ====================================================================
\section{Dependent Type Theory}\label{sec:dependent_type_theory}
% ====================================================================

Dependent Types (\S\ref{sec:dependent_type})

Dependently-typed $\lambda$-calculus (\S\ref{sec:dependent_lambda})

By Curry-Howard Isomorphism Dependent Types correspond to Propositions
of First-order Predicate Logic (\S\ref{sec:firstorder_logic})


\textbf{Categorical Semantics} (\S\ref{sec:categorical_semantics})

Categorical Model (\S\ref{sec:categorical_model})

Comprehension Category (\S\ref{sec:comprehension_category}),
Contextual Category (\S\ref{sec:contextual_category})

Interpretation of Judgements of Dependent Type Theory in a given
Category $\cat{C}$ with Finite Limits (\S\ref{sec:finite_limit})

Codomain Fibration (\S\ref{sec:codomain_fibration}):
\[
  cod:\cat{C}^I \rightarrow \cat{C}
\]

Classifying Functor (Grothendieck Construction
\S\ref{sec:grothendieck_construction}):
\[
  \chi : \cat{C}^{op} \rightarrow \cat{Cat}
\]
sends an Object in $\cat{C}$ to the Slice Category
(\S\ref{sec:slice_category}) over it:
\[
  \chi = \Gamma \mapsto \cat{C}/\Gamma
\]
and sends a Moprhism $f : \Gamma \rightarrow \Gamma'$ to the Pullback
(\S\ref{sec:pullback})/Base Change (\S\ref{sec:base_change}) Functor:
\[
  f^* : \cat{C}/\Gamma' \rightarrow \cat{C}/\Gamma
\]


\textbf{Rules}

Rules for choices ``$[xyz]$'' associating every String ``$xyz$'' of
Symbols in Type Theory with Objects and Morphisms in $\cat{C}$: a
collection of such choices following the Rules is an Interpretation (a
choice of Categorical Semantics) of the Type Theory in the Category
$\cat{C}$.

\emph{Contexts and Type Judgements}:
\begin{enumerate}
  \item $[()] := *$ -- Empty Context $()$ is Interpreted as the
    Terminal Object $*$ of $\cat{C}$
  \item For Context $\Gamma$ with Interpretation $[\Gamma] \in
    \cat{C}_0$, a Judgement $\Gamma \vdash A\type$ is Interpreted
    as an Object in the Slice Category over $\Gamma$:
    \[
      [\Gamma \vdash A\type] \in (\cat{C}/\Gamma)_0
    \]
    giving a choice of Morphism:
    \[
      [\Gamma \vdash A\type] : [(\Gamma,x:A)] \rightarrow [\Gamma]
    \]
  \item For Judgement $\Gamma \vdash A\type$ Interpreted as $[\Gamma
    \vdash A\type]$ above, an Extended Context $(\Gamma,x:A)$ is
    Interpreted as the Domain Object $[(\Gamma,x:A)]$ of the above
    choice of Morphism
\end{enumerate}

\emph{Terms}

For Context $\Gamma$ and Judgement $\Gamma \vdash A\type$ with chosen
Interpretation $[\Gamma \vdash A\type] : [(\Gamma,x:A)] \rightarrow
[\Gamma]$, a Judgement $\Gamma \vdash a:A$ is Interpreted as a Section
(\S\ref{sec:section}) of $[\Gamma \vdash A\type]$, equivalently as a
Morphism in $\cat{C}/\Gamma$:
\[
  [\Gamma \vdash a:A]: * \rightarrow [\Gamma,x:A]
\]
giving a Commuting Triangle:
\[
  1_{[\Gamma]} = [\Gamma \vdash A\type] \circ [\Gamma \vdash a:A]
\]

\emph{Variables}

\emph{Substitution}



% --------------------------------------------------------------------
\subsection{Ornament}\label{sec:ornament}
% --------------------------------------------------------------------

\cite{mcbride13}

Algebraic Ornament (\S\ref{sec:algebraic_ornament})

Ornamental Algebra

Dependent Types: ``axis'' of Indexing for Data Structures

Datatype of Datatype Descriptions (\emph{Universe}: Martin-L\"of84)

Refinement Types (\S\ref{sec:refinement_type}): Decoration with
``Logical Data''; Ornaments ``Decorate'' with additional ``Non-logical
Data'' %FIXME



\subsubsection{Algebraic Ornament}\label{sec:algebraic_ornament}

Type Refinement (\S\ref{sec:refinement_type}) Induced by Algebras over
a Datatype's Structure



% ====================================================================
\section{Intuitionistic Type Theory}\label{sec:intuitionistic_type}
% ====================================================================

\cite{martinlof84}

\emph{Intuitionistic Type Theory} (also \emph{Constructive Type
  Theory} or \emph{Martin-L\"of Type Theory})

Calculus of Constructions (\S\ref{sec:coc})

Dependent Type Theory (\S\ref{sec:dependent_type_theory})

Inductive Types (\S\ref{sec:inductive_type})

Modelled by Locally Cartesian Closed Category
(\S\ref{sec:locally_cartesian})

Extensional Martin-L\"of Type Theory: Internal Language
(\S\ref{sec:internal_logic}) for Cartesian Closed Quasi-categories
(\S\ref{sec:quasicategory})

Formation: the Context in which the Type is defined

Introduction: rules for Construction

Elimination: rules for De-construction

Computation: ???

Four forms of Judgements:
\begin{description}
  \item [Well-formed Type]: $A$ is a Set, $A$ is a Proposition, $A$ is
    an Expectation, $A$ is a Task; Types (encodes Syntax of Formulas
    ``A is a Proposition''; note some Formulas are only Well-formed if
    certain Judgements are Derivable \cite{thompson99}):
    \[
      A \text{ type}
    \]
  \item [Equality of Types]: $A$ and $B$ are Equal Sets:
    \[
      A \equiv B \text{ type}
    \]
  \item [Well-formed Term of Type]: $a$ is an Element of $A$, $a$ is a
    Proof of $A$, $a$ is a Realization of $A$, $a$ is a Method for
    doing $A$:
    \[
      a : A
    \]
  \item [Equality of Terms]: $a$ and $b$ are Equal Elements of Set $A$:
    \[
      a \equiv b : A
    \]
\end{description}

Dependent Type (\S\ref{sec:dependent_type}):
\[
  (x:A)B
\]
Removal of Dependency by Substitution:
\[
  [x/a]B
\]
Abstracted Object:
\[
  [x]b
\]
Removal of Abstration on Object:
\[
  b[x/a]
\]
Well-formed Context of Typing Assumptions
(\S\ref{sec:typing_assumption}):
\[
  \vdash \Gamma \textsf{ Context}
\]
Context (\S\ref{sec:type_context}) Judgements:
\begin {itemize}
\item Well-formed Type $\sigma$:
  \[
    \Gamma \vdash \sigma \mathsf{ Type}
  \]
\item Well-formed Term $t$ of Type $\sigma$:
  \[
    \Gamma \vdash t : \sigma
  \]
\item Type Equivalence:
  \[
    \Gamma \vdash \sigma \equiv \tau
  \]
\item Term Equivalence:
  \[
    \Gamma \vdash t \equiv u : \sigma
  \]
\end {itemize}
\hfill\\
Type Universe:
\[
  \class{U}
\]
Dependent Type mapping Objects to Types:
\[
  \textrm{El}
\]

Definitional Equality (\S\ref{sec:proof_equality})

Structural Rules (\S\ref{sec:structural_rule})



\textbf{Identity Types} (\S\ref{sec:equality_type})
\\
Identity Type Introduction:
\[
  \frac{
    \Gamma \vdash m : A
  }{
    \Gamma \vdash refl_A(m) : Id_A(m,m)
  } (Id_A\text{-I})
\]
Identity Type Elimination:
\[
  \frac{
    \Gamma \vdash p : Id_A (m,n) \quad
    \Gamma, x:A, y:A, z : Id_A(x,y) \vdash C_{x,y,z} \text{ type}\quad
    \Gamma, x : A \vdash q : [x, x, refl_A(x)/x,y,z]C
  }{
    \Gamma \vdash refl_A(m) : Id_A(m,m)
  } (Id_A\text{-E})
\]
\textbf{Dependent Product Types} (\S\ref{sec:pi_type})
\\
Logical Implication and Universal Quantification
\\
Dependent Product Formation:
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma, x:A \vdash B \text{ type}
  }{
    \Gamma \vdash (\Pi x:A) B \text{ type}
  } (\Pi\text{-F})
\]
Dependent Product Introduction:
\[
  \frac{
    \Gamma, x : A \vdash m_x : B_x \quad
  }{
    \Gamma \vdash (\lambda x:A.m_x : B_x) : (\Pi x:A) B
  } (\Pi\text{-I})
\]
Dependent Product Elimination:
\[
  \frac{
    \Gamma \vdash m : (\Pi x:A) B \quad
    \Gamma \vdash n : A
  }{
    \Gamma \vdash m\;n : [n/x]B
  } (\Pi\text{-E})
\]
Dependent Product Computation (cf. $\beta$-reduction
\S\ref{sec:beta_reduction}):
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma , x : A \vdash m : B
  }{
    \Gamma \vdash (\lambda x : A.m)\;n \equiv [n/x]m : [n/x]B
  } (\Pi\text{-C})
\]


\textbf{Dependent Sum Types} (\S\ref{sec:sigma_type})
\\
Logical Conjunction and Existential Quantification
\\
Dependent Sum Formation:
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma, x : A \vdash B_x \text{ type}
  }{
    \Gamma \vdash (\Sigma x:A) B_x \text{ type}
  } (\Sigma\text{-F})
\]
Dependent Sum Introduction:
\[
  \frac{
    \Gamma \vdash m : A \quad
    \Gamma \vdash n : [m/x]B
  }{
    \Gamma \vdash (m,n) : (\Sigma x:A) B_x
  } (\Sigma\text{-I})
\]
Dependent Sum Elimination 1:
\[
  \frac{
    \Gamma \vdash m : (\Sigma x:A) B_x
  }{
    \Gamma \vdash \pi_1\;m : A
  } (\Sigma\text{-E$_1$})
\]
Dependent Sum Elimination 2:
\[
  \frac{
    \Gamma \vdash m : (\Sigma x:A) B_x
  }{
    \Gamma \vdash \pi_2\;m : B[\pi_1\;m/x]
  } (\Sigma\text{-E$_2$})
\]
\textbf{Binary Sum Types} (\S\ref{sec:sum_type})
\\
Disjunction
\\
Binary Sum Introduction 1:
\[
  \frac{
    \Gamma \vdash m : A
  }{
    \Gamma \vdash inl(m) : A + B
  } (+\text{-I}_1)
\]
Binary Sum Introduction 2:
\[
  \frac{
    \Gamma \vdash n : B
  }{
    \Gamma \vdash inr(n) : A + B
  } (+\text{-I}_2)
\]
Binary Sum Elimination:
\[
  \frac{
    \Gamma \vdash m : A + B \quad
    \Gamma, z : A + B \vdash C \text{ type} \quad
    \Gamma, x : A \vdash n : [inl(x)/z]C \quad
    \Gamma, y : B \vdash p : [inr(y)/z]C
  }{
    \Gamma \vdash case (m, x\;n, y\;p) : [m/z]C
  } (+\text{-E})
\]



Categorical Model, ``Category with Families'':

\begin{itemize}
  \item Category $\mathsf{C}$ of Contexts: Objects are Contexts,
    Morphisms are Substitutions
  \item Functor $T : \mathsf{C}^{op} \rightarrow \mathbf{Fam(Set)}$
    where $\mathbf{Fam(Set)}$ is the Category of Families
    (\S\ref{sec:family}) of Sets where Objects are Pairs $(A,B)$ of an
    Index Set $A$ and a Function $B: X \rightarrow A$ and Morphisms
    are Pairs of Functions $f: A \rightarrow A$ and $g: X \rightarrow
    X'$ such that $B' \circ g = f \circ B$, i.e. $f$ maps $B_a$ to
    $B'_{g(a)}$
\end{itemize}

The Functor $T$ assigns a Context $\Gamma$ to a Set of Types
$Ty(\Gamma)$, and for each $A : Ty(\Gamma)$ a Set of Terms
$Tm(\Gamma,A)$.

The Empty Context is the Terminal Object of $\mathsf{C}$.

Final Object for \emph{Comprehension} (or \emph{Context Extension}) % FIXME



\textbf{Alternate description}\cite{bastenhof09}

Language $L$:
\begin{enumerate}
  \item $1$ (Unity Type), $\Omega$ (Truth Value Type)
  \item Base Types $\tau_1, \tau_2, \tau_3, \ldots$
  \item Function Symbols $f, g, h, \ldots$
\end{enumerate}
The Types of a System are given by the smallest Set including $1$,
$\Omega$, and the Base Types closed under $\times$ (Product Types
\S\ref{sec:product_type}) and Unary Type Operator $P$ (Power Types
\S\ref{sec:power_type}).

Terms of Type $\Omega$ represent Formulas, e.g. $\tau_1 = \tau_2$.


\asterism


\textbf{Sum Type} (\S\ref{sec:sum_type}) (Tagged Union)

$A \cup B = \{ a_1, a_2, ..., b_1, b_2, ... \}$

$x \in A \cup B \Rightarrow x \in A \vee x \in B$

$U \subset A \cup B \Rightarrow \forall u \in U, u \in A \vee u \in B \}$


\textbf{Product Type} (\S\ref{sec:product_type}) (Pairs)

$A \times B = \{ (a_1,b_1), (a_1,b_2), ..., (a_2,b_1), (a_2,b_2), ... \}$

$(x,y) \in A \times B \Rightarrow x \in A \wedge y \in B$

$U \subset A \times B
\Rightarrow \forall (u,v) \in U, u \in A \wedge v \in B$


\textbf{Powerset} (\S\ref{sec:powerset})
(Relations \S\ref{sec:binary_relation})

$\pow(A \times B) = \{ \linebreak[1]
\{(a_1,b_1)\}, \{(a_1,b_2)\}, ...,
\{(a_2,b_1)\}, \{(a_2,b_2)\}, ...
\linebreak[1] \vdots \linebreak[1]
\{(a_1,b_1), (a_1,b_2)\}, \{(a_1,b_1), (a_1,b_3)\}, ...,
\{(a_2,b_1), (a_2,b_2)\}, \{(a_2,b_1), (a_2,b_3)\}, ...
\linebreak[1] \vdots \linebreak[1]
..., A \times B - \{(a_2,b_1), (a_2,b_3)\}, \allowbreak
A \times B - \{(a_2,b_1), (a_2,b_2)\}, \allowbreak
..., A \times B - \{(a_1,b_1), (a_1,b_3)\}, \allowbreak
A \times B - \{(a_1,b_1), (a_1,b_2)\}, \allowbreak
\linebreak[1] \vdots \linebreak[1]
..., A \times B - \{(a_2,b_2)\}, A \times B - \{(a_2,b_1)\}, \allowbreak
..., A \times B - \{(a_1,b_2)\}, A \times B - \{(a_1,b_1)\}, \allowbreak
\linebreak[1] A \times B
\}$

$A \times B \in \pow(A \times B)$

$U \in \pow(A \times B) \Rightarrow U \subseteq A \times B \allowbreak
\Rightarrow \forall (u,v) \in U, u \in A \wedge v \in B$

$\class{V} \subset \pow(A \times B)
\Rightarrow \forall U \in \class{V}, U \subseteq A \times B$


\textbf{Function Type} (\S\ref{sec:function_type})

$A \rightarrow B = B^A = \{ \linebreak[1]
\{ (a_1, b_1), (a_2, b_1), (a_3, b_1), ...\},
\{ (a_1, b_2), (a_2, b_2), (a_3, b_2), ...\},
\{ (a_1, b_3), (a_2, b_3), (a_3, b_3), ...\}, ...
\linebreak[1] \vdots \linebreak[1]
\{ (a_1, b_2), (a_2, b_1), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_2), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_1), (a_3, b_2), ...\}, ...
\linebreak[1] \vdots \linebreak[1]
\{ (a_1, b_3), (a_2, b_1), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_3), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_1), (a_3, b_3), ...\},
\linebreak[1] \vdots \linebreak[1]
\}$

$B^A \subset \pow(A \times B)$

$f \in B^A
\Rightarrow f \in \pow(A \times B) \wedge f \neq A \times B \allowbreak
\Rightarrow f \subset A \times B
\Rightarrow \forall (x, f(x)) \in f, x \in A \wedge f(x) \in B$

$U \subset B^A \Rightarrow \forall u \in U, u \in \pow(A \times B)$


\textbf{Dependent Type} (\S\ref{sec:dependent_type})

$a:A \vdash B(a) = \{(a_1,B(a_1)), (a_2,B(a_2)), ...\}$

$a:A \vdash B(a) \in \class{U}^A \linebreak[1]
\Rightarrow a:A \vdash B(a) \subset A \times \class{U}$

$(x,X) \in a:A \vdash B(a) \Rightarrow x \in A \wedge X \in \class{U}$

$U \subset a:A \vdash B(a) \Rightarrow \forall (x,X) \in U, x \in A
\wedge X \in \class{U}$


\textbf{Dependent Sum Type} ($\Sigma$-type \S\ref{sec:sigma_type})

$(\Sigma a:A) B(a) = \{\{ (a_1, x_1), (a_1, x_2), ...\},
\{ (a_2, y_1), (a_2, y_2), ...\}, \cdots \}$

$(\Sigma a:A) B(a) \subset \pow \bigsqcup_{X \in \class{U}} A \times X$

$Z \in (\Sigma a:A) B(a) \Rightarrow \exists x \in A : \forall y \in
B(x), (x,y) \in P$



\textbf{Dependent Product Type} ($\Pi$-type \S\ref{sec:pi_type})

$(\Pi a:A) B(a) = \{(a_1, x), (a_2, y), (a_3, z), ...\}$

$(\Pi a:A) B(a) \subset \pow \bigsqcup_{a \in A} (\Sigma a:A) B(a)$


\asterism



% --------------------------------------------------------------------
\subsection{Constructive Type}\label{sec:constructive_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Meaning Explanation}\label{sec:meaning_explanation}
% --------------------------------------------------------------------

Martin-L\"of, a Proof-theoretic Semantics
(\S\ref{sec:proof_semantics}) for Type Theory

Realizability Model (\S\ref{sec:realizability_model}) for Type Theory

Intensional Type Theory (\S\ref{sec:intensional_type})

Extensional Type Theory (\S\ref{sec:extensional_type})

Terms $x,y,z,X,Y,Z,\ldots$

$x \Rightarrow y$: $x$ Computes (Reduces, Transitive) to $y$

Predicates:
\begin{itemize}
  \item $A \type$
  \item $a : A$
  \item $a = b : A$
\end{itemize}

Induction Recursion (\S\ref{sec:induction_recursion}): $A \type$ by
Induction (\S\ref{sec:mathematical_induction}) and two Recursive
Functions:
\begin{itemize}
  \item $|A|$ the Collection of Terms of Type $A$
  \item $=_A$ the Collection of Pairs of Equal Terms of Type $A$
\end{itemize}
(each Collection may be defined Inductively)



% --------------------------------------------------------------------
\subsection{Extensional Type Theory}\label{sec:extensional_type}
\cite{harper12}
% --------------------------------------------------------------------

\emph{Extensional Type Theory} (\emph{ETT})

Strict Equivalence

``Homotopy Set Theory'' (Homotopically Discrete)

\emph{NuPRL}

Equality Reflection Principle



% --------------------------------------------------------------------
\subsection{Intensional Type Theory}\label{sec:intensional_type}
\cite{harper12}
% --------------------------------------------------------------------

Weak Equivalence



% --------------------------------------------------------------------
\subsection{Observational Type Theory}\label{sec:observational_type}
% --------------------------------------------------------------------

``Homotopy Set Theory'' -- first-stage approximation to Homotopy Type
Theory (\S\ref{sec:hott}): Propositions of OTT correspond to
$h$-propositions (\S\ref{sec:h_proposition}) of HoTT and Types of OTT
correspond to $h$-sets (\S\ref{sec:h_set}) in HoTT.

Equality based on Setoids (\S\ref{sec:setoid})--special case of Higher
Internal Groupoids (???)

Intensional (Definitional) Equality and Type Checking are Decidable

Propositional Equality is Extensional
(\S\ref{sec:extensional_equality}), i.e. Functions are Equal if they
are Point-wise (Observationally) Equal

Propositional Equality is \emph{Substitutive}: Coercion between Types
with Observationally Equivalent Subterms.

\emph{Canonicity}: any Closed Term is Definitionally Reducible to a
Canonical Value



% ====================================================================
\section{Modal Type Theory}\label{sec:modal_type_theory}
% ====================================================================

Modal Logic (\S\ref{sec:modal_logic})

Type Formation Rules for Modalities (\S\ref{sec:modality})

Closure Operator Modality (???)

Idempotent Monadic or Idempotent Comonadic (???)



% --------------------------------------------------------------------
\subsection{Modal Type}\label{sec:modal_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Functional Reactive Programming}\label{sec:frp}
% --------------------------------------------------------------------

%FIXME possibly move this? dynamical systems? control theory?

\fist \cite{winskel-nielsen93} refers to Distributed (Concurrent)
Systems as \emph{Reactive Systems}, see Process Calculus
(\S\ref{sec:process_calculus}) and Interaction Categories
(\S\ref{sec:interaction_category})
%FIXME

(FRP)

Pure Functions over Signals \S\ref{sec:signal} (Time-dependent Values)

Temporal Logic (\S\ref{sec:temporal_logic})

Linear Temporal Logic (LTL) (\S\ref{sec:linear_temporal})

LTL Propositions \emph{as} Types \\
Proofs of LTL Formulae \emph{as} FRP Programs \cite{jeffrey12},
(Jeltsch 11)

LTL Types express Temporal Behaviors of Programs, e.g. a Program which
must be used immediately, or one which may be used at some Time in the
Future \cite{jeffrey12} %FIXME clarify used

Fan Categories (\S\ref{sec:fan_category}) \cite{jeltsch12}

Hughes Arrows (\S\ref{sec:hughes_arrow}) with Loops (???): Type Class
(\S\ref{sec:constrained_type}) for Freyd Categories
(\S\ref{sec:freyd_category}), i.e. Premonoidal Categories
(\S\ref{sec:premonoidal_category}) with a Cartesian Center (???) and a
Premonoidal Trace (\S\ref{sec:category_trace}) -- defines the Dataflow
Structure but lacks Temporal Properties \cite{jeffrey12}
%FIXME

Reactive Programs form Proofs of Constructive LTL Properties
\cite{jeffrey12}

Implications in LTL give rise to Stateless Functions on Streams (???),
``Constrains'' Modality gives rise to Causal Functions
\cite{jeffrey12} %FIXME xref

Reactive Programs form a Partially-traced Monoidal Category
(\S\ref{sec:partially_traced}) \cite{jeffrey12}

Arrows with Loops where the Type System enforces that only Decoupled
Functions can be Looped \cite{jeffrey12}

Stateless Function $\Rightarrow$, Causal Function $\unrhd$, Decoupled
Function $\rhd$: expression as LTL Operators \cite{jeffrey12}

LTL Formulae: Reactive Types (\S\ref{sec:reactive_type})

Implementation in a Dependent Type Theory
(\S\ref{sec:dependent_type}): not efficiently executable as a Polling
Pull (???) implementation and also suffers from Time Leaks in that the
entire Input History must be recorded (and can't be Garbage Collected)
\cite{jeffrey12}

Push-pull FRP: underlying I/O model is Asynchronous



\subsubsection{Reactive Type}\label{sec:reactive_type}

\cite{jeffrey12}:

correspondance with Propositions of Linear Temporal Logic (LTL)
(\S\ref{sec:linear_temporal})

Loop Combinator: Cyclic Dataflow Graphs (???), Type of a Partial Trace
(\S\ref{sec:partial_trace}) %FIXME

\emph{Reactive Type}

Elements of $Time \rightarrow Set$

\begin{flalign*}
  \quad & RSet : Set_1 & \\
  \quad & RSet = Time \rightarrow Set \\
  \quad & \langle \rangle : Set \rightarrow RSet \\
  \quad & \langle A \rangle(t) = A \\
  \quad & \llbracket \rrbracket : RSet \rightarrow Set \\
  \quad & \llbracket A \rrbracket = \forall \{t\}A(t)
\end{flalign*}

$\langle A \rangle$ -- Constant Reactive Type for each Type $A$

$\llbracket A \rrbracket$ -- Reactive Type with Elements as Signals
(\S\ref{sec:signal}) $\sigma$ such that $\sigma\{t\} : A(t)$ for all
Times $t$; generalizes the Signal Type Constructor with Isomorphism:
\[
  Signal(A) \cong \llbracket \langle A \rangle \rrbracket
\]
$\llbracket \langle \rangle \rrbracket : Set \rightarrow Set$ is a
Monad (\S\ref{sec:monad}) as an Instance of the Read-only State Monad
where State is the current Time

Example Reactive Type:
\begin{flalign*}
  \quad & Past : RSet & \\
  \quad & Past(t) = \exists \{s\}(s \leq t)
\end{flalign*}

Type Combinators can be Pointwise Lifted (Lifting Monad?
\S\ref{sec:lifting_monad}) from Types to Reactive Types, e.g. Lifted
version of the $Maybe$ Type:
\begin{flalign*}
  \quad & E : RSet \rightarrow RSet & \\
  \quad & E(A)(t) = Maybe(A(t))
\end{flalign*}

Category of Reactive Types $\cat{RSet}$:
\begin{itemize}
  \item Objects: Reactive Types
  \item Morphisms: Elements of $\llbracket A \Rightarrow B \rrbracket$
  \item Identity and Composition: inherited Pointwise from $\cat{Set}$
\end{itemize}
The Cartesian-closed (\S\ref{sec:cartesian_closed}) Structure of
$\cat{Set}$ Lifts to $\cat{RSet}$ and $\langle \rangle$ gives rise to
a Functor from $\cat{Set}$ to $\cat{RSet}$.

Temporal Propositions \S\ref{sec:temporal_logic} (Propositions with
one Time Parameter) \emph{as} Reactive Types

Modalities (\S\ref{sec:modality}) of Linear-time Temporal Logic (LTL)
(\S\ref{sec:linear_temporal}) \emph{as} Reactive Type Combinators

Primitive Modalities:
\begin{itemize}
  \item $\ocircle \phi$ -- Next
  \item $\phi \;\until\; \psi$ -- Until
\end{itemize}

Derived Modalities:
\begin{itemize}
  \item $\lozenge \phi$ -- Future
  \item $\square \phi$ -- Globally: $\phi$ True at all Future Times
  \item $\phi \;\untileq\; \psi$ -- Non-strict Until
  \item $\phi \rhd \psi$ -- Constrains
  \item $\phi \unrhd \psi$ -- Non-strict Constrains
  \item $\phi \rightsquigarrow \psi$ -- Choice: Constructively defines
    a Choice Function, Classically collapses to $\Rightarrow$
\end{itemize}

Duals of $\ocircle$, $\untileq$, $\lozenge$, $\square$:
\begin{itemize}
  \item $\ominus \phi$ -- Yesterday: $\phi$ True at Time $s$ when True
    at Time $s - 1$
  \item $\phi \;\sinceeq\; \psi$ -- Non-strict Since
  \item $\minlozenge \phi$ -- Once: True when $\phi$ is True at some
    Past Time
  \item $\boxminus \phi$ -- Historically: True whenever $\phi$ is True
    at all Past Times
\end{itemize}

$\Rightarrow$, $\rhd$, and $\unrhd$ define Function Spaces:
\begin{itemize}
  \item $A \Rightarrow B$ -- \emph{Stateless Functions}: Output Value
    at Time $t$ depends only on Input Value at Time $t$; Implications
    in LTL
  \item $A \unrhd B$ -- \emph{Causal Functions}: Output Value at Time
    $t$ depends on History of Inputs (respect Equality up to the
    current Time); ``Constrains'' Modality
  \item $A \rhd B$ -- \emph{Decoupled Functions}: Output Value at Time
    $t$ depends on History of Inputs but cannot depend on Input Value
    at Time $t$
\end{itemize}

Derivations in Classical Logic:
\begin{align*}
  \lozenge A &= T \;\until\; A \\
  \square A &= \neg(\lozenge\neg A) \\
  A \; \untileq\; B &= A \;\until\; (A \wedge B) \\
  A \rhd B &= \neg(A \;\until\; \neg B) \\
  A \unrhd B &= A \neg(A \;\untileq\; \neg B) \\ %FIXME is this right?
  A \rightsquigarrow B &= \neg((A \wedge \neg B) \;\untileq\; T)
\end{align*}


\textbf{Combinators}

Signal Functions (\S\ref{sec:signal_function}) $f,g$:

$f \ggg g$, $f \&\&\& g$, and $loop f$ allow Dataflow Networks to be
built which can be visualized in any Traced Monoidal Category
(\S\ref{sec:traced_monoidal})

Example $clickMonitor$:
\begin{flalign*}
  \quad & clickMonitor : \llbracket \langle MouseButtonState \rangle
    \unrhd \langle MouseEvent \rangle \rrbracket & \\
  \quad & clickMonitor = arr (\cdot = up) \ggg edge \ggg tag(mouseClick)
\end{flalign*}

$\ggg$ and $\&\&\&$ respect Decoupling:
\begin{itemize}
  \item if $f:\llbracket A \rhd B \rrbracket$ and $g : \llbracket B
    \unrhd C \rrbracket$ then $f \ggg g : \llbracket A \rhd C
    \rrbracket$
  \item if $f:\llbracket A \unrhd B \rrbracket$ and $g : \llbracket B
    \rhd C \rrbracket$ then $f \ggg g : \llbracket A \rhd C
    \rrbracket$
  \item if $f:\llbracket A \rhd B \rrbracket$ and $g : \llbracket B
    \rhd C \rrbracket$ then $f \&\&\& g : \llbracket A \rhd B \wedge C
    \rrbracket$
\end{itemize}


\textbf{FRP Primitives}

$constant : \forall\{A,B\}\llbracket \square B
  \Rightarrow A \rhd B \rrbracket$

$localTime : \forall\{A\} \llbracket A \rhd
  \langle Time \rangle \rrbracket$

$initially : \forall\{A\} \llbracket A
  \Rightarrow A \unrhd A \rrbracket$

$decouple : \forall\{A\} \llbracket \ominus A
  \Rightarrow A \rhd \ominus A \rrbracket$

\emph{Nested Signals} via the $\square$ Modality indicates a
\emph{Stream} of Future Values, e.g. $\llbracket \square\square A
\rrbracket$ is Inhabited by Signals of Signals of Type $A$.

$decouple$ Primitive used to introduce minimal Decoupling, i.e. acts
as an Identity with a $1$ Unit delay.


\textbf{Feedback Loops}

\[
  \llbracket ((A \wedge B) \unrhd (A \wedge C))
    \Rightarrow B \unrhd C \rrbracket
\]
required to Satisfy the Equations of a Traced Premonoidal Category
(\S\ref{sec:traced_premonoidal})

Instance of the Type Class of Arrows (\S\ref{sec:hughes_arrow}) with
Loops

Consequence of the existence of Loops is that every Type is Inhabited,
e.g. defining:
\begin{flalign*}
  \quad & f : \llbracket (F \wedge T) \unrhd (F \wedge F) \rrbracket & \\
  \quad & f = arr[\lambda(x,y).(x,x)]
\end{flalign*}
and Tracing (???) $f$ gives a Function $T \unrhd F$ which can be used
to Inhabit the Empty Type. When this is not desired it can be avoided
by only giving Fixed Points to Decoupled Functions leading to a Type
for $loop$:
\begin{flalign*}
  \quad & loop : \forall\{A,B,C\} \llbracket ((A \wedge B)
    \rhd (A \wedge C)) \Rightarrow B \rhd C \rrbracket & \\
  \quad & loop f = (ifix(f \ggg fst) \&\&\& id) \ggg f \ggg snd
\end{flalign*}
where $ifix$ is the Function for Indexed Fixed Points.

Decoupled Functions form Contraction Maps
(\S\ref{sec:contraction_map}) in an Ultrametric Space
(\S\ref{sec:ultrametric_space}) of Functions and so have Fixed Points.

Because $loop$ can only be Applied to Decoupled Functions and not
Functions in general it does not form a Trace
(\S\ref{sec:category_trace}) and instead forms a Partial Trace
(\S\ref{sec:partial_trace}).


\asterism


Comonad Structure of $\square$:
\begin{flalign*}
  \quad & extend : \forall\{A,B\} \llbracket A \Rightarrow B \rrbracket
    \rightarrow \llbracket \square A
    \Rightarrow \square B \rrbracket & \\
  \quad & extract : \forall\{A\} \llbracket \square A
    \Rightarrow A \rrbracket \\
  \quad & duplicate : \forall\{A\} \llbracket \square A
    \Rightarrow \square\square A \rrbracket
\end{flalign*}

Applicative Structure of $\square$:
\begin{flalign*}
  \quad & [\cdot] : \forall\{A\} \llbracket A \rrbracket
    \rightarrow \llbracket \square A \rrbracket & \\
  \quad & (\cdot \langle * \rangle \cdot) : \forall\{A,B\}
    \llbracket \square (A \Rightarrow B) \Rightarrow \square A
    \Rightarrow \square B \rrbracket
\end{flalign*}

Comonad and Applicative Structure of $\square$ show that $\square$ is
a Model of $S4$ (Alethic) Modal Logic (\S\ref{sec:alethic_logic})

$\ocircle$, $\ominus$: Applicative Functors
(\S\ref{sec:applicative_functor})

$\lozenge$, $\minlozenge$: Applicative Monads
(\S\ref{sec:applicative_monad})

$\boxminus$: Applicative Comonad (\S\ref{sec:applicative_comonad})

Kleisli Category (\S\ref{sec:kleisli_category}) $\boxminus \cat{RSet}$:
\begin{itemize}
  \item Objects: Reactive Types
  \item Morphisms: Elements of $\llbracket \boxminus A \Rightarrow B
    \rrbracket$
  \item Identity and Composition: usual for Kleisli Construction
\end{itemize}

Enriched Categorical (\S\ref{sec:enriched_category}) Structure of
$\unrhd$ (with Hom-objects given by $\unrhd$): $arr$, $id$, $before$,
$after$, $\$$, $\ggg$

$\unrhd \cat{RSet}$:
\begin{itemize}
  \item Objects: Reactive Types
  \item Morphisms: Elements of $\llbracket A \unrhd B
    \rrbracket$
  \item Identity and Composition: as given by Enriched Category
    Structure of $\unrhd$
\end{itemize}

\begin{itemize}
  \item $\cat{Set}$: Morphisms are Witnesses of Implication with no
    place in Time
  \item $\cat{RSet}$: Morphisms are Witnesses of Implication whose
    Hypothesis is True at some Time $t$
  \item $\unrhd \cat{RSet}$: Morphisms are Witnesses of Implication
    whose Hypothesis is True over an Interval $[s,t]$
  \item $\boxminus \cat{RSet}$: Morphisms are Witnesses of Implication
    whose Hypothesis is True over an Interval $(-\infty,t]$
\end{itemize}
leads to (Embedding \S\ref{sec:category_embedding}) Functors:
\[
  \cat{Set} \hookrightarrow \cat{RSet} \hookrightarrow
    \unrhd\cat{RSet} \hookrightarrow \boxminus\cat{RSet}
\]
All have Finite Products inherited from $\cat{Set}$

All but $\unrhd\cat{RSet}$ are Cartesian Closed
(\S\ref{sec:cartesian_closed}): in $\cat{RSet}$, $\sinceeq$
(with its Arguments flipped) is Left-adjoint to $\unrhd$ so
$\cat{RSet}$ has a Closed Structure for $\unrhd$ even if
$\unrhd\cat{RSet}$ does not.


$\cat{RSet}$ inherits Coproducts from $\cat{Set}$

$\unrhd\cat{RSet}$ has Weak Coproducts

$\boxminus\cat{RSet}$ does not have Coproducts

\fist Note that the Embedding of $\unrhd\cat{RSet} \hookrightarrow
\boxminus\cat{RSet}$ requires the existence of a Least Element of Time
$-\infty$.

$\mathsf{C}$ -- Chop Modality on Paths; Interval Temporal Logic
(\S\ref{sec:interval_temporal})


\asterism


\textbf{Implementation}

Implementation uses Interval Types (\S\ref{sec:interval_type}) instead
of Reactive Types (\S\ref{sec:reactive_type}); Interval Temporal Logic
(\S\ref{sec:interval_temporal}) admits the Chop Modality $\mathsf{C}$
on Paths and may give a Cartesian Closed structure to $\unrhd$

For a Causal Function Space $A \unrhd B$ the State (???) of a Causal
Function is Modelled as a \emph{Process} of Type:
\[
  (A @ s \multimap B @ u)
\]
that has ``Received'' Input up to Time $s$ and ``Produced'' Output up
to Time $u$; initial State of a Causal Function at Time $t$ is a
Process where $s = t = u$. A Process can Terminate when $u = \infty$,
i.e. when it has ``Produced'' all its Output (even if $s \prec
\infty$).

Resumption Model of Concurrency (???)

(??? cf. Processes \S\ref{sec:process} in Process Calculus?)



\subsubsection{Interval Type}\label{sec:interval_type}

\cite{jeffrey12}:

\emph{Time Intervals}: Segments of Signals

$Time^\infty$ -- Type of Time Bounds, Extends $Time$ with $\infty$

$[s \prec t)$ -- \emph{Time Interval}

$i \sim j$ -- \emph{Concatenable Intervals}: $i = [s \prec t)$ and $j
    = [t \prec u)$

$i \frown j \because i \sim j$ -- \emph{Concatenation} of $i = [s
        \prec t)$ and $j = [t \prec u)$ is $[s \prec u)$



\emph{Interval Types}

\emph{Monotone Interval Type}

$MSet$

Non-monotone Semantics

Monotone Semantics



\subsubsection{Signal}\label{sec:signal}

\emph{Signal} (or \emph{Behavior})

$a$-valued Behavior: $Time \rightarrow a$

\cite{jeffrey12}:

gives rise to an Event Stream (\S\ref{sec:frp_event})

\begin{flalign*}
  \quad & Signal : Set \rightarrow Set & \\
  \quad & Signal(A) = Time \rightarrow A
\end{flalign*}

$Time$ forms a Decidable Total Order:
\begin{flalign*}
  \quad & Time : Set & \\
  \quad & \leq : Time \rightarrow Time \rightarrow Set \\
  \quad & + : Time \rightarrow \nats \rightarrow Time \\
  \quad & - : Time \rightarrow Time \rightarrow \nats
\end{flalign*}

assuming a Discrete Time Model: Termination Property of $fix$

Dense Time FRP: $\epsilon$-decoupled Functions for some $0 <
\epsilon$; \emph{Zeno Processes} perform Output which is successively
smaller; \emph{Zeno Event Signals}

Isomorphism with Reactive Type (\S\ref{sec:reactive_type})
Constructors:
\[
  Signal(A) \cong \llbracket \langle A \rangle \rrbracket
\]

$\llbracket \langle \rangle \rrbracket : Set \rightarrow Set$ is a
Monad (\S\ref{sec:monad}) as an Instance of the Read-only State Monad
where State is the current Time

Signals of Signals give rise to Signals

Continuous Behaviors

Discrete Behaviors: \emph{Events} (\S\ref{sec:frp_event})



\paragraph{Signal Function}\label{sec:signal_function}\hfill

or \emph{Reactive Function}

\cite{jeffrey12}:

Functions from Signals to Signals

Functions required to be Causal Functions $A \unrhd B$:
\begin{flalign*}
  \quad & SF : Set \rightarrow Set \rightarrow Set & \\
  \quad & SF(A,B) = (f : Signal(A) \rightarrow
    Signal(B)) \times (Causal (f))
\end{flalign*}

Causal Functions respect Equivalence up to the current Time

$SF(A,B)$ encoded in LTL over the past:
\[
  SF(A,B) \cong \llbracket \boxminus\langle A \rangle
    \Rightarrow \langle B \rangle \rrbracket
\]
gives a Semantics for Signal Functions in $\boxminus\cat{RSet}$ and
$\boxminus\cat{RSet}$ is compatible with Hughes Arrows
(\S\ref{sec:hughes_arrow}) as any Category with Finite Products is
trivially a Freyd Category (\S\ref{sec:freyd_category})

$SF$ modified with $era$ Parameter (Jeltsch 09):
\begin{flalign*}
  \quad & SF' : Set \rightarrow Set \rightarrow Time
    \rightarrow Set & \\
  \quad & SF' (A,B,s) = (f : Signal(A) \rightarrow
    Signal(B)) \times (Causal_s(f))
\end{flalign*}
$SF'(A,B,s)$ encoded in LTL:
\[
  SF'(A,B) \cong \langle A \rangle \unrhd \langle B \rangle
\]
has a Semantics in $\unrhd\cat{RSet}$ which also satisfies the
requirements of Arrows.

Decoupled Functions are a Subset of Signal Functions:
\begin{flalign*}
  \quad & SF'' : Set \rightarrow Set \rightarrow Time
    \rightarrow Set & \\
  \quad & SF'' (A,B,s) = (f : Signal(A) \rightarrow
    Signal(B)) \times (Decoupled_s(f))
\end{flalign*}
$SF'(A,B,s)$ encoded in LTL:
\[
  SF''(A,B) \cong \langle A \rangle \rhd \langle A \rangle
\]

\fist Note that $\rhd\cat{RSet}$ is not a Category as it has
Composition but not Identities (Identity Function is only Decoupled on
Singleton Types), cf. Contraction Maps in a Complete Metric Space:
Identities are Non-expanding but not Contracting
%FIXME xref


\textbf{Combinators}

Signal Functions $f,g$:

$f \ggg g$, $f \&\&\& g$, and $loop f$ allow Dataflow Networks to be
built which can be visualized in any Traced Monoidal Category
(\S\ref{sec:traced_monoidal})



\subsubsection{Event}\label{sec:frp_event}

\cite{jeffrey12}:

Discrete Behaviors

Signal gives rise to an \emph{Event Stream}


Semantics given by Signals of Type $E A$ where:
\begin{flalign*}
  \quad & E : RSet \rightarrow RSet & \\
  \quad & E(A)(t) = Maybe(A(t))
\end{flalign*}
A Signal of Type $E A$ at Time $t$ is either $Nothing$ (no Event has
arrived) or $Just(a)$ (an Event of $a$ of Type $A(t)$ has arrived).

Example:
\[
  mouseClick : \llbracket E \langle MouseEvent \rangle \rrbracket
\]


\textbf{Event Primitives}

$never : \forall\{A,B\} \llbracket A \rhd E B \rrbracket$

$now : \forall\{A,B\} \llbracket B \Rightarrow A \rhd E B \rrbracket$

$later : \forall\{A,B\} \llbracket \lozenge B
  \Rightarrow A \rhd E B \rrbracket$

$tag : \forall\{A,B\} \llbracket \square B \Rightarrow
  E A \unrhd E B \rrbracket$

$edge : \llbracket [Bool] \unrhd E T \rrbracket$ -- converts Signals
  into Events

$hold : \forall\{A\} \llbracket A \Rightarrow E A
  \rhd \minlozenge A \rrbracket$ -- converts Events into Signals


\textbf{Switching}

starting and stopping Signal Functions based on Events

Switching Combinators:

$switch : \forall\{A,B,C\} \llbracket (A \unrhd (B \wedge E C))
  \Rightarrow \square(C \Rightarrow (A \unrhd B))
  \Rightarrow (A \unrhd B) \rrbracket$ -- only React to the first
  Switching Event

$rswitch : \forall\{A,B\} \llbracket (A \unrhd B)
  \Rightarrow (A \wedge E(A \unrhd B)) \unrhd B \rrbracket$ -- React
  on every Switching Event

Example Function which Returns True after an Event has occurred:
\[
  switch(constant[False] \&\&\& id)[\lambda x.constant[True]]
\]



% ====================================================================
\section{Homotopy Type Theory}\label{sec:hott}
% ====================================================================

Homotopy Theory (\S\ref{sec:homotopy})

- Function Extensionality
- Univalence Axiom (\S\ref{sec:univalence_axiom})

- Values (Points), Paths, Homotopies

- Internal Language of Higher Categories
(\S\ref{sec:higher_category}).

Homotopy Types Model $\infty$-groupoids
(\S\ref{sec:infinity_groupoid})

Categorical Semantics (\S\ref{sec:categorical_semantics})

nLab:

Observational Type Theory (\S\ref{sec:observational_type}) is a
first-step approximation to Homotopy Type Theory: Propositions of OTT
correspond to $h$-propositions (\S\ref{sec:h_proposition}) of HoTT and
Types of OTT correspond to $h$-sets (\S\ref{sec:h_set}) of HoTT.

Homotopy Levels (\S\ref{sec:homotopy_level}), Homotopy Type
(\S\ref{sec:homotopy_type}):

$h$-level 1: $h$-proposition (\S\ref{sec:h_proposition})

$h$-level 2, Homotopy $0$-type (\S\ref{sec:homotopy_0type}): $h$-set
(\S\ref{sec:h_set})

$h$-level 3, Homotopy $1$-type (\S\ref{sec:homotopy_1type}):
$h$-groupoid (\S\ref{sec:h_groupoid})



% --------------------------------------------------------------------
\subsection{$h$-proposition}\label{sec:h_proposition}
% --------------------------------------------------------------------

$h$-level 1

nLab:

(or \emph{Mere Proposition})

Internalization of notion of Proposition (\S\ref{sec:proposition}),
i.e. Semantically corresponding to $(-1)$-truncated Objects
(\S\ref{sec:truncated_object})

Propositions of Observational Type Theory
(\S\ref{sec:observational_type}) correspond to $h$-propositions of HoTT



% --------------------------------------------------------------------
\subsection{$h$-set}\label{sec:h_set}
% --------------------------------------------------------------------

Types in Observational Type Theory (\S\ref{sec:observational_type})
correspond to $h$-sets of HoTT



% --------------------------------------------------------------------
\subsection{$h$-groupoid}\label{sec:h_groupoid}
% --------------------------------------------------------------------

Groupoid (\S\ref{sec:groupoid})



% --------------------------------------------------------------------
\subsection{Higher Inductive Type}\label{sec:higher_inductive_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Inference Rules}\label{sec:homotopy_rules}
% --------------------------------------------------------------------

Inference Rules (\S\ref{sec:type_inference}) have the form:
\[
  \frac{J_1 \quad \cdots \quad J_k} {J} Name
\]
where $J_i$ are provided as derived hypothetical (metatheoretical)
Judgements and $J$ is the conclusion.

A Tree constructed from Inference Rules forms a Derivation
(\S\ref{sec:typing_derivation}) of a Judgement.



\textbf{Context Rules}

The following Rules of Inference allow for the determination of a
Well-formed Context:
\begin{enumerate}
\item
\[
  {
    \frac{}{(.)ctx}
  } ctx-EMP
\]
\item
\[
  {
    \frac
    {x_1:A_1, \ldots, x_{n-1}:A_{n-1} \vdash A_n : \class{U}_i}
    {(x_1:A_1,\ldots,x_n:A_n) ctx}
  } ctx-EXT
\]
\end{enumerate}



\textbf{Structural Rules}

Given a Context, derive Typing Judgements
(\S\ref{sec:typing_judgement}) listed in the Context:
\[
  {
    \frac
    {(x_1:A_1, \ldots, x_n:A_n)ctx}
    {x_1:A_1, \ldots, x_n:A_n \vdash x_i:A_i}
  } Vble
\]

Substitution for Typing Judgements:
\[
  {
    \frac
    {\Gamma \vdash a : A \;\;\;\;\;\;\;
    \Gamma,x:A,\Delta \vdash b : B}
    {\Gamma,[a/x]\Delta \vdash [a/x]b : [a/x]B}
  } Subst_1
\]

Weakening for Typing Judgements:
\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i \;\;\;\;\;\;\;
    \Gamma,\Delta \vdash b : B}
    {\Gamma,x:A,\Delta \vdash b:B}
  } Wkg_1
\]

Substitution for Judgemental Equality:
\[
  {
    \frac
    {\Gamma \vdash a : A \;\;\;\;\;\;\;
    \Gamma,x:A,\Delta \vdash b \equiv c : B}
    {\Gamma,[a/x]\Delta \vdash [a/x]b \equiv [a/x]c : [a/x]B}
  } Subst_2
\]

Weakening for Judgemental Equality:
\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i \;\;\;\;\;\;\;
    \Gamma,\Delta \vdash b \equiv c : B}
    {\Gamma, x:A, \Delta \vdash b \equiv c : B}
  } Wkg_2
\]



\textbf{Universe Rules}

\[
  {
    \frac
    {(\Gamma) ctx}
    {\Gamma \vdash \class{U}_i : \class{U}_{i+1}}
  } \class{U}-INTRO
\]

\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i}
    {\Gamma \vdash A : \class{U}_{i+1}}
  } \class{U}-CUMUL
\]



\textbf{Dependent Function Type Rules}

\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i \;\;\;\;\;\;\;
    \Gamma,x:A \vdash B : \class{U}_i}
    {\Gamma \vdash \prod_{(x:A)} B : \class{U}_i}
  } \Pi-FORM
\]\[
  {
    \frac
    {}
    {}
  } \Pi-INTRO
\]\[
  {
    \frac
    {}
    {}
  } \Pi-ELIM
\]\[
  {
    \frac
    {}
    {}
  } \Pi-COMP
\]\[
  {
    \frac
    {}
    {}
  } \Pi-UNIQ
\]



% --------------------------------------------------------------------
\subsection{Univalence Axiom}\label{sec:univalence_axiom}
% --------------------------------------------------------------------

``Identity is Equivalent to Equivalence''

``Equivalent Types are Identical''
\[
  (A = B) \simeq (A \simeq B)
\]
where $A = B$ is notation for the Type $Id_U(A,B)$ where $U$ is the
Universe containing $A$ and $B$.



% --------------------------------------------------------------------
\subsection{Opetopic Type Theory}\label{sec:opetopic_typetheory}
% --------------------------------------------------------------------

Internal Language of $\infty$-categories
(\S\ref{sec:infinity_category})



% ====================================================================
\section{Metaprogramming}\label{sec:metaprogramming}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Reflection}\label{sec:type_reflection}
% --------------------------------------------------------------------

Type Introspection (???) + Manipulation

Monadic Reflection (\S\ref{sec:monadic_reflection})
