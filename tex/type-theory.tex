%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Type Theory}\label{part:type_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Type Theory} is the study of Classes of Formal Systems
(\S\ref{sec:formal_system}) where each Term (\S\ref{sec:term}) has a
\emph{Type} (\S\ref{sec:type}) and Operations are restricted to Terms
of specific Types.

A Type Theory may have two Signatures: $\sigma_\tau$ for Type Symbols
and $\sigma_o$ for Object (Term) Symbols. From this one may construct
a Monad $R = R_{\sigma_o}$, a Module over $R$: $LM =
LM_{\sigma_\tau,\sigma_o}$, and a Contextual Category
(\S\ref{sec:contextual_category}) $CC(R,LM)$ describing a Class of
Sub-quotients of $CC(R,LM)$ in terms of Objects Constructed from $R$
and $LM$. \cite{voevedsky14}

As a Formal Theory (\S\ref{sec:formal_theory}), Judgements
(\S\ref{sec:judgement}) in Type Theory are of three
kinds\cite{hott13}:
\begin{enumerate}

\item \emph{Well-formed Context} (\S\ref{sec:type_context}):
  \[
    (\Gamma) ctx
  \]
  ``$\Gamma$ is a Well-formed Context''

\item \emph{Propositional Equality} (Typing Judgement
    \S\ref{sec:typing_judgement}):
  \[
    \Gamma \vdash a : A
  \]
  ``Given Contex $\Gamma$, $a$ is a Term of Type $A$''

\item \emph{Definitional (Judgemental) Equality}:
  \[
    \Gamma \vdash a \equiv b : A
  \]
  ``Given Context $\Gamma$, $a$ and $b$ are Definitionally Equal Terms
  of Type $A$''

\end{enumerate}
with a Deductive Apparatus (\S\ref{sec:deductive_apparatus})
consisting of Inference Rules (\S\ref{sec:type_inference}) only and no
Axioms. Judgemental Equality is an Equivalence Relation respected by
Typing.



\textbf{Intensional \& Extensional Type Theory}

\begin{itemize}
\item \emph{Extensional Type Theory} (\S\ref{sec:extensional_type}):
  Definitional (Computational) Equality is not distinguished from
  Propositional (Proof) Equality (Strict Equivalence) but Type Checking
  (\S\ref{sec:type_checking}) is Undecidable; see also
  \emph{Observational Type Theory} (\S\ref{sec:observational_type})
\item \emph{Intensional Type Theory}: Type Checking is Decidable but
  Extensional Reasoning must be carried out using Setoids
  (\S\ref{sec:setoid}); (Weak Equivalence)
\item \emph{Homotopy Type Theory} (\S\ref{sec:homotopy_type_theory}):
  Higher Inductive Types (\S\ref{sec:higher_inductive_type}) allow
  definition of Higher-order Constructors
\end{itemize}

Term Rewrite System (\S\ref{sec:term_rewriting})

\emph{Conversion Rules}

\emph{Canonical Form} (\S\ref{sec:canonical_form})

\emph{Normal Form}


Meaning Explanation (\S\ref{sec:meaning_explanation})



% ====================================================================
\section{Expression}\label{sec:type_expression}
% ====================================================================

An \emph{Expression} is an Equivalence Class of Syntactic forms which
differ in the names of \emph{Bound Variables}. That is, changing the
name of a Bound Variable everywhere within an Expression
(\emph{$\alpha$-conversion}) does not change the Expression.

A Variable is Bound in an Expression by an \emph{Abstraction}
expressing that the Variable is \emph{local} to the Expression:
\[
  \lambda x.B
\]
or:
\[
  x.B
\]

\emph{Substitution}:
\[
  [a/x]B
\]
Substitute Term $a$ for Free occurrences of Variable $x$ in the Term
$B$. Generalized:
\[
  [a_1,\ldots,a_n / x_1,\ldots,x_n]B
\]



% --------------------------------------------------------------------
\subsection{Term Constant}\label{sec:term_constant}
% --------------------------------------------------------------------

A \emph{Term Constant} is a Term that is a Base Type
(\S\ref{sec:type_constant})
% FIXME ???



% --------------------------------------------------------------------
\subsection{Well-typed Term}\label{sec:well_typed}
% --------------------------------------------------------------------

A \emph{Well-typed Term} (or \emph{Typable Term}) is a Term for which
a Typing Derivation (\S\ref{sec:typing_derivation}) exists.



% ====================================================================
\section{Type}\label{sec:type}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Type Constant}\label{sec:type_constant}
% --------------------------------------------------------------------

\emph{Type Constant} (or \emph{Base Type} or \emph{Atomic Type})

Uninterpreted (\S\ref{sec:uninterpreted_function}) % FIXME



% --------------------------------------------------------------------
\subsection{Principal Type}\label{sec:principal_type}
% --------------------------------------------------------------------

Type System with Principal Type Property

given a Term, all other Types are instances of the Principal Type

Type Inference

%FIXME xref
Robinson's Unification Algorithm, used by Hindley-Milner Type
Inference

Polymorphic Recursion makes Inference of the Principal Type Undecidable

Generalized Algebraic Data Types negates the Principal Type Property



% --------------------------------------------------------------------
\subsection{Type Order}\label{sec:type_order}
% --------------------------------------------------------------------

In Simply-typed $\lambda$-calculus ($\lambda^\rightarrow$), the
\emph{Order} of a Type $\tau$, denoted $o(\tau)$, is defined
Inductively as:
\begin{itemize}
\item $o(T) = 0$ if $T$ is a Base Type
\item $o(\sigma \rightarrow \tau) = \text{max}(o(\sigma) + 1,
  o(\tau))$
\end{itemize}



% --------------------------------------------------------------------
\subsection{Inhabited Type}\label{sec:inhabited_type}
% --------------------------------------------------------------------

\emph{Inhabited}

In Simply-typed $\lambda$-calculus (\S\ref{sec:simply_typed}), a Type
is Inhabited if and only if its corresponding Proposition is a
Tautology of Minimal Implicative Logic (\S\ref{sec:minimal_logic}).

In Second-order $\lambda$-calculus (\S\ref{sec:system_f}), a
Type is Inhabited if and only if its corresponding Proposition is a
Tautology of Second-order Logic (\S\ref{sec:secondorder_logic}).



% --------------------------------------------------------------------
\subsection{Finite Type}\label{sec:finite_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Infinite Type}\label{sec:infinite_type}
% --------------------------------------------------------------------

Infinite Data Type (\S\ref{sec:infinite_datatype})



% --------------------------------------------------------------------
\subsection{Equality Type}\label{sec:equality_type}
% --------------------------------------------------------------------

The \emph{Equality Type} (or \emph{Identity Type}), denoted
\emph{Propositional Equality}, represents Equality of Types and Terms.

$a =_A b$: ``$a$ and $b$ are Equal Objects of Type $A$''

Martin-L\"of Notation $I(A,a,b)$

For $a,b:A$, the Term $a = b : I(A,a,b)$ Denotes the Type of Equality
Proofs for ``$a$ is Equal to $b$''. If the Type $I(A,a,b)$ is
Inhabited (a Proof exists), then $a$ is Equal to $b$.

There is one Canonical Inhabitant of $I(A,a,a)$ (Proof of
Reflexivity):
\[
  \text{refl}: \prod_{a:A} (a=a)
\]



% --------------------------------------------------------------------
\subsection{Power Type}\label{sec:power_type}
% --------------------------------------------------------------------

$P A$ the Type of all Subtypes (\S\ref{sec:power_type}) of $A$



% --------------------------------------------------------------------
\subsection{Data Type}\label{sec:data_type}
% --------------------------------------------------------------------

\subsubsection{Recursive Data Type}\label{sec:recursive_datatype}

or (\emph{Inductive Data Type})

Values may contain Values of the same Type

Well-founded (\S\ref{sec:well_founded})



\paragraph{Tree}\label{sec:tree_type}
\hfill \\

Tree (Graph Theory \S\ref{sec:tree})

Mutally Recursive Defenition: Forest (\S\ref{sec:forest_type})



\paragraph{Mutually Recursive Data Type}\label{sec:mutually_recursive_datatype}

\subparagraph{Forest}\label{sec:forest_type}

Tree (\S\ref{sec:tree_type})



\paragraph{Isorecursive Data Type}\label{sec:isorecursive_datatype}

\paragraph{Equirecursive Data Type}\label{sec:equirecursive_datatype}



\paragraph{Infinite Data Type}\label{sec:infinite_datatype}
\hfill \\

(Proof Object) Definition by Recursion: Proof by Induction



\subsubsection{Composite Data Type}\label{sec:composite_datatype}

\subsubsection{Algebraic Data Type}\label{sec:algebraic_datatype}

Trees (\S\ref{sec:tree})

$W$ Type

All standard Algebraic Data Types are Functors (\S\ref{sec:functor}).
A Parametrically Polymorphic (\S\ref{sec:parametric_polymorphism})
Function between two such Functors is a Natural Transformation
(\S\ref{sec:natural_transformation}).

Algebraic Data Types form a Semiring (\S\ref{sec:semiring})



\paragraph{Sum Type}\label{sec:sum_type}
\hfill \\

(or \emph{Variant Type} or \emph{Tagged Union})

Corresponds to Disjoint Union (\S\ref{sec:disjoint_union})

Coproduct (\S\ref{sec:coproduct})

Choices, Multiple ``Classes'' of Data



\paragraph{Product Type}\label{sec:product_type}
\hfill \\

(or \emph{Record Type})

(Cartesian) Product Types: Structs, Tuples

If $\sigma$ and $\tau$ are Types, then $\sigma \times \tau$ is a Type

$x : \sigma$, $y : \tau$, $(x,y) : \sigma \times \tau$

$fst_{\sigma,\tau} : (\sigma \times \tau) \Rightarrow \sigma$

$snd_{\sigma,\tau} : (\sigma \times \tau) \Rightarrow \tau$

Corresponds to Cartesian Product (\S\ref{sec:cartesian_product})

Product Type $A \times B$ is a special case of Dependent Sum Type
(\S\ref{sec:sigma_type}) $\Sigma_{(x:A)}B$ with a Constant Codomain
Type $B$:
\[
  \Sigma_{(x:A)} B \equiv A \times B
\]
where $\equiv$ is Judgemental Equality.



\paragraph{Coproduct Type}\label{sec:coproduct_type}
\hfill \\

%FIXME sum type?



\paragraph{Quotient Type}\label{sec:quotient_type}
\hfill \\

Set Theoretic Quotients

Categorical Semantics: Quotient Object (\S\ref{sec:quotient_object}) /
Coequalizer (\S\ref{sec:coequalizer})



\subsubsection{Generalized Algebraic Data Type}\label{sec:gadt}

\subsubsection{Logically Qualified Data Type}
\label{sec:logically_qualified}\cite{rondon-kawaguchi-jhala08}

\emph{Liquid Type}

Predicate Abstraction (\S\ref{sec:predicate_abstraction})

Logical Qualifier: Boolean Predicate

Dependent Type where the Refinement Predicate
(\S\ref{sec:refinement_type}) is a Conjunction of Logical Qualifiers.

Value Variable

Base Refinement:
\[
  \{ v : B | e \}
\]
where $e$ is a Boolean-valued Expression constraining $v$ called a
\emph{Refinement Predicate}.



% --------------------------------------------------------------------
\subsection{Data Constructor}\label{sec:data_constructor}
% --------------------------------------------------------------------

A \emph{Constructor} Introduces a Data Type on the right-hand side of
a definition.

A \emph{Destructor} Eliminates a Data Type on the left-hand side of a
definition.

Elimination for (Finite) Data corresponds to (Well-founded)
Recursion.

Introduction for Codata corresponds to Corecursion.



% --------------------------------------------------------------------
\subsection{Congruence Type}\label{sec:congruence_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Universe Type}\label{sec:universe_type}
% --------------------------------------------------------------------

A \emph{Universe Type} contains all other Types, see Type Universe
(\S\ref{sec:type_universe}).



% --------------------------------------------------------------------
\subsection{Inductive Type}\label{sec:inductive_type}
% --------------------------------------------------------------------

Monotonic Type Function $\Theta : \sigma \Rightarrow \tau$

Initial Algebras (\S\ref{sec:initial_algebra})

Type Constructor (\S\ref{sec:type_constructor})

Structural Recursion (\S\ref{sec:structural_recursion})

Streams between interacting processes in Programming Languages



\subsubsection{Coinductive Type}\label{sec:coinductive_type}

\emph{Coinductive Type} (\emph{Codata}), Coinduction
(\S\ref{sec:coinduction})



\subsubsection{Induction Induction}\label{sec:induction_induction}

\emph{Induction Induction}



\subsubsection{Induction Recursion}\label{sec:induction_recursion}

\emph{Induction Recursion}



\subsubsection{Initial \& Final Type}\label{sec:initial_final_type}

\emph{Initial Data Types} are defined by the Least Fixed Point
(\S\ref{sec:least_fixedpoint}), up to Isomorphism given by an Initial
Algebra (\S\ref{sec:initial_algebra}), of a Type Function
(\S\ref{sec:type_function}). Ordinary Recursion
(\S\ref{sec:recursion}) defines Recursive Functions with an Initial
Data Type for a Domain.

\emph{Final Data Types} are defined, up to Isomorphism given by a
Final Coalgebra (\S\ref{sec:terminal_coalgebra}) by the Greatest
Fixpoint. Corecursion (\S\ref{sec:corecursion}) defines Recursive
Functions with a Final Data Type as a Codomain.

Initial (\S\ref{sec:initial_object}) \& Terminal
(\S\ref{sec:terminal_object}) Objects

In $\mathbf{Set}$, the Final Data Types may have Infinite,
Non-well-founded (\S\ref{sec:non_wellfounded}) Values.

In $\mathbf{Cpo}$ (the Category of Complete Partial Orders
\S\ref{sec:complete_partialorder} and Continuous Functions), Final
Types coincide with Initial Types and the corresponding Initial
Algebra and Final Coalgebras are Isomorphic.



% --------------------------------------------------------------------
\subsection{Concrete Type}\label{sec:concrete_type}
% --------------------------------------------------------------------

\HandRight\; Cf. Abstract (Existential) Type (\S\ref{sec:abstract_type})



% --------------------------------------------------------------------
\subsection{Abstract Type}\label{sec:abstract_type}
% --------------------------------------------------------------------

\emph{Abstract Type} (or \emph{Existential Type})

Type in a Nominal Type System (\S\ref{sec:nominal_type_system}) that
cannot be Instantiated (\S\ref{sec:instantiation}) directly.

Existentially Quantified Type Variable

Programming: Module Interfaces

Second-order Typed $\lambda$-calculus with Existential Quantification
(whereas System $F$ is Second-order Typed $\lambda$-calculus with
Universal Quantification.

a Type that is not Abstract is a Concrete Type
(\S\ref{sec:concrete_type})

Abstract Type with no Implementation: Protocol, Interface, etc.



\subsubsection{Abstract Data Type}\label{sec:abstract_datatype}

Type defined by certain Properties %FIXME

Type (with associated Operations) whose Representation is hidden

Co-algebra (\S\ref{sec:coalgebra})

\begin{itemize}
  \item Primitive Types in certain Programming Languages (e.g. Haskell)
  \item Parameterized Data Types (\S\ref{sec:parametric_datatype}, a
    weak form of Abstract Data Type)
  \item Type Class (Constrained Type \S\ref{sec:constrained_type})
\end{itemize}

Monads (\S\ref{sec:monad}) give the Interface to the Abstract Data
Type of ``Program Fragments'' (\HandRight\; Cf. Algebraic Effects
\S\ref{sec:algebraic_effect})



\paragraph{Parametric Data Type}\label{sec:parametric_datatype}
\hfill \\

\emph{Parametric Data Type} (or \emph{Parameterized Data Type} or
\emph{Generic Data Type})

Weak form of Abstract Data Type

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism})



\paragraph{Constrained Type}\label{sec:constrained_type}
\hfill \\

\emph{Type Class}

Ad-hoc Polymorphism \S\ref{sec:adhoc_polymorphism}) (Function
Overloading)



\subparagraph{Functional Dependency}\label{sec:functional_dependency}
\hfill \\

used to Constrain the Parameters (dependcies between the Parameters)
of a (Multi-parameter) Type Class

%FIXME xref relational database theory



% --------------------------------------------------------------------
\subsection{Polymorphic Type}\label{sec:polymorphic_type}
% --------------------------------------------------------------------

$\tau \mapsto \sigma$

Introduction:
\[
  {
  \frac{
    \begin{matrix}
      x : \sigma \\
      \vdots \\
      b : B
    \end{matrix}
  }
  {b : \sigma \mapsto \tau}
  }(\mapsto I)
\]

Terms depending on Types, e.g.:
\[
  x:\tau \vdash id(x):\tau
\]
where the Type of the Term $id(x)$ is $\tau$, which is dependent on
the Type $\tau$ of $x$, where the Type of $id$:
\[
  id:\sigma \rightarrow \sigma
\]
is Universally Quantified ``$\forall \sigma$''
(\S\ref{sec:parametric_polymorphism}).

Dependent Product Type (\S\ref{sec:pi_type})

Second-order $\lambda$-calculus (\S\ref{sec:system_f})

Subtyping (\S\ref{sec:subtype})

Variance (\S\ref{sec:type_variance})

Ad-hoc Polymorphism (\S\ref{sec:adhoc_polymorphism})

Restricted Rank

Rank-1 \emph{Prenex Polymorphism}: Type Variables may not be
instantiated with Polymorphic Types.

Rank-$k$: Quantifier may not appear to the left of $k$ or more Arrows;
Type Inference is decidable for Rank-2 but Rank-3 and above is not

Rank-$n$: Quantifier may appear to the left of arbitrarily many Arrows

Predicative: a Type $\tau$ containing a Type Variable $\alpha$ may not
have $\alpha$ Instantiated to a Polymorphic Type (Martin-L\"of Type
Theory \S\ref{sec:intuitionistic_type} and NuPRL).

Impredicative \emph{First-class Polymorphism}: Self-referential
(System F \S\ref{sec:system_f})

Parametric (\S\ref{sec:parametric_polymorphism}): Universal
Quantification

Existential (\S\ref{sec:abstract_type}): Existential Quantification

The Type $(\exists x : A).B$ is inhabited by Pairs $(a,b)$ with $a:A$
and $b:B[a/x]$, i.e. the Sum of the Types $B(x)$ as $x$ ranges over
$A$ \emph{or} the Subset of $A$ consisting of those $a \in A$ with the
Property $B[a/x]$.

Bounded Quantification (\S\ref{sec:bounded_polymorphism})



\subsubsection{Subtype}\label{sec:subtype}

\emph{Intersection Type}

\emph{Subtype Polymorphism}

System $F_{<:}$ (\S\ref{sec:system_fsub})

Bounded Polymorphism (\S\ref{sec:bounded_polymorphism})

Subtyping Judgement:
\[
  \Gamma \vdash \tau_1 \preceq \tau_2
\]

Power Type (\S\ref{sec:power_type}) $P A$: Type of all Subtypes of $A$



\paragraph{Variance}\label{sec:type_variance}
\hfill \\

\emph{Variance} describes how Type Constructors either preserve,
reverse, or ignore Subtyping on input Types.

\begin{itemize}
  \item \emph{Covariant}: Preserves Subtyping
  \item \emph{Contravariant}: Reverses Subtyping
  \item \emph{Bivariant}: Both Subtypes
  \item \emph{Invariant}: No Subtyping
\end{itemize}

$(\rightarrow)$ is Contravariant on the Input Type and Covariant on
the Output Type.



\paragraph{Refinement Type}\label{sec:refinement_type}
\hfill \\

Predicate assumed to hold for any Element of Refined Type

cf. Behavioral Subtyping (\S\ref{sec:behavioral_subtype})

Type Targeted Testing, Liquid Types (Logically Qualified Types
\S\ref{sec:logically_qualified})



\subparagraph{Predicate Subtype}\label{sec:predicate_subtype}



\paragraph{Behavioral Subtype}\label{sec:behavioral_subtype}
\hfill \\

\emph{Substitutability}



\subsubsection{Parametric Polymorphism}
\label{sec:parametric_polymorphism}

\emph{Generic Function}

Parametric Datatype (\S\ref{sec:parametric_datatype})

Uniformaly for all Types (``for all''); used to define Natural
Transformations (\S\ref{sec:natural_transformation}) in Programming
Languages

Universally Quantified Type Variable

Type-level Function Abstraction $\Lambda$

Second-order $\lambda$-calculus (System F \S\ref{sec:system_f})

Bounded (\S\ref{sec:bounded_polymorphism}) Parametric Polymorphism



\subsubsection{Ad-hoc Polymorphism}\label{sec:adhoc_polymorphism}

\emph{Function Overloading}, \emph{Operator Overloading}

Polymorphic Functions (\S\ref{sec:polymorphic_function}) applied to
Terms of different Types

Ad-hoc Polymorphism is contrasted with Parametric Polymorphism by
supporting a limited number of distinct Types rather than any Type
whatsoever.

Constrained Type (Abstract Data Type \S\ref{sec:constrained_type})



\subsubsection{Bounded Polymorphism}\label{sec:bounded_polymorphism}

\emph{Bounded Quantification} (or \emph{Bounded Polymorphism} or
\emph{Constrained Genericity})

Bounds on Type Parameters to range only over Subtypes
(\S\ref{sec:subtype}) of a particular Type

Type Class (\S\ref{sec:constrained_type})



\subsubsection{Higher-rank Impredicative Polymorphism}
\label{sec:higherrank_impredicative}

\emph{Higher-rank Impredicative Polymorphism} (most general)



\subsubsection{Predicative Prenex Polymorphism}
\label{sec:predicative_prened}

\emph{Predicative Prenex Polymorphism} (Restricted Rank and
Predicative)

``\emph{Let-polymorphism}''



\subsubsection{Polymorphic Function}\label{sec:polymorphic_function}

A Polymorphic Function has a Dependent Product Type
(\S\ref{sec:pi_type}):
\[
  \Pi_{(A:\class{U})} A \rightarrow C
\]



\paragraph{Polymorphic Recursion}\label{sec:polymorphic_recursion}
\hfill \\

Recursive Parametrically Polymorphic Function

Type Inference under Polymorphic Recursion is Undecidable (equivalent
to Semi-unification) %FIXME



\paragraph{Free Theorem}\label{sec:free_theorem}



% --------------------------------------------------------------------
\subsection{Type Function}\label{sec:type_function}
% --------------------------------------------------------------------

\emph{Type Function} (or \emph{Type Operator})

Adding additional Type Operators to Simply-typed Lambda Calculus
results in \emph{Simply-typed Lambda Calculus with Type Operators}
``$\lambda \underline{\omega}$'' (\S\ref{sec:simplytyped_operators})

System F$_{\omega}$ (\S\ref{sec:system_fomega})

The Type Operators themselves can be viewed as a Simply-typed
$\lambda$-calculus with only one Base Type (\S\ref{sec:type_constant})
denoted `$\ast$' representing the Type of all Types in the underlying
Language which are called \emph{Proper Types} to distinguish from the
Type of the Type Operators which are called \emph{Kinds}
(\S\ref{sec:kind}).

A Type Function is an Endofunctor on the Category of Types.



\subsubsection{Type Variable}\label{sec:type_variable}

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism}):
Universally Quantified Type Variables

Existential Types (\S\ref{sec:abstract_type}):
Existentially Quantified Type Variables



\subsubsection{Kind}\label{sec:kind}

A \emph{Kind} is the Type of a Type Operator, or the Type of a
Higher-order Type Operator \S\ref{sec:higherorder_typeoperator}).



\subsubsection{Higher-order Type Operator}
\label{sec:higherorder_typeoperator}

Allowing for the Type Operators to form a Simply-typed
$\lambda$-calculus with the single Base Type `$*$' allows for
Higher-order Type Operators.



\subsubsection{Function Type}\label{sec:function_type}

A \emph{Function Type} (or \emph{Arrow Type}) is Type formed by the
Higher-kinded Type Constructor $\rightarrow$

The Function Type $A \rightarrow B$ is a special case of Dependent
Product Type (\S\ref{sec:pi_type}) $\Pi_{(a:A)}B$ with a Constant
Codomain Type $B$:
\[
  \Pi_{(a:A)}B \equiv A \rightarrow B
\]
where $\equiv$ is Judgemental Equality.

In a Category without Products, the Function Type can't be defined.

Function Types are Covariant Functors on the Return Type and
Contravariant Functors on the Argument Type. Cf. Hughes Arrows
(\S\ref{sec:hughes_arrow}).



\paragraph{Exponential Type}\label{sec:exponential_type}
\hfill \\

Higher-order Functions

Function Space

Function Type (\S\ref{sec:function_type})



\subsubsection{Type Constructor}\label{sec:type_constructor}

Injective Type Function: maps all Types of a particular Kind to a new
Set of Types and Type Synonyms

\emph{Type Constructor}



\subsubsection{Type Family}\label{sec:type_family}

A \emph{Type Family} is a Partial Type Function that allows Types to
be defined by matching Terms. The Functionality of this Type Function

Generalization of Predicates (Relations) over Domains



\paragraph{Associated Type}\label{sec:associated_type}
\hfill \\

A Type Family declared inside a Type Class is an \emph{Associated
  Type}



% --------------------------------------------------------------------
\subsection{Dependent Type}\label{sec:dependent_type}
% --------------------------------------------------------------------

A \emph{Dependent Type} depends on a Term or another Type.

\[
  x : A \vdash B(x):\mathrm{Types}
\]

A Dependent Product Type (\S\ref{sec:pi_type}) is defined by
a Dependent Function (\S\ref{sec:dependent_function}).

Logical Quantifiers (\S\ref{sec:quantifier})

Intuitionistic Type Theory (\S\ref{sec:intuitionistic_type})

Categorically, Dependent Types correspond to Morphisms regarded as
Indexed Families (Bundle or Fibration), represented by a \emph{Display
  Map} (\S\ref{sec:display_map}) which is a Morphism $p : B
\rightarrow A$ where $B(x)$ is the Fiber (\S\ref{sec:fiber}) of $p$
over $x:A$.

Classifying Morphism (\S\ref{sec:classifying_morphism}),
Classifying Space (\S\ref{sec:classifying_space})

A Dependent Type is the Type of a Dependent Function
(\S\ref{sec:dependent_function}).

Dependent Pairs (Dependent Sum Type \S\ref{sec:sigma_type})


\textbf{First-order Dependent Type Theory} ($\lambda \Pi$):
\emph{Logical Framework} (\S\ref{sec:logical_framework}), adding the
Dependent Product Type (\S\ref{sec:pi_type}) to Simply-typed
$\lambda$-calculus.


\textbf{Second-order Dependent Type Theory} ($\lambda \Pi 2$):
allowing Quantification over Type Constructors
(\S\ref{sec:type_constructor}), $\Pi$ operator Subsumes both
$\rightarrow$ of Simply-typed $\lambda$-calculus and $\forall$ of
System F (\S\ref{sec:system_f})


\textbf{Higher-order Dependently Typed Polymorphic $\lambda$-calculus}
($\lambda \Pi \omega$): corresponds to \emph{Calculus of
  Constructions} (\S\ref{sec:coq}); extends $\lambda \Pi 2$ to all
abstractions of the $\lambda$-cube (\S\ref{sec:lambda_cube})



\subsubsection{Dependent Function}\label{sec:dependent_function}

A \emph{Dependent Function} is a Function from Terms to Types
(Codomain varies depending on Argument). The Type of a Dependent
Function is a \emph{Dependent Product Type}
(\S\ref{sec:pi_type}).

Dependent Function Space: if $f:(\forall x: A).B$ then $f a : B[a/x]$

Functionality (respect for Definitional Equality
\S\ref{sec:proof_equality}):
\[
  x : A \vdash B_x \;\text{type}
\]\[
  m : A \mapsto B[m/x] \;\text{type}
\]\[
  m \equiv n : A \mapsto B[m/x] \equiv B[n/x] \;\text{type}
\]

Doubly-indexed Type:
\[
  x : A, y : B_x \vdash C_{x,y} \;\text{type}
\]

Example: Family of Types Indexed by $\mathbb{N}$:
\[
  x : \mathbb{N} \vdash even(x) \;\text{type}
\]
is a Propositional Function (takes a Natural Number and yields a
Proposition). For each Natural Number, either $even(x)$ is Inhabited
(if $x$ is Even) or Uninhabited (if $x$ is Odd).\cite{harper12}



\subsubsection{Dependent Sum Type ($\Sigma$-type)}\label{sec:sigma_type}

\emph{$\Sigma$-type} (or \emph{Dependent Sum Type} or \emph{Dependent
  Pair Type})

Dependent Sum (\S\ref{sec:dependent_sum})

\[
  \Sigma_{(x:A)} B(x)
\]

If $B$ is Constant, then $\Sigma_{(x:A)}B$ is Judgementally Equal to
the Product Type (\S\ref{sec:product_type}) $A \times B$:
\[
  \Sigma_{(x:A)} B \equiv A \times B
\]

By Curry-Howard, $\Sigma$-types model Conjunction and Existential
Quantification.

Analagous to Coproduct or Disjoint Union.



\subsubsection{Dependent Product Type ($\Pi$-type)}\label{sec:pi_type}

The \emph{$\Pi$-type} (or \emph{Dependent Product Type} or
\emph{Dependent Function Type}) is the Type of a Dependent Function.
By Curry-Howard, $\Pi$-types model Implication and Universal
Quantification.

Dependent Product (\S\ref{sec:dependent_product})

For a Type $A : \class{U}$ in Type Universe
(\S\ref{sec:type_universe}) $\class{U}$, a Family of Types:
\[
  B : A \rightarrow \class{U}
\]
can be defined by a Dependent Function which assigns a Type $B(a) :
\class{U}$ to Each Term $a : A$. The Type of this Function is a
Dependent Product Type:
\[
  \Pi_{(x:A)}B(x)
\]

If $B$ is Constant, then $\Pi_{(x:A)}B$ is Judgementally Equal to the
Function Type (\S\ref{sec:function_type}) $A \rightarrow B$:
\[
  \Pi_{(x:A)}B \equiv A \rightarrow B
\]

Generalizes the idea of a Polymorphic Function
(\S\ref{sec:polymorphic_function})

\cite{hott13}:

Example $id$:
\[
  id : \Pi_{(A : \class{U})} A \rightarrow A
\]

Example 2 $swap$:
\[
  swap : \Pi_{(A:\class{U})} \Pi_{(B:\class{U})} \Pi_{(C:\class{U})}
  (A \rightarrow B \rightarrow C) \rightarrow (B \rightarrow A
  \rightarrow C)
\]
Type arguments may be written as subscripts: $id_A$, $swap_{A,B,C}$

A Polymorphic Function returning elements of Type $C$ has Polymorphic
Type (\S\ref{sec:polymorphic_type}):
\[
  \Pi_{(A:\class{U})} A \rightarrow C
\]



% --------------------------------------------------------------------
\subsection{Effect System}\label{sec:effect_system}
% --------------------------------------------------------------------

Effect Theory

(Wadler, Thiemann - 2003 - \emph{The marriage of effects and monads}):
%FIXME

Types $\tau$, $\tau'$

Effect $\sigma$

$\tau \xrightarrow{\sigma} \tau'$

$(\tau \xrightarrow{\sigma} \tau')^\dag$
$\rightsquigarrow$
$\tau^\dag \rightarrow T^\sigma \tau'^\dag$



\subsubsection{Computational Effect}\label{sec:computational_effect}

Computational Effects

e.g. Exceptions, Non-determinism, Interactive Input/Output,
Concurrency, State, Time, Continuations, etc. \cite{plotkin-pretnar09}

Monad (\S\ref{sec:monad})

Computation (Monad) $T$ Returning Value of Type $X$:
\[
  T X
\]

Return

Bind



\subsubsection{Algebraic Effect}\label{sec:algebraic_effect}

\cite{nielson-nielson99}
\cite{plotkin-pretnar09}
\cite{pretnar15}

(Countable) Equational Theories (Algebraic Theory
\S\ref{sec:algebraic_theory})


\cite{plotkin-pretnar09}:

Subclass of Computational Effects (\S\ref{sec:computational_effect}):
Effects that allow Representation by Operations and Equations.

Sets of Operations

Computational Effects representable by an Algebraic Theory:
Nondeterminism, Interactive Input/Output, Concurrency, State, Time,
Stream Redirection, Backtracking, Co-operative Multi-threading,
Delimited Continuations, etc.

Computation Monad: Free-model Monad (???, Free Monad
\S\ref{sec:free_monad}) of the Algebraic Theory

Handlers (\S\ref{sec:effect_handler}) correspond to a Model of the
Algebraic Theory

\HandRight\; Note that some Handlers (e.g. for Backtracking) do not
respect the Equations of an Algebraic Theory. \cite{pretnar15}


as an alternative to using Monads (\S\ref{sec:monad}) to Model
Side-effects, most often seen in Strict Languages

subsumed by Monads: ``Lazy State'' and ``Lazy Writer'' cannot be
captured by any Effect System (E. Kmett)

Continuations (\S\ref{sec:continuation}) are not representable as
Algebraic Effects


\cite{pretnar15}:

Occurence of an Effect can been seen as a Branching in the Execution
of a Program (number of Branches equal to the number of possible
outcomes of an Effect)

``Source'' of an Effect is represented by an Operation with Arity
equal to the number of outcomes and Arguments represent Branches


\textbf{Language}

\cite{pretnar15}:

\emph{Values}:
\begin{flalign*}
  \quad v ::=&\quad x \quad | \quad \true \quad | \quad \false \quad
            | \quad \lambda x \mapsto c &\\
      \quad |&\quad \mathtt{handler}\; \{ \mathtt{return}\; x
              \mapsto c_r, \mathtt{op}_1(x;k) \mapsto c_1, \ldots,
              \mathtt{op}_n(x;k) \mapsto c_n \}&
\end{flalign*}

\emph{Computations}:
\begin{flalign*}
  \quad c ::=&\quad \mathtt{return}\; v \quad | \quad \mathtt{op}(v;y.c) \quad
            | \quad \mathtt{do}\; x \leftarrow c_1 \;\mathtt{in}\; c_2 &\\
      \quad |&\quad \mathtt{if}\; v \;\mathtt{then}\; c_1
              \;\mathtt{else}\; c_2 \quad
            | \quad v_1 v_2 \quad | \quad \;\mathtt{with}\; v
              \;\mathtt{handle}\; c&
\end{flalign*}

Sequencing:
\[
  \mathtt{do}\; x \leftarrow c_1 \;\mathtt{in}\; c_2
\]
first Evaluate $c_1$, Bind result Value to $x$, and proceed as $c_2$;
if $x$ does not appear in $c_2$, then abbreviate to $c1; c2$.

Operation Call:
\[
  \mathtt{op}(v;y.c)
\]
Parameter Value $v$ (e.g. Memory Location to be Read) passed to
$\mathtt{op}$, $\mathtt{op}$ performs Effect, Result Value (e.g.
Contents of Memory Location) is Bound to $y$ and Evaluation of
Continuation $c$ resumes. (Handlers \S\ref{sec:effect_handler}) may
override this behavior).

Generic Effect (\S\ref{sec:generic_effect}):
\[
  \mathtt{op}\; \stackrel{\mathrm{def}}{=} \;\mathtt{fun}\; x \mapsto
  \mathtt{op}(x; y.\mathtt{return}\; y)
\]
Parameter Value $x$ passed to Operation with the Trivial Continuation;
specific Operations $\mathtt{op}(v;y.c)$ can be recovered by
Evaluating:
\[
  \mathtt{do}\; y \leftarrow \mathtt{op}\; v \;\mathtt{in}\; c
\]


\textbf{Denotational Semantics} \cite{pretnar15}

Computations as Trees:

Returned Values (or Bottom $\bot$ for Divergent Computation that does
not call any Operations) are Leaves and Branching Points are
Operations

Operation Calls create a ``Branching Point'' in the Evaluation with as
many Branches as there are possible Results that can be Yielded to the
Continuation. \cite{pretnar15}

A Divergent Computation that repeatedly Calls Operations gives a
Non-well-founded Tree. \cite{pretnar15}


\emph{Denotational Semantics Returning First-order Values and no
  Recursion}:

Value Type $A$: Set $\llbracket A \rrbracket$

Computation Type $\llbracket A!\Delta \rrbracket$: Set of Trees with
Leaves (Values) in $\llbracket A \rrbracket$ and Nodes (Operations) in
$\Delta$

Handlers: Functions between Trees defined by Structural Recursion on
Tree of the Handled Computation and Handling is Interpreted by
Application of such Functions

A \emph{Model} of $\Delta$ is a Set $M$ with Maps:
\[
  \mathtt{op}_M : \llbracket A \rrbracket
    \times M^{\llbracket B \rrbracket} \rightarrow M
\]
for each Operation $\mathtt{op} : A \rightarrow B$ in $\Delta$

\emph{Homomorphism} between Models $M$, $N$ is a Map $h : M
\rightarrow N$ such that:
\[
  (h \circ \mathtt{op}_M)(x,k) = \mathtt{op}_N(x,h \circ k)
\]

$\llbracket A ! \Delta \rrbracket$ is the \emph{Free Model} of
$\Delta$ over $A$ with Universal Property
(\S\ref{sec:universal_property}):

For any Model $M$ of $\Delta$ and Map $f : \llbracket A \rrbracket
\rightarrow M$ there exists a Unique Homomorphism $h : \llbracket A !
\Delta \rrbracket \rightarrow M$ that agrees with $f$ on Leaves.
\cite{pretnar15}

Operation Clauses define a Model of Operations and the Return Clause
provides a Function $f$ that can be extended to a Homomorphism.
\cite{pretnar15}

\HandRight\; With General Recursion and Higher-order Results then
Domains (\S\ref{sec:order_domain}) are used instead of Sets.

Comodel: Set $W$ of possible World States and Map $\mathtt{op}^W : W
\times \llbracket A \rrbracket \rightarrow W \times \llbracket B
\rrbracket$ for each Operation $\mathtt{op} : A \rightarrow B$ in
$\Sigma$

when Operation Call $\mathtt{op}(v; y.c)$ escapes all Handlers, pass
current State $w \in W$ and Parameter $v$ to $\mathtt{op}^W$ and get
back new State and Result, assigning Result to $y$ and continue
Evaluating $c$. \cite{pretnar15}


\textbf{Operational Semantics} \cite{pretnar15}

Small-step Operational Semantics

Operation Calls do not perform Effects: they behave as ``Signals''
that propagate outwards until they reach a Handler with a matching
Clause. \cite{pretnar15}

An Operation that escapes all Handlers is treated as a Terminating
Computation (no further Reductions). \cite{pretnar15}

``Actual'' Effectful behavior simulated by an Outermost Handler.
\cite{pretnar15}



\paragraph{Effect Handler}\label{sec:effect_handler}
\hfill \\

Homomorphism from Free Algebras
\cite{bauer-pretnar12}

(Pretnar, Plotkin - 2009 - \emph{Handlers of Algebraic Effects}): %FIXME

corresponds to Model of the Algebraic Theory
(\S\ref{sec:algebraic_theory}) of the Effects

Handling a Computational Effect: Homomorphically Mapping the Handled
Computation into another Computation

\cite{pretnar15}:
\[
  \mathtt{handler}\; \{ \mathtt{return}\; x
          \mapsto c_r, \mathtt{op}_1(x;k) \mapsto c_1, \ldots,
          \mathtt{op}_n(x;k) \mapsto c_n \}
\]



\subparagraph{Shallow Handler}\label{sec:shallow_handler}
\hfill \\

only Handle the first call of an Operation

more ``elementary'': can be used to simulate Deep Handler through
Recursion \cite{pretnar15}



\subparagraph{Deep Handler}\label{sec:deep_handler}
\hfill \\

continue Handling Operations in the Continuation
(\S\ref{sec:continuation})



\paragraph{Generic Effect}\label{sec:generic_effect}
\hfill \\

\cite{pretnar15}:
\[
  \mathtt{op}\; \stackrel{\mathrm{def}}{=} \;\mathtt{fun} x \mapsto
  \;\mathtt{op}(x; y.\mathtt{return}\; y)
\]
Parameter $x$ passed to Operation with the Trivial Continuation



\paragraph{Extensible Effect}\label{sec:extensible_effect}
\hfill \\

van Laarhoven Free Monad (\S\ref{sec:vanlaarhoven_free_monad})



\paragraph{Communication Effect}\label{sec:communication_effect}
\hfill \\

Communication \S\ref{sec:communication}



% --------------------------------------------------------------------
\subsection{Partial Type}\label{sec:partial_type}
\cite{thompson99}
% --------------------------------------------------------------------

Non-terminating Computations

Total Objects are Identified at Simple Types

Undefined Object ``Bottom'' $\uparrow$ is a Member of every Type

\[
  \sigma \rightarrow \tau \quad
  \sigma \rightarrow \overline{\tau} \quad
  \overline{\sigma} \rightarrow \overline{\tau} \quad
  \overline{\sigma \rightarrow \tau} \quad
  \overline{\sigma \rightarrow \overline{\tau}} \quad
  \overline{\overline{\sigma} \rightarrow \overline{\tau}} \quad
\]



% --------------------------------------------------------------------
\subsection{Type Conversion}\label{sec:type_conversion}
% --------------------------------------------------------------------

\subsubsection{Type Promotion}\label{sec:type_promotion}

Special case of Implicit Type Conversion



% ====================================================================
\section{Type Universe}\label{sec:type_universe}
% ====================================================================

A \emph{Type Universe} is a Type whose Elements are Types.

Small Type %FIXME

Type Theory analogue of Inaccessible Cardinal
(\S\ref{sec:inaccessible_cardinal})

$\class{U}_0$ is the Universe of all Small Types. Every Name
(\S\ref{sec:name}) $a:\class{U}_0$ has an associated Type $El(a)$
giving its Extension or Meaning ($El$ is a Dependent Type
\S\ref{sec:dependent_type} that maps each Object to its corresponding
Type).

A Predicative Cumulative Hierarchy (\S\ref{sec:cumulative_hierarchy}):
\[
  \class{U}_0, \class{U}_1, \class{U}_2, \ldots
\]
is such that any Type in $\class{U}_n$ is also in
$\class{U}_{n+1}$:
\[
  u_n:\class{U}_n+1
\]
with (Cumulative Property):
\[
  El(u_n) \equiv \class{U}_n
\]

See $\class{U}-INTRO$ and $\class{U}-CUMUL$
\S\ref{sec:homotopy_rules}.



% --------------------------------------------------------------------
\subsection{Girard's Paradox}\label{sec:girards_paradox}
% --------------------------------------------------------------------



% ====================================================================
\section{Context}\label{sec:type_context}
% ====================================================================

A \emph{Context} (or \emph{Typing Environment} or \emph{Variable
  Assignment}), $\Gamma$, is a list of \emph{Typing Assumptions}
(\S\ref{sec:typing_assumption}) of the form:
\[
  \Gamma = x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n
\]
where each Element $x_i : A_i$ is an Assumption that the distinct
Variable $x_i$ has type $A_i$.

\emph{Typing Judgements} (\S\ref{sec:typing_judgement}) are formulated
under the Assumptions of a particular Context, $\Gamma$:
\[
  \Gamma \vdash a : A
\]
For an empty Context:
\[
  \vdash a : A
\]
or:
\[
  . \vdash a : A
\]

Closed Terms are those Terms that are Typable
(\S\ref{sec:typing_derivation}) in an Empty Context, e.g. the I, S,
and K Combinators (\S\ref{sec:combinator}).



% --------------------------------------------------------------------
\subsection{Typing Assumption}\label{sec:typing_assumption}
% --------------------------------------------------------------------

\emph{Typing Assumption})

\[
  e : \tau
\]
``Term $e$ has Type $\tau$''



% --------------------------------------------------------------------
\subsection{Type Annotation}\label{sec:type_annotation}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Type Erasure}\label{sec:type_erasure}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Reification}\label{sec:reification}
% --------------------------------------------------------------------

* opposite of Type Erasure
* see Type Inference (\S\ref{sec:type_inference})

Abstract idea about a computer program turned into an explicit Data
Model or Object

(Hypostatize) %FIXME



% ====================================================================
\section{Typing Judgement}\label{sec:typing_judgement}
% ====================================================================

A \emph{Typing Judgement} is an instance of a \emph{Typing Relation}
(\S\ref{sec:typing_relation}).

A Typing Judgement expresses Propositional Equality. % FIXME

The Validity of a Typing Judgement is given by a Typing Derivation
(\S\ref{sec:typing_derivation}).

Constant Type % FIXME empty context



% --------------------------------------------------------------------
\subsection{Typing Relation}\label{sec:typing_relation}
% --------------------------------------------------------------------

\emph{Typing Relation} between Terms and Types

\[
  \Gamma \vdash e : \tau
\]
``$e$ is a (Well-typed \S\ref{sec:well_typed}) Term of Type $\tau$ in
Context $\Gamma$'',

Terms that are Well-typed in the Empty Context are Closed Terms.

Under a Proof Theoretic Interpretation, $p : P$ may be read as ``$p$
is a Proof of Proposition $P$''



% --------------------------------------------------------------------
\subsection{Typing Rule}\label{sec:typing_rule}
% --------------------------------------------------------------------

A \emph{Typing Rule} (or \emph{Type Rule}) describes how a Type is
assigned to a Syntactic Construction.

Corresponding to Introduction and Elimination Rules of Proof Theory
(\S\ref{sec:structural_rule}).

Introduction and Elimination corresponds to Data Constructors
(\S\ref{sec:data_constructor}).

The notation for Type Rules is that of Sequent Notation
(\S\ref{sec:sequent}):
\[
  {
    \frac
    { \Gamma_1 \vdash e_1:\tau_1 \quad \cdots
      \quad \Gamma_n \vdash e_n:\tau_n }
    { \Gamma \vdash e:\tau }
  }
\]
where $\Gamma$ are Typing Environments and $e:\tau$ are Typing
Judgements.



% --------------------------------------------------------------------
\subsection{Typing Derivation}\label{sec:typing_derivation}
% --------------------------------------------------------------------

A \emph{Typing Derivation} shows the Validity of a Typing Judgement
and is constructed from Typing Rules (\S\ref{sec:typing_rule}).

Derivation (\S\ref{sec:formal_proof})

Undischarged Assumptions in Formal Proofs correspond to Free Variables
in Typing Derivations, Discharged Assumptions to Bound Variables

A Rewrite Rule maps a Valid Typing Derivation to another Valid Typing
Derivation (\emph{Subject Reduction} \S\ref{sec:subject_reduction},
\emph{Type Soundness}) \cite{wadler14}

A Term for which a Typing Derivation exists is called a
\emph{Well-typed Term} (\S\ref{sec:well_typed}).



\subsubsection{Type Witness}\label{sec:type_witness}

\emph{Witnessing Information} gives verification of a Typing
Assumption



\subsubsection{Subject Reduction}\label{sec:subject_reduction}

A Type System has \emph{Subject Reduction} (or \emph{Type
  Preservation}) if Evaluation of Expressions leaves their Types
unchanged.



% ====================================================================
\section{Type Inference}\label{sec:type_inference}
% ====================================================================

% ====================================================================
\section{Typed $\lambda$-Calculus}\label{sec:typed_lambda}
% ====================================================================

\emph{Typed $\lambda$-Calculus} allows for Lambda Terms to be assigned
Types (\S\ref{sec:type}).

Simply-typed $\lambda$-calculus (\S\ref{sec:simply_typed}) has only
one Type Constructor (\S\ref{sec:type_constructor}), $\rightarrow$
(see Function Type \S\ref{sec:function_type}).

Untyped $\lambda$-calculus (\S\ref{sec:untyped_lambda}) may be
considered a Typed $\lambda$-calculus with only one Type.

A Denotational Semantics can be given by a \emph{B\"ohm Tree}
(\S\ref{sec:bohm_tree}).



% --------------------------------------------------------------------
\subsection{Simply-typed $\lambda$-calculus}\label{sec:simply_typed}
% --------------------------------------------------------------------

\emph{Simply-typed $\lambda$-calculus} ($\lambda^\rightarrow$) is a
Typed Interpretation of $\lambda$-calculus with one Type Constructor
for Function Types: $\rightarrow$ (\S\ref{sec:function_type}).

Strongly Normalizing, not Turing Complete: addition of $fix_\alpha$
Operator or Recursive Types (\S\ref{sec:recursive_datatype}) gives
Turing Completeness

``Simply-typed'' is to distinguish from extensions such as:
\begin{itemize}
  \item System F (\S\ref{sec:system_f}): Polymorphic Types
  \item Logical Framework (\S\ref{sec:logical_framework}): Dependent
    Types
\end{itemize}
because Polymorphism and Dependency cannot be encoding using only
$\rightarrow$ and Type Variables. Adding Record Types
(\S\ref{sec:product_type}) to Simply-typed $\lambda$-calculus allows
for Subtyping (\S\ref{sec:subtype}), and the resulting System
(\S\ref{sec:conjunctive_lambda}) is no longer ``Simply-typed'' because
it allows for Terms to have more than one Type.

The following extensions are still considered ``Simply-typed''
systems:
\begin{itemize}
  \item System T (\S\ref{sec:system_t}): Products, Coproducts, Natural
    Numbers
  \item PCF (\S\ref{sec:pcf}): Full Recursion
\end{itemize}

Simply-typed $\lambda$-calculus has the same Equational Theory of
$\beta\eta$-equivalence (\S\ref{sec:beta_reduction},
\S\ref{sec:eta_conversion}) as Untyped $\lambda$-calculus, subject to
Type restrictions.

$\beta$-reduction:
\[
  (\lambda x:s.t)u =_\beta t[x := u]
\]
holds in Context $\Gamma$ when $\Gamma$, $x:\sigma \rightarrow t:\tau$
and $\Gamma \vdash u:\sigma$.

$\eta$-reduction:
\[
  \lambda x:\sigma .t x =_\eta t
\]
holds when $\Gamma \vdash t : \sigma \rightarrow \tau$ and $x$ is not
Free in $t$.

With the Function Type Constructor $\rightarrow$ and the Base Types
$B$, the Types of a Simply-typed $\lambda$-calculus are defined (with
BNF Notation):
\[
  \tau ::= \tau \rightarrow \tau \;|\; T \in B
\]

\emph{Term Constant}

That is, Expressions of Simply-typed $\lambda$-calculus are defined
as:
\[
  e ::= x \;|\; \lambda x:t.e \;|\; e e \;|\; c
\]
where $x$ is a Variable and $\tau$ is a Type, and $c$ is a Term
Constant. These Expressions are, in order:
\begin{itemize}
  \item Variable Reference
  \item Abstraction
  \item Application
  \item Constant
\end{itemize}

Abstraction corresponds to Existential Quantification in Second-order
Logic (\S\ref{sec:secondorder_logic}).



\textbf{Intrinsic Interpretation}: \emph{Church-style}

* Only Well-typed Terms have Meaning (Meaning assigned to Typing
Derivations), therefore equivalent Terms having different Annotations
may have different Meanings, cf. Reification
(\S\ref{sec:reification}):



\textbf{Extrinsic Interpretation}: \emph{Curry-style}

* Terms Interpreted as in an Untyped Language, cf. Type Erasure
(\S\ref{sec:type_erasure})



\subsubsection{Simply-typed $\lambda$-calculus Typing Rules}
\label{sec:simplytyped_rules}

Typing Rules (\S\ref{sec:typing_rule}):
\begin{enumerate}
\item
  \[
    {
      \frac
      {x : \tau \in \Gamma}
      {\Gamma \vdash x : \tau}
    }
  \]
\item
  \[
    {
      \frac
      {c \;\text{is a constant of Base Type}\; T}
      {\Gamma \vdash c:T}
    }
  \]
\item
  \[
    {
      \frac
      {\Gamma, x:\sigma \vdash e:\tau}
      {\Gamma \vdash (\lambda x:\sigma.e):(\sigma \rightarrow \tau)}
    }
  \]
\item
  \[
    {
      \frac
      {\Gamma \vdash e_1:\sigma \rightarrow \tau \quad
        \Gamma \vdash e_2:\sigma}
      {\Gamma \vdash e_1 e_2 : \tau}
    }
  \]
\end{enumerate}



\textbf{Operational Semantics}

\textbf{Categorical Semantics}

Simply-typed $\lambda$-calculus is the Internal Language
(\S\ref{sec:internal_logic}) of the Cartesian Closed Categories
(\S\ref{sec:cartesian_closed}).



\textbf{Proof-theoretic Semantics}

Simply-typed $\lambda$-calculus is Isomorphic by Curry-Howard
(\S\ref{sec:curry_howard}) to Minimal Logic
(\S\ref{sec:minimal_logic}):
\begin{itemize}
  \item Terms correspond to Proofs in Natural Deduction
    (\S\ref{sec:natural_deduction})
  \item (Inhabited) Types correspond to Tautologies in Minimal Logic
\end{itemize}



Minimal Logic $\leftrightarrow$ Simply-typed $\lambda$-calculus:
\[
  \supset \leftrightarrow \rightarrow
\] \[
  \wedge \leftrightarrow \times
\] \[
  \vee \leftrightarrow +
\] \[
  False \leftrightarrow \bot
\]



\emph{Type Assignment}:
\[
  \frac{
    f:A \rightarrow B \quad x:A
  }{
    f x : B
  }(\rightarrow e)
\]\[
  \frac{
    x:A \quad y:B
  }{
    \lambda x.y : A \rightarrow B
  }(\rightarrow i)
\]



\subsubsection{System T}\label{sec:system_t}

G\"odel

Proof Interpretation of Heyting Arithmetic into a Finite-type
Extension of Primitive Recursive Arithmetic
(\S\ref{sec:primitive_recursive})

All Recursive Functions in Peano Arithmetic are definable



\subsubsection{PCF}\label{sec:pcf}

\emph{Programming Computable Functions}

extended version of Typed Lambda Calculus (\S\ref{sec:typed_lambda})

Geometry of Interaction (\S\ref{sec:geometry_of_interaction})

Denotational Semantics (\S\ref{sec:denotational_semantics}):
\emph{Scott Model}

Scott-continuous Function (\S\ref{sec:scott_continuity})



\subsubsection{Reflexive Domain}\label{sec:reflexive_domain}

Dana Scott % FIXME



% --------------------------------------------------------------------
\subsection{$\lambda$-calculus with Conjunctive Types}
\label{sec:conjunctive_lambda}
% --------------------------------------------------------------------

Subtyping (\S\ref{sec:subtype})

System $F_{<:}$ (\S\ref{sec:system_fsub})



% --------------------------------------------------------------------
\subsection{Simply-typed $\lambda$-calculus with Type Operators}
\label{sec:simplytyped_operators}
% --------------------------------------------------------------------

$\lambda\underline{\omega}$

Types depending on Types

System F$_\omega$ (\S\ref{sec:system_fomega})



% --------------------------------------------------------------------
\subsection{System F}\label{sec:system_f}
% --------------------------------------------------------------------

\emph{System F} (or \emph{Second-order $\lambda$-calculus})

(\emph{Girard-Reynolds}) \emph{Polymorphic $\lambda$-calculus})

Universal Quantification over all Types (cf. Existential Type Theory
\S\ref{sec:abstract_type}) %FIXME

By Curry-Howard Isomorphism, System F corresponds to the fragment of
Second-order Intuitionistic Logic using only Universal Quantification;
can describe all Functions that are Provably Total in Second-order
Logic (\S\ref{sec:secondorder_logic})

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism}):
Type-level Function Abstraction $\Lambda$

Quantification over Propositional Variables in Second-order Logic
corresponds to Type Abstraction in Second-order $\lambda$-calculus.
\cite{wadler14}



\subsubsection{System F$_{<:}$}\label{sec:system_fsub}

\subsubsection{System F$_\omega$}\label{sec:system_fomega}



% --------------------------------------------------------------------
\subsection{LF Logical Framework}
\label{sec:logical_framework}
% --------------------------------------------------------------------

Dependent Types (\S\ref{sec:dependent_type})

Dependently-typed $\lambda$-calculus is base of Intuitionistic Type
Theory (\S\ref{sec:intuitionistic_type}), Calculus of Constructions
(\S\ref{sec:coq})

By Curry-Howard Isomorphism Dependent Types correspond to Propositions
of First-order Predicate Logic (\S\ref{sec:firstorder_logic})

Dependently-typed $\lambda$-calculus with a Type of all Types (the
simplest Pure Type System \S\ref{sec:pure_type_system}) is not
Strongly Normalizing due to Girard's Paradox
(\S\ref{sec:girards_paradox})

Contextual Category (\S\ref{sec:contextual_category})



% --------------------------------------------------------------------
\subsection{Linear $\lambda$-calculus}\label{sec:linear_lambda}
% --------------------------------------------------------------------

Linear Type System (\S\ref{sec:linear_type})



% --------------------------------------------------------------------
\subsection{$\kappa$-calculus}\label{sec:kappa_calculus}
% --------------------------------------------------------------------

First-order fragment of Typed $\lambda$-calculus



% --------------------------------------------------------------------
\subsection{B\"ohm Tree}\label{sec:bohm_tree}
% --------------------------------------------------------------------

A \emph{B\"ohm Tree} is a Possibly Infinite Directed Acyclic Graph
where some Vertices are Labelled by $\lambda$-terms and all Vertices
besides the Root have exactly one Parent, every Vertex has a finite
number of Children, and every Unlabelled Vertex has no Children.



% ====================================================================
\section{Calculus of Constructions}\label{sec:coq}
% ====================================================================

% ====================================================================
\section{Pure Type System}\label{sec:pure_type_system}
% ====================================================================

Arbitrary number of Sorts and Dependencies

Generalization of the \emph{Lambda Cube} to more sorts than Terms and
Types

Not necessarily Strongly Normalizing (\S\ref{sec:normalization})

Barendregt-Geuvers-Klop Conjecture



% --------------------------------------------------------------------
\subsection{Lambda Cube}\label{sec:lambda_cube}
% --------------------------------------------------------------------

All Strongly Normalizing

$\lambda\rightarrow$: Simply-typed $\lambda$-calculus
(\S\ref{sec:simply_typed}); Terms depending on Terms (Function Type
\S\ref{sec:function_type})

$\lambda\underline{\omega}$: Simply-typed $\lambda$-calculus with Type
Operators (\S\ref{sec:simplytyped_operators}); Types depending on
Types (Type Functions \S\ref{sec:type_function})

$\lambda2$: Second-order $\lambda$-calculus (System F
\S\ref{sec:system_f}); Terms depending on Types (Parametric
Polymorphism \S\ref{sec:parametric_polymorphism})

$\lambda\Pi$: Dependently-typed $\lambda$-calculus (Logical Framework
\S\ref{sec:logical_framework}); Types depending on Terms (Dependent
Types \S\ref{sec:dependent_type})



% ====================================================================
\section{Intuitionistic Type Theory}\label{sec:intuitionistic_type}
\cite{martinlof84}
% ====================================================================

\emph{Intuitionistic Type Theory} (also \emph{Constructive Type
  Theory} or \emph{Martin-L\"of Type Theory})

Inductive Types (\S\ref{sec:inductive_type})

Modelled by Locally Cartesian Closed Category
(\S\ref{sec:locally_cartesian})

Extensional Martin-L\"of Type Theory: Internal Language
(\S\ref{sec:internal_logic}) for Cartesian Closed Quasi-categories
(\S\ref{sec:quasicategory})

Formation: the Context in which the Type is defined

Introduction: rules for Construction

Elimination: rules for De-construction

Computation:

Four forms of Judgements:
\begin{description}
  \item [Well-formed Type]: $A$ is a Set, $A$ is a Proposition, $A$ is
    an Expectation, $A$ is a Task; Types (encodes Syntax of Formulas
    ``A is a Proposition''; note some Formulas are only Well-formed if
    certain Judgements are Derivable \cite{thompson99}):
    \[
      A \text{ type}
    \]
  \item [Equality of Types]: $A$ and $B$ are Equal Sets:
    \[
      A \equiv B \text{ type}
    \]
  \item [Well-formed Term of Type]: $a$ is an Element of $A$, $a$ is a
    Proof of $A$, $a$ is a Realization of $A$, $a$ is a Method for
    doing $A$:
    \[
      a : A
    \]
  \item [Equality of Terms]: $a$ and $b$ are Equal Elements of Set $A$:
    \[
      a \equiv b : A
    \]
\end{description}

Dependent Type (\S\ref{sec:dependent_type}):
\[
  (x:A)B
\]
Removal of Dependency by Substitution:
\[
  [x/a]B
\]
Abstracted Object:
\[
  [x]b
\]
Removal of Abstration on Object:
\[
  b[x/a]
\]
Well-formed Context of Typing Assumptions
(\S\ref{sec:typing_assumption}):
\[
  \vdash \Gamma \textsf{ Context}
\]
Context (\S\ref{sec:type_context}) Judgements:
\begin {itemize}
\item Well-formed Type $\sigma$:
  \[
    \Gamma \vdash \sigma \mathsf{ Type}
  \]
\item Well-formed Term $t$ of Type $\sigma$:
  \[
    \Gamma \vdash t : \sigma
  \]
\item Type Equivalence:
  \[
    \Gamma \vdash \sigma \equiv \tau
  \]
\item Term Equivalence:
  \[
    \Gamma \vdash t \equiv u : \sigma
  \]
\end {itemize}
\hfill\\
Type Universe:
\[
  \class{U}
\]
Dependent Type mapping Objects to Types:
\[
  \textrm{El}
\]

Definitional Equality (\S\ref{sec:proof_equality})

Structural Rules (\S\ref{sec:structural_rule})



\hfill \\
\textbf{Identity Types} (\S\ref{sec:equality_type})
\\
Identity Type Introduction:
\[
  \frac{
    \Gamma \vdash m : A
  }{
    \Gamma \vdash refl_A(m) : Id_A(m,m)
  } (Id_A\text{-I})
\]
Identity Type Elimination:
\[
  \frac{
    \Gamma \vdash p : Id_A (m,n) \quad
    \Gamma, x:A, y:A, z : Id_A(x,y) \vdash C_{x,y,z} \text{ type}\quad
    \Gamma, x : A \vdash q : [x, x, refl_A(x)/x,y,z]C
  }{
    \Gamma \vdash refl_A(m) : Id_A(m,m)
  } (Id_A\text{-E})
\]
\hfill \\
\textbf{Dependent Product Types} (\S\ref{sec:pi_type})
\\
Logical Implication and Universal Quantification
\\
Dependent Product Formation:
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma, x:A \vdash B \text{ type}
  }{
    \Gamma \vdash \Pi_{x:A} B \text{ type}
  } (\Pi\text{-F})
\]
Dependent Product Introduction:
\[
  \frac{
    \Gamma, x : A \vdash m_x : B_x \quad
  }{
    \Gamma \vdash (\lambda x:A.m_x : B_x) : \Pi_{x:A} B
  } (\Pi\text{-I})
\]
Dependent Product Elimination:
\[
  \frac{
    \Gamma \vdash m : \Pi_{x:A} B \quad
    \Gamma \vdash n : A
  }{
    \Gamma \vdash m\;n : [n/x]B
  } (\Pi\text{-E})
\]
Dependent Product Computation (cf. $\beta$-reduction
\S\ref{sec:beta_reduction}):
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma , x : A \vdash m : B
  }{
    \Gamma \vdash (\lambda x : A.m)\;n \equiv [n/x]m : [n/x]B
  } (\Pi\text{-C})
\]


\hfill \\
\textbf{Dependent Sum Types} (\S\ref{sec:sigma_type})
\\
Logical Conjunction and Existential Quantification
\\
Dependent Sum Formation:
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma, x : A \vdash B_x \text{ type}
  }{
    \Gamma \vdash \Sigma_{x:A} B_x \text{ type}
  } (\Sigma\text{-F})
\]
Dependent Sum Introduction:
\[
  \frac{
    \Gamma \vdash m : A \quad
    \Gamma \vdash n : [m/x]B
  }{
    \Gamma \vdash (m,n) : \Sigma_{x:A} B_x
  } (\Sigma\text{-I})
\]
Dependent Sum Elimination 1:
\[
  \frac{
    \Gamma \vdash m : \Sigma_{x:A} B_x
  }{
    \Gamma \vdash \pi_1\;m : A
  } (\Sigma\text{-E$_1$})
\]
Dependent Sum Elimination 2:
\[
  \frac{
    \Gamma \vdash m : \Sigma_{x:A} B_x
  }{
    \Gamma \vdash \pi_2\;m : B[\pi_1\;m/x]
  } (\Sigma\text{-E$_2$})
\]
\hfill \\
\textbf{Binary Sum Types} (\S\ref{sec:sum_type})
\\
Disjunction
\\
Binary Sum Introduction 1:
\[
  \frac{
    \Gamma \vdash m : A
  }{
    \Gamma \vdash inl(m) : A + B
  } (+\text{-I}_1)
\]
Binary Sum Introduction 2:
\[
  \frac{
    \Gamma \vdash n : B
  }{
    \Gamma \vdash inr(n) : A + B
  } (+\text{-I}_2)
\]
Binary Sum Elimination:
\[
  \frac{
    \Gamma \vdash m : A + B \quad
    \Gamma, z : A + B \vdash C \text{ type} \quad
    \Gamma, x : A \vdash n : [inl(x)/z]C \quad
    \Gamma, y : B \vdash p : [inr(y)/z]C
  }{
    \Gamma \vdash case (m, x\;n, y\;p) : [m/z]C
  } (+\text{-E})
\]



Categorical Model, ``Category with Families'':

\begin{itemize}
  \item Category $\mathsf{C}$ of Contexts: Objects are Contexts,
    Morphisms are Substitutions
  \item Functor $T : \mathsf{C}^{op} \rightarrow \mathbf{Fam(Set)}$
    where $\mathbf{Fam(Set)}$ is the Category of Families
    (\S\ref{sec:family}) of Sets where Objects are Pairs $(A,B)$ of an
    Index Set $A$ and a Function $B: X \rightarrow A$ and Morphisms
    are Pairs of Functions $f: A \rightarrow A$ and $g: X \rightarrow
    X'$ such that $B' \circ g = f \circ B$, i.e. $f$ maps $B_a$ to
    $B'_{g(a)}$
\end{itemize}

The Functor $T$ assigns a Context $\Gamma$ to a Set of Types
$Ty(\Gamma)$, and for each $A : Ty(\Gamma)$ a Set of Terms
$Tm(\Gamma,A)$.

The Empty Context is the Terminal Object of $\mathsf{C}$.

Final Object for \emph{Comprehension} (or \emph{Context Extension}) % FIXME



\textbf{Alternate description}\cite{bastenhof09}

Language $L$:
\begin{enumerate}
  \item $1$ (Unity Type), $\Omega$ (Truth Value Type)
  \item Base Types $\tau_1, \tau_2, \tau_3, \ldots$
  \item Function Symbols $f, g, h, \ldots$
\end{enumerate}
The Types of a System are given by the smallest Set including $1$,
$\Omega$, and the Base Types closed under $\times$ (Product Types
\S\ref{sec:product_type}) and Unary Type Operator $P$ (Power Types
\S\ref{sec:power_type}).

Terms of Type $\Omega$ represent Formulas, e.g. $\tau_1 = \tau_2$.


\center *** \raggedright


\textbf{Sum Type} (\S\ref{sec:sum_type}) (Tagged Union)

$A \cup B = \{ a_1, a_2, ..., b_1, b_2, ... \}$

$x \in A \cup B \Rightarrow x \in A \vee x \in B$

$U \subset A \cup B \Rightarrow \forall u \in U, u \in A \vee u \in B \}$


\textbf{Product Type} (\S\ref{sec:product_type}) (Pairs)

$A \times B = \{ (a_1,b_1), (a_1,b_2), ..., (a_2,b_1), (a_2,b_2), ... \}$

$(x,y) \in A \times B \Rightarrow x \in A \wedge y \in B$

$U \subset A \times B
\Rightarrow \forall (u,v) \in U, u \in A \wedge v \in B$


\textbf{Powerset} (\S\ref{sec:powerset})
(Relations \S\ref{sec:binary_relation})

$\pow(A \times B) = \{ \linebreak[1]
\{(a_1,b_1)\}, \{(a_1,b_2)\}, ...,
\{(a_2,b_1)\}, \{(a_2,b_2)\}, ...
\linebreak[1] \vdots \linebreak[1]
\{(a_1,b_1), (a_1,b_2)\}, \{(a_1,b_1), (a_1,b_3)\}, ...,
\{(a_2,b_1), (a_2,b_2)\}, \{(a_2,b_1), (a_2,b_3)\}, ...
\linebreak[1] \vdots \linebreak[1]
..., A \times B - \{(a_2,b_1), (a_2,b_3)\}, \allowbreak
A \times B - \{(a_2,b_1), (a_2,b_2)\}, \allowbreak
..., A \times B - \{(a_1,b_1), (a_1,b_3)\}, \allowbreak
A \times B - \{(a_1,b_1), (a_1,b_2)\}, \allowbreak
\linebreak[1] \vdots \linebreak[1]
..., A \times B - \{(a_2,b_2)\}, A \times B - \{(a_2,b_1)\}, \allowbreak
..., A \times B - \{(a_1,b_2)\}, A \times B - \{(a_1,b_1)\}, \allowbreak
\linebreak[1] A \times B
\}$

$A \times B \in \pow(A \times B)$

$U \in \pow(A \times B) \Rightarrow U \subseteq A \times B \allowbreak
\Rightarrow \forall (u,v) \in U, u \in A \wedge v \in B$

$\class{V} \subset \pow(A \times B)
\Rightarrow \forall U \in \class{V}, U \subseteq A \times B$


\textbf{Function Type} (\S\ref{sec:function_type})

$A \rightarrow B = B^A = \{ \linebreak[1]
\{ (a_1, b_1), (a_2, b_1), (a_3, b_1), ...\},
\{ (a_1, b_2), (a_2, b_2), (a_3, b_2), ...\},
\{ (a_1, b_3), (a_2, b_3), (a_3, b_3), ...\}, ...
\linebreak[1] \vdots \linebreak[1]
\{ (a_1, b_2), (a_2, b_1), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_2), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_1), (a_3, b_2), ...\}, ...
\linebreak[1] \vdots \linebreak[1]
\{ (a_1, b_3), (a_2, b_1), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_3), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_1), (a_3, b_3), ...\},
\linebreak[1] \vdots \linebreak[1]
\}$

$B^A \subset \pow(A \times B)$

$f \in B^A
\Rightarrow f \in \pow(A \times B) \wedge f \neq A \times B \allowbreak
\Rightarrow f \subset A \times B
\Rightarrow \forall (x, f(x)) \in f, x \in A \wedge f(x) \in B$

$U \subset B^A \Rightarrow \forall u \in U, u \in \pow(A \times B)$


\textbf{Dependent Type} (\S\ref{sec:dependent_type})

$a:A \vdash B(a) = \{(a_1,B(a_1)), (a_2,B(a_2)), ...\}$

$a:A \vdash B(a) \in \class{U}^A \linebreak[1]
\Rightarrow a:A \vdash B(a) \subset A \times \class{U}$

$(x,X) \in a:A \vdash B(a) \Rightarrow x \in A \wedge X \in \class{U}$

$U \subset a:A \vdash B(a) \Rightarrow \forall (x,X) \in U, x \in A
\wedge X \in \class{U}$


\textbf{Dependent Sum Type} ($\Sigma$-type \S\ref{sec:sigma_type})

$\Sigma_{(a:A)} B(a) = \{\{ (a_1, x_1), (a_1, x_2), ...\},
\{ (a_2, y_1), (a_2, y_2), ...\}, \cdots \}$

$\Sigma_{(a:A)} B(a) \subset \pow \bigsqcup_{X \in \class{U}} A \times X$

$Z \in \Sigma_{(a:A)} B(a) \Rightarrow \exists x \in A : \forall y \in
B(x), (x,y) \in P$



\textbf{Dependent Product Type} ($\Pi$-type \S\ref{sec:pi_type})

$\Pi_{(a:A)} B(a) = \{(a_1, x), (a_2, y), (a_3, z), ...\}$

$\Pi_{(a:A)} B(a) \subset \pow \bigsqcup_{a \in A} \Sigma_{(a:A)} B(a)$


\center *** \raggedright


% --------------------------------------------------------------------
\subsection{Constructive Type}\label{sec:constructive_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Meaning Explanation}\label{sec:meaning_explanation}
% --------------------------------------------------------------------

Martin-L\"of, a Proof-theoretic Semantics
(\S\ref{sec:proof_semantics}) for Type Theory

Realizability Model (\S\ref{sec:realizability_model}) for Type Theory

Intensional Type Theory (\S\ref{sec:intensional_type})

Extensional Type Theory (\S\ref{sec:extensional_type})

Terms $x,y,z,X,Y,Z,\ldots$

$x \Rightarrow y$: $x$ Computes (Reduces, Transitive) to $y$

Predicates:
\begin{itemize}
  \item $A \type$
  \item $a : A$
  \item $a = b : A$
\end{itemize}

Induction Recursion (\S\ref{sec:induction_recursion}): $A \type$ by
Induction (\S\ref{sec:mathematical_induction}) and two Recursive
Functions:
\begin{itemize}
  \item $|A|$ the Collection of Terms of Type $A$
  \item $=_A$ the Collection of Pairs of Equal Terms of Type $A$
\end{itemize}
(each Collection may be defined Inductively)



% --------------------------------------------------------------------
\subsection{Extensional Type Theory}\label{sec:extensional_type}
\cite{harper12}
% --------------------------------------------------------------------

\emph{Extensional Type Theory} (\emph{ETT})

Strict Equivalence

``Homotopy Set Theory'' (Homotopically Discrete)

\emph{NuPRL}

Equality Reflection Principle



\subsubsection{Observational Type Theory}\label{sec:observational_type}

``Homotopy Set Theory''

Setoid (\S\ref{sec:setoid})



% --------------------------------------------------------------------
\subsection{Intensional Type Theory}\label{sec:intensional_type}
\cite{harper12}
% --------------------------------------------------------------------

Weak Equivalence



% ====================================================================
\section{Homotopy Type Theory}\label{sec:homotopy_type_theory}
% ====================================================================

Homotopy Thoery (\S\ref{sec:homotopy})

- Function Extensionality
- Univalence Axiom (\S\ref{sec:univalence_axiom})

- Values (Points), Paths, Homotopies

- Internal Language of Higher Categories
(\S\ref{sec:higher_category}).

Homotopy Types Model $\infty$-groupoids
(\S\ref{sec:infinity_groupoid})



% --------------------------------------------------------------------
\subsection{Higher Inductive Type}\label{sec:higher_inductive_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Inference Rules}\label{sec:homotopy_rules}
% --------------------------------------------------------------------

Inference Rules (\S\ref{sec:type_inference}) have the form:
\[
  \frac{J_1 \quad \cdots \quad J_k} {J} Name
\]
where $J_i$ are provided as derived hypothetical (metatheoretical)
Judgements and $J$ is the conclusion.

A Tree constructed from Inference Rules forms a Derivation
(\S\ref{sec:typing_derivation}) of a Judgement.



\textbf{Context Rules}

The following Rules of Inference allow for the determination of a
Well-formed Context:
\begin{enumerate}
\item
\[
  {
    \frac{}{(.)ctx}
  } ctx-EMP
\]
\item
\[
  {
    \frac
    {x_1:A_1, \ldots, x_{n-1}:A_{n-1} \vdash A_n : \class{U}_i}
    {(x_1:A_1,\ldots,x_n:A_n) ctx}
  } ctx-EXT
\]
\end{enumerate}



\textbf{Structural Rules}

Given a Context, derive Typing Judgements
(\S\ref{sec:typing_judgement}) listed in the Context:
\[
  {
    \frac
    {(x_1:A_1, \ldots, x_n:A_n)ctx}
    {x_1:A_1, \ldots, x_n:A_n \vdash x_i:A_i}
  } Vble
\]

Substitution for Typing Judgements:
\[
  {
    \frac
    {\Gamma \vdash a : A \;\;\;\;\;\;\;
    \Gamma,x:A,\Delta \vdash b : B}
    {\Gamma,[a/x]\Delta \vdash [a/x]b : [a/x]B}
  } Subst_1
\]

Weakening for Typing Judgements:
\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i \;\;\;\;\;\;\;
    \Gamma,\Delta \vdash b : B}
    {\Gamma,x:A,\Delta \vdash b:B}
  } Wkg_1
\]

Substitution for Judgemental Equality:
\[
  {
    \frac
    {\Gamma \vdash a : A \;\;\;\;\;\;\;
    \Gamma,x:A,\Delta \vdash b \equiv c : B}
    {\Gamma,[a/x]\Delta \vdash [a/x]b \equiv [a/x]c : [a/x]B}
  } Subst_2
\]

Weakening for Judgemental Equality:
\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i \;\;\;\;\;\;\;
    \Gamma,\Delta \vdash b \equiv c : B}
    {\Gamma, x:A, \Delta \vdash b \equiv c : B}
  } Wkg_2
\]



\textbf{Universe Rules}

\[
  {
    \frac
    {(\Gamma) ctx}
    {\Gamma \vdash \class{U}_i : \class{U}_{i+1}}
  } \class{U}-INTRO
\]

\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i}
    {\Gamma \vdash A : \class{U}_{i+1}}
  } \class{U}-CUMUL
\]



\textbf{Dependent Function Type Rules}

\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i \;\;\;\;\;\;\;
    \Gamma,x:A \vdash B : \class{U}_i}
    {\Gamma \vdash \prod_{(x:A)} B : \class{U}_i}
  } \Pi-FORM
\]\[
  {
    \frac
    {}
    {}
  } \Pi-INTRO
\]\[
  {
    \frac
    {}
    {}
  } \Pi-ELIM
\]\[
  {
    \frac
    {}
    {}
  } \Pi-COMP
\]\[
  {
    \frac
    {}
    {}
  } \Pi-UNIQ
\]



% --------------------------------------------------------------------
\subsection{Univalence Axiom}\label{sec:univalence_axiom}
% --------------------------------------------------------------------

``Identity is Equivalent to Equivalence''

``Equivalent Types are Identical''
\[
  (A = B) \simeq (A \simeq B)
\]
where $A = B$ is notation for the Type $Id_U(A,B)$ where $U$ is the
Universe containing $A$ and $B$.



% ====================================================================
\section{Opetopic Type Theory}\label{sec:opetopic_typetheory}
% ====================================================================

Internal Language of $\infty$-categories
(\S\ref{sec:infinity_category})



% ====================================================================
\section{Curry-Howard Correspondence}\label{sec:curry_howard}
% ====================================================================

\emph{Curry-Howard Correspondence}

Type Theory, Proof Theory, Algebra (Preorders: $\leq$ is a Reflexive
and Transitive Relation), Category Theory

Syntactic Category (\S\ref{sec:syntactic_category}) %FIXME

``Computational Trinitarianism''
\\
\begin{tabular}{| l | l | l |}
\hline
\textbf{Logic} & \textbf{Type Theory} & \textbf{Category Theory}\\ \hline \hline
Proposition & $A$ (Type) & $A \in \cat{C}_0$ \\ \hline
Proof & $a : A$ (Term) & $a:U \rightarrow A \in \cat{C}_1$ \\
\hline
\end{tabular}
\\
\cite{harper12}
\\
\begin{tabular}{| p{2cm} | p{3cm} | p{4.5cm} | p{3cm} |}
\hline
& \textbf{Logic} & \textbf{Type} & \textbf{Algebra}\\ \hline \hline
Trivial Proposition
  & \begin{center} $\overline{A \vdash \top}$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $\overline{A \leq \top}$ \end{center} \\ \hline
Bottom
  & \begin{center} $\overline{\bot \vdash A}$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $\overline{\bot \leq A}$ \end{center} \\ \hline
Reflexivity
  & \begin{center} $A \vdash A$ \end{center}
  & \begin{center} $x : A \vdash x : A$ \end{center}
  & \begin{center} $A \leq A$ \end{center} \\ \hline
Negation Elimination
  & \begin{center} $\neg A \vdash A \rightarrow \bot$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $A \wedge \neg A = \bot$ \end{center} \\ \hline
Negation Introduction
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\underline{C \wedge A \leq \bot}$\newline
      $C \leq \overline{A}$
    \end{center} \\ \hline
Elimination Rules
  & \begin{center}
      $\overline{A \wedge B \vdash A}$,\newline\newline
      $\overline{A \wedge B \vdash B}$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\overline{A \wedge B \leq A}$,\newline\newline
      $\overline{A \wedge B \leq B}$
    \end{center} \\ \hline
Introduction Rules
  & \begin{center}
      $\overline{A \vdash A \vee B}$,\newline\newline
      $\overline{B \vdash A \vee B}$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\overline{A \leq A \vee B}$,\newline\newline
      $\overline{B \leq A \vee B}$
    \end{center} \\ \hline
Conjunction
  & \begin{center}
    $\underline{C \vdash A \quad C \vdash B}$\newline
    $C \vdash A \wedge B$
    \end{center}
  & \begin{center}
    $\underline{x:C \vdash m:A \quad x:C \vdash n:B}$\newline
    $x:C \vdash (m,n):A \times B$
    \end{center}
  & \begin{center}
    $\underline{C \leq A \quad C \leq B}$\newline
    $C \leq A \wedge B$
    \end{center} \\ \hline
Disjunction
  & \begin{center}
    $\underline{A \vdash C \quad B \vdash C}$\newline
    $A \vee B \vdash C$
    \end{center}
  & \begin{center}
    ???
    \end{center}
  & \begin{center}
    $\underline{A \leq C \quad B \leq C}$\newline
    $A \vee B \leq C$
    \end{center} \\ \hline
Transitivity
  & \begin{center}
      $\underline{A \vdash B \quad B \vdash C}$\newline
      $A \vdash C$
    \end{center}
  & \begin{center}
    $\underline{x:A \vdash m:B \quad y:B \vdash n:C}$\newline
    $x:A \vdash [m/y]n:C$
    \end{center}
  & \begin{center}
    $\underline{A \leq B \quad B \leq C}$\newline
    $A \leq C$
    \end{center} \\ \hline
\hline
\end{tabular}
\\
\begin{tabular}{| p{2cm} | p{3cm} | p{4.5cm} | p{3cm} |}
\hline
& \textbf{Logic} & \textbf{Type} & \textbf{Algebra}\\ \hline \hline
Implication Elimination
  & \begin{center} $A, (A \rightarrow B) \vdash B$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Implication Introduction
  & \begin{center}
      $\underline{A \wedge C \vdash B}$\newline
      $C \vdash A \rightarrow B$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Weakening
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Contraction
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Exchange
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
\hline
\end{tabular}

Proofs and Propositions form the Object Language; Derivations are used
to infer Judgements about the Object Language

***

$p : P$ ``$p$ is a Proof of Proposition $P$''

A Proof of $A \wedge B$ is a Pair of Proofs $p : A$ and $q : B$ (holds
in both Classical and Constructive Systems)

A Proof of $A \vee B$ is a Proof $p : A$ or a Proof $q : B$ with an
indication of which Formula is Proved (differs from Classical Logic)

A Proof of $A \Rightarrow B$ is a Function that Transforms a Proof $p
: A$ into a Proof $q : B$.

No Proof for the Contradictory Proposition $\bot$

$(\exists x : A).P$ where $P$ is a Witness (\S\ref{sec:type_witness})
$w : A$ with a Proof that $P$ holds of $w$, i.e. $[w/x]P$

$(\forall x : A).P$ implies that $[a/x]P$ is Valid for every $a$ in
$A$; a Function mapping any Proof of $A$ to a Proof of $P$.

Introduction Rule for $\forall$:
\[
  {
    \frac{
      \begin{matrix}
        [x : A]\\
        \vdots\\
        p : P
      \end{matrix}
    }{
      (\lambda x : A).p : (\forall x : A).P
    }
  } (\forall I)
\]

Computation Rule for $\forall$:
\[
  ((\lambda x : A).p) \rightarrow [a/x]p
\]

Introduction Rule for $\exists$:
\[
  {
    \frac{
      a : A \quad\quad p : [a/x]P
    }{
      (a,p) : (\exists x : A).P
    }
  } (\exists I)
\]

Computation Rules for $\exists$:
\[
  fst (p,q) \rightarrow p
\]\[
  snd (p,q) \rightarrow q
\]

The Formation Rule for Equality Types (\S\ref{sec:equality_type})
requires other Judgements (Type Assumptions) in addition to
Well-typing Judgements:
\[
  {
    \frac{ A \mathsf{ Type} \quad\quad a : A \quad\quad b:A }
    { I (A,a,b) \mathsf{ Type}}
  } (I F)
\]

Introduction Rule for $I$:
\[
  {
    \frac{ a : A }
    { r(a) : I(A,a,a)}
  } (II)
\]

Elimination Rule for $I$:
\[
  {
    \frac{ c : I (A, a, b) \quad\quad d : C(a,a,r(a)) }
    { J(c,d) : C(a,b,c) }
  } (I E)
\]

Computation Rule for $I$:
\[
  J (r(a), d) \rightarrow d
\]

Leibniz Law

***

Formation Rules : Defines what the Types of the System are (Syntax)

Introduction \& Elimination Rules : Define which Terms are Members of
which Types; Typing Rules (\S\ref{sec:typing_rule})

Computation Rules : How Objects can be Reduced, i.e. Evaluated
(Computation)

Natural Deduction - Typed Lambda Calculus

Minimal Logic - Simple Types (Simply-typed $\lambda$-calculus
\S\ref{sec:simply_typed})

Predicate Logic - Dependent Types (Intuitionistic Type Theory
\S\ref{sec:intuitionistic_type})

Modal Logic - Monads

Classical-Intuitionistic Embedding - Continuation-passing Style
(\S\ref{sec:continuation})

Subset Type $(\exists x:A).B$ (Pairs of Objects and the Proofs that
they have Property): $\{ x : A | B \}$ consisting of those $a$ in $A$
with Property $[a/x]B$, i.e. $[a/x]B$ is Inhabited.



% ====================================================================
\section{Type System}\label{sec:type_system}
% ====================================================================

\emph{Type System} (or \emph{Typing Discipline})



% --------------------------------------------------------------------
\subsection{Type Checking}\label{sec:type_checking}
% --------------------------------------------------------------------

\subsubsection{Bi-directional Type Checking}
\label{sec:bidirectional_checking}

\emph{Checking}

\emph{Synthesis}



\subsubsection{Extended Static Checking}\label{sec:extended_static}



% --------------------------------------------------------------------
\subsection{Nominal Type System}\label{sec:nominal_type_system}
% --------------------------------------------------------------------

Names



% --------------------------------------------------------------------
\subsection{Unified Type System}\label{sec:unified_type_system}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Structural Type System}\label{sec:structural_type_system}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Substructural Type System}
\label{sec:substructural_type_system}
% --------------------------------------------------------------------

Substructural Logic (\S\ref{sec:substructural_logic})

Substructural Type Systems are categorized by allowing or disallowing
Structural rules of Exchange (\S\ref{sec:exchange_rule}), Weakening
(\S\ref{sec:weakening_rule}), or Contraction
(\S\ref{sec:contraction_rule}):

\begin{itemize}
  \item Linear Type Systems (\S\ref{sec:linear_type}): Allow Exchange,
    not Weakening or Contraction; Every Variable used exactly once
  \item Affine Type Systems (\S\ref{sec:affine_type}): Allow Exchange
    and Weakening, not Contraction; Every occurrence of a Variable
    used at most once
  \item Relevant Type System (\S\ref{sec:relevant_type}): Allow
    Exchange and Contraction, not Weakening; Every variable used at
    least once
  \item Ordered Type System (\S\ref{sec:ordered_type}): Disallow
    Exchange, Contraction and Weakening; Every Variable is used
    Exactly once in the order it was introduced
\end{itemize}



\subsubsection{Linear Type System}\label{sec:linear_type}

Values used exactly once

Linear Logic (\S\ref{sec:linear_logic}) allows safe Deallocation
(Objects used exactly once)

Distribution and Concurrency (Session Types \S\ref{sec:session_type})

Linear $\lambda$-calculus (\S\ref{sec:linear_lambda})

Internal Language (\S\ref{sec:internal_logic}) of Closed Symmetric
Monoidal Categories (\S\ref{sec:closed_symmetric_monoidal})

Allows References but not Aliases

Modelling of Heap-based Memory Allocation

No-cloning Theorem (Quantum States):
\begin{itemize}
  \item No Diagonal Functor (\S\ref{sec:diagonal_functor})
    which could duplicate States
  \item No $K$-combinator which can destroy States
  \item A Variable $x$ can appear at most once in a $\lambda$-term
\end{itemize}



\paragraph{Affine Type System}\label{sec:affine_type}
\hfill \\

Values used at most once

Affine Logic (\S\ref{sec:affine_logic})



\paragraph{Session Type}\label{sec:session_type}
\hfill \\

\emph{Session Types} are a Typing Discipline (\S\ref{sec:type_system})
for Heterogenous Bidirectional Communication Channels defining the
possible Sequences of Messages (\S\ref{sec:message}) determined by the
Channel's Session Type (e.g. Stream-based Internet Protocols)
\cite{neubauer-thiemann04}

Message Sequences are Described by a Regular Language
(\S\ref{sec:regular_language}) on Atomic Communication Actions
(\S\ref{sec:communication}); Channel Type (\S\ref{sec:channel_type})
specifies the Language with a Fix-point Expression ($\mu$). Operations
peel off the ``outermost'' Action (???) of the Channel Type and change
the Channel Type (Linearity). \cite{neubauer-thiemann04}

Implementation requirements: \cite{neubauer-thiemann04}
\begin{itemize}
  \item Type Constraints (Type Classes \S\ref{sec:constrained_type})
    with Functional Dependencies (\S\ref{sec:functional_dependency}):
    modelling the progression of the current state of the Channel
  \item Functions with Polymorphic Parameters
    (\S\ref{sec:parametric_polymorphism}): models Client and Server
    side of a Communication with one specification
\end{itemize}

Static Analysis of the Communication Behavior (???) of Agents (???) in
a Distributed System \cite{gay-vasconcelos10}

(Communication) Protocol

Distribution and Concurrency

$\parr$

$\otimes$

Curry-Howard (\S\ref{sec:curry_howard}) for Process Calculi
(\S\ref{sec:process_calculus}):
\begin{itemize}
  \item Propositions as Session Types
  \item Proofs as Processes (\S\ref{sec:process})
  \item Cut-elimination (\S\ref{sec:cut_elimination}) as Communication
    (\S\ref{sec:communication})
\end{itemize}

Linear Propositions (\S\ref{sec:linear_logic})

Dual Intuitionistic Linear Logic \cite{caires-pfenning10} (Shared ???,
Linear)

% FIXME ???
Session: a ``unit'' of a Communication

Session Type: ``structure'' of a Communication

Only Processes with Dual Protocols can Interact

Cotype


\cite{honda-vasconcelos-kubo98}:

Session: a Sequence of Dyadic Interactions

Program: a Collection of Dyadic Interactions in a Session \emph{or} a
Process with no Free Variables % FIXME

Channel: Private Port Designating a Session (cf. Information Theory
\S\ref{sec:channel} Channels)

Session Protocol (\S\ref{sec:session_protocol})


\cite{neubauer-thiemann04}:
\begin{enumerate}
  \item First-order Base Type Values
  \item Functions
  \item Labels (cf. Labels in Record (\S\ref{sec:product_type}) or
    Variant Types (\S\ref{sec:sum_type})
\end{enumerate}


\textbf{Primitives}

\begin{itemize}
  \item \emph{Send}
  \item \emph{Receive}
  \item \emph{Sequence}
  \item \emph{Choice}
  \item \emph{Recursion}
\end{itemize}



\paragraph{Channel Type}\label{sec:channel_type}

\subparagraph{Label}\label{sec:channel_label}



\subsubsection{Relevant Type System}\label{sec:relevant_type}

Relevant Logic (\S\ref{sec:relevance_logic})



\subsubsection{Ordered Type System}\label{sec:ordered_type}

Noncommutative Logic (\S\ref{sec:noncommutative_logic})

modelling Stack-based Memory Allocation

only Objects on top of modelled Stack may be used, after which it is
popped off



% --------------------------------------------------------------------
\subsection{Hindley-Milner Type System}\label{sec:hindley_milner}
% --------------------------------------------------------------------

$\lambda$-calculus with Parametric Polymorphism



\subsubsection{Algorithm W}\label{sec:algorithm_w}
