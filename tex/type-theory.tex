%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Type Theory}\label{part:type_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Type Theory} is the study of Classes of Formal Systems
(\S\ref{sec:formal_system}) where each Term (\S\ref{sec:term}) has a
\emph{Type} (\S\ref{sec:type}) and Operations are restricted to Terms
of specific Types.

A Type Theory may have two Signatures: $\sigma_\tau$ for Type Symbols
and $\sigma_o$ for Object (Term) Symbols. From this one may construct
a Monad $R = R_{\sigma_o}$, a Module over $R$: $LM =
LM_{\sigma_\tau,\sigma_o}$, and a Contextual Category
(\S\ref{sec:contextual_category}) $CC(R,LM)$ describing a Class of
Sub-quotients of $CC(R,LM)$ in terms of Objects Constructed from $R$
and $LM$. \cite{voevedsky14}

As a Formal Theory (\S\ref{sec:formal_theory}), Judgements
(\S\ref{sec:judgement}) in Type Theory are of three
kinds\cite{hott13}:
\begin{enumerate}

\item \emph{Well-formed Context} (\S\ref{sec:type_context}):
  \[
    (\Gamma) ctx
  \]
  ``$\Gamma$ is a Well-formed Context''

\item \emph{Propositional Equality} (Typing Judgement
    \S\ref{sec:typing_judgement}):
  \[
    \Gamma \vdash a : A
  \]
  ``Given Contex $\Gamma$, $a$ is a Term of Type $A$''

\item \emph{Definitional (Judgemental) Equality}:
  \[
    \Gamma \vdash a \equiv b : A
  \]
  ``Given Context $\Gamma$, $a$ and $b$ are Definitionally Equal Terms
  of Type $A$''

\end{enumerate}
with a Deductive Apparatus (\S\ref{sec:deductive_apparatus})
consisting of Inference Rules (\S\ref{sec:type_inference}) only and no
Axioms. Judgemental Equality is an Equivalence Relation respected by
Typing.

every Type Theory gives rise to a Cartesian Multicategory
(\S\ref{sec:cartesian_multicategory}) with Objects as Types and
Multimorphisms as Terms



\textbf{Intensional \& Extensional Type Theory}

\begin{itemize}
\item \emph{Extensional Type Theory} (\S\ref{sec:extensional_type}):
  Definitional (Computational) Equality is not distinguished from
  Propositional (Proof) Equality (Strict Equivalence) but Type Checking
  (\S\ref{sec:type_checking}) is Undecidable; see also
  \emph{Observational Type Theory} (\S\ref{sec:observational_type})
\item \emph{Intensional Type Theory}: Type Checking is Decidable but
  Extensional Reasoning must be carried out using Setoids
  (\S\ref{sec:setoid}); (Weak Equivalence)
\item \emph{Homotopy Type Theory} (\S\ref{sec:homotopy_type_theory}):
  Higher Inductive Types (\S\ref{sec:higher_inductive_type}) allow
  definition of Higher-order Constructors
\end{itemize}

Term Rewrite System (\S\ref{sec:term_rewriting})

\emph{Conversion Rules}

\emph{Canonical Form} (\S\ref{sec:canonical_form})

\emph{Normal Form}


Meaning Explanation (\S\ref{sec:meaning_explanation})



% ====================================================================
\section{Expression}\label{sec:type_expression}
% ====================================================================

An \emph{Expression} is an Equivalence Class of Syntactic forms which
differ in the names of \emph{Bound Variables}. That is, changing the
name of a Bound Variable everywhere within an Expression
(\emph{$\alpha$-conversion}) does not change the Expression.

A Variable is Bound in an Expression by an \emph{Abstraction}
expressing that the Variable is \emph{local} to the Expression:
\[
  \lambda x.B
\]
or:
\[
  x.B
\]

\emph{Substitution}:
\[
  [a/x]B
\]
Substitute Term $a$ for Free occurrences of Variable $x$ in the Term
$B$. Generalized:
\[
  [a_1,\ldots,a_n / x_1,\ldots,x_n]B
\]



% --------------------------------------------------------------------
\subsection{Term Constant}\label{sec:term_constant}
% --------------------------------------------------------------------

A \emph{Term Constant} is a Term that is a Base Type
(\S\ref{sec:type_constant})
% FIXME ???



% --------------------------------------------------------------------
\subsection{Well-typed Term}\label{sec:well_typed}
% --------------------------------------------------------------------

A \emph{Well-typed Term} (or \emph{Typable Term}) is a Term for which
a Typing Derivation (\S\ref{sec:typing_derivation}) exists.



% ====================================================================
\section{Type}\label{sec:type}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Type Constant}\label{sec:type_constant}
% --------------------------------------------------------------------

\emph{Type Constant} (or \emph{Base Type} or \emph{Atomic Type})

Uninterpreted (\S\ref{sec:uninterpreted_function}) % FIXME



% --------------------------------------------------------------------
\subsection{Principal Type}\label{sec:principal_type}
% --------------------------------------------------------------------

Type System with Principal Type Property

given a Term, all other Types are instances of the Principal Type

Type Inference

%FIXME xref
Robinson's Unification Algorithm, used by Hindley-Milner Type
Inference

Polymorphic Recursion makes Inference of the Principal Type Undecidable

Generalized Algebraic Data Types negates the Principal Type Property



% --------------------------------------------------------------------
\subsection{Type Order}\label{sec:type_order}
% --------------------------------------------------------------------

In Simply-typed $\lambda$-calculus ($\lambda^\rightarrow$), the
\emph{Order} of a Type $\tau$, denoted $o(\tau)$, is defined
Inductively as:
\begin{itemize}
\item $o(T) = 0$ if $T$ is a Base Type
\item $o(\sigma \rightarrow \tau) = \text{max}(o(\sigma) + 1,
  o(\tau))$
\end{itemize}



% --------------------------------------------------------------------
\subsection{Inhabited Type}\label{sec:inhabited_type}
% --------------------------------------------------------------------

\emph{Inhabited}

In Simply-typed $\lambda$-calculus (\S\ref{sec:simply_typed}), a Type
is Inhabited if and only if its corresponding Proposition is a
Tautology of Minimal Implicative Logic (\S\ref{sec:minimal_logic}).

In Second-order $\lambda$-calculus (\S\ref{sec:system_f}), a
Type is Inhabited if and only if its corresponding Proposition is a
Tautology of Second-order Logic (\S\ref{sec:secondorder_logic}).



% --------------------------------------------------------------------
\subsection{Finite Type}\label{sec:finite_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Infinite Type}\label{sec:infinite_type}
% --------------------------------------------------------------------

Infinite Data Type (\S\ref{sec:infinite_datatype})



% --------------------------------------------------------------------
\subsection{Equality Type}\label{sec:equality_type}
% --------------------------------------------------------------------

The \emph{Equality Type} (or \emph{Identity Type}), denoted
\emph{Propositional Equality}, represents Equality of Types and Terms.

$a =_A b$: ``$a$ and $b$ are Equal Objects of Type $A$''

Martin-L\"of Notation $I(A,a,b)$

For $a,b:A$, the Term $a = b : I(A,a,b)$ Denotes the Type of Equality
Proofs for ``$a$ is Equal to $b$''. If the Type $I(A,a,b)$ is
Inhabited (a Proof exists), then $a$ is Equal to $b$.

There is one Canonical Inhabitant of $I(A,a,a)$ (Proof of
Reflexivity):
\[
  \text{refl}: \prod_{a:A} (a=a)
\]



% --------------------------------------------------------------------
\subsection{Power Type}\label{sec:power_type}
% --------------------------------------------------------------------

$P A$ the Type of all Subtypes (\S\ref{sec:power_type}) of $A$



% --------------------------------------------------------------------
\subsection{Data Type}\label{sec:data_type}
% --------------------------------------------------------------------

\subsubsection{Recursive Data Type}\label{sec:recursive_datatype}

or (\emph{Inductive Data Type})

Values may contain Values of the same Type

Well-founded (\S\ref{sec:well_founded})



\paragraph{Tree}\label{sec:tree_type}
\hfill \\

Tree (Graph Theory \S\ref{sec:tree})

Mutally Recursive Defenition: Forest (\S\ref{sec:forest_type})



\paragraph{Mutually Recursive Data Type}\label{sec:mutually_recursive_datatype}

\subparagraph{Forest}\label{sec:forest_type}

Tree (\S\ref{sec:tree_type})



\paragraph{Isorecursive Data Type}\label{sec:isorecursive_datatype}

\paragraph{Equirecursive Data Type}\label{sec:equirecursive_datatype}



\paragraph{Infinite Data Type}\label{sec:infinite_datatype}
\hfill \\

(Proof Object) Definition by Recursion: Proof by Induction



\subsubsection{Composite Data Type}\label{sec:composite_datatype}

\subsubsection{Algebraic Data Type}\label{sec:algebraic_datatype}

Trees (\S\ref{sec:tree})

$W$ Type

All standard Algebraic Data Types are Functors (\S\ref{sec:functor}).
A Parametrically Polymorphic (\S\ref{sec:parametric_polymorphism})
Function between two such Functors is a Natural Transformation
(\S\ref{sec:natural_transformation}).

Algebraic Data Types form a Semiring (\S\ref{sec:semiring})



\paragraph{Sum Type}\label{sec:sum_type}
\hfill \\

(or \emph{Variant Type} or \emph{Tagged Union})

Corresponds to Disjoint Union (\S\ref{sec:disjoint_union})

Coproduct (\S\ref{sec:coproduct})

Choices, Multiple ``Classes'' of Data



\paragraph{Product Type}\label{sec:product_type}
\hfill \\

(or \emph{Record Type})

(Cartesian) Product Types: Structs, Tuples

If $\sigma$ and $\tau$ are Types, then $\sigma \times \tau$ is a Type

$x : \sigma$, $y : \tau$, $(x,y) : \sigma \times \tau$

$fst_{\sigma,\tau} : (\sigma \times \tau) \Rightarrow \sigma$

$snd_{\sigma,\tau} : (\sigma \times \tau) \Rightarrow \tau$

Corresponds to Cartesian Product (\S\ref{sec:cartesian_product})

Product Type $A \times B$ is a special case of Dependent Sum Type
(\S\ref{sec:sigma_type}) $\Sigma_{(x:A)}B$ with a Constant Codomain
Type $B$:
\[
  \Sigma_{(x:A)} B \equiv A \times B
\]
where $\equiv$ is Judgemental Equality.



\paragraph{Coproduct Type}\label{sec:coproduct_type}
\hfill \\

%FIXME sum type?



\paragraph{Quotient Type}\label{sec:quotient_type}
\hfill \\

Set Theoretic Quotients

Categorical Semantics: Quotient Object (\S\ref{sec:quotient_object}) /
Coequalizer (\S\ref{sec:coequalizer})



\subsubsection{Generalized Algebraic Data Type}\label{sec:gadt}

\subsubsection{Logically Qualified Data Type}
\label{sec:logically_qualified}\cite{rondon-kawaguchi-jhala08}

\emph{Liquid Type}

Predicate Abstraction (\S\ref{sec:predicate_abstraction})

Logical Qualifier: Boolean Predicate

Dependent Type where the Refinement Predicate
(\S\ref{sec:refinement_type}) is a Conjunction of Logical Qualifiers.

Value Variable

Base Refinement:
\[
  \{ v : B | e \}
\]
where $e$ is a Boolean-valued Expression constraining $v$ called a
\emph{Refinement Predicate}.



% --------------------------------------------------------------------
\subsection{Data Constructor}\label{sec:data_constructor}
% --------------------------------------------------------------------

A \emph{Constructor} Introduces a Data Type on the right-hand side of
a definition.

A \emph{Destructor} Eliminates a Data Type on the left-hand side of a
definition.

Elimination for (Finite) Data corresponds to (Well-founded)
Recursion.

Introduction for Codata corresponds to Corecursion.



% --------------------------------------------------------------------
\subsection{Congruence Type}\label{sec:congruence_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Universe Type}\label{sec:universe_type}
% --------------------------------------------------------------------

A \emph{Universe Type} contains all other Types, see Type Universe
(\S\ref{sec:type_universe}).



% --------------------------------------------------------------------
\subsection{Inductive Type}\label{sec:inductive_type}
% --------------------------------------------------------------------

Monotonic Type Function $\Theta : \sigma \Rightarrow \tau$

Initial Algebras (\S\ref{sec:initial_algebra})

Type Constructor (\S\ref{sec:type_constructor})

Structural Recursion (\S\ref{sec:structural_recursion})

Streams between interacting processes in Programming Languages



\subsubsection{Coinductive Type}\label{sec:coinductive_type}

\emph{Coinductive Type} (\emph{Codata}), Coinduction
(\S\ref{sec:coinduction})

Terminal Coalgebras (\S\ref{sec:terminal_coalgebra})


\subsubsection{Induction Induction}\label{sec:induction_induction}

\emph{Induction Induction}



\subsubsection{Induction Recursion}\label{sec:induction_recursion}

\emph{Induction Recursion}



\subsubsection{Initial \& Final Type}\label{sec:initial_final_type}

\emph{Initial Data Types} are defined by the Least Fixed Point
(\S\ref{sec:least_fixedpoint}), up to Isomorphism given by an Initial
Algebra (\S\ref{sec:initial_algebra}), of a Type Function
(\S\ref{sec:type_function}). Ordinary Recursion
(\S\ref{sec:recursion}) defines Recursive Functions with an Initial
Data Type for a Domain.

\emph{Final Data Types} are defined, up to Isomorphism given by a
Final Coalgebra (\S\ref{sec:terminal_coalgebra}) by the Greatest
Fixpoint. Corecursion (\S\ref{sec:corecursion}) defines Recursive
Functions with a Final Data Type as a Codomain.

Initial (\S\ref{sec:initial_object}) \& Terminal
(\S\ref{sec:terminal_object}) Objects

In $\mathbf{Set}$, the Final Data Types may have Infinite,
Non-well-founded (\S\ref{sec:non_wellfounded}) Values.

In $\mathbf{Cpo}$ (the Category of Complete Partial Orders
\S\ref{sec:complete_partialorder} and Continuous Functions), Final
Types coincide with Initial Types and the corresponding Initial
Algebra and Final Coalgebras are Isomorphic.



% --------------------------------------------------------------------
\subsection{Concrete Type}\label{sec:concrete_type}
% --------------------------------------------------------------------

\fist Cf. Abstract (Existential) Type (\S\ref{sec:abstract_type})



% --------------------------------------------------------------------
\subsection{Abstract Type}\label{sec:abstract_type}
% --------------------------------------------------------------------

\emph{Abstract Type} (or \emph{Existential Type})

Type in a Nominal Type System (\S\ref{sec:nominal_type_system}) that
cannot be Instantiated (\S\ref{sec:instantiation}) directly.

Existentially Quantified Type Variable

Programming: Module Interfaces

Second-order Typed $\lambda$-calculus with Existential Quantification
(whereas System $F$ is Second-order Typed $\lambda$-calculus with
Universal Quantification.

a Type that is not Abstract is a Concrete Type
(\S\ref{sec:concrete_type})

Abstract Type with no Implementation: Protocol, Interface, etc.



\subsubsection{Abstract Data Type}\label{sec:abstract_datatype}

Type defined by certain Properties %FIXME

Type (with associated Operations) whose Representation is hidden

Co-algebra (\S\ref{sec:coalgebra})

\begin{itemize}
  \item Primitive Types in certain Programming Languages (e.g. Haskell)
  \item Parameterized Data Types (\S\ref{sec:parametric_datatype}, a
    weak form of Abstract Data Type)
  \item Type Class (Constrained Type \S\ref{sec:constrained_type})
\end{itemize}

Monads (\S\ref{sec:monad}) give the Interface to the Abstract Data
Type of ``Program Fragments'' (\fist Cf. Algebraic Effects
\S\ref{sec:algebraic_effect})



\paragraph{Parametric Data Type}\label{sec:parametric_datatype}
\hfill \\

\emph{Parametric Data Type} (or \emph{Parameterized Data Type} or
\emph{Generic Data Type})

Weak form of Abstract Data Type

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism})



\paragraph{Constrained Type}\label{sec:constrained_type}
\hfill \\

\emph{Type Class}

Ad-hoc Polymorphism \S\ref{sec:adhoc_polymorphism}) (Function
Overloading)



\subparagraph{Functional Dependency}\label{sec:functional_dependency}
\hfill \\

used to Constrain the Parameters (dependcies between the Parameters)
of a (Multi-parameter) Type Class

%FIXME xref relational database theory



% --------------------------------------------------------------------
\subsection{Polymorphic Type}\label{sec:polymorphic_type}
% --------------------------------------------------------------------

$\tau \mapsto \sigma$

Introduction:
\[
  {
  \frac{
    \begin{matrix}
      x : \sigma \\
      \vdots \\
      b : B
    \end{matrix}
  }
  {b : \sigma \mapsto \tau}
  }(\mapsto I)
\]

Terms depending on Types, e.g.:
\[
  x:\tau \vdash id(x):\tau
\]
where the Type of the Term $id(x)$ is $\tau$, which is dependent on
the Type $\tau$ of $x$, where the Type of $id$:
\[
  id:\sigma \rightarrow \sigma
\]
is Universally Quantified ``$\forall \sigma$''
(\S\ref{sec:parametric_polymorphism}).

Dependent Product Type (\S\ref{sec:pi_type})

Second-order $\lambda$-calculus (\S\ref{sec:system_f})

Subtyping (\S\ref{sec:subtype})

Variance (\S\ref{sec:type_variance})

Ad-hoc Polymorphism (\S\ref{sec:adhoc_polymorphism})

Restricted Rank

Rank-1 \emph{Prenex Polymorphism}: Type Variables may not be
instantiated with Polymorphic Types.

Rank-$k$: Quantifier may not appear to the left of $k$ or more Arrows;
Type Inference is decidable for Rank-2 but Rank-3 and above is not

Rank-$n$: Quantifier may appear to the left of arbitrarily many Arrows

Predicative: a Type $\tau$ containing a Type Variable $\alpha$ may not
have $\alpha$ Instantiated to a Polymorphic Type (Martin-L\"of Type
Theory \S\ref{sec:intuitionistic_type} and NuPRL).

Impredicative \emph{First-class Polymorphism}: Self-referential
(System F \S\ref{sec:system_f})

Parametric (\S\ref{sec:parametric_polymorphism}): Universal
Quantification

Existential (\S\ref{sec:abstract_type}): Existential Quantification

The Type $(\exists x : A).B$ is inhabited by Pairs $(a,b)$ with $a:A$
and $b:B[a/x]$, i.e. the Sum of the Types $B(x)$ as $x$ ranges over
$A$ \emph{or} the Subset of $A$ consisting of those $a \in A$ with the
Property $B[a/x]$.

Bounded Quantification (\S\ref{sec:bounded_polymorphism})



\subsubsection{Subtype}\label{sec:subtype}

\emph{Intersection Type}

\emph{Subtype Polymorphism}

System $F_{<:}$ (\S\ref{sec:system_fsub})

Bounded Polymorphism (\S\ref{sec:bounded_polymorphism})

Subtyping Judgement:
\[
  \Gamma \vdash \tau_1 \preceq \tau_2
\]

Power Type (\S\ref{sec:power_type}) $P A$: Type of all Subtypes of $A$

Coherence



\paragraph{Variance}\label{sec:type_variance}
\hfill \\

\emph{Variance} describes how Type Constructors either preserve,
reverse, or ignore Subtyping on input Types.

\begin{itemize}
  \item \emph{Covariant}: Preserves Subtyping
  \item \emph{Contravariant}: Reverses Subtyping
  \item \emph{Bivariant}: Both Subtypes
  \item \emph{Invariant}: No Subtyping
\end{itemize}

$(\rightarrow)$ is Contravariant on the Input Type and Covariant on
the Output Type.



\paragraph{Refinement Type}\label{sec:refinement_type}
\hfill \\

Predicate assumed to hold for any Element of Refined Type

\fist Cf. Behavioral Subtyping (\S\ref{sec:behavioral_subtype})

Type Targeted Testing, Liquid Types (Logically Qualified Types
\S\ref{sec:logically_qualified})



\subparagraph{Predicate Subtype}\label{sec:predicate_subtype}



\paragraph{Behavioral Subtype}\label{sec:behavioral_subtype}
\hfill \\

\emph{Substitutability}



\subsubsection{Parametric Polymorphism}
\label{sec:parametric_polymorphism}

\emph{Generic Function}

Parametric Datatype (\S\ref{sec:parametric_datatype})

Uniformaly for all Types (``for all''); used to define Natural
Transformations (\S\ref{sec:natural_transformation}) in Programming
Languages

Universally Quantified Type Variable

Type-level Function Abstraction $\Lambda$

Second-order $\lambda$-calculus (System F \S\ref{sec:system_f})

Bounded (\S\ref{sec:bounded_polymorphism}) Parametric Polymorphism



\subsubsection{Ad-hoc Polymorphism}\label{sec:adhoc_polymorphism}

\emph{Function Overloading}, \emph{Operator Overloading}

Polymorphic Functions (\S\ref{sec:polymorphic_function}) applied to
Terms of different Types

Ad-hoc Polymorphism is contrasted with Parametric Polymorphism by
supporting a limited number of distinct Types rather than any Type
whatsoever.

Constrained Type (Abstract Data Type \S\ref{sec:constrained_type})



\subsubsection{Bounded Polymorphism}\label{sec:bounded_polymorphism}

\emph{Bounded Quantification} (or \emph{Bounded Polymorphism} or
\emph{Constrained Genericity})

Bounds on Type Parameters to range only over Subtypes
(\S\ref{sec:subtype}) of a particular Type

Type Class (\S\ref{sec:constrained_type})



\subsubsection{Higher-rank Impredicative Polymorphism}
\label{sec:higherrank_impredicative}

\emph{Higher-rank Impredicative Polymorphism} (most general)



\subsubsection{Predicative Prenex Polymorphism}
\label{sec:predicative_prened}

\emph{Predicative Prenex Polymorphism} (Restricted Rank and
Predicative)

``\emph{Let-polymorphism}''



\subsubsection{Polymorphic Function}\label{sec:polymorphic_function}

A Polymorphic Function has a Dependent Product Type
(\S\ref{sec:pi_type}):
\[
  \Pi_{(A:\class{U})} A \rightarrow C
\]



\paragraph{Polymorphic Recursion}\label{sec:polymorphic_recursion}
\hfill \\

Recursive Parametrically Polymorphic Function

Type Inference under Polymorphic Recursion is Undecidable (equivalent
to Semi-unification) %FIXME



\paragraph{Free Theorem}\label{sec:free_theorem}



% --------------------------------------------------------------------
\subsection{Type Function}\label{sec:type_function}
% --------------------------------------------------------------------

\emph{Type Function} (or \emph{Type Operator})

Adding additional Type Operators to Simply-typed Lambda Calculus
results in \emph{Simply-typed Lambda Calculus with Type Operators}
``$\lambda \underline{\omega}$'' (\S\ref{sec:simplytyped_operators})

System F$_{\omega}$ (\S\ref{sec:system_fomega})

The Type Operators themselves can be viewed as a Simply-typed
$\lambda$-calculus with only one Base Type (\S\ref{sec:type_constant})
denoted `$\ast$' representing the Type of all Types in the underlying
Language which are called \emph{Proper Types} to distinguish from the
Type of the Type Operators which are called \emph{Kinds}
(\S\ref{sec:kind}).

A Type Function is an Endofunctor on the Category of Types.



\subsubsection{Type Variable}\label{sec:type_variable}

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism}):
Universally Quantified Type Variables

Existential Types (\S\ref{sec:abstract_type}):
Existentially Quantified Type Variables



\subsubsection{Kind}\label{sec:kind}

A \emph{Kind} is the Type of a Type Operator, or the Type of a
Higher-order Type Operator \S\ref{sec:higherorder_typeoperator}).



\subsubsection{Higher-order Type Operator}
\label{sec:higherorder_typeoperator}

Allowing for the Type Operators to form a Simply-typed
$\lambda$-calculus with the single Base Type `$*$' allows for
Higher-order Type Operators.



\subsubsection{Function Type}\label{sec:function_type}

A \emph{Function Type} (or \emph{Arrow Type}) is Type formed by the
Higher-kinded Type Constructor $\rightarrow$

The Function Type $A \rightarrow B$ is a special case of Dependent
Product Type (\S\ref{sec:pi_type}) $\Pi_{(a:A)}B$ with a Constant
Codomain Type $B$:
\[
  \Pi_{(a:A)}B \equiv A \rightarrow B
\]
where $\equiv$ is Judgemental Equality.

In a Category without Products, the Function Type can't be defined.

Function Types are Covariant Functors on the Return Type and
Contravariant Functors on the Argument Type. Cf. Hughes Arrows
(\S\ref{sec:hughes_arrow}).



\paragraph{Exponential Type}\label{sec:exponential_type}
\hfill \\

Higher-order Functions

Function Space

Function Type (\S\ref{sec:function_type})



\subsubsection{Type Constructor}\label{sec:type_constructor}

Injective Type Function: maps all Types of a particular Kind to a new
Set of Types and Type Synonyms

\emph{Type Constructor}

(or \emph{Type Schema})



\subsubsection{Type Family}\label{sec:type_family}

A \emph{Type Family} is a Partial Type Function that allows Types to
be defined by matching Terms. The Functionality of this Type Function

Generalization of Predicates (Relations) over Domains



\paragraph{Associated Type}\label{sec:associated_type}
\hfill \\

A Type Family declared inside a Type Class is an \emph{Associated
  Type}



% --------------------------------------------------------------------
\subsection{Partial Type}\label{sec:partial_type}
\cite{thompson99}
% --------------------------------------------------------------------

Non-terminating Computations

Total Objects are Identified at Simple Types

Undefined Object ``Bottom'' $\uparrow$ is a Member of every Type

\[
  \sigma \rightarrow \tau \quad
  \sigma \rightarrow \overline{\tau} \quad
  \overline{\sigma} \rightarrow \overline{\tau} \quad
  \overline{\sigma \rightarrow \tau} \quad
  \overline{\sigma \rightarrow \overline{\tau}} \quad
  \overline{\overline{\sigma} \rightarrow \overline{\tau}} \quad
\]



% --------------------------------------------------------------------
\subsection{Type Conversion}\label{sec:type_conversion}
% --------------------------------------------------------------------

\subsubsection{Type Promotion}\label{sec:type_promotion}

Special case of Implicit Type Conversion



% ====================================================================
\section{Type Universe}\label{sec:type_universe}
% ====================================================================

A \emph{Type Universe} is a Type whose Elements are Types.

Small Type %FIXME

Type Theory analogue of Inaccessible Cardinal
(\S\ref{sec:inaccessible_cardinal})

$\class{U}_0$ is the Universe of all Small Types. Every Name
(\S\ref{sec:name}) $a:\class{U}_0$ has an associated Type $El(a)$
giving its Extension or Meaning ($El$ is a Dependent Type
\S\ref{sec:dependent_type} that maps each Object to its corresponding
Type).

A Predicative Cumulative Hierarchy (\S\ref{sec:cumulative_hierarchy}):
\[
  \class{U}_0, \class{U}_1, \class{U}_2, \ldots
\]
is such that any Type in $\class{U}_n$ is also in
$\class{U}_{n+1}$:
\[
  u_n:\class{U}_n+1
\]
with (Cumulative Property):
\[
  El(u_n) \equiv \class{U}_n
\]

See $\class{U}-INTRO$ and $\class{U}-CUMUL$
\S\ref{sec:homotopy_rules}.



% --------------------------------------------------------------------
\subsection{Girard's Paradox}\label{sec:girards_paradox}
% --------------------------------------------------------------------



% ====================================================================
\section{Context}\label{sec:type_context}
% ====================================================================

A \emph{Context} (or \emph{Typing Environment} or \emph{Variable
  Assignment}), $\Gamma$, is a list of \emph{Typing Assumptions}
(\S\ref{sec:typing_assumption}) of the form:
\[
  \Gamma = x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n
\]
where each Element $x_i : A_i$ is an Assumption that the distinct
Variable $x_i$ has type $A_i$.

\emph{Typing Judgements} (\S\ref{sec:typing_judgement}) are formulated
under the Assumptions of a particular Context, $\Gamma$:
\[
  \Gamma \vdash a : A
\]
For an empty Context:
\[
  \vdash a : A
\]
or:
\[
  . \vdash a : A
\]

Closed Terms are those Terms that are Typable
(\S\ref{sec:typing_derivation}) in an Empty Context, e.g. the I, S,
and K Combinators (\S\ref{sec:combinator}).



% --------------------------------------------------------------------
\subsection{Typing Assumption}\label{sec:typing_assumption}
% --------------------------------------------------------------------

\emph{Typing Assumption})

\[
  e : \tau
\]
``Term $e$ has Type $\tau$''



% --------------------------------------------------------------------
\subsection{Type Annotation}\label{sec:type_annotation}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Type Erasure}\label{sec:type_erasure}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Reification}\label{sec:reification}
% --------------------------------------------------------------------

* opposite of Type Erasure
* see Type Inference (\S\ref{sec:type_inference})

Abstract idea about a computer program turned into an explicit Data
Model or Object

(Hypostatize) %FIXME

Monadic Reification (\S\ref{sec:monadic_reification})



% ====================================================================
\section{Typing Judgement}\label{sec:typing_judgement}
% ====================================================================

A \emph{Typing Judgement} is an instance of a \emph{Typing Relation}
(\S\ref{sec:typing_relation}).

A Typing Judgement expresses Propositional Equality. % FIXME

The Validity of a Typing Judgement is given by a Typing Derivation
(\S\ref{sec:typing_derivation}).

Constant Type % FIXME empty context



% --------------------------------------------------------------------
\subsection{Typing Relation}\label{sec:typing_relation}
% --------------------------------------------------------------------

\emph{Typing Relation} between Terms and Types

\[
  \Gamma \vdash e : \tau
\]
``$e$ is a (Well-typed \S\ref{sec:well_typed}) Term of Type $\tau$ in
Context $\Gamma$'',

Terms that are Well-typed in the Empty Context are Closed Terms.

Under a Proof Theoretic Interpretation, $p : P$ may be read as ``$p$
is a Proof of Proposition $P$''



% --------------------------------------------------------------------
\subsection{Typing Rule}\label{sec:typing_rule}
% --------------------------------------------------------------------

A \emph{Typing Rule} (or \emph{Type Rule}) describes how a Type is
assigned to a Syntactic Construction.

Corresponding to Introduction and Elimination Rules of Proof Theory
(\S\ref{sec:structural_rule}).

Introduction and Elimination corresponds to Data Constructors
(\S\ref{sec:data_constructor}).

The notation for Type Rules is that of Sequent Notation
(\S\ref{sec:sequent}):
\[
  {
    \frac
    { \Gamma_1 \vdash e_1:\tau_1 \quad \cdots
      \quad \Gamma_n \vdash e_n:\tau_n }
    { \Gamma \vdash e:\tau }
  }
\]
where $\Gamma$ are Typing Environments and $e:\tau$ are Typing
Judgements.



% --------------------------------------------------------------------
\subsection{Typing Derivation}\label{sec:typing_derivation}
% --------------------------------------------------------------------

A \emph{Typing Derivation} shows the Validity of a Typing Judgement
and is constructed from Typing Rules (\S\ref{sec:typing_rule}).

Derivation (\S\ref{sec:formal_proof})

Undischarged Assumptions in Formal Proofs correspond to Free Variables
in Typing Derivations, Discharged Assumptions to Bound Variables

A Rewrite Rule maps a Valid Typing Derivation to another Valid Typing
Derivation (\emph{Subject Reduction} \S\ref{sec:subject_reduction},
\emph{Type Soundness}) \cite{wadler14}

A Term for which a Typing Derivation exists is called a
\emph{Well-typed Term} (\S\ref{sec:well_typed}).



\subsubsection{Type Witness}\label{sec:type_witness}

\emph{Witnessing Information} gives verification of a Typing
Assumption



\subsubsection{Subject Reduction}\label{sec:subject_reduction}

A Type System has \emph{Subject Reduction} (or \emph{Type
  Preservation}) if Evaluation (\S\ref{sec:evaluation_strategy}) of
Expressions leaves their Types unchanged.



% ====================================================================
\section{Type Inference}\label{sec:type_inference}
% ====================================================================

% ====================================================================
\section{Type System}\label{sec:type_system}
% ====================================================================

\emph{Type System} (or \emph{Typing Discipline})



% --------------------------------------------------------------------
\subsection{Type Checking}\label{sec:type_checking}
% --------------------------------------------------------------------

\subsubsection{Bi-directional Type Checking}
\label{sec:bidirectional_checking}

\emph{Checking}

\emph{Synthesis}



\subsubsection{Extended Static Checking}\label{sec:extended_static}



% --------------------------------------------------------------------
\subsection{Nominal Type System}\label{sec:nominal_type_system}
% --------------------------------------------------------------------

Names



% --------------------------------------------------------------------
\subsection{Unified Type System}\label{sec:unified_type_system}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Structural Type System}\label{sec:structural_type_system}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Substructural Type System}
\label{sec:substructural_type_system}
% --------------------------------------------------------------------

Substructural Logic (\S\ref{sec:substructural_logic})

Substructural Type Systems are categorized by allowing or disallowing
Structural rules of Exchange (\S\ref{sec:exchange_rule}), Weakening
(\S\ref{sec:weakening_rule}), or Contraction
(\S\ref{sec:contraction_rule}):

\begin{itemize}
  \item Linear Type Systems (\S\ref{sec:linear_type}): Allow Exchange,
    not Weakening or Contraction; Every Variable used exactly once
  \item Affine Type Systems (\S\ref{sec:affine_type}): Allow Exchange
    and Weakening, not Contraction; Every occurrence of a Variable
    used at most once
  \item Relevant Type System (\S\ref{sec:relevant_type}): Allow
    Exchange and Contraction, not Weakening; Every variable used at
    least once
  \item Ordered Type System (\S\ref{sec:ordered_type}): Disallow
    Exchange, Contraction and Weakening; Every Variable is used
    Exactly once in the order it was introduced
\end{itemize}



\subsubsection{Linear Type System}\label{sec:linear_type}

Values used exactly once

Linear Logic (\S\ref{sec:linear_logic}) allows safe Deallocation
(Objects used exactly once)

Distribution and Concurrency (Session Types \S\ref{sec:session_type})

Linear $\lambda$-calculus (\S\ref{sec:linear_lambda})

Internal Language (\S\ref{sec:internal_logic}) of Closed Symmetric
Monoidal Categories (\S\ref{sec:closed_symmetric_monoidal})

Allows References but not Aliases

Modelling of Heap-based Memory Allocation

No-cloning Theorem (Quantum States):
\begin{itemize}
  \item No Diagonal Functor (\S\ref{sec:diagonal_functor})
    which could duplicate States
  \item No $K$-combinator which can destroy States
  \item A Variable $x$ can appear at most once in a $\lambda$-term
\end{itemize}



\paragraph{Affine Type System}\label{sec:affine_type}
\hfill \\

Values used at most once

Affine Logic (\S\ref{sec:affine_logic})



\paragraph{Session Type}\label{sec:session_type}
\hfill \\

\emph{Session Types} are a Typing Discipline (\S\ref{sec:type_system})
for Heterogenous Bidirectional Communication Channels defining the
possible Sequences of Messages (\S\ref{sec:message}) determined by the
Channel's Session Type (e.g. Stream-based Internet Protocols)
\cite{neubauer-thiemann04}

Message Sequences are Described by a Regular Language
(\S\ref{sec:regular_language}) on Atomic Communication Actions
(\S\ref{sec:communication}); Channel Type (\S\ref{sec:channel_type})
specifies the Language with a Fix-point Expression ($\mu$). Operations
peel off the ``outermost'' Action (???) of the Channel Type and change
the Channel Type (Linearity). \cite{neubauer-thiemann04}

Implementation requirements: \cite{neubauer-thiemann04}
\begin{itemize}
  \item Type Constraints (Type Classes \S\ref{sec:constrained_type})
    with Functional Dependencies (\S\ref{sec:functional_dependency}):
    modelling the progression of the current state of the Channel
  \item Functions with Polymorphic Parameters
    (\S\ref{sec:parametric_polymorphism}): models Client and Server
    side of a Communication with one specification
\end{itemize}

Static Analysis of the Communication Behavior (???) of Agents (???) in
a Distributed System \cite{gay-vasconcelos10}

(Communication) Protocol

Distribution and Concurrency

$\parr$

$\otimes$

Curry-Howard (\S\ref{sec:curry_howard}) for Process Calculi
(\S\ref{sec:process_calculus}):
\begin{itemize}
  \item Propositions as Session Types
  \item Proofs as Processes (\S\ref{sec:process})
  \item Cut-elimination (\S\ref{sec:cut_elimination}) as Communication
    (\S\ref{sec:communication})
\end{itemize}

Linear Propositions (\S\ref{sec:linear_logic})

Dual Intuitionistic Linear Logic \cite{caires-pfenning10} (Shared ???,
Linear)

% FIXME ???
Session: a ``unit'' of a Communication

Session Type: ``structure'' of a Communication

Only Processes with Dual Protocols can Interact

Cotype


\cite{honda-vasconcelos-kubo98}:

Session: a Sequence of Dyadic Interactions

Program: a Collection of Dyadic Interactions in a Session \emph{or} a
Process with no Free Variables % FIXME

Channel: Private Port Designating a Session (cf. Information Theory
\S\ref{sec:channel} Channels)

Session Protocol (\S\ref{sec:session_protocol})


\cite{neubauer-thiemann04}:
\begin{enumerate}
  \item First-order Base Type Values
  \item Functions
  \item Labels (cf. Labels in Record (\S\ref{sec:product_type}) or
    Variant Types (\S\ref{sec:sum_type})
\end{enumerate}


\textbf{Primitives}

\begin{itemize}
  \item \emph{Send}
  \item \emph{Receive}
  \item \emph{Sequence}
  \item \emph{Choice}
  \item \emph{Recursion}
\end{itemize}



\paragraph{Channel Type}\label{sec:channel_type}

\subparagraph{Label}\label{sec:channel_label}



\subsubsection{Relevant Type System}\label{sec:relevant_type}

Relevant Logic (\S\ref{sec:relevance_logic})



\subsubsection{Ordered Type System}\label{sec:ordered_type}

Noncommutative Logic (\S\ref{sec:noncommutative_logic})

modelling Stack-based Memory Allocation

only Objects on top of modelled Stack may be used, after which it is
popped off



% --------------------------------------------------------------------
\subsection{Hindley-Milner Type System}\label{sec:hindley_milner}
% --------------------------------------------------------------------

$\lambda$-calculus with Parametric Polymorphism



\subsubsection{Algorithm W}\label{sec:algorithm_w}



% ====================================================================
\section{Effect System}\label{sec:effect_system}
% ====================================================================

(Wadler, Thiemann - 2003 - \emph{The marriage of effects and monads}):
%FIXME

Types $\tau$, $\tau'$

Effect $\sigma$

$\tau \xrightarrow{\sigma} \tau'$

$(\tau \xrightarrow{\sigma} \tau')^\dag$
$\rightsquigarrow$
$\tau^\dag \rightarrow T^\sigma \tau'^\dag$

subsumed by Monads: ``Lazy State'' and ``Lazy Writer'' cannot be
captured by any Effect System (E. Kmett)



% --------------------------------------------------------------------
\subsection{Computational Effect}\label{sec:computational_effect}
% --------------------------------------------------------------------

Computational Effects

e.g. Exceptions, Non-determinism, Interactive Input/Output,
Concurrency, State, Time, Continuations, etc. \cite{plotkin-pretnar09}

Monad (\S\ref{sec:monad})

Computation (Monad) $T$ Returning Value of Type $A$:
\[
  T A
\]

Return

Bind

\cite{plotkin-pretnar13}:

In the Category $\cat{Set}$, a Computation that Returns Values from a
Set $A$ is Modelled by an Element $T A$ for a ``suitable'' Monad $T$.

E.g. Exceptions, State, Non-determinism, Interactive Input/Output,
Time, Continuations, etc. (and combinations thereof)

Algebraic Effects (\S\ref{sec:algebraic_effect}):
\begin{itemize}
  \item Set of Operations representing Sources of Effects
  \item Equational Theory describing Properties of the Operations
\end{itemize}



\subsubsection{Partiality Effect}\label{sec:partiality_effect}

an Effect that all Recursively Defined Functions have
(\S\ref{sec:recursive_function})

possible Semantics:

Lifting Monad (\S\ref{sec:lifting_monad})

Continuation-based (\S\ref{sec:continuation})



\subsubsection{Exception Effect}\label{sec:exception_effect}

\cite{plotkin-pretnar13}:

Finite Set of Exceptions $\mathbf{exc}$

Exception Monad

\begin{align*}
     T A & \defeq A + \mathbf{exc} \\
  \eta_A & \defeq in_1 : A \rightarrow A + \mathbf{exc}
\end{align*}

Computations:

$\mono{return}\; V$ Interpreted by $\eta_A(V) = in_1(V)$

$\mono{raise}_e()$ Interpreted by $in_2(e)$

Effect Handler (\S\ref{sec:effect_handler})

Exception Handling

Computation $M \in A + \mathbf{exc}$
\[
  M \;\mono{handled\;with}\;
    \{\mono{raise}_e \mapsto M_e \}_{e\in\mathbf{exc}}
\]
where $\{\cdots\}_{e\in\mathbf{exc}}$ is a Set of Computations, one
for each Exception $e \in \mathbf{exc}$

carries out $M$, ``Intercepting'' Exceptions $e \in \mathbf{exc}$ by
carrying out predefined Computations $M_e \in A + \mathbf{exc}$
instead

Un-handled Exceptions take $M_e$ to be $\mono{raise}_e()$

Handling Construct Satisfies two Equations:
\begin{enumerate}
  \item $\mono{return}\; V \;\mono{handled\;with}\;
    \{\mono{raise}_e \mapsto M_e\}_{e \in \mathbf{exc}}
    = in_1(V)$
  \item $\mono{raise}_{e'}() \;\mono{handled\;with}\;
    \{\mono{raise}_e \mapsto M_e\}_{e \in \mathbf{exc}}
    = M_{e'}$
\end{enumerate}

the Computations $M_e$ give a new Model $\mathcal{M}$ for the Theory
of Exceptions with same Carrier (i.e. Domain \S\ref{sec:domain}) $A +
\mathbf{exc}$ and for each $e$, each $\mono{raise}_e ()$ is instead
Interpreted by $M_e$

\[
  h(M) \defeq M \;\mono{handled\;with}\;
    \{\mono{raise}_e \mapsto M_e\}_{e \in \mathbf{exc}}
\]
is a Unique Homomorphism (Preserving Operations) from $A +
\mathbf{exc}$ to $\mathcal{M}$ that Extends $in_1 : A \rightarrow A +
\mathbf{exc}$, i.e. such that:
\[
  A \xrightarrow{in_1} \mathcal{M} =
    A \xrightarrow{\eta_A} A + \mathbf{exc} \xrightarrow{h} \mathcal{M}
\]

Extended Handling Construct:
\[
  M \;\mono{handled\;with}\;
    \{\mono{raise}_e() \mapsto M_e \}_{e\in\mathbf{exc}}
    \;\mono{to}\; x : A.N(x)
\]

\begin{enumerate}
  \item $\mono{return}\; V \;\mono{handled\;with}\;
    \{\mono{raise}_e() \mapsto N_e\}_{e \in \mathbf{exc}}
    \;\mono{to}\; x:A.N(x)
    = N(V)$
  \item $\mono{raise}_{e'}() \;\mono{handled\;with}\;
    \{\mono{raise}_e() \mapsto N_e\}_{e \in \mathbf{exc}}
    \;\mono{to}\; x:A.N(x)
    = N_{e'}$
\end{enumerate}
\[
  A \xrightarrow{N} \mathcal{M} =
    A \xrightarrow{\eta_A} A + \mathbf{exc} \xrightarrow{h} \mathcal{M}
\]

Homomorphisms from the Free Model to a Model on a given Carrier

Effect Handler (\S\ref{sec:effect_handler}): Exceptions replaced by
Handling Computations



\subsubsection{State Effect}\label{sec:state_effect}

\subsubsection{Subeffect}\label{sec:subeffect}

Layered Monad (\S\ref{sec:layered_monad}) \cite{filinski99}



\subsubsection{Layered Monad}\label{sec:layered_monad}
\cite{filinski99}

each Effect specified independently by a Formal Monadic Translation

Proto-operations: Monadic Reflection (\S\ref{sec:monadic_reflection}),
Monadic Reification (\S\ref{sec:monadic_reification})

\fist Cf. Algebraic Effects (\S\ref{sec:algebraic_effect}):
\emph{Effect Constructors} (Algebraic Operations
\S\ref{sec:algebraic_operation}) and \emph{Effect Deconstructors}
(Effect Handlers \S\ref{sec:effect_handler})


establishes a (Trivial) Bijection between ``Opaque'' and
``Transparent'' Representations of an Effectful Computation

Effect Operations defined using the Transparent Representation

General Programs written using the Opaque Abstraction

each Monadic Translation can be simulated by a Continuation-passing
(\S\ref{sec:continuation}) Translation: original Transparent
Representation but with a different Opaque Representation substituted

$e ::= \mathfrak{n} | \mathfrak{p} | \cdots$ Effect Names

$E$ Expressions

$\tau$ Types

$\Gamma$ Context (Assumptions)

Typing Judgement:
\[
  \Gamma \vdash E : \tau / e
\]
Expression $E$ has Type $\tau$ and possible Effects $e$

$\mathfrak{n}$: \emph{None}: Evaluation of $E$ has no Effects

$\mathfrak{p}$: \emph{Partiality} (\S\ref{sec:partiality_effect};
Evaluation of $E$ may Diverge (\S\ref{sec:divergence}); all
Recursively Defined Functions (\S\ref{sec:recursive_function}) have
Partiality

$\mathfrak{ex}$: \emph{Exceptions} (\S\ref{sec:exception_effect}

$\mathfrak{st}$: \emph{State} (\S\ref{sec:state_effect}

Effect-layering Relation $e_1 \prec e_2$: typically $e_2$ was defined
by a Formal Translation into a Language with $e_1$-effects; Subeffect
(\S\ref{sec:subeffect})

$\preceq$ Reflexive, Transitive Closure of $\prec$

$\tau_1 \xrightarrow{\mathfrak{n}} \tau_2$ may be written $\tau_1
\rightarrow \tau_2$

$\Gamma \vdash E : \tau / \mathfrak{n}$ may be written as

$\Gamma \vdash E : \tau$ may be written as

\emph{Complete Program}: Closed Term of Base Type

``Escaping'' Effects (disallowed)

Signature $\Sigma$ assigns (potentially Polymorphic) Types to the Base
Constants of the Language (e.g. standard Arithmetic Functions,
Call-by-value Fix-point Operators, etc.)

Implicit Subtyping (\S\ref{sec:subtype}), Implicit Subeffect
(\S\ref{sec:subeffect})

Coercion Terms

Chain-complete Posets (CPO \S\ref{sec:cpo})

Monad (\S\ref{sec:monad}) $T$ Maps a CPO $A$ to a CPO of
$A$-computations

Elements of $T A$ are Effectful Computations yielding Values in $A$

\emph{Layering} of Monad $(T,\eta,\mu)$ Over another Monad
$(\overline{T}, \overline{\eta}, \overline{\mu})$ is a Family of
Functions:
\[
  \zeta_A : \overline{T}(T A) \rightarrow T A
\]
such that each $(T A, \zeta_A)$ is a $\overline{T}$-algebra
(\S\ref{sec:t_algebra}) %FIXME

Any Monad can be Layered over itself %FIXME

For Monad $T$ Layered over Monad $\overline{T}$, a Family of
\emph{Computation-inclusion} (or \emph{Lifting}) Functions:
\[
  i_A = \zeta_A \circ \overline{T} \eta_A :
    \overline{T} A \rightarrow T A
\]

For Monad Morphism (\S\ref{sec:monad_morphism}) $i : \overline{T}
\rightarrow T$, a Layering is obtained by:
\[
  \zeta_A = id^*_{T A} \circ i_A
\]

(Trivial) Layering of a Monad $T$ over the Identity Monad
(\S\ref{sec:identity_monad}) by taking $\zeta_A t = t$

Semantics $\class{L}$ of Effect-language $L$:
\begin{itemize}
  \item Base Types $b$: CPO $\class{B}(b)$
  \item Effects $e$: Monad $\class{E}(e) = (T^e,\eta^e,\mu^e)$
    \begin{itemize}
      \item if $e' \prec e$ then $\class{E}(e)$ is Layered over
        $\class{E}(e')$ by $\zeta^e$
    \end{itemize}
\end{itemize}

$\class{E}(\mathfrak{n})$ Identity Monad $I$

$\class{E}(\mathfrak{p})$ Lifting Monad $L$

Definitional Translation: ``explaining away'' and Effect

Syntactic Extension: \emph{Formal Monad} $\mathsf{T}$ over Effect
$\bar{e}$ in $L$ is a Type Constructor with 3 ``Polymorphic Terms''
(???):
\begin{align*}
  \mathsf{T} - &: Type \rightarrow Type \\
  glue_\alpha &: (1 \xrightarrow{\bar{e}} \mathsf{T} \alpha)
    \rightarrow \mathsf{T} \alpha \\
  unit_\alpha &: \alpha \rightarrow \mathsf{T} \alpha \\
  bind_{\alpha_1,\alpha_2} &: \mathsf{T} \alpha_1 \times (\alpha_1
    \rightarrow \mathsf{T} \alpha_2) \rightarrow \mathsf{T} \alpha_2
\end{align*}
denotes an (actual) Monad:
\[
  \class{L}\llbracket \mathsf{T} \rrbracket^m = (T,\eta,\mu,\zeta)
\]
Layered over $\class{E}(\bar{E})$ in a Semantics $\class{L}$ of
Effect-language $L$ if: %FIXME
\begin{enumerate}
  \item
  \item
  \item
  \item
\end{enumerate}

\fist $\mathsf{T}$ does not necessarily denote a Monad for all
Interpretations of the Effect $\bar{e}$, e.g. the List Monad can only
be properly Layered over a Commutative Monad (???) such as Partiality
%FIXME

Given $\mathsf{T}$, $L^\mathsf{T}$ is an (Proper) Extension of $L$
with new Effect $t$ and new Proto-operations \emph{Monadic Reflection}
(\S\ref{sec:monadic_reflection}) and \emph{Monadic Reification}
(\S\ref{sec:monadic_reification}):
\begin{align*}
  \mono{reflect}_\alpha^t &: \mathsf{T} \alpha \xrightarrow{t} \alpha \\
  \mono{reify}_\alpha^t &: (1 \xrightarrow{t} \alpha) \rightarrow
    \mathsf{T} \alpha
\end{align*}

\fist Cf. Algebraic Effects (\S\ref{sec:algebraic_effect}):
\emph{Effect Constructors} (Algebraic Operations
\S\ref{sec:algebraic_operation}) and \emph{Effect Deconstructors}
(Effect Handlers \S\ref{sec:effect_handler})

Any $L$-program is still a Valid $L^\mathsf{T}$-program with the same
Meaning: Semantics of $L^\mathsf{T}$ can be defined by a Formal
Monadic Translation $|-|_\mathsf{T}$ back into $L$ by expanding only
the new Type and Term Constructors into their $L$-definitions

Explicit Effect-passing (???)

Effect-ordering: Hierarchical, Translation-based Definition

different orderings correspond to different intended Semantics

Example ordering:
\[
\mathfrak{p} \prec \mathfrak{st} \prec \mathfrak{ex}
\]
with State persistent across Exceptions, corresponds to Effect Type:
\[
  ||\alpha / \mathfrak{ex}|_{EX}|_{ST} = |1
  \xrightarrow{\mathfrak{st}} \alpha + exn|_{ST} = 1 \rightarrow state
  \xrightarrow{\mathfrak{p}} (\alpha + exn) \times state
\]
$\mathfrak{st}$-computations always Implicitly Coercible (with
Subtyping Definitions) into an
$\mathfrak{ex}$-computation

Each individual Monadic Translation can be uniformly simulated by a
Layer of Continuation-passing

Any hierarchy of Continuation-passing Layers can be simulated by a
single Effect comprising First-class Continuations and Mutable State

$\mono{shift}$

$\mono{reset}$

$T$-$K$ Simulation Theorem

$K$-$CS$ Simulation Theorem

$T^*$-$CS^*$ Simulation Theorem

Metacontinution (???)

Resumption-computation (\S\ref{sec:resumption})

Effect-recursive Monads (???): new Effect being defined is implicitly
used in its own Specification



\paragraph{Monadic Reflection}\label{sec:monadic_reflection}
\hfill \\
\[
  \mono{reflect}_\alpha^t : \mathsf{T} \alpha \xrightarrow{t} \alpha
\]

\emph{Effect Deconstructor}: Algebraic Effects
(\S\ref{sec:algebraic_effect}), Effect Handler
(\S\ref{sec:effect_handler})



\paragraph{Monadic Reification}\label{sec:monadic_reification}
\hfill \\
\[
  \mono{reify}_\alpha^t : (1 \xrightarrow{t} \alpha) \rightarrow
    \mathsf{T} \alpha
\]

\emph{Effect Constructor}: Algebraic Effects
(\S\ref{sec:algebraic_effect}), Algebraic Operation
(\S\ref{sec:algebraic_operation})



% --------------------------------------------------------------------
\subsection{Algebraic Effect}\label{sec:algebraic_effect}
% --------------------------------------------------------------------

\cite{nielson-nielson99}
\cite{plotkin-pretnar09}
\cite{plotkin-pretnar13}
\cite{pretnar15}

\fist The paper \emph{Handlers of Algebraic Effects}
\cite{plotkin-pretnar09} (Plotkin, Pretnar 2009) is a preliminary
version of \emph{Handling Algebraic Effects} \cite{plotkin-pretnar13}
(Plotkin, Pretnar 2013). In \cite{plotkin-pretnar09}, there are
restricted facilities for defining Handlers (the \emph{Minimal}
approach). Two levels of Language are considered: in the first there
are no Handlers but it is used to define Handlers, and if they give
Models then they are used in Handling Constructs in the second level
(with no facilities for further definition of Handlers). In
\cite{plotkin-pretnar13} Handlers and Handling may be nested
arbitrarily deeply (the \emph{Maximal} approach).


(Countable) Equational Theories (Algebraic Theory
\S\ref{sec:algebraic_theory})

Algebraic Operation (\S\ref{sec:algebraic_operation})


as an alternative to using Monads (\S\ref{sec:monad}) to Model
Side-effects, most often seen in Strict Languages

Continuations (\S\ref{sec:continuation}) are not representable as
Algebraic Effects


Call-by-value, Call-by-push-value %FIXME


\cite{plotkin-pretnar08}:

Effectful Programs (1) cause Effects (Computation Terms combined by an
Operation), (2) Return Values (Returned Value Terms), (3) have an
Evaluation Order (Computations Sequenced with a $\mono{let}$ Binding)

$a$-calculus: Values, Effects, Computations

Operations: ``sources'' of Effects

Value Theory $\thy{V}$

$\Sigma_{\mathrm{fun}}$

Value Contex $\Gamma$

Effect Theory $\thy{E}$

$\Sigma_{\mathrm{op}}$

Effect Contex $\Xi$

Computations Returning Value of Type $\sigma$: $F \sigma$

Evaluation of Computation $\mono{let}\; x \;\mono{be}\; \mono{op}(t_1,
\ldots, t_n) \;\mono{in}\; t'$ begins with Occurrence of Effect
represented by $\mono{op}:n$ and then based on the Outcome (???) of an
Effect, proceeds by Evaluating one of the Computation Terms $t_1,
\ldots, t_n$ and Binding its Result to $x$ in Computation Term $t'$

Effect Theory $\thy{E}$ gives rise to a Lawvere Theory
(\S\ref{sec:lawvere_theory}) $\cat{L}$

\textbf{Semantics}

Value Terms Interpreted in $\cat{Set}$

Effect Terms Interpreted in a Lawvere Theory $\cat{L}$

Computation Terms Interpreted in the Category of Models
(\S\ref{sec:category_of_models}) $\cat{Mod}_\cat{L}(\cat{Set})$ of
Models of $\cat{L}$ in $\cat{Set}$.



\cite{plotkin-pretnar13}:

Algebraic Effects (\S\ref{sec:algebraic_effect}):
\begin{itemize}
  \item Set of Operations representing Sources of Effects
  \item Equational Theory (\S\ref{sec:equational_theory}) describing
    Properties of the Operations
\end{itemize}

Each Computation either Returns a Value, or performs an Operation with
an Outcome that determines a Continuation (\S\ref{sec:continuation})
of the Computation with Arguments of the Operation representing
possible Continuations (possible Computations after the occurrence of
an Effect).



\cite{plotkin-pretnar09}:

$T X$: Computations $T$ that Return Values in $X$, for ``suitable''
Monad (\S\ref{sec:monad}) $T$

Subclass of Computational Effects (\S\ref{sec:computational_effect}):
Effects that allow Representation by Operations and Equations.

Equational Logic (\S\ref{sec:equational_logic})

Computational Effects representable by an Algebraic Theory:
Nondeterminism, Interactive Input/Output, Concurrency, State, Time,
Stream Redirection, Backtracking, Co-operative Multi-threading,
Delimited Continuations, etc.

Sets of Operations

Operations give rise to Effects

Arguments of an Operation represent possible Computations after an
Occurrence (???) of an Effect

Example Non-deterministic Boolean $\mono{or}$ Operator:
\[
  \mono{or}(\mono{return}\;true, \mono{return}\;false)
  : F \mathrm{Bool}
\]

$F \sigma$: Type of Computations with Return Values of Type $\sigma$

Computation Monad: Free-model Monad (???, Free Monad
\S\ref{sec:free_monad}) of the Algebraic Theory; Equations of the
Theory Generate the Free-model Functor (exactly the corresponding
Monad for the Effect, Modulo the Forgetful Functor): used to Interpret
the Type $F \sigma$.

Operations Interpreted by the Model Structure

Family of Functions Parametric in $X$ (Algebraic Operation),
characterized by a Naturality Condition %FIXME

Example Parametric Operation:
\[
  \mono{or}_X : T X^2 \rightarrow T X
\]

Algebraic Operations \S\ref{sec:algebraic_operation} (\emph{Effect
  Constructors}) and Effect Handlers \S\ref{sec:effect_handler}
(\emph{Effect Destructors}) are Dual

\fist Cf. Monadic Reflection (\S\ref{sec:monadic_reflection})
and Monadic Reification (\S\ref{sec:monadic_reification})

Handlers (\S\ref{sec:effect_handler}) correspond to a Model of the
Algebraic Theory

Handling a Computation is Composing it with a Unique Homomorphism
(defined Universally) with Domain a Free Model
(\S\ref{sec:free_model}) of the Algebraic Theory of the Effects ``at
hand'', and Range the Programmer-defined Model (???) of the Algebraic
Theory, Extending a Programmer-defined Map on Values.

Instances of Handlers: Exception Handling, Stream Redirection,
Renaming and Hiding, Timeout, Rollback, etc.

\fist Note that some Handlers (e.g. for Backtracking) do not
respect the Equations of an Algebraic Theory. \cite{pretnar15}

\cite{plotkin-pretnar09}:

Parts of an Effect System detailed below:
\begin{itemize}
  \item Base Signature $\Sigma_\mathrm{base}$:
    \begin{itemize}
      \item Base Types
      \item Function Symbols
      \item Relation Symbols
    \end{itemize}
  \item Base Terms
  \item Base Formulas
  \item Effect Signature $\Sigma_\mathrm{eff}$:
    \begin{itemize}
      \item Operations
    \end{itemize}
  \item Effect Terms
  \item (Conditional) Effect Theory (\S\ref{sec:effect_theory})
    $\thy{E}$:
    \begin{itemize}
      \item Conditional Equations
    \end{itemize}
  \item Handler (\S\ref{sec:effect_handler}) Signature
    $\Sigma_\mathrm{hand}$:
    \begin{itemize}
      \item Handler Symbols
    \end{itemize}
  \item Handler Types
  \item Handler Terms
  \item Computation Types
  \item Computation Terms
\end{itemize}


\emph{Base Signature} $\Sigma_{\mathrm{base}}$:
\begin{itemize}
  \item Base Types $\beta_1, \beta_2, \ldots$
  \begin{itemize}
    \item Arity Types $\alpha_1, \alpha_2, \ldots$
  \end{itemize}
  \item Function Symbols $f : (\vec{\beta}) \rightarrow \beta$
  \item Relation Symbols $R : (\vec{\beta})$
\end{itemize}

Variables $x,y,z,\ldots$

Function Symbols $f,g,h,\ldots$

\emph{Base Terms}:
\begin{flalign*}
  \quad v ::=& x \; | \; f (\vec{v}) &
\end{flalign*}

\emph{Base Formulas} $\varphi$: Equations $v_1 = v_2$, Relation
Symbols $R (\vec{v})$, Logical Connectives, Quantifiers
applied to Base Types

\emph{Context} $\Gamma$: Variables Bound to Base Types

A Context $\Gamma$ Types Base Terms as $\Gamma \vdash v:\beta$ and
Base Formulas as $\Gamma \vdash \varphi : \mathbf{form}$

\emph{Interpretation} of the Base Signature:
\begin{itemize}
  \item Sets $\llbracket \beta \rrbracket$ for each Base Type
    (Countable when $\beta$ is an Arity Type)
  \item Maps $\llbracket f \rrbracket : \llbracket \vec{\beta}
    \rrbracket \rightarrow \llbracket \beta \rrbracket$ for each
    Function Symbol
  \item Subsets $\llbracket R \rrbracket \subseteq \llbracket
    \vec{\beta} \rrbracket$ for each Relation Symbol
  \item Maps $\llbracket v \rrbracket : \llbracket \Gamma \rrbracket
    \rightarrow \llbracket \beta \rrbracket$ for Terms
  \item Subsets $\llbracket \varphi \rrbracket \subseteq \llbracket
    \Gamma \rrbracket$ for Formulas
\end{itemize}
where $\llbracket \vec{\beta} \rrbracket = \llbracket \beta_1
\rrbracket \times \cdots \times \llbracket \beta_n \rrbracket$

\emph{Effect Signature} $\Sigma_{\mathrm{eff}}$:
\begin{itemize}
  \item Operation Symbols $\mono{op} : \vec{\beta}; \vec{\alpha}_1,
    \ldots, \vec{\alpha}_n$ where $\vec{\beta}$ is a list of Parameter
    Base Type and $\vec{\alpha}_1, \ldots, \vec{\alpha}_n$ are Lists
    of Argument Arity Types (``;'' is ommitted if the List of Base
    Types is Empty and $n$ is used if all $\vec{\alpha}_i$ Lists of
    Argument Arities are Empty)
\end{itemize}

\emph{Effect Variables} $w$

\emph{Effect Terms}:
\begin{flalign*}
  \quad T ::=& w(\vec{v}) \; | \; \mono{op}_{\vec{v}}
  (\vec{x}_1:\vec{\alpha}_1.T_1, \ldots, \vec{x}_n:\vec{\alpha}_n.T_n)
  &
\end{flalign*}
where $\vec{x}_i:\vec{\alpha}_i$ are Lists of Base Terms of Arity
Types.

$\Delta$ is a Set of Effect Variables $w:(\vec{\alpha})$ with rules:
\begin{enumerate}
  \item $(w:(\vec{\alpha}) \in \Delta)$:
  \[
    {\Gamma \vdash \vec{v}:\vec{\alpha}}
    \over{\Gamma;\Delta \vdash w(\vec{v})}
  \]
  \item $(\mono{op} : \vec{\beta}; \vec{\alpha}_1, \ldots,
    \vec{\alpha}_n \in \Sigma_\mathrm{eff})$:
    \[
      {\Gamma \vdash \vec{v}:\vec{\beta} \quad\quad
        \Gamma, \vec{x}_i:\vec{\alpha}_i;
        \Delta \vdash T_i \quad (i = 1, \ldots, n)}
      \over{\Gamma; \Delta \vdash
        \mono{op}_{\vec{v}(\vec{x}_i:\vec{\alpha}_i.T_i)_i}}
    \]
\end{enumerate}

Typing Effect Terms: $\Gamma; \Delta \vdash T$

\emph{Conditional Equations}: $\Gamma; \Delta \vdash T_1 = T_2
(\varphi)$ given that $\Gamma; \Delta \vdash T_1$, $\Gamma; \Delta
\vdash T_2$, and $\Gamma \vdash \varphi:\mathbf{form}$

\emph{Conditional Effect Theory} (\S\ref{sec:effect_theory}):
$\thy{E}$ is a collection of Conditional Equations

Equational Theory (\S\ref{sec:equational_theory}) given by Effect
Theory:
\begin{itemize}
  \item For each Operator $\mono{op}:\vec{\beta}; \vec{\alpha}_1,
    \ldots, \vec{\alpha}_n \in \Sigma_\mathrm{eff}$ and $\vec{b} \in
    \llbracket \vec{\beta} \rrbracket$ take an Operation Symbol
    $\mono{op}_{\vec{b}}$ of (Countable) Arity $\sum_{i}|\llbracket
    \vec{\alpha}_i \rrbracket|$
  \item Each Effect Term $\Gamma; \Delta \vdash T$ and each $\vec{c}
    \in \llbracket \Gamma \rrbracket$ gives rise to a Term $\Delta'
    \vdash T_{\vec{c}}$ with $\Delta'$ consisting of Effect Variables
    $w_{\vec{a}}$ for each $w:(\vec{\alpha}) \in \Delta$ and $\vec{a}
    \in \llbracket \vec{\alpha} \rrbracket$
  \item Equations:
    \[
      \Delta' \vdash T_{\vec{c}} = T_{\vec{c'}}
    \]
    for any Conditional Equations $\Gamma; \Delta \vdash T =
    T'(\varphi)$ in $\thy{E}$ and any $\vec{c} \in \llbracket \varphi
    \rrbracket$
\end{itemize}

Model of the Effect Theory:
\begin{itemize}
  \item Set $M$
  \item Family of Maps $\{ \mono{op}_M : \llbracket \vec{\beta}
    \rrbracket \times \prod_i M^{\llbracket \vec{\alpha}_i
      \rrbracket} \rightarrow M \}_{\mono{op}:\vec{\beta};
      \vec{\alpha}_1, \ldots, \vec{\alpha}_n \in
      \Sigma_{\mathrm{eff}}}$
\end{itemize}
such that the corresponding Maps $\mono{op}_M(\vec{b})$ (where
$\vec{b} \in \llbracket \vec{\beta} \rrbracket$) Satisfy
(\S\ref{sec:satisfaction}) the Equations of the Induced Infinitary
Effect Theory.

A Homomorphism between Models $M$ and $N$ is a Map $f : M \rightarrow
N$ such that $\mono{op}_N \circ (id_{\llbracket \vec{\beta}
  \rrbracket} \times \prod_i f^{\llbracket \vec{\alpha}_i \rrbracket})
= f \circ \mono{op}_M$

Category of Models and Homomorphisms $\cat{Mod}_\thy{E}$

Forgetful Functor $U : \cat{Mod}_\thy{E} \rightarrow \cat{Set}$

Left-adjoint to $U$ Free-model Functor $F$: constructs the Free Model
(\S\ref{sec:free_model}) $F A$ on a Set of Generators $A$.

$U F A$: Set of Computations Returning Values in $A$

$U F$: Monad used to Model the corresponding Effect

\emph{Handler Types}:
\begin{flalign*}
  \quad \chi &::= X \; | \; F \sigma \; | \; 1 \;
    | \; \chi_1 \times \chi_2 \; | \; \sigma \rightarrow \chi &
\end{flalign*}

\emph{Handler Terms}:
\begin{flalign*}
  \quad h ::=& \; z(\vec{v}) \;
    | \; \mono{op}_{\vec{v}}
      (\vec{x}_1:\vec{\alpha}_1.h_1, \ldots, \vec{x}_n:\vec{\alpha}_n.h_n) & \\
    |&\; \mono{if}\; \varphi \;\mono{then}\; h_1
      \;\mono{else}\; h_2 \; | \; \mono{return}\; u \;
    | \; \mono{let}\; x \;\mono{be}\; h \;\mono{in}\; h' & \\
    |&\; \star \;
    | \; \langle h_1, h_2 \rangle \; | \; \mono{fst}\; h \;
    | \; \mono{snd}\; h \; | \; \lambda x:\sigma.h \;
    | \; h u &
\end{flalign*}

Typing Handlers

Handler (\S\ref{sec:effect_handler}) Signature $\Sigma_\mathrm{hand}$:
Set of Handler Symbols $H$

\emph{Computation Type}:
\begin{flalign*}
  \quad \underline{\tau} &::= F \sigma \; | \; 1 \;
    | \; \underline{\tau}_1 \times \underline{\tau}_2 \;
    | \; \sigma \rightarrow \underline{\tau} &
\end{flalign*}

\emph{Computation Term}:
\begin{flalign*}
  \quad t ::=& \; \mono{op}_{\vec{v}}
      (\vec{x}_1:\vec{\alpha}_1.t_1, \ldots \vec{x}_n:\vec{\alpha}_n.t_n) & \\
    |&\; \mono{if}\; \varphi \;\mono{then}\; t_1
      \;\mono{else}\; t_2 \; | \; \mono{return}\; u \;
    | \; \mono{let}\; x \;\mono{be}\; t \;\mono{in}\; t' & \\
    |&\; \mono{try}\; t \;\mono{with}\; H(\vec{u};
      \vec{t}) \;\mono{as}\; x \;\mono{in}\; t' \\
    |&\; \star \; | \; \langle t_1, t_2 \rangle \;
    | \; \mono{fst}\; t \;
    | \; \mono{snd}\; t \; | \; \lambda x:\sigma.t \;
    | \; t u &
\end{flalign*}

\fist Note that Computation Types mirror Handler Types (except
for Type Variables), and Computation Terms mirror Handler Terms
(except for Handler Variables and the addition of the
$\mono{try}\ldots\mono{with}$ Construct)

The syntax:
\[
  \mono{handle}\; t \;\mono{with}\;
  H(\vec{u};\vec{t})
\]
can be used in place of:
\[
    \mono{try}\; t \;\mono{with}\; H(\vec{u};
      \vec{t}) \;\mono{as}\; x \;\mono{in\;return}\; x
\]

When the Handler Signature consists of a single Handler Symbol $H$ it
may be ommitted:
\[
    \mono{try}\; t \;\mono{with}\; \vec{u};
      \vec{t} \;\mono{as}\; x \;\mono{in}\; t'
\]

Typing Computation Terms

a Handler:
\[
  H : (\vec{\sigma}; \vec{\chi})
    \rightarrow \chi \;\mathbf{handler} \in \Sigma_\mathrm{hand}
\]

Typing Handling Constructs

Examples: \cite{plotkin-pretnar09}

CCS (Calculus of Communicating Systems \S\ref{sec:ccs})

%FIXME



\cite{plotkin-pretnar13}:

Free Model (\S\ref{sec:free_model}) $F A$ Generated by the Equational
Theory (\S\ref{sec:equational_theory})

Computation Returning Values from a Set $A$ is an Element of the Free
Model $F A$

(Modulo the Forgetful Functor) the Free-model Functor $F$ is the Monad
(\S\ref{sec:monad}) used to Model the corresponding Effect; an
Algebraic Effect. Continuations (\S\ref{sec:continuation}) are an
example of a Non-algebraic Effect (does not arise from an Equational
Presentation).

\emph{Handlers} correspond to (not-necessarily Free) Models of the
Equational Theory

Semantics of Handling given using Universal Property of the Free Model
(it Induces Unique Homomorphisms to the Models)

Exception Handling Construct: Application of Unique Homomorphism that
Preserves Returned Values

\emph{or}

(generalizing to all Algebraic Effects, e.g. Stream Redirection,
Renaming and Hiding, Timeout, Rollback, etc.): Returned Values are
passed to a user-defined Continuation (Application of an arbitrary
Homomorphism to a Computation)

Algebraic Operations \S\ref{sec:algebraic_operation} (\emph{Effect
  Constructors}: giving rise to the Effects) are Dual to Effect
Handlers \S\ref{sec:effect_handler} (\emph{Effect Deconstructors}:
proceeding according to Effects already created)

\fist Cf. Layered Monads (\S\ref{sec:layered_monad}): Monadic
Reflection (\S\ref{sec:monadic_reflection}) and Monadic Reification
(\S\ref{sec:monadic_reification})


\textbf{Types}

\emph{Signature Types}:
\[
  \alpha, \beta ::= b \;|\; 1 \;|\; \alpha \times \beta \;|\;
    \Sigma_{\ell \in L} \alpha_\ell
\]

(Type) Signature: Base Types, Typed Function Symbols, Typed Operation
Symbols

Syntax Parameterized by choice of Signature

Base Types $b$

Labels $\ell$

$Lab$ all possible Labels

$L$ Finite Subsets of Labels

Arity Base Types

Arity Signature Type: a Signature Type that contains only Arity Base
Types

\emph{Function Symbols} $f : \alpha \rightarrow \beta$

\emph{Operation Symbols} $op : \alpha \rightarrowtriangle \beta$

\emph{Effect Theory} (\S\ref{sec:effect_theory}) $\thy{T}$

Operations: Sources of Effects

Effect Theory: Properties of Effects

Operation $op : \alpha \rightarrowtriangle \beta$:
\begin{enumerate}
  \item accepts Parameter of Type $\alpha$
  \item performs relevant Effect
  \item outcome of Type $\beta$ determines its Continuation
\end{enumerate}
%FIXME

$op$ is:
\begin{itemize}
  \item Parameterized on $\alpha$
  \item has Arity $\beta$ ($\beta$-ary)
\end{itemize}

When $\alpha = 1$, $op$ may be written $op:\beta$

\emph{Value Types} $A,B,\ldots$:
\begin{flalign*}
  \quad A,B ::=&\; b \;|\; 1 \;|\; A \times B
    \;|\; \sum_{\ell \in L}A_{\ell} \;|\; U \underline{C} &
\end{flalign*}

\emph{Computation Types} $\underline{C},\ldots$:
\begin{flalign*}
  \quad \underline{C} ::=&\; F A
    \;|\; \prod_{\ell \in L} \underline{C}_{\ell}
    \;|\; A \rightarrow \underline{C} &
\end{flalign*}

Value Types extend Signature Types by addition of Type Constructor $U
-$ classifying Computations of Type $\underline{C}$ that have been
Thunked (???) into Values (later Forced back into Evaluation).
%FIXME xref Thunk, Forced

Computation Type $F A$ classifies Computations that Return Value of
Type $A$

$\prod_{\ell \in L} \underline{C}_{\ell}$ classifies Finite Indexed
Products of Computations

$A \rightarrow \underline{C}$ Computations of Type $\underline{C}$
Parametric on Values of Type $A$


\textbf{Terms}

Value Terms, Computation Terms, Handler Terms

(``Value'', ``Computation'', or ``Handler'' may be used instead of
``Value Term'', ``Computation Term'', or ``Handler Term'')

Value Variables $x,y,\ldots$

\emph{Value Terms} $V,W,\ldots$:
\begin{flalign*}
  \quad V,W ::=&\; x \;|\; f(V) \;|\; \langle \rangle
    \;|\; \langle V,W \rangle \;|\; \ell (V) \;|\; \mono{thunk}\; M &
\end{flalign*}


Continuation Variables $k,\ldots$

\emph{Computation Terms} $M,N,\ldots$:
\begin{flalign*}
  \quad M,N ::=&\; \mono{match}\; V \;\mono{with}\;
      \langle x,y \rangle \mapsto M
    \;|\; \mono{match}\; V \;\mono{with}\; \{\ell(x_\ell) \mapsto
      M_\ell\}_{\ell \in L}
    \;|\; \mono{force}\; V & \\
    \;|\;& \mono{return}\; V \;|\; M \;\mono{to}\; x:A.N
    \;|\; \langle M_\ell \rangle_{\ell \in L} \;|\; \mono{prj}_\ell M
    \;|\; \lambda x:A.M \;|\; M V & \\
    \;|\;& op_V(x:\beta.M) \;|\; k(V)s
    \;|\; M \;\mono{handled\;with}\; H \;\mono{to}\; x:A.N &
\end{flalign*}


\emph{Handler Terms} $H,\ldots$:
\begin{flalign*}
  \quad H ::=&\; \{ op_{x:\alpha}
    (k:\beta \rightarrow \underline{C}) \mapsto
    M_{op} \}_{\mono{op:\alpha \rightarrowtriangle \beta}} &
\end{flalign*}


$\{\cdots\}_{\ell \in L}$ Set of Computations, one for each Label
$\ell \in L$

$\{\cdots\}_{op: \alpha \rightarrowtriangle \beta}$ Set of
Computations, one for each Operation Symbol $op: \alpha
\rightarrowtriangle \beta$

Value Terms involve only Constructors; corresponding Destructor Terms
are Computations

Constructor, Destructor Terms for Computation Types

For Type $F A$:
\begin{itemize}
  \item Return $\mono{return}\; V$
  \item Sequencing Construct $M \;\mono{to}\; x:A.N$
\end{itemize}

Operation Application (Computation Term):
\[
  op_V(x:\beta.M)
\]
first triggers Operation $op$ with Parameter $V$, then binds
Outcome to $x$ and Proceeds as Continuation $M$.

Handler Term:
\[
  \{ op_{x:\alpha}
    (k:\beta \rightarrow \underline{C}) \mapsto
    M_{op} \}_{\mono{op:\alpha \rightarrowtriangle \beta}}
\]
is given by a Finite Set of \emph{Handling Operation Definitions}:
\[
  op_{x:\alpha}
    (k:\beta \rightarrow \underline{C}) \mapsto
    M_{op}
\]
one for each Operation Symbol $op$

Handling Terms $M_{op}$ are dependent on their Parameters
(captured in their Parameter Values $x$) and on the Continuations of
the Handled Operations (captured in their Continuation Variables $k$)

\fist Note Continuation Variables always appear applied to a Value
$k(V)$

Handling Computation Term:
\[
  M \;\mono{handled\;with}\; H \;\mono{to}\; x:A.N
\]
Evaluates Computation $M$, Handling all Operation Application
Computations according to $H$, Binds result to $x$ and proceeds as $N$

Sequencing is a special case of Handling where $H$ Handles all
Operations ``by themselves''

Example: if $M$ triggers an Operation Application $op_V(y.M')$
and the corresponding Handling Term is $op_z(k) \mapsto
M_op \in H$, then the Operation is Handled by Evaluating
$M_op$ instead with Parameter Variable $z$ bound to $V$ and
each occurrence of a Term $k(W)$ in $M_op$ replaced by:
\[
  M'[W/y] \;\mono{handled\;with}\; H \;\mono{to}\; x:A.N
\]
and the Continuation $k$ receives an outcome $W$, determined by
$M_op$ and is Handled in the same way as $M$.

\fist Note that while Continuations are Handled by $H$, the Handling
Term $M_op$ is not; any Operations it triggers or Values it
Returns escape the Handler.

$\mono{let}$-binding abbreviation:
\[
  \mono{let}\; x:A \;\mono{be}\; V \;\mono{in}\; M
    \defeq (\lambda x:A.M)V
\]


\textbf{Typing Judgements}

\emph{Value Context}:
\[
  \Gamma = x_1:A_1, \ldots,x_m:A_m
\]
of Value Variables $x_i$ Bound to Value Types $A_i$

\emph{Continuation Context}:
\[
  K = k_1:\alpha_1 \rightarrow \underline{C}_1, \ldots,
    k_n:\alpha_n \rightarrow \underline{C}_n
\]
of Continuation Variables $k_j$ Bound to Continuation Types $\alpha_j
\rightarrow \underline{C}_j$

A Continuation Type $\alpha \rightarrow \underline{C}$ with an Arity
Signature Type $\alpha$ Types a Continuation $k$ that accepts a Value
of Type $\alpha$ and proceeds as a Computation of Type
$\underline{C}$.

Values are Typed:
\[
  \Gamma | K \vdash V:A
\]

Computations are Typed:
\[
  \Gamma | K \vdash M : \underline{C}
\]

Handlers are Typed:
\[
  \Gamma | K \vdash H : \underline{C} \;\mathbf{handler}
\]

Value Typing Rules, Computation Typing Rules, Handler Typing Rules
%FIXME

$K$ may contain more than one Continuation Variable when the Handler
being Defined is used in Handling Definitions of other Handlers

Handlers for a Subset $\Theta$ of Operation Symbols %FIXME

Handler with Identity Continuation:
\[
  M \;\mono{handled\;with}\; H
    \defeq M \;\mono{handled\;with}\; H \;\mono{to}\;
      x:A.\mono{return}\; x
\]

Binary Deconstructor (Unix Pipe, Parallel Combinator in CCS
\S\ref{sec:ccs}) %FIXME

Simple Handlers (\S\ref{sec:simple_handler})

Parameter-passing Handlers (\S\ref{sec:parameter_passing_handler})


\textbf{CCS Example}

Effect Constructors (Operations):
\begin{enumerate}
  \item Deadlock $\mono{nil} : 1 \rightarrowtriangle 0$
  \item Action Prefix $\mono{prefix} : Act \rightarrowtriangle 1$
  \item Sum $\mono{choose} : 1 \rightarrowtriangle 2$
\end{enumerate}

Effect Deconstructors (Handlers):
\begin{enumerate}
  \item Renaming $P[b/a]$
  \item Hiding $P \backslash a$
  \item Parallel $P | Q$
\end{enumerate}


\asterism


\textbf{Semantics}

Denotational Semantics (\S\ref{sec:denotational_semantics})

Cartesian-closed Category (\S\ref{sec:cartesian_closed})

First-class Functions, Finite Products and Finite Sums (Coproducts)

Free Model (\S\ref{sec:free_model}) Construction (Functor ???)

Parametric Lifting (??? Lifting Monad \S\ref{sec:lifting_monad}) of
Maps to Homomorphisms from the Free Model

Sets, $\omega$-cpos (\S\ref{sec:omega_cpo})

Lawvere Theories (\S\ref{sec:lawvere_theory})

Lawvere $\cat{V}$-theories (???)


\asterism


Template Variables $z$

\emph{Templates} $T,\ldots$:
\begin{flalign*}
  \quad T ::=& \; z(V) \;|\; \mono{match}\; V
    \;\mono{with}\; \langle x,y \rangle \mapsto T
    \;|\; \mono{match}\; V \;\mono{with}\; \{\ell(x_\ell) \mapsto
    T_\ell\}_{\ell \in L} \;|\; op_V(x:\beta.T)
\end{flalign*}
Templates describe Common Properties of Computations; they are not
Typed, but Well-formed relative to a Value Context and a Template Context

Templates are limited to Signature Values (e.g. can be Typed as
$\Gamma \vdash V:\alpha$); Typing Rules are the same as the Typing
Rules for Values with the omission of Continuation Contexts and the
Rule for Typing Thunks.

\emph{Template Context}:
\[
  Z = z_1:\alpha_1, \ldots, z_n:\alpha_n
\]
of Template Variables $z_j$ Bound to Arity Signature Types $\alpha_j$.

$z_j:\alpha_j$ represents a Computation dependent on a Value of Type
$\alpha_j$

Typing Judgements for being a Well-formed Template $\Gamma | Z \vdash
T$, given by Rules:
%FIXME


\emph{Effect Theory} $\thy{T}$ is a Finite Set of Equations:
\[
  \Gamma | Z \vdash T_1 = T_2
\]
where $T_1$ and $T_2$ are Well-formed relative to $\Gamma$ and $Z$

Effect Theories for: Exceptions, State, Read-only State,
Nondeterminism, Input/Output %FIXME

Combining Theories:
\begin{enumerate}
  \item \emph{Sum} simple Union assuming disjoint Sets of Operation
    Symbols

  \item \emph{Tensor} Commuting combinations of two Effects, e.g. two
    Independent States; given by Union again assuming disjoing Sets of
    Operation Symbols plus the Equation:
    \[
    \begin{split}
      y:\alpha,y':\alpha' | z:\beta \times \beta' \vdash
        op_y(x:\beta.op'_{y'}(x':\beta'.z(x.x'))) \\
        \quad = op'_{y'}(x':\beta'.op_y(x:\beta.z(x,x')))
    \end{split}
    \]
    for each Operation Symbol $op : \alpha \rightarrowtriangle \beta$
    from the first Theory and Operation Symbol $op' : \alpha'
    \rightarrowtriangle \beta'$ from the second Theory.
\end{enumerate}

More example Theories:
\begin{itemize}
  \item Explicit Nondeterminism
  \item CCS: Sum of Theories for Nondeterminism and Explicit
    Nondeterminism
  \item Time
  \item Destructive Exceptions (``Rollback''): Tensor Product of
    Theories for State and Exceptions
\end{itemize}


\textbf{Interpretation of an Effect Theory}

Model $\struct{M}$ for an Effect Theory $\thy{T}$

Carrier Set $|\struct{M}|$

An Operation:
\[
  op_\struct{M} : \llbracket \alpha \rrbracket \times
    |\struct{M}|^{\llbracket \beta \rrbracket} \rightarrow |\struct{M}|
\]
for each Operation Symbol $op:\alpha \rightarrowtriangle \beta$, such
that $\llbracket T_1 \rrbracket = \llbracket T_2 \rrbracket$ for all
the Equations $\Gamma | Z \vdash T_1 = T_2$ in $\thy{T}$

Homomorphism of Models $h : \struct{M}_1 \multimap \struct{M}_2$ is a
Map $h : |\struct{M}_1| \rightarrow |\struct{M}_2|$ such that:
\[
  h \circ op_{\struct{M}_1} = op_{\struct{M}_2} \circ
    (id_{\llbracket \alpha \rrbracket}
      \times h^{\llbracket \beta \rrbracket})
\]
holds for all Operation Symbols $op:\alpha \rightarrowtriangle \beta$

Category $\cat{Mod}_\thy{T}$ of Models of $\thy{T}$ and Homomorphisms
between them

Forgetful Functor $U : \cat{Mod}_\thy{T} \rightarrow \cat{Set}$ where:
\[
  \begin{split}
    U \struct{M} \defeq & |\struct{M}| \\
    U h \defeq & h
  \end{split}
\]
Left-adjoint to the Forgetful Functor is the Free-model Functor $F :
\cat{Set} \rightarrow \cat{Mod}_\thy{T}$

$F A$ Free Model over Set $A$

Homomorphism Induced by $f : A \rightarrow U \struct{M}$: Adjoint
Homomorphism $\bar{f} : F A \multimap \struct{M}$

Unit $\eta_A : A \rightarrow F A$


\textbf{Interpretation of Values and Computation Types}

given a Signature, an Effect Theory $\thy{T}$ over the Signature, and
an Interpretation of the Effect Theory

Product Models, Exponent Models (???) %FIXME

An Interpretation $\llbracket V \rrbracket$ of a Well-typed Value
$\Gamma | K \vdash V:A$ is a Map $\llbracket \Gamma \rrbracket \times
\llbracket K \rrbracket \rightarrow \llbracket A \rrbracket$

Kleene Equality $\simeq$: Equal if both sides are Defined and Equal or
both sides are Undefined %FIXME xref

\emph{Parameterized Lifting} $f^{\dagger_\struct{M}} : A
\times U F B \rightarrow U \struct{M}$ of a Map $f : A \times B
\rightarrow U \struct{M}$ given by:
\[
  f^{\dagger_\struct{M}} \defeq U \bar{f} \circ st
\]
where $\bar{f}$ is the Homomorphism Induced by $f$ and $st : A \times
U F B \rightarrow U F (A \times B)$ is the Strength
(\S\ref{sec:strong_monad}) of Monad $U F$.


\emph{Interpretation of Handlers}

Handler Correctness: for an Empty Effect Theory, any Handler is
Correct, but in general Correctness is Undecidable

Correctness of Simple Handlers (\S\ref{sec:simple_handler}) is
$\Pi_2$-complete


\asterism


Equivalence of Computations

Weak Equality Judgement $\bumpeq$

Definedness Judgement $\downarrow$

Template Substitution

Capture-avoiding Substitution

Inheritance Rule

Equations for the Handling Construct state the Universal properties of
the Induced Homomorphism:
\begin{enumerate}
  \item Extends the Inducing Map on Values
  \item acts Homomorphically on Operations
\end{enumerate}

Rule for showing Handler Correctness: %FIXME
states that a Handler is Correct when its Operation Definitions
respect the Equations of the Effect Theory

\emph{Simple Handler} (\S\ref{sec:simple_handler})

\emph{Parameter-passing Handler}
(\S\ref{sec:parameter_passing_handler})

\emph{Simple Signature}: no Base Types or Function Symbols, Implies a
Unique (Trivial) Interpretation

Simple Signatures and Theories are equivalent to ones with all
Operation Symbols are $n$-ary for some $n$

Simple Signatures: Exceptions over a Finite Set, Read-only State,
Input/Output, and Nondeterminism

\emph{Uniformly Simple} Family of Handlers: Exception Handler,
Temporary-state Handler, Stream Redirection Handler

A Family of Handlers is Correct if each Handler in the Family is
Correct

Deciding whether a Uniformly Simple Family of Closed Handlers is
$\Sigma_1$-complete (Semidecidable)

Effect Theories with a Simple Signature corresond to ordinary Finite
Equational Theories (i.e. Finitely many Finitary Function Symbols and
Finitely many Axioms)

For a Simple Signature, Decidable Effect Theory, and a Uniformly
Simple Family of Handlers, Correctness of the Family of Handlers is
Decidable


\textbf{Recursion}

Nondeterminism Operator:
\[
  \Omega : 1 \rightarrowtriangle 0
\]

Fixed-point Constructor $\mono{rec}\; x : U \underline{C}.M$, Typed
by:
\[
  \frac{\Gamma,x:U \underline{C} | K \vdash M : \underline{C}}
  {\Gamma | K \vdash \mono{rec}\; x : U \underline{C}.M : \underline{C}}
\]

Effect Theories become \emph{Inequations} $\Gamma | Z \vdash T_1 \leq
T_2$

always contains the Inequation:
\[
  \cdot | z:1 \vdash \Omega() \leq z
\]
stating that $\Omega$ is the Least Element

$\omega\cat{Cpo}$ Category of $\omega$-cpos and Continuous Functions
(instead of $\cat{Set}$)

Flat $\omega$-cpo

$U : \cat{Mod}_\thy{T} \rightarrow \omega \cat{Cpo}$

$F : \omega\cat{Cpo} \rightarrow \cat{Mod}_\thy{T}$

both $U$ and $F$ have Continuous Strengths and are Locally Continuous

Carriers of Models are Pointed $\omega$-cpos and Model Homomorphisms
are Strict Continuous Functions (Preserving Least Elements)

\emph{Lifting} $Q_\bot$ is the $\omega$-cpo obtained from $Q$ by
adding a new Least Element %FIXME xref?

Nondeterminism: Convex Powerdomain Monad (???)

Continuously Parameterised Countably Infinitary Inequational Theories:
equivalent to Discrete Countable Lawvere $\omega\cat{Cpo}$-theories

Value Types: Interpreted by $\omega$-cpos

Computation Types: Interpreted by Models whose Carriers are Pointed
$\omega$-cpos

Values, Computations, and Handlers are Interpreted by Continuous Maps
(such Interpretations may not be defined)

Fixed-point Constructor is Interpreted using the Least Fixed-point
Interpretation %FIXME

Correct Handlers cannot redefine $\Omega$ as the Theory of $\Omega$
fixes it Uniquely

Open question: Parallel Computations (Binary Deconstructors)



\cite{pretnar15}:

Occurence of an Effect can been seen as a Branching in the Execution
of a Program (number of Branches equal to the number of possible
outcomes of an Effect)

``Source'' of an Effect is represented by an Operation with Arity
equal to the number of outcomes and Arguments represent Branches


\textbf{Language}

\cite{pretnar15}:

\emph{Values}:
\begin{flalign*}
  \quad v ::=&\; x \; | \; \true \; | \; \false \;
            | \; \lambda x \mapsto c &\\
      \; |&\; \mono{handler}\; \{ \mono{return}\; x
              \mapsto c_r, \mono{op}_1(x;k) \mapsto c_1, \ldots,
              \mono{op}_n(x;k) \mapsto c_n \}&
\end{flalign*}

\emph{Computations}:
\begin{flalign*}
  \quad c ::=&\; \mono{return}\; v \; | \; \mono{op}(v;y.c) \;
            | \; \mono{do}\; x \leftarrow c_1 \;\mono{in}\; c_2 &\\
      \; |&\; \mono{if}\; v \;\mono{then}\; c_1
              \;\mono{else}\; c_2 \;
            | \; v_1 v_2 \; | \; \;\mono{with}\; v
              \;\mono{handle}\; c&
\end{flalign*}

Sequencing:
\[
  \mono{do}\; x \leftarrow c_1 \;\mono{in}\; c_2
\]
first Evaluate $c_1$, Bind result Value to $x$, and proceed as $c_2$;
if $x$ does not appear in $c_2$, then abbreviate to $c1; c2$.

Operation Call:
\[
  \mono{op}(v;y.c)
\]
Parameter Value $v$ (e.g. Memory Location to be Read) passed to
$\mono{op}$, $\mono{op}$ performs Effect, Result Value (e.g.
Contents of Memory Location) is Bound to $y$ and Evaluation of
Continuation $c$ resumes. (Handlers \S\ref{sec:effect_handler}) may
override this behavior).

Generic Effect (\S\ref{sec:generic_effect}):
\[
  \mono{op}\; \defeq \;\mono{fun}\; x \mapsto
    \mono{op}(x; y.\mono{return}\; y)
\]
Parameter Value $x$ passed to Operation with the Trivial Continuation;
specific Operations $\mono{op}(v;y.c)$ can be recovered by
Evaluating:
\[
  \mono{do}\; y \leftarrow \mono{op}\; v \;\mono{in}\; c
\]


\textbf{Denotational Semantics} \cite{pretnar15}

Computations as Trees:

Returned Values (or Bottom $\bot$ for Divergent Computation that does
not call any Operations) are Leaves and Branching Points are
Operations

Operation Calls create a ``Branching Point'' in the Evaluation with as
many Branches as there are possible Results that can be Yielded to the
Continuation. \cite{pretnar15}

A Divergent Computation that repeatedly Calls Operations gives a
Non-well-founded Tree. \cite{pretnar15}


\emph{Denotational Semantics Returning First-order Values and no
  Recursion}:

Value Type $A$: Set $\llbracket A \rrbracket$

Computation Type $\llbracket A!\Delta \rrbracket$: Set of Trees with
Leaves (Values) in $\llbracket A \rrbracket$ and Nodes (Operations) in
$\Delta$

Handlers: Functions between Trees defined by Structural Recursion on
Tree of the Handled Computation and Handling is Interpreted by
Application of such Functions

A \emph{Model} of $\Delta$ is a Set $M$ with Maps:
\[
  \mono{op}_M : \llbracket A \rrbracket
    \times M^{\llbracket B \rrbracket} \rightarrow M
\]
for each Operation $\mono{op} : A \rightarrow B$ in $\Delta$

\emph{Homomorphism} between Models $M$, $N$ is a Map $h : M
\rightarrow N$ such that:
\[
  (h \circ \mono{op}_M)(x,k) = \mono{op}_N(x,h \circ k)
\]

$\llbracket A ! \Delta \rrbracket$ is the \emph{Free Model}
(\S\ref{sec:free_model}) of $\Delta$ over $A$ with Universal Property
(\S\ref{sec:universal_property}):

For any Model $M$ of $\Delta$ and Map $f : \llbracket A \rrbracket
\rightarrow M$ there exists a Unique Homomorphism $h : \llbracket A !
\Delta \rrbracket \rightarrow M$ that agrees with $f$ on Leaves.
\cite{pretnar15}

Operation Clauses define a Model of Operations and the Return Clause
provides a Function $f$ that can be extended to a Homomorphism.
\cite{pretnar15}

\fist With General Recursion and Higher-order Results then
Domains (\S\ref{sec:order_domain}) are used instead of Sets.

Comodel: Set $W$ of possible World States and Map $\mono{op}^W : W
\times \llbracket A \rrbracket \rightarrow W \times \llbracket B
\rrbracket$ for each Operation $\mono{op} : A \rightarrow B$ in
$\Sigma$

when Operation Call $\mono{op}(v; y.c)$ escapes all Handlers, pass
current State $w \in W$ and Parameter $v$ to $\mono{op}^W$ and get
back new State and Result, assigning Result to $y$ and continue
Evaluating $c$. \cite{pretnar15}


\textbf{Operational Semantics} \cite{pretnar15}

Small-step Operational Semantics

Operation Calls do not perform Effects: they behave as ``Signals''
that propagate outwards until they reach a Handler with a matching
Clause. \cite{pretnar15}

An Operation that escapes all Handlers is treated as a Terminating
Computation (no further Reductions). \cite{pretnar15}

``Actual'' Effectful behavior simulated by an Outermost Handler.
\cite{pretnar15}



\subsubsection{Effect Theory}\label{sec:effect_theory}
\cite{plotkin-pretnar09}

$\thy{E}$

Conditional Effect Theory: collection of Conditional Equations:
\[
  \Gamma; \Delta \vdash T_1 = T_2(\varphi)
\]
given that $\Gamma; \Delta \vdash T_1$, $\Gamma; \Delta \vdash T_2$,
and $\Gamma \vdash \varphi : \mathbf{form}$

An Effect Theory $\thy{E}$ gives rise to a standard (possibly
Infinitary) Equational Theory (\S\ref{sec:equational_theory}).
\cite{plotkin-pretnar09}



\subsubsection{Effect Handler}\label{sec:effect_handler}

Homomorphism from Free Algebras
\cite{bauer-pretnar12}

\cite{plotkin-pretnar13}:

Homomorphisms from the Free Model to a Model on a given Carrier

Model of an Equational Theory: Carrier Set, Set of Handling Maps (one
for each Operation) Satisfying Equations

Computations Interpreted in the Free Model

Handling Constructs Interpreted by Induced Homomorphisms

Operations replaced by Operation Maps

\fist Cf. Exception Handlers (\S\ref{sec:exception_effect}) where
Exceptions are replaced by Handling Computations

\danger\; Note that note all Families of Maps yield a Model of the
Theory, for some Families it is Undecidable given their Definitions
whether they yield a Model or not; if allowing complete freedom in the
Language (all possible Definitions allowed), not all Handlers will
have Interpretations



\cite{plotkin-pretnar09}:

Handling corresponds to Model of the Algebraic Theory
(\S\ref{sec:algebraic_theory}) of the Effects

Handling a Computational Effect: Homomorphically Mapping the Handled
Computation into another Computation

Well-formed-ness, Correctness (redefinition of Operations yields a
Model of the Effect Theory)

\cite{plotkin-pretnar09}:

Type Variables $X$

Value Types $\sigma$

Handler Variables $z$

Value Terms $u$

Quantifier-free Formulas $\varphi$

\emph{Handler Types}:
\begin{flalign*}
  \quad \chi &::= X \; | \; F \sigma \; | \; 1 \;
    | \; \chi_1 \times \chi_2 \; | \; \sigma \rightarrow \chi &
\end{flalign*}

\emph{Handler Terms}:
\begin{flalign*}
  \quad h ::=& \; z(v_1, v_2, \ldots) \;
    | \; \mono{op}_{v_1, v_2, \ldots}
      (X_1:A_1.h_1, X_2:A_2.h_2, \ldots) & \\
    |&\; \mono{if}\; \varphi \;\mono{then}\; h_1
      \;\mono{else}\; h_2 \; | \; \mono{return}\; u \;
    | \; \mono{let}\; x \;\mono{be}\; h \;\mono{in}\; h' & \\
    |&\; \star \;
    | \; \langle h_1, h_2 \rangle \; | \; \mono{fst}\; h \;
    | \; \mono{snd}\; h \; | \; \lambda x:\sigma.h \;
    | \; h u &
\end{flalign*}

Typing Handler Terms:
\begin{itemize}
  \item Context $\Gamma$ of Value Types
  \item Context $Z$ of Handler Variables $z : (\alpha_1, \alpha_2,
    \ldots) \rightarrow \chi$ (written $z:\chi$ if the List of Arity
    Types is Empty), according to rules:
    \begin{enumerate}
      \item $(z:(\alpha_1, \alpha_2, \ldots) \rightarrow \chi \in Z)$
        %FIXME
      \item $(\mono{op}:\beta_1, \ldots, \beta_m; A_1, \ldots, A_n \in
        \Sigma_\mathrm{eff})$
        %FIXME
      \item %FIXME
      \item %FIXME
    \end{enumerate}
\end{itemize}

Handler Signature $\Sigma_\mathrm{hand}$: Set of Handler Symbols $H$

a Handler:
\[
  H : (\sigma_1, \sigma_2, \ldots; \chi_1, \chi_2, \ldots)
    \rightarrow \chi \mathbf{handler} \in \Sigma_\mathrm{hand}
\]

Computation Types

Computation Terms

Typing Computation Terms

Typing Handling Constructs

Uniform Handler, Parametrically Uniform Handler
\cite{plotkin-pretnar09}


\cite{pretnar15}:
\[
  \mono{handler}\; \{ \mono{return}\; x
          \mapsto c_r, \mono{op}_1(x;k) \mapsto c_1, \ldots,
          \mono{op}_n(x;k) \mapsto c_n \}
\]


\asterism


Timeout Handler



\paragraph{Shallow Handler}\label{sec:shallow_handler}
\hfill \\

only Handle the first call of an Operation

more ``elementary'': can be used to simulate Deep Handler through
Recursion \cite{pretnar15}



\paragraph{Deep Handler}\label{sec:deep_handler}
\hfill \\

continue Handling Operations in the Continuation
(\S\ref{sec:continuation})



\paragraph{Simple Handler}\label{sec:simple_handler}
\cite{plotkin-pretnar13}
\hfill \\

Simple Handlers define Handling Computations in terms of Polymorphic
Constructs only.

Examples: Exception Handler, Temporary-state Handler, Stream
Redirection Handler, CCS Renaming and Hiding Handlers, etc.

No Parameter-passing Handlers
(\S\ref{sec:parameter_passing_handler})are Simple

\emph{Uniformly Simple} Family of Handlers



\paragraph{Parameter-passing Handler}
\label{sec:parameter_passing_handler}
\cite{plotkin-pretnar13}
\hfill \\

contains $\lambda$-abstraction in the Handling Terms



\subsubsection{Generic Effect}\label{sec:generic_effect}

\cite{pretnar15}:
\[
  \mono{op}\; \stackrel{\mathrm{def}}{=} \;\mono{fun} x \mapsto
  \;\mono{op}(x; y.\mono{return}\; y)
\]
Parameter $x$ passed to Operation with the Trivial Continuation



\subsubsection{Extensible Effect}\label{sec:extensible_effect}

van Laarhoven Free Monad (\S\ref{sec:vanlaarhoven_free_monad})



\subsubsection{Communication Effect}\label{sec:communication_effect}

Communication \S\ref{sec:communication}



% ====================================================================
\section{Curry-Howard Correspondence}\label{sec:curry_howard}
% ====================================================================

\emph{Curry-Howard Correspondence}

Type Theory, Proof Theory, Algebra (Preorders: $\leq$ is a Reflexive
and Transitive Relation), Category Theory

Syntactic Category (\S\ref{sec:syntactic_category}) %FIXME

``Computational Trinitarianism''
\\
\begin{tabular}{| l | l | l |}
\hline
\textbf{Logic} & \textbf{Type Theory} & \textbf{Category Theory}\\ \hline \hline
Proposition & $A$ (Type) & $A \in \cat{C}_0$ \\ \hline
Proof & $a : A$ (Term) & $a:U \rightarrow A \in \cat{C}_1$ \\
\hline
\end{tabular}
\\
\cite{harper12}
\\
\begin{tabular}{| p{2cm} | p{3cm} | p{4.5cm} | p{3cm} |}
\hline
& \textbf{Logic} & \textbf{Type} & \textbf{Algebra}\\ \hline \hline
Trivial Proposition
  & \begin{center} $\overline{A \vdash \top}$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $\overline{A \leq \top}$ \end{center} \\ \hline
Bottom
  & \begin{center} $\overline{\bot \vdash A}$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $\overline{\bot \leq A}$ \end{center} \\ \hline
Reflexivity
  & \begin{center} $A \vdash A$ \end{center}
  & \begin{center} $x : A \vdash x : A$ \end{center}
  & \begin{center} $A \leq A$ \end{center} \\ \hline
Negation Elimination
  & \begin{center} $\neg A \vdash A \rightarrow \bot$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $A \wedge \neg A = \bot$ \end{center} \\ \hline
Negation Introduction
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\underline{C \wedge A \leq \bot}$\newline
      $C \leq \overline{A}$
    \end{center} \\ \hline
Elimination Rules
  & \begin{center}
      $\overline{A \wedge B \vdash A}$,\newline\newline
      $\overline{A \wedge B \vdash B}$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\overline{A \wedge B \leq A}$,\newline\newline
      $\overline{A \wedge B \leq B}$
    \end{center} \\ \hline
Introduction Rules
  & \begin{center}
      $\overline{A \vdash A \vee B}$,\newline\newline
      $\overline{B \vdash A \vee B}$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\overline{A \leq A \vee B}$,\newline\newline
      $\overline{B \leq A \vee B}$
    \end{center} \\ \hline
Conjunction
  & \begin{center}
    $\underline{C \vdash A \quad C \vdash B}$\newline
    $C \vdash A \wedge B$
    \end{center}
  & \begin{center}
    $\underline{x:C \vdash m:A \quad x:C \vdash n:B}$\newline
    $x:C \vdash (m,n):A \times B$
    \end{center}
  & \begin{center}
    $\underline{C \leq A \quad C \leq B}$\newline
    $C \leq A \wedge B$
    \end{center} \\ \hline
Disjunction
  & \begin{center}
    $\underline{A \vdash C \quad B \vdash C}$\newline
    $A \vee B \vdash C$
    \end{center}
  & \begin{center}
    ???
    \end{center}
  & \begin{center}
    $\underline{A \leq C \quad B \leq C}$\newline
    $A \vee B \leq C$
    \end{center} \\ \hline
Transitivity
  & \begin{center}
      $\underline{A \vdash B \quad B \vdash C}$\newline
      $A \vdash C$
    \end{center}
  & \begin{center}
    $\underline{x:A \vdash m:B \quad y:B \vdash n:C}$\newline
    $x:A \vdash [m/y]n:C$
    \end{center}
  & \begin{center}
    $\underline{A \leq B \quad B \leq C}$\newline
    $A \leq C$
    \end{center} \\ \hline
\hline
\end{tabular}
\\
\begin{tabular}{| p{2cm} | p{3cm} | p{4.5cm} | p{3cm} |}
\hline
& \textbf{Logic} & \textbf{Type} & \textbf{Algebra}\\ \hline \hline
Implication Elimination
  & \begin{center} $A, (A \rightarrow B) \vdash B$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Implication Introduction
  & \begin{center}
      $\underline{A \wedge C \vdash B}$\newline
      $C \vdash A \rightarrow B$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Weakening
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Contraction
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Exchange
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
\hline
\end{tabular}

Proofs and Propositions form the Object Language; Derivations are used
to infer Judgements about the Object Language


\asterism


$p : P$ ``$p$ is a Proof of Proposition $P$''

A Proof of $A \wedge B$ is a Pair of Proofs $p : A$ and $q : B$ (holds
in both Classical and Constructive Systems)

A Proof of $A \vee B$ is a Proof $p : A$ or a Proof $q : B$ with an
indication of which Formula is Proved (differs from Classical Logic)

A Proof of $A \Rightarrow B$ is a Function that Transforms a Proof $p
: A$ into a Proof $q : B$.

No Proof for the Contradictory Proposition $\bot$

$(\exists x : A).P$ where $P$ is a Witness (\S\ref{sec:type_witness})
$w : A$ with a Proof that $P$ holds of $w$, i.e. $[w/x]P$

$(\forall x : A).P$ implies that $[a/x]P$ is Valid for every $a$ in
$A$; a Function mapping any Proof of $A$ to a Proof of $P$.

Introduction Rule for $\forall$:
\[
  {
    \frac{
      \begin{matrix}
        [x : A]\\
        \vdots\\
        p : P
      \end{matrix}
    }{
      (\lambda x : A).p : (\forall x : A).P
    }
  } (\forall I)
\]

Computation Rule for $\forall$:
\[
  ((\lambda x : A).p) \rightarrow [a/x]p
\]

Introduction Rule for $\exists$:
\[
  {
    \frac{
      a : A \quad\quad p : [a/x]P
    }{
      (a,p) : (\exists x : A).P
    }
  } (\exists I)
\]

Computation Rules for $\exists$:
\[
  fst (p,q) \rightarrow p
\]\[
  snd (p,q) \rightarrow q
\]

The Formation Rule for Equality Types (\S\ref{sec:equality_type})
requires other Judgements (Type Assumptions) in addition to
Well-typing Judgements:
\[
  {
    \frac{ A \mathsf{ Type} \quad\quad a : A \quad\quad b:A }
    { I (A,a,b) \mathsf{ Type}}
  } (I F)
\]

Introduction Rule for $I$:
\[
  {
    \frac{ a : A }
    { r(a) : I(A,a,a)}
  } (II)
\]

Elimination Rule for $I$:
\[
  {
    \frac{ c : I (A, a, b) \quad\quad d : C(a,a,r(a)) }
    { J(c,d) : C(a,b,c) }
  } (I E)
\]

Computation Rule for $I$:
\[
  J (r(a), d) \rightarrow d
\]

Leibniz Law


\asterism


Formation Rules : Defines what the Types of the System are (Syntax)

Introduction \& Elimination Rules : Define which Terms are Members of
which Types; Typing Rules (\S\ref{sec:typing_rule})

Computation Rules : How Objects can be Reduced, i.e. Evaluated
(Computation)

Natural Deduction - Typed Lambda Calculus

Minimal Logic - Simple Types (Simply-typed $\lambda$-calculus
\S\ref{sec:simply_typed})

Predicate Logic - Dependent Types (Intuitionistic Type Theory
\S\ref{sec:intuitionistic_type})

Modal Logic - Monads

Classical-Intuitionistic Embedding - Continuation-passing Style
(\S\ref{sec:continuation})

Linear Logic - Session Types (\S\ref{sec:session_type})

Linear Temporal Logic - Reactive Types (\S\ref{sec:reactive_type})

Subset Type $(\exists x:A).B$ (Pairs of Objects and the Proofs that
they have Property): $\{ x : A | B \}$ consisting of those $a$ in $A$
with Property $[a/x]B$, i.e. $[a/x]B$ is Inhabited.



% ====================================================================
\section{Typed $\lambda$-Calculus}\label{sec:typed_lambda}
% ====================================================================

\emph{Typed $\lambda$-Calculus} allows for Lambda Terms to be assigned
Types (\S\ref{sec:type}).

Simply-typed $\lambda$-calculus (\S\ref{sec:simply_typed}) has only
one Type Constructor (\S\ref{sec:type_constructor}), $\rightarrow$
(see Function Type \S\ref{sec:function_type}).

Untyped $\lambda$-calculus (\S\ref{sec:untyped_lambda}) may be
considered a Typed $\lambda$-calculus with only one Type.

Extension to Untyped $\lambda$-calculus may be achieved by
considering Recursive Types with Recursion in Negative Positions;
Untyped $\lambda$-calculus can be Modelled by a Solution to the
Recursion Equation $X \simeq X \rightarrow X$. \cite{wadler12}

A Denotational Semantics can be given by a \emph{B\"ohm Tree}
(\S\ref{sec:bohm_tree}).



% --------------------------------------------------------------------
\subsection{Simply-typed $\lambda$-calculus}\label{sec:simply_typed}
% --------------------------------------------------------------------

\emph{Simply-typed $\lambda$-calculus} ($\lambda^\rightarrow$) is a
Typed Interpretation of $\lambda$-calculus with one Type Constructor
for Function Types: $\rightarrow$ (\S\ref{sec:function_type}).

Strongly Normalizing, not Turing Complete: addition of $fix_\alpha$
Operator or Recursive Types (\S\ref{sec:recursive_datatype}) gives
Turing Completeness

``Simply-typed'' is to distinguish from extensions such as:
\begin{itemize}
  \item System F (\S\ref{sec:system_f}): Polymorphic Types
  \item Logical Framework (\S\ref{sec:logical_framework}): Dependent
    Types
\end{itemize}
because Polymorphism and Dependency cannot be encoding using only
$\rightarrow$ and Type Variables. Adding Record Types
(\S\ref{sec:product_type}) to Simply-typed $\lambda$-calculus allows
for Subtyping (\S\ref{sec:subtype}), and the resulting System
(\S\ref{sec:conjunctive_lambda}) is no longer ``Simply-typed'' because
it allows for Terms to have more than one Type.

The following extensions are still considered ``Simply-typed''
systems:
\begin{itemize}
  \item System T (\S\ref{sec:system_t}): Products, Coproducts, Natural
    Numbers
  \item PCF (\S\ref{sec:pcf}): Full Recursion
\end{itemize}

Simply-typed $\lambda$-calculus has the same Equational Theory of
$\beta\eta$-equivalence (\S\ref{sec:beta_reduction},
\S\ref{sec:eta_conversion}) as Untyped $\lambda$-calculus, subject to
Type restrictions.

$\beta$-reduction:
\[
  (\lambda x:s.t)u =_\beta t[x := u]
\]
holds in Context $\Gamma$ when $\Gamma$, $x:\sigma \rightarrow t:\tau$
and $\Gamma \vdash u:\sigma$.

$\eta$-reduction:
\[
  \lambda x:\sigma .t x =_\eta t
\]
holds when $\Gamma \vdash t : \sigma \rightarrow \tau$ and $x$ is not
Free in $t$.

With the Function Type Constructor $\rightarrow$ and the Base Types
$B$, the Types of a Simply-typed $\lambda$-calculus are defined (with
BNF Notation):
\[
  \tau ::= \tau \rightarrow \tau \;|\; T \in B
\]

\emph{Term Constant}

That is, Expressions of Simply-typed $\lambda$-calculus are defined
as:
\[
  e ::= x \;|\; \lambda x:t.e \;|\; e e \;|\; c
\]
where $x$ is a Variable and $\tau$ is a Type, and $c$ is a Term
Constant. These Expressions are, in order:
\begin{itemize}
  \item Variable Reference
  \item Abstraction
  \item Application
  \item Constant
\end{itemize}

Abstraction corresponds to Existential Quantification in Second-order
Logic (\S\ref{sec:secondorder_logic}).



\textbf{Intrinsic Interpretation}: \emph{Church-style}

* Only Well-typed Terms have Meaning (Meaning assigned to Typing
Derivations), therefore equivalent Terms having different Annotations
may have different Meanings, cf. Reification
(\S\ref{sec:reification}):



\textbf{Extrinsic Interpretation}: \emph{Curry-style}

* Terms Interpreted as in an Untyped Language, cf. Type Erasure
(\S\ref{sec:type_erasure})



\subsubsection{Simply-typed $\lambda$-calculus Typing Rules}
\label{sec:simplytyped_rules}

Typing Rules (\S\ref{sec:typing_rule}):
\begin{enumerate}
\item
  \[
    {
      \frac
      {x : \tau \in \Gamma}
      {\Gamma \vdash x : \tau}
    }
  \]
\item
  \[
    {
      \frac
      {c \;\text{is a constant of Base Type}\; T}
      {\Gamma \vdash c:T}
    }
  \]
\item
  \[
    {
      \frac
      {\Gamma, x:\sigma \vdash e:\tau}
      {\Gamma \vdash (\lambda x:\sigma.e):(\sigma \rightarrow \tau)}
    }
  \]
\item
  \[
    {
      \frac
      {\Gamma \vdash e_1:\sigma \rightarrow \tau \quad
        \Gamma \vdash e_2:\sigma}
      {\Gamma \vdash e_1 e_2 : \tau}
    }
  \]
\end{enumerate}



\textbf{Operational Semantics}

\textbf{Categorical Semantics}

Simply-typed $\lambda$-calculus is the Internal Language
(\S\ref{sec:internal_logic}) of the Cartesian Closed Categories
(\S\ref{sec:cartesian_closed}).



\textbf{Proof-theoretic Semantics}

Simply-typed $\lambda$-calculus is Isomorphic by Curry-Howard
(\S\ref{sec:curry_howard}) to Minimal Logic
(\S\ref{sec:minimal_logic}):
\begin{itemize}
  \item Terms correspond to Proofs in Natural Deduction
    (\S\ref{sec:natural_deduction})
  \item (Inhabited) Types correspond to Tautologies in Minimal Logic
\end{itemize}



Minimal Logic $\leftrightarrow$ Simply-typed $\lambda$-calculus:
\[
  \supset \leftrightarrow \rightarrow
\] \[
  \wedge \leftrightarrow \times
\] \[
  \vee \leftrightarrow +
\] \[
  False \leftrightarrow \bot
\]



\emph{Type Assignment}:
\[
  \frac{
    f:A \rightarrow B \quad x:A
  }{
    f x : B
  }(\rightarrow e)
\]\[
  \frac{
    x:A \quad y:B
  }{
    \lambda x.y : A \rightarrow B
  }(\rightarrow i)
\]



\subsubsection{System T}\label{sec:system_t}

G\"odel

Proof Interpretation of Heyting Arithmetic into a Finite-type
Extension of Primitive Recursive Arithmetic
(\S\ref{sec:primitive_recursive})

All Recursive Functions in Peano Arithmetic are definable



\subsubsection{PCF}\label{sec:pcf}

\emph{Programming Computable Functions}

extended version of Typed Lambda Calculus (\S\ref{sec:typed_lambda})

Geometry of Interaction (\S\ref{sec:interaction_geometry})

Denotational Semantics (\S\ref{sec:denotational_semantics}):
\emph{Scott Model}

Scott-continuous Function (\S\ref{sec:scott_continuity})



\subsubsection{Reflexive Domain}\label{sec:reflexive_domain}

Dana Scott % FIXME



% --------------------------------------------------------------------
\subsection{$\lambda$-calculus with Conjunctive Types}
\label{sec:conjunctive_lambda}
% --------------------------------------------------------------------

Subtyping (\S\ref{sec:subtype})

System $F_{<:}$ (\S\ref{sec:system_fsub})



% --------------------------------------------------------------------
\subsection{Simply-typed $\lambda$-calculus with Type Operators}
\label{sec:simplytyped_operators}
% --------------------------------------------------------------------

$\lambda\underline{\omega}$

Types depending on Types

System F$_\omega$ (\S\ref{sec:system_fomega})



% --------------------------------------------------------------------
\subsection{System F}\label{sec:system_f}
% --------------------------------------------------------------------

\emph{System F} (or \emph{Second-order $\lambda$-calculus})

(\emph{Girard-Reynolds}) \emph{Polymorphic $\lambda$-calculus})

Universal Quantification over all Types (cf. Existential Type Theory
\S\ref{sec:abstract_type}) %FIXME

By Curry-Howard Isomorphism, System F corresponds to the fragment of
Second-order Intuitionistic Logic using only Universal Quantification;
can describe all Functions that are Provably Total in Second-order
Logic (\S\ref{sec:secondorder_logic})

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism}):
Type-level Function Abstraction $\Lambda$

Quantification over Propositional Variables in Second-order Logic
corresponds to Type Abstraction in Second-order $\lambda$-calculus.
\cite{wadler14}



\subsubsection{System F$_{<:}$}\label{sec:system_fsub}

\subsubsection{System F$_\omega$}\label{sec:system_fomega}



% --------------------------------------------------------------------
\subsection{LF Logical Framework}
\label{sec:logical_framework}
% --------------------------------------------------------------------

Dependent Types (\S\ref{sec:dependent_type})

Dependently-typed $\lambda$-calculus is base of Intuitionistic Type
Theory (\S\ref{sec:intuitionistic_type}), Calculus of Constructions
(\S\ref{sec:coq})

By Curry-Howard Isomorphism Dependent Types correspond to Propositions
of First-order Predicate Logic (\S\ref{sec:firstorder_logic})

Dependently-typed $\lambda$-calculus with a Type of all Types (the
simplest Pure Type System \S\ref{sec:pure_type_system}) is not
Strongly Normalizing due to Girard's Paradox
(\S\ref{sec:girards_paradox})

Contextual Category (\S\ref{sec:contextual_category})



% --------------------------------------------------------------------
\subsection{Linear $\lambda$-calculus}\label{sec:linear_lambda}
% --------------------------------------------------------------------

Linear Type System (\S\ref{sec:linear_type})



\subsubsection{Good Variation}\label{sec:good_variation}
\cite{wadler12}

Gay-Vasconcelos 2010 (Semantics: Asynchronous Buffered
Communication) %FIXME

Linear Functional Language for Session Types

Session Types $\subset$ Types

\fist See \emph{Classical Processes} (CP
\S\ref{sec:classical_processes}) for a Session-typed $\pi$-calculus
Translation

No Deadlock

Extensions:
\begin{itemize}
  \item $Mix$ (Girard):
\[
  \frac{P \vdash \Gamma \quad Q \vdash \Delta}
  {P | Q \vdash \Gamma, \Delta} (Mix)
\]
    No Channels in Common between $P$ and $Q$ (rather than one Channel
    in common as in $Cut$); Equivalent to Provability of the
    Proposition:
\[
  A \otimes B \multimap A \parr B
\]
    Still no Deadlock but allows Independent Concurrent Components.
  \item $BiCut$ (\cite{abramsky-gay-nagarajan96}; special case of
    $MultiCut$):
\[
  \frac{P \vdash \Gamma, x:A, y:B \quad
    Q \vdash \Delta, x:A^\bot, y:B^\bot}
  {\nu x:A.y:B.(P|Q) \vdash \Gamma, \Delta} (BiCut)
\]
    Two Channels in common between $P$ and $Q$ (rather than one
    Channel in common as in $Cut$); Equivalent to Provability of the
    Proposition:
\[
  A \parr B \multimap A \otimes B
\]
    Allows for systems where Communication forms a loop and may
    Deadlock
\end{itemize}

Systems with both $Mix$ and $BiCut$ are Compact: from either of $A
\otimes B$ and $A \parr B$ one may derive the other;
Compact Linear Systems (\S\ref{sec:compact_linear_system}),
Interaction Categories (\S\ref{sec:interaction_category})

\emph{Types}:
\begin{flalign*}
  \quad T,U,V &::= S \;|\; T \otimes U \;|\; T \multimap U
    \;|\; T \rightarrow U \;|\; Unit &
\end{flalign*}

$S$ -- (Linear) Session Type

$T \otimes U$ -- (Linear) Tensor Product

$T \multimap U$ -- (Linear) Function

$T \rightarrow U$ -- (Unlimited) Function

$Unit$ -- (Unlimited) Unit

\emph{Unlimited Types} support Weakening and Contraction,
\emph{Linear Types} do not

Unlimited Types correspond to Types written with $!$ in CP
(\S\ref{sec:classical_processes})

\emph{Session Types}:
\begin{flalign*}
  \quad S &::= \;!T.S \;|\; ?T.S \;|\; \oplus\{l_i:S_i\}_{i \in I}
    \;|\; \&\{l_i:S_i\}_{i \in I} \;|\; end_! \;|\; end_? &
\end{flalign*}

$!T.S$ -- Output Value of Type $T$ then Behave as $S$

$?T.S$ -- Input Value of Type $T$ then Behave as $S$

$\oplus\{l_i:S_i\}_{i \in I}$ -- Select from Behaviors $S_i$ with
Label $l_i$

$\&\{l_i:S_i\}_{i \in I}$ -- Offer Choice of Behaviors $S_i$ with
Label $l_i$

$end_!$ -- Terminator for use with Output

$end_?$ -- Terminator for use with Input


Session Type Duals:
\begin{align*}
  \overline{!T.S} &= ?T.\overline{S} \\
  \overline{?T.S} &= !T.\overline{S} \\
  \overline{\oplus\{l_i:S_i\}_{i \in I}} &=
    \&\{l_i:\overline{S_i}\}_{i \in I} \\
  \overline{\&\{l_i:S_i\}_{i \in I}} &=
    \oplus\{l_i:\overline{S_i}\}_{i \in I} \\
  \overline{end_!} &= end_? \\
  \overline{end_?} &= end_!
\end{align*}

$\overline{\overline{S}} = S$

Duality on Session Types in GV leaves the Types of Sent and Received
Values unchanged, i.e.:
\begin{align*}
  \overline{!T.S} &= ?T.\overline{S} \\
  \overline{?T.S} &= !T.\overline{S}
\end{align*}


\emph{Environments} $\Phi, \Psi$ associating Values to Types

$un(\Phi)$ -- Each Type in $\Phi$ is Unlimited


\emph{Terms}:
\begin{flalign*}
  \quad L,M,N &::= x \;|\; \mono{unit} \;|\; \lambda x.N \;|\; L M
    \;|\; (M,N) \;|\; \mono{let}\; (x,y) = M \;\mono{in}\; N & \\
    & \;|\; \mono{send}\; M N \;|\; \mono{receive}\; M
    \;|\; \mono{select}\; l M
    \;|\; \mono{case}\; M \;\mono{of}\; \{l_i:x.N_i\}_{i\in I} & \\
    & \;|\; \mono{with}\; x \;\mono{connect}\; M \;\mono{to}\; N
    \;|\; \mono{terminate}\; M &
\end{flalign*}

Linear $\lambda$-calculus:

$x$ -- Identifier

$\mono{unit}$ -- Unit Constant

$\lambda x.N$ -- Function Abstraction

$L M$ -- Function Application

$(M,N)$ -- Pair Construction

$\mono{let}\; (x,y) = M \;\mono{in}\; N$

Communication on a Channel:

$\mono{send}\; M N$ -- Send Value $M$ on Channel $N$

$\mono{receive}\; M$ -- Receive on Channel $M$

$\mono{select}\; l M$ -- Select Label $l$ on Channel $M$

$\mono{case}\; M \;\mono{of}\; \{l_i:x.N_i\}_{i\in I}$ -- Offer Choice
on Channel $M$

$\mono{with}\; x \;\mono{connect}\; M \;\mono{to}\; N$ -- Connect $M$
to $N$ by Channel $x$

$\mono{terminate}\; M$ -- Terminate Input


Type Rules

Function Abstraction may produce an Unlimited Function if and only if
all of its Free Variables are of Unlimited Type.

Each Term is not required to have a Unique Type, e.g. a
$\lambda$-expression where all Free Variables have Unlimited Type may
be given either a Linear or Unlimited Function Type.

Possibly Subtyping could be added to arrange for giving each Term a
Unique Smallest Type.


\asterism


\emph{Output} -- $\mono{send}\; M N$: \\
Outputs the Value $M$ of Type $T$ on Channel $N$ of Session Type
$!T.S$ \\
Returns the updated Channel after which the Output has Session Type
$S$

\emph{Input} -- $\mono{receive}\; M$: \\
Inputs a Value from Channel $M$ of Session Type $?T.S$ \\
Returns a (Linear) Pair of the Input Value of Type $T$ and the updated
Channel after which the Input has Session Type $S$

\emph{New Channel} ($Connect$) -- $\mono{with}\; x \;\mono{connect}\;
M \;\mono{to}\; N$ \\
Creates a new Channel $x$ with Session Type $S$ where $x$ is used at
Type $S$ in Term $M$ and Dual Type $\overline{S}$ in Term $N$ \\
$M$ and $N$ are Evaluated Concurrently \\
Left Subterm returns exhausted Channel of Type $end_!$ %FIXME

\emph{Terminate Channel} ($Terminate$) -- $\mono{terminate}\; M$: \\
Evaluates Term $M$ which Returns a Pair of an Exhausted Channel of
Type $end_?$ and a Value of Type $T$ \\
Deallocates the Channel and Returns the Value

Constructs for $Connect$ and $Terminate$ Deallocate two ends of a
Channel between them.

Alternative designs %FIXME


\asterism


\textbf{Translation of GV into CP}

CP (\S\ref{sec:classical_processes})

Translation of Session Types:
\begin{align*}
  \llbracket !T.S \rrbracket &=
    \llbracket T \rrbracket^\bot \parr \llbracket S \rrbracket \\
  \llbracket ?T.S \rrbracket &=
    \llbracket T \rrbracket \otimes \llbracket S \rrbracket \\
  \llbracket \oplus \{l_i : S_i\}_{i \in I} \rrbracket &=
    \llbracket S_1 \rrbracket \& \cdots \& \llbracket S_n \rrbracket,
    \quad I = \{1,\ldots,n\} \\
  \llbracket \& \{l_i : S_i\}_{i \in I} \rrbracket &=
    \llbracket S_1 \rrbracket \oplus \cdots \oplus
    \llbracket S_n \rrbracket, \quad I = \{1,\ldots,n\} \\
  \llbracket end_! \rrbracket &= \bot \\
  \llbracket end_? \rrbracket &= 1
\end{align*}

\fist Note that Input/Output are translated into their Duals. This is
explained by Send and Receive in GV taking Channels as
\emph{Arguments}, while in the Interpretations in CP Channels are
\emph{Results}.
\begin{itemize}
  \item \emph{Send}: takes a Value and a Channel and Sends the Value
    on that Channel (the Channel must \emph{Input} the Value)
  \item \emph{Receive}: takes a Channel and Returns a Value (the
    Channel must \emph{Output} the Value)
\end{itemize}
Since Duality on Session Types in GV leaves Types of Sent and Received
Values unchanged, the Translation of these Operations takes the Dual
of the Sent Value, but not the Received Value, i.e.:
\begin{align*}
  \llbracket !T.S \rrbracket &=
    \llbracket T \rrbracket^\bot \parr \llbracket S \rrbracket \\
  \llbracket ?T.S \rrbracket &=
    \llbracket T \rrbracket \otimes \llbracket S \rrbracket
\end{align*}
and following the equality in Linear Logic, $A \multimap B = A^\bot
\parr B$, $\llbracket T \rrbracket^\bot \parr \llbracket S \rrbracket$
could alternatively be written $\llbracket T \rrbracket \multimap
\llbracket S \rrbracket$.

Translation Preserves Duality:
\[
  \llbracket \overline{S} \rrbracket = \llbracket S \rrbracket^\bot
\]

Translation of Types:
\begin{align*}
  \llbracket T \multimap U \rrbracket &=
    \llbracket T \rrbracket^\bot \parr \llbracket U \rrbracket \\
  \llbracket T \rightarrow U \rrbracket &=
    \;!(\llbracket T \rrbracket^\bot \parr \llbracket U \rrbracket) \\
  \llbracket T \otimes U \rrbracket &=
    \llbracket T \rrbracket \otimes \llbracket U \rrbracket \\
  \llbracket Unit \rrbracket &= \;!\top
\end{align*}

$\llbracket T \rrbracket^\bot \parr \llbracket U \rrbracket$ could
alternatively be written:
\[
  \llbracket T \rrbracket \multimap \llbracket U \rrbracket
\]

$!(\llbracket T \rrbracket^\bot \parr \llbracket U \rrbracket)$ could
alternatively be written:
\[
  !(\llbracket T \rrbracket \multimap \llbracket U \rrbracket)
\]

$!T$ could alternatively be written $1$ (Unit for $\otimes$)

This Translation follows the Call-by-value Translation of Classical
Linear Logic (\S\ref{sec:cll})

Translation of Terms:

Linear $\lambda$ Terms:
\begin{itemize}
  \item Variable Translates to an $Axiom$
  \item $Weaken$ and $Contract$ Translate to $Weaken$ and $Contract$
  \item Function Abstraction and Product Deconstruction Translate to
    Input
  \item Function Application and Product Construction Translate to
    Output
  \item Translation of Elimination Rules ($\multimap-E$,
    $\rightarrow-E$, $\times-E$) require use of $Cut$
\end{itemize}

Communication Operation Terms:
\begin{itemize}
  \item Send: Output Operation $x[y].(P|Q)$
  \item Select: Select Operation $x[in_j].P$
  \item Case: Choice Operation $\mono{case}(Q_1, \ldots, Q_n)$
  \item $end_!$ in Connect: Empty Output $y[].0$
  \item Terminate: Empty Input $x().P$
  \item Receive (Trivial): $x(y).R$ (???)
  \item Connect: $Cut$ corresponds to introducing a Channel for
    Communication between two Subterms
\end{itemize}
Each of these Communication Translations involve a $Cut$ corresponding
to Communication with given Channel.

Term $M$ of Type $T$ is Translated $\llbracket M \rrbracket_z$ where
$z$ is a Channel of Type $\llbracket T \rrbracket$ where $\llbracket M
\rrbracket_z$ Sends the ``Answer'' it Computes on $z$, as expressed by
the Theorem:

Th. \textbf{Translation Preserves Types}

\[
  \text{If } \Phi \vdash M : T \text{ then }
  \llbracket M \rrbracket z \vdash \llbracket \Phi \rrbracket^\bot,
  z : \llbracket T \rrbracket
\]



% --------------------------------------------------------------------
\subsection{$\kappa$-calculus}\label{sec:kappa_calculus}
% --------------------------------------------------------------------

First-order fragment of Typed $\lambda$-calculus



% --------------------------------------------------------------------
\subsection{B\"ohm Tree}\label{sec:bohm_tree}
% --------------------------------------------------------------------

A \emph{B\"ohm Tree} is a Possibly Infinite Directed Acyclic Graph
where some Vertices are Labelled by $\lambda$-terms and all Vertices
besides the Root have exactly one Parent, every Vertex has a finite
number of Children, and every Unlabelled Vertex has no Children.



% ====================================================================
\section{Calculus of Constructions}\label{sec:coq}
% ====================================================================

% ====================================================================
\section{Pure Type System}\label{sec:pure_type_system}
% ====================================================================

Arbitrary number of Sorts and Dependencies

Generalization of the \emph{Lambda Cube} to more sorts than Terms and
Types

Not necessarily Strongly Normalizing (\S\ref{sec:normalization})

Barendregt-Geuvers-Klop Conjecture



% --------------------------------------------------------------------
\subsection{Lambda Cube}\label{sec:lambda_cube}
% --------------------------------------------------------------------

All Strongly Normalizing

$\lambda\rightarrow$: Simply-typed $\lambda$-calculus
(\S\ref{sec:simply_typed}); Terms depending on Terms (Function Type
\S\ref{sec:function_type})

$\lambda\underline{\omega}$: Simply-typed $\lambda$-calculus with Type
Operators (\S\ref{sec:simplytyped_operators}); Types depending on
Types (Type Functions \S\ref{sec:type_function})

$\lambda2$: Second-order $\lambda$-calculus (System F
\S\ref{sec:system_f}); Terms depending on Types (Parametric
Polymorphism \S\ref{sec:parametric_polymorphism})

$\lambda\Pi$: Dependently-typed $\lambda$-calculus (Logical Framework
\S\ref{sec:logical_framework}); Types depending on Terms (Dependent
Types \S\ref{sec:dependent_type})



% ====================================================================
\section{Intuitionistic Type Theory}\label{sec:intuitionistic_type}
\cite{martinlof84}
% ====================================================================

\emph{Intuitionistic Type Theory} (also \emph{Constructive Type
  Theory} or \emph{Martin-L\"of Type Theory})

Inductive Types (\S\ref{sec:inductive_type})

Modelled by Locally Cartesian Closed Category
(\S\ref{sec:locally_cartesian})

Extensional Martin-L\"of Type Theory: Internal Language
(\S\ref{sec:internal_logic}) for Cartesian Closed Quasi-categories
(\S\ref{sec:quasicategory})

Formation: the Context in which the Type is defined

Introduction: rules for Construction

Elimination: rules for De-construction

Computation:

Four forms of Judgements:
\begin{description}
  \item [Well-formed Type]: $A$ is a Set, $A$ is a Proposition, $A$ is
    an Expectation, $A$ is a Task; Types (encodes Syntax of Formulas
    ``A is a Proposition''; note some Formulas are only Well-formed if
    certain Judgements are Derivable \cite{thompson99}):
    \[
      A \text{ type}
    \]
  \item [Equality of Types]: $A$ and $B$ are Equal Sets:
    \[
      A \equiv B \text{ type}
    \]
  \item [Well-formed Term of Type]: $a$ is an Element of $A$, $a$ is a
    Proof of $A$, $a$ is a Realization of $A$, $a$ is a Method for
    doing $A$:
    \[
      a : A
    \]
  \item [Equality of Terms]: $a$ and $b$ are Equal Elements of Set $A$:
    \[
      a \equiv b : A
    \]
\end{description}

Dependent Type (\S\ref{sec:dependent_type}):
\[
  (x:A)B
\]
Removal of Dependency by Substitution:
\[
  [x/a]B
\]
Abstracted Object:
\[
  [x]b
\]
Removal of Abstration on Object:
\[
  b[x/a]
\]
Well-formed Context of Typing Assumptions
(\S\ref{sec:typing_assumption}):
\[
  \vdash \Gamma \textsf{ Context}
\]
Context (\S\ref{sec:type_context}) Judgements:
\begin {itemize}
\item Well-formed Type $\sigma$:
  \[
    \Gamma \vdash \sigma \mathsf{ Type}
  \]
\item Well-formed Term $t$ of Type $\sigma$:
  \[
    \Gamma \vdash t : \sigma
  \]
\item Type Equivalence:
  \[
    \Gamma \vdash \sigma \equiv \tau
  \]
\item Term Equivalence:
  \[
    \Gamma \vdash t \equiv u : \sigma
  \]
\end {itemize}
\hfill\\
Type Universe:
\[
  \class{U}
\]
Dependent Type mapping Objects to Types:
\[
  \textrm{El}
\]

Definitional Equality (\S\ref{sec:proof_equality})

Structural Rules (\S\ref{sec:structural_rule})



\hfill \\
\textbf{Identity Types} (\S\ref{sec:equality_type})
\\
Identity Type Introduction:
\[
  \frac{
    \Gamma \vdash m : A
  }{
    \Gamma \vdash refl_A(m) : Id_A(m,m)
  } (Id_A\text{-I})
\]
Identity Type Elimination:
\[
  \frac{
    \Gamma \vdash p : Id_A (m,n) \quad
    \Gamma, x:A, y:A, z : Id_A(x,y) \vdash C_{x,y,z} \text{ type}\quad
    \Gamma, x : A \vdash q : [x, x, refl_A(x)/x,y,z]C
  }{
    \Gamma \vdash refl_A(m) : Id_A(m,m)
  } (Id_A\text{-E})
\]
\hfill \\
\textbf{Dependent Product Types} (\S\ref{sec:pi_type})
\\
Logical Implication and Universal Quantification
\\
Dependent Product Formation:
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma, x:A \vdash B \text{ type}
  }{
    \Gamma \vdash \Pi_{x:A} B \text{ type}
  } (\Pi\text{-F})
\]
Dependent Product Introduction:
\[
  \frac{
    \Gamma, x : A \vdash m_x : B_x \quad
  }{
    \Gamma \vdash (\lambda x:A.m_x : B_x) : \Pi_{x:A} B
  } (\Pi\text{-I})
\]
Dependent Product Elimination:
\[
  \frac{
    \Gamma \vdash m : \Pi_{x:A} B \quad
    \Gamma \vdash n : A
  }{
    \Gamma \vdash m\;n : [n/x]B
  } (\Pi\text{-E})
\]
Dependent Product Computation (cf. $\beta$-reduction
\S\ref{sec:beta_reduction}):
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma , x : A \vdash m : B
  }{
    \Gamma \vdash (\lambda x : A.m)\;n \equiv [n/x]m : [n/x]B
  } (\Pi\text{-C})
\]


\hfill \\
\textbf{Dependent Sum Types} (\S\ref{sec:sigma_type})
\\
Logical Conjunction and Existential Quantification
\\
Dependent Sum Formation:
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma, x : A \vdash B_x \text{ type}
  }{
    \Gamma \vdash \Sigma_{x:A} B_x \text{ type}
  } (\Sigma\text{-F})
\]
Dependent Sum Introduction:
\[
  \frac{
    \Gamma \vdash m : A \quad
    \Gamma \vdash n : [m/x]B
  }{
    \Gamma \vdash (m,n) : \Sigma_{x:A} B_x
  } (\Sigma\text{-I})
\]
Dependent Sum Elimination 1:
\[
  \frac{
    \Gamma \vdash m : \Sigma_{x:A} B_x
  }{
    \Gamma \vdash \pi_1\;m : A
  } (\Sigma\text{-E$_1$})
\]
Dependent Sum Elimination 2:
\[
  \frac{
    \Gamma \vdash m : \Sigma_{x:A} B_x
  }{
    \Gamma \vdash \pi_2\;m : B[\pi_1\;m/x]
  } (\Sigma\text{-E$_2$})
\]
\hfill \\
\textbf{Binary Sum Types} (\S\ref{sec:sum_type})
\\
Disjunction
\\
Binary Sum Introduction 1:
\[
  \frac{
    \Gamma \vdash m : A
  }{
    \Gamma \vdash inl(m) : A + B
  } (+\text{-I}_1)
\]
Binary Sum Introduction 2:
\[
  \frac{
    \Gamma \vdash n : B
  }{
    \Gamma \vdash inr(n) : A + B
  } (+\text{-I}_2)
\]
Binary Sum Elimination:
\[
  \frac{
    \Gamma \vdash m : A + B \quad
    \Gamma, z : A + B \vdash C \text{ type} \quad
    \Gamma, x : A \vdash n : [inl(x)/z]C \quad
    \Gamma, y : B \vdash p : [inr(y)/z]C
  }{
    \Gamma \vdash case (m, x\;n, y\;p) : [m/z]C
  } (+\text{-E})
\]



Categorical Model, ``Category with Families'':

\begin{itemize}
  \item Category $\mathsf{C}$ of Contexts: Objects are Contexts,
    Morphisms are Substitutions
  \item Functor $T : \mathsf{C}^{op} \rightarrow \mathbf{Fam(Set)}$
    where $\mathbf{Fam(Set)}$ is the Category of Families
    (\S\ref{sec:family}) of Sets where Objects are Pairs $(A,B)$ of an
    Index Set $A$ and a Function $B: X \rightarrow A$ and Morphisms
    are Pairs of Functions $f: A \rightarrow A$ and $g: X \rightarrow
    X'$ such that $B' \circ g = f \circ B$, i.e. $f$ maps $B_a$ to
    $B'_{g(a)}$
\end{itemize}

The Functor $T$ assigns a Context $\Gamma$ to a Set of Types
$Ty(\Gamma)$, and for each $A : Ty(\Gamma)$ a Set of Terms
$Tm(\Gamma,A)$.

The Empty Context is the Terminal Object of $\mathsf{C}$.

Final Object for \emph{Comprehension} (or \emph{Context Extension}) % FIXME



\textbf{Alternate description}\cite{bastenhof09}

Language $L$:
\begin{enumerate}
  \item $1$ (Unity Type), $\Omega$ (Truth Value Type)
  \item Base Types $\tau_1, \tau_2, \tau_3, \ldots$
  \item Function Symbols $f, g, h, \ldots$
\end{enumerate}
The Types of a System are given by the smallest Set including $1$,
$\Omega$, and the Base Types closed under $\times$ (Product Types
\S\ref{sec:product_type}) and Unary Type Operator $P$ (Power Types
\S\ref{sec:power_type}).

Terms of Type $\Omega$ represent Formulas, e.g. $\tau_1 = \tau_2$.


\asterism


\textbf{Sum Type} (\S\ref{sec:sum_type}) (Tagged Union)

$A \cup B = \{ a_1, a_2, ..., b_1, b_2, ... \}$

$x \in A \cup B \Rightarrow x \in A \vee x \in B$

$U \subset A \cup B \Rightarrow \forall u \in U, u \in A \vee u \in B \}$


\textbf{Product Type} (\S\ref{sec:product_type}) (Pairs)

$A \times B = \{ (a_1,b_1), (a_1,b_2), ..., (a_2,b_1), (a_2,b_2), ... \}$

$(x,y) \in A \times B \Rightarrow x \in A \wedge y \in B$

$U \subset A \times B
\Rightarrow \forall (u,v) \in U, u \in A \wedge v \in B$


\textbf{Powerset} (\S\ref{sec:powerset})
(Relations \S\ref{sec:binary_relation})

$\pow(A \times B) = \{ \linebreak[1]
\{(a_1,b_1)\}, \{(a_1,b_2)\}, ...,
\{(a_2,b_1)\}, \{(a_2,b_2)\}, ...
\linebreak[1] \vdots \linebreak[1]
\{(a_1,b_1), (a_1,b_2)\}, \{(a_1,b_1), (a_1,b_3)\}, ...,
\{(a_2,b_1), (a_2,b_2)\}, \{(a_2,b_1), (a_2,b_3)\}, ...
\linebreak[1] \vdots \linebreak[1]
..., A \times B - \{(a_2,b_1), (a_2,b_3)\}, \allowbreak
A \times B - \{(a_2,b_1), (a_2,b_2)\}, \allowbreak
..., A \times B - \{(a_1,b_1), (a_1,b_3)\}, \allowbreak
A \times B - \{(a_1,b_1), (a_1,b_2)\}, \allowbreak
\linebreak[1] \vdots \linebreak[1]
..., A \times B - \{(a_2,b_2)\}, A \times B - \{(a_2,b_1)\}, \allowbreak
..., A \times B - \{(a_1,b_2)\}, A \times B - \{(a_1,b_1)\}, \allowbreak
\linebreak[1] A \times B
\}$

$A \times B \in \pow(A \times B)$

$U \in \pow(A \times B) \Rightarrow U \subseteq A \times B \allowbreak
\Rightarrow \forall (u,v) \in U, u \in A \wedge v \in B$

$\class{V} \subset \pow(A \times B)
\Rightarrow \forall U \in \class{V}, U \subseteq A \times B$


\textbf{Function Type} (\S\ref{sec:function_type})

$A \rightarrow B = B^A = \{ \linebreak[1]
\{ (a_1, b_1), (a_2, b_1), (a_3, b_1), ...\},
\{ (a_1, b_2), (a_2, b_2), (a_3, b_2), ...\},
\{ (a_1, b_3), (a_2, b_3), (a_3, b_3), ...\}, ...
\linebreak[1] \vdots \linebreak[1]
\{ (a_1, b_2), (a_2, b_1), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_2), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_1), (a_3, b_2), ...\}, ...
\linebreak[1] \vdots \linebreak[1]
\{ (a_1, b_3), (a_2, b_1), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_3), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_1), (a_3, b_3), ...\},
\linebreak[1] \vdots \linebreak[1]
\}$

$B^A \subset \pow(A \times B)$

$f \in B^A
\Rightarrow f \in \pow(A \times B) \wedge f \neq A \times B \allowbreak
\Rightarrow f \subset A \times B
\Rightarrow \forall (x, f(x)) \in f, x \in A \wedge f(x) \in B$

$U \subset B^A \Rightarrow \forall u \in U, u \in \pow(A \times B)$


\textbf{Dependent Type} (\S\ref{sec:dependent_type})

$a:A \vdash B(a) = \{(a_1,B(a_1)), (a_2,B(a_2)), ...\}$

$a:A \vdash B(a) \in \class{U}^A \linebreak[1]
\Rightarrow a:A \vdash B(a) \subset A \times \class{U}$

$(x,X) \in a:A \vdash B(a) \Rightarrow x \in A \wedge X \in \class{U}$

$U \subset a:A \vdash B(a) \Rightarrow \forall (x,X) \in U, x \in A
\wedge X \in \class{U}$


\textbf{Dependent Sum Type} ($\Sigma$-type \S\ref{sec:sigma_type})

$\Sigma_{(a:A)} B(a) = \{\{ (a_1, x_1), (a_1, x_2), ...\},
\{ (a_2, y_1), (a_2, y_2), ...\}, \cdots \}$

$\Sigma_{(a:A)} B(a) \subset \pow \bigsqcup_{X \in \class{U}} A \times X$

$Z \in \Sigma_{(a:A)} B(a) \Rightarrow \exists x \in A : \forall y \in
B(x), (x,y) \in P$



\textbf{Dependent Product Type} ($\Pi$-type \S\ref{sec:pi_type})

$\Pi_{(a:A)} B(a) = \{(a_1, x), (a_2, y), (a_3, z), ...\}$

$\Pi_{(a:A)} B(a) \subset \pow \bigsqcup_{a \in A} \Sigma_{(a:A)} B(a)$


\asterism



% --------------------------------------------------------------------
\subsection{Constructive Type}\label{sec:constructive_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Meaning Explanation}\label{sec:meaning_explanation}
% --------------------------------------------------------------------

Martin-L\"of, a Proof-theoretic Semantics
(\S\ref{sec:proof_semantics}) for Type Theory

Realizability Model (\S\ref{sec:realizability_model}) for Type Theory

Intensional Type Theory (\S\ref{sec:intensional_type})

Extensional Type Theory (\S\ref{sec:extensional_type})

Terms $x,y,z,X,Y,Z,\ldots$

$x \Rightarrow y$: $x$ Computes (Reduces, Transitive) to $y$

Predicates:
\begin{itemize}
  \item $A \type$
  \item $a : A$
  \item $a = b : A$
\end{itemize}

Induction Recursion (\S\ref{sec:induction_recursion}): $A \type$ by
Induction (\S\ref{sec:mathematical_induction}) and two Recursive
Functions:
\begin{itemize}
  \item $|A|$ the Collection of Terms of Type $A$
  \item $=_A$ the Collection of Pairs of Equal Terms of Type $A$
\end{itemize}
(each Collection may be defined Inductively)



% --------------------------------------------------------------------
\subsection{Extensional Type Theory}\label{sec:extensional_type}
\cite{harper12}
% --------------------------------------------------------------------

\emph{Extensional Type Theory} (\emph{ETT})

Strict Equivalence

``Homotopy Set Theory'' (Homotopically Discrete)

\emph{NuPRL}

Equality Reflection Principle



\subsubsection{Observational Type Theory}\label{sec:observational_type}

``Homotopy Set Theory''

Setoid (\S\ref{sec:setoid})



% --------------------------------------------------------------------
\subsection{Intensional Type Theory}\label{sec:intensional_type}
\cite{harper12}
% --------------------------------------------------------------------

Weak Equivalence



% ====================================================================
\section{Dependent Type Theory}\label{sec:dependent_type_theory}
% ====================================================================

\textbf{Categorical Semantics} (\S\ref{sec:categorical_semantics})

Categorical Model (\S\ref{sec:categorical_model})

Interpretation of Judgements of Dependent Type Theory in a given
Category $\cat{C}$ with Finite Limits (\S\ref{sec:finite_limit})

Codomain Fibration (\S\ref{sec:codomain_fibration}):
\[
  cod:\cat{C}^I \rightarrow \cat{C}
\]

Classifying Functor (Grothendieck Construction
\S\ref{sec:grothendieck_construction}):
\[
  \chi : \cat{C}^{op} \rightarrow \cat{Cat}
\]
sends an Object in $\cat{C}$ to the Slice Category
(\S\ref{sec:slice_category}) over it:
\[
  \chi = \Gamma \mapsto \cat{C}/\Gamma
\]
and sends a Moprhism $f : \Gamma \rightarrow \Gamma'$ to the Pullback
(\S\ref{sec:pullback})/Base Change (\S\ref{sec:base_change}) Functor:
\[
  f^* : \cat{C}/\Gamma' \rightarrow \cat{C}/\Gamma
\]


\textbf{Rules}

Rules for choices ``$[xyz]$'' associating every String ``$xyz$'' of
Symbols in Type Theory with Objects and Morphisms in $\cat{C}$: a
collection of such choices following the Rules is an Interpretation (a
choice of Categorical Semantics) of the Type Theory in the Category
$\cat{C}$.

\emph{Contexts and Type Judgements}:
\begin{enumerate}
  \item $[()] := *$ -- Empty Context $()$ is Interpreted as the
    Terminal Object $*$ of $\cat{C}$
  \item For Context $\Gamma$ with Interpretation $[\Gamma] \in
    \cat{C}_0$, a Judgement $\Gamma \vdash A\type$ is Interpreted
    as an Object in the Slice Category over $\Gamma$:
    \[
      [\Gamma \vdash A\type] \in (\cat{C}/\Gamma)_0
    \]
    giving a choice of Morphism:
    \[
      [\Gamma \vdash A\type] : [(\Gamma,x:A)] \rightarrow [\Gamma]
    \]
  \item For Judgement $\Gamma \vdash A\type$ Interpreted as $[\Gamma
    \vdash A\type]$ above, an Extended Context $(\Gamma,x:A)$ is
    Interpreted as the Domain Object $[(\Gamma,x:A)]$ of the above
    choice of Morphism
\end{enumerate}

\emph{Terms}

For Context $\Gamma$ and Judgement $\Gamma \vdash A\type$ with chosen
Interpretation $[\Gamma \vdash A\type] : [(\Gamma,x:A)] \rightarrow
[\Gamma]$, a Judgement $\Gamma \vdash a:A$ is Interpreted as a Section
(\S\ref{sec:section}) of $[\Gamma \vdash A\type]$, equivalently as a
Morphism in $\cat{C}/\Gamma$:
\[
  [\Gamma \vdash a:A]: * \rightarrow [\Gamma,x:A]
\]
giving a Commuting Triangle:
\[
  1_{[\Gamma]} = [\Gamma \vdash A\type] \circ [\Gamma \vdash a:A]
\]

\emph{Variables}

\emph{Substitution}



% --------------------------------------------------------------------
\subsection{Dependent Type}\label{sec:dependent_type}
% --------------------------------------------------------------------

A \emph{Dependent Type} depends on a Term or another Type.

\[
  x : A \vdash B(x):\mathrm{Types}
\]

A Dependent Product Type (\S\ref{sec:pi_type}) is defined by
a Dependent Function (\S\ref{sec:dependent_function}).

Logical Quantifiers (\S\ref{sec:quantifier})

Intuitionistic Type Theory (\S\ref{sec:intuitionistic_type})

Categorically, Dependent Types correspond to Morphisms regarded as
Indexed Families (Bundle or Fibration), represented by a \emph{Display
  Map} (\S\ref{sec:display_map}) which is a Morphism $p : B
\rightarrow A$ where $B(x)$ is the Fiber (\S\ref{sec:fiber}) of $p$
over $x:A$.

Classifying Morphism (\S\ref{sec:classifying_morphism}),
Classifying Space (\S\ref{sec:classifying_space})

A Dependent Type is the Type of a Dependent Function
(\S\ref{sec:dependent_function}).

Dependent Pairs (Dependent Sum Type \S\ref{sec:sigma_type})


\textbf{First-order Dependent Type Theory} ($\lambda \Pi$):
\emph{Logical Framework} (\S\ref{sec:logical_framework}), adding the
Dependent Product Type (\S\ref{sec:pi_type}) to Simply-typed
$\lambda$-calculus.


\textbf{Second-order Dependent Type Theory} ($\lambda \Pi 2$):
allowing Quantification over Type Constructors
(\S\ref{sec:type_constructor}), $\Pi$ operator Subsumes both
$\rightarrow$ of Simply-typed $\lambda$-calculus and $\forall$ of
System F (\S\ref{sec:system_f})


\textbf{Higher-order Dependently Typed Polymorphic $\lambda$-calculus}
($\lambda \Pi \omega$): corresponds to \emph{Calculus of
  Constructions} (\S\ref{sec:coq}); extends $\lambda \Pi 2$ to all
abstractions of the $\lambda$-cube (\S\ref{sec:lambda_cube})



\subsubsection{Dependent Function}\label{sec:dependent_function}

A \emph{Dependent Function} is a Function from Terms to Types
(Codomain varies depending on Argument). The Type of a Dependent
Function is a \emph{Dependent Product Type}
(\S\ref{sec:pi_type}).

Dependent Function Space: if $f:(\forall x: A).B$ then $f a : B[a/x]$

Functionality (respect for Definitional Equality
\S\ref{sec:proof_equality}):
\[
  x : A \vdash B_x \;\text{type}
\]\[
  m : A \mapsto B[m/x] \;\text{type}
\]\[
  m \equiv n : A \mapsto B[m/x] \equiv B[n/x] \;\text{type}
\]

Doubly-indexed Type:
\[
  x : A, y : B_x \vdash C_{x,y} \;\text{type}
\]

Example: Family of Types Indexed by $\mathbb{N}$:
\[
  x : \mathbb{N} \vdash even(x) \;\text{type}
\]
is a Propositional Function (takes a Natural Number and yields a
Proposition). For each Natural Number, either $even(x)$ is Inhabited
(if $x$ is Even) or Uninhabited (if $x$ is Odd).\cite{harper12}



\subsubsection{Dependent Sum Type ($\Sigma$-type)}\label{sec:sigma_type}

\emph{$\Sigma$-type} (or \emph{Dependent Sum Type} or \emph{Dependent
  Pair Type})

Dependent Sum (\S\ref{sec:dependent_sum})

\[
  \Sigma_{(x:A)} B(x)
\]

If $B$ is Constant, then $\Sigma_{(x:A)}B$ is Judgementally Equal to
the Product Type (\S\ref{sec:product_type}) $A \times B$:
\[
  \Sigma_{(x:A)} B \equiv A \times B
\]

By Curry-Howard, $\Sigma$-types model Conjunction and Existential
Quantification.

Analagous to Coproduct or Disjoint Union.



\subsubsection{Dependent Product Type ($\Pi$-type)}\label{sec:pi_type}

The \emph{$\Pi$-type} (or \emph{Dependent Product Type} or
\emph{Dependent Function Type}) is the Type of a Dependent Function.
By Curry-Howard, $\Pi$-types model Implication and Universal
Quantification.

Dependent Product (\S\ref{sec:dependent_product})

For a Type $A : \class{U}$ in Type Universe
(\S\ref{sec:type_universe}) $\class{U}$, a Family of Types:
\[
  B : A \rightarrow \class{U}
\]
can be defined by a Dependent Function which assigns a Type $B(a) :
\class{U}$ to Each Term $a : A$. The Type of this Function is a
Dependent Product Type:
\[
  \Pi_{(x:A)}B(x)
\]

If $B$ is Constant, then $\Pi_{(x:A)}B$ is Judgementally Equal to the
Function Type (\S\ref{sec:function_type}) $A \rightarrow B$:
\[
  \Pi_{(x:A)}B \equiv A \rightarrow B
\]

Generalizes the idea of a Polymorphic Function
(\S\ref{sec:polymorphic_function})

\cite{hott13}:

Example $id$:
\[
  id : \Pi_{(A : \class{U})} A \rightarrow A
\]

Example 2 $swap$:
\[
  swap : \Pi_{(A:\class{U})} \Pi_{(B:\class{U})} \Pi_{(C:\class{U})}
  (A \rightarrow B \rightarrow C) \rightarrow (B \rightarrow A
  \rightarrow C)
\]
Type arguments may be written as subscripts: $id_A$, $swap_{A,B,C}$

A Polymorphic Function returning elements of Type $C$ has Polymorphic
Type (\S\ref{sec:polymorphic_type}):
\[
  \Pi_{(A:\class{U})} A \rightarrow C
\]



\subsubsection{Dependent Equality Type}\label{sec:dependent_equality}



% ====================================================================
\section{Modal Type Theory}\label{sec:modal_type_theory}
% ====================================================================

Modal Logic (\S\ref{sec:modal_logic})

Type Formation Rules for Modalities (\S\ref{sec:modality})

Closure Operator Modality (???)

Idempotent Monadic or Idempotent Comonadic (???)



% --------------------------------------------------------------------
\subsection{Modal Type}\label{sec:modal_type}
% --------------------------------------------------------------------



% --------------------------------------------------------------------
\subsection{Functional Reactive Programming}\label{sec:frp}
% --------------------------------------------------------------------

%FIXME possibly move this? dynamical systems? control theory?

\fist \cite{winskel-nielsen93} refers to Distributed (Concurrent)
Systems as \emph{Reactive Systems}, see Process Calculus
(\S\ref{sec:process_calculus}) and Interaction Categories
(\S\ref{sec:interaction_category})
%FIXME

(FRP)

Pure Functions over Signals \S\ref{sec:signal} (Time-dependent Values)

Temporal Logic (\S\ref{sec:temporal_logic})

Linear Temporal Logic (LTL) (\S\ref{sec:linear_temporal})

LTL Propositions \emph{as} Types \\
Proofs of LTL Formulae \emph{as} FRP Programs \cite{jeffrey12},
(Jeltsch 11)

LTL Types express Temporal Behaviors of Programs, e.g. a Program which
must be used immediately, or one which may be used at some Time in the
Future \cite{jeffrey12} %FIXME clarify used

Fan Categories (\S\ref{sec:fan_category}) \cite{jeltsch12}

Hughes Arrows (\S\ref{sec:hughes_arrow}) with Loops (???): Type Class
(\S\ref{sec:constrained_type}) for Freyd Categories
(\S\ref{sec:freyd_category}), i.e. Premonoidal Categories
(\S\ref{sec:premonoidal_category}) with a Cartesian Center (???) and a
Premonoidal Trace (\S\ref{sec:category_trace}) -- defines the Dataflow
Structure but lacks Temporal Properties \cite{jeffrey12}
%FIXME

Reactive Programs form Proofs of Constructive LTL Properties
\cite{jeffrey12}

Implications in LTL give rise to Stateless Functions on Streams (???),
``Constrains'' Modality gives rise to Causal Functions
\cite{jeffrey12} %FIXME xref

Reactive Programs form a Partially-traced Monoidal Category
(\S\ref{sec:partially_traced}) \cite{jeffrey12}

Arrows with Loops where the Type System enforces that only Decoupled
Functions can be Looped \cite{jeffrey12}

Stateless Function $\Rightarrow$, Causal Function $\unrhd$, Decoupled
Function $\rhd$: expression as LTL Operators \cite{jeffrey12}

LTL Formulae: Reactive Types (\S\ref{sec:reactive_type})

Implementation in a Dependent Type Theory
(\S\ref{sec:dependent_type}): not efficiently executable as a Polling
Pull (???) implementation and also suffers from Time Leaks in that the
entire Input History must be recorded (and can't be Garbage Collected)
\cite{jeffrey12}

Push-pull FRP: underlying I/O model is Asynchronous



\subsubsection{Reactive Type}\label{sec:reactive_type}

\cite{jeffrey12}:

correspondance with Propositions of Linear Temporal Logic (LTL)
(\S\ref{sec:linear_temporal})

Loop Combinator: Cyclic Dataflow Graphs (???), Type of a Partial Trace
(\S\ref{sec:partial_trace}) %FIXME

\emph{Reactive Type}

Elements of $Time \rightarrow Set$

\begin{flalign*}
  \quad & RSet : Set_1 & \\
  \quad & RSet = Time \rightarrow Set \\
  \quad & \langle \rangle : Set \rightarrow RSet \\
  \quad & \langle A \rangle(t) = A \\
  \quad & \llbracket \rrbracket : RSet \rightarrow Set \\
  \quad & \llbracket A \rrbracket = \forall \{t\}A(t)
\end{flalign*}

$\langle A \rangle$ -- Constant Reactive Type for each Type $A$

$\llbracket A \rrbracket$ -- Reactive Type with Elements as Signals
(\S\ref{sec:signal}) $\sigma$ such that $\sigma\{t\} : A(t)$ for all
Times $t$; generalizes the Signal Type Constructor with Isomorphism:
\[
  Signal(A) \cong \llbracket \langle A \rangle \rrbracket
\]
$\llbracket \langle \rangle \rrbracket : Set \rightarrow Set$ is a
Monad (\S\ref{sec:monad}) as an Instance of the Read-only State Monad
where State is the current Time

Example Reactive Type:
\begin{flalign*}
  \quad & Past : RSet & \\
  \quad & Past(t) = \exists \{s\}(s \leq t)
\end{flalign*}

Type Combinators can be Pointwise Lifted (Lifting Monad?
\S\ref{sec:lifting_monad}) from Types to Reactive Types, e.g. Lifted
version of the $Maybe$ Type:
\begin{flalign*}
  \quad & E : RSet \rightarrow RSet & \\
  \quad & E(A)(t) = Maybe(A(t))
\end{flalign*}

Category of Reactive Types $\cat{RSet}$:
\begin{itemize}
  \item Objects: Reactive Types
  \item Morphisms: Elements of $\llbracket A \Rightarrow B \rrbracket$
  \item Identity and Composition: inherited Pointwise from $\cat{Set}$
\end{itemize}
The Cartesian-closed (\S\ref{sec:cartesian_closed}) Structure of
$\cat{Set}$ Lifts to $\cat{RSet}$ and $\langle \rangle$ gives rise to
a Functor from $\cat{Set}$ to $\cat{RSet}$.

Temporal Propositions \S\ref{sec:temporal_logic} (Propositions with
one Time Parameter) \emph{as} Reactive Types

Modalities (\S\ref{sec:modality}) of Linear-time Temporal Logic (LTL)
(\S\ref{sec:linear_temporal}) \emph{as} Reactive Type Combinators

Primitive Modalities:
\begin{itemize}
  \item $\ocircle \phi$ -- Next
  \item $\phi \;\until\; \psi$ -- Until
\end{itemize}

Derived Modalities:
\begin{itemize}
  \item $\lozenge \phi$ -- Future
  \item $\square \phi$ -- Globally: $\phi$ True at all Future Times
  \item $\phi \;\untileq\; \psi$ -- Non-strict Until
  \item $\phi \rhd \psi$ -- Constrains
  \item $\phi \unrhd \psi$ -- Non-strict Constrains
  \item $\phi \rightsquigarrow \psi$ -- Choice: Constructively defines
    a Choice Function, Classically collapses to $\Rightarrow$
\end{itemize}

Duals of $\ocircle$, $\untileq$, $\lozenge$, $\square$:
\begin{itemize}
  \item $\ominus \phi$ -- Yesterday: $\phi$ True at Time $s$ when True
    at Time $s - 1$
  \item $\phi \;\sinceeq\; \psi$ -- Non-strict Since
  \item $\minlozenge \phi$ -- Once: True when $\phi$ is True at some
    Past Time
  \item $\boxminus \phi$ -- Historically: True whenever $\phi$ is True
    at all Past Times
\end{itemize}

$\Rightarrow$, $\rhd$, and $\unrhd$ define Function Spaces:
\begin{itemize}
  \item $A \Rightarrow B$ -- \emph{Stateless Functions}: Output Value
    at Time $t$ depends only on Input Value at Time $t$; Implications
    in LTL
  \item $A \unrhd B$ -- \emph{Causal Functions}: Output Value at Time
    $t$ depends on History of Inputs (respect Equality up to the
    current Time); ``Constrains'' Modality
  \item $A \rhd B$ -- \emph{Decoupled Functions}: Output Value at Time
    $t$ depends on History of Inputs but cannot depend on Input Value
    at Time $t$
\end{itemize}

Derivations in Classical Logic:
\begin{align*}
  \lozenge A &= T \;\until\; A \\
  \square A &= \neg(\lozenge\neg A) \\
  A \; \untileq\; B &= A \;\until\; (A \wedge B) \\
  A \rhd B &= \neg(A \;\until\; \neg B) \\
  A \unrhd B &= A \neg(A \;\untileq\; \neg B) \\ %FIXME is this right?
  A \rightsquigarrow B &= \neg((A \wedge \neg B) \;\untileq\; T)
\end{align*}


\textbf{Combinators}

Signal Functions (\S\ref{sec:signal_function}) $f,g$:

$f \ggg g$, $f \&\&\& g$, and $loop f$ allow Dataflow Networks to be
built which can be visualized in any Traced Monoidal Category
(\S\ref{sec:traced_monoidal})

Example $clickMonitor$:
\begin{flalign*}
  \quad & clickMonitor : \llbracket \langle MouseButtonState \rangle
    \unrhd \langle MouseEvent \rangle \rrbracket & \\
  \quad & clickMonitor = arr (\cdot = up) \ggg edge \ggg tag(mouseClick)
\end{flalign*}

$\ggg$ and $\&\&\&$ respect Decoupling:
\begin{itemize}
  \item if $f:\llbracket A \rhd B \rrbracket$ and $g : \llbracket B
    \unrhd C \rrbracket$ then $f \ggg g : \llbracket A \rhd C
    \rrbracket$
  \item if $f:\llbracket A \unrhd B \rrbracket$ and $g : \llbracket B
    \rhd C \rrbracket$ then $f \ggg g : \llbracket A \rhd C
    \rrbracket$
  \item if $f:\llbracket A \rhd B \rrbracket$ and $g : \llbracket B
    \rhd C \rrbracket$ then $f \&\&\& g : \llbracket A \rhd B \wedge C
    \rrbracket$
\end{itemize}


\textbf{FRP Primitives}

$constant : \forall\{A,B\}\llbracket \square B
  \Rightarrow A \rhd B \rrbracket$

$localTime : \forall\{A\} \llbracket A \rhd
  \langle Time \rangle \rrbracket$

$initially : \forall\{A\} \llbracket A
  \Rightarrow A \unrhd A \rrbracket$

$decouple : \forall\{A\} \llbracket \ominus A
  \Rightarrow A \rhd \ominus A \rrbracket$

\emph{Nested Signals} via the $\square$ Modality indicates a
\emph{Stream} of Future Values, e.g. $\llbracket \square\square A
\rrbracket$ is Inhabited by Signals of Signals of Type $A$.

$decouple$ Primitive used to introduce minimal Decoupling, i.e. acts
as an Identity with a $1$ Unit delay.


\textbf{Feedback Loops}

\[
  \llbracket ((A \wedge B) \unrhd (A \wedge C))
    \Rightarrow B \unrhd C \rrbracket
\]
required to Satisfy the Equations of a Traced Premonoidal Category
(\S\ref{sec:traced_premonoidal})

Instance of the Type Class of Arrows (\S\ref{sec:hughes_arrow}) with
Loops

Consequence of the existence of Loops is that every Type is Inhabited,
e.g. defining:
\begin{flalign*}
  \quad & f : \llbracket (F \wedge T) \unrhd (F \wedge F) \rrbracket & \\
  \quad & f = arr[\lambda(x,y).(x,x)]
\end{flalign*}
and Tracing (???) $f$ gives a Function $T \unrhd F$ which can be used
to Inhabit the Empty Type. When this is not desired it can be avoided
by only giving Fixed Points to Decoupled Functions leading to a Type
for $loop$:
\begin{flalign*}
  \quad & loop : \forall\{A,B,C\} \llbracket ((A \wedge B)
    \rhd (A \wedge C)) \Rightarrow B \rhd C \rrbracket & \\
  \quad & loop f = (ifix(f \ggg fst) \&\&\& id) \ggg f \ggg snd
\end{flalign*}
where $ifix$ is the Function for Indexed Fixed Points.

Decoupled Functions form Contraction Maps
(\S\ref{sec:contraction_map}) in an Ultrametric Space
(\S\ref{sec:ultrametric_space}) of Functions and so have Fixed Points.

Because $loop$ can only be Applied to Decoupled Functions and not
Functions in general it does not form a Trace
(\S\ref{sec:category_trace}) and instead forms a Partial Trace
(\S\ref{sec:partial_trace}).


\asterism


Comonad Structure of $\square$:
\begin{flalign*}
  \quad & extend : \forall\{A,B\} \llbracket A \Rightarrow B \rrbracket
    \rightarrow \llbracket \square A
    \Rightarrow \square B \rrbracket & \\
  \quad & extract : \forall\{A\} \llbracket \square A
    \Rightarrow A \rrbracket \\
  \quad & duplicate : \forall\{A\} \llbracket \square A
    \Rightarrow \square\square A \rrbracket
\end{flalign*}

Applicative Structure of $\square$:
\begin{flalign*}
  \quad & [\cdot] : \forall\{A\} \llbracket A \rrbracket
    \rightarrow \llbracket \square A \rrbracket & \\
  \quad & (\cdot \langle * \rangle \cdot) : \forall\{A,B\}
    \llbracket \square (A \Rightarrow B) \Rightarrow \square A
    \Rightarrow \square B \rrbracket
\end{flalign*}

Comonad and Applicative Structure of $\square$ show that $\square$ is
a Model of $S4$ (Alethic) Modal Logic (\S\ref{sec:alethic_logic})

$\ocircle$, $\ominus$: Applicative Functors
(\S\ref{sec:applicative_functor})

$\lozenge$, $\minlozenge$: Applicative Monads
(\S\ref{sec:applicative_monad})

$\boxminus$: Applicative Comonad (\S\ref{sec:applicative_comonad})

Kleisli Category (\S\ref{sec:kleisli_category}) $\boxminus \cat{RSet}$:
\begin{itemize}
  \item Objects: Reactive Types
  \item Morphisms: Elements of $\llbracket \boxminus A \Rightarrow B
    \rrbracket$
  \item Identity and Composition: usual for Kleisli Construction
\end{itemize}

Enriched Categorical (\S\ref{sec:enriched_category}) Structure of
$\unrhd$ (with Hom-objects given by $\unrhd$): $arr$, $id$, $before$,
$after$, $\$$, $\ggg$

$\unrhd \cat{RSet}$:
\begin{itemize}
  \item Objects: Reactive Types
  \item Morphisms: Elements of $\llbracket A \unrhd B
    \rrbracket$
  \item Identity and Composition: as given by Enriched Category
    Structure of $\unrhd$
\end{itemize}

\begin{itemize}
  \item $\cat{Set}$: Morphisms are Witnesses of Implication with no
    place in Time
  \item $\cat{RSet}$: Morphisms are Witnesses of Implication whose
    Hypothesis is True at some Time $t$
  \item $\unrhd \cat{RSet}$: Morphisms are Witnesses of Implication
    whose Hypothesis is True over an Interval $[s,t]$
  \item $\boxminus \cat{RSet}$: Morphisms are Witnesses of Implication
    whose Hypothesis is True over an Interval $(-\infty,t]$
\end{itemize}
leads to (Embedding \S\ref{sec:category_embedding}) Functors:
\[
  \cat{Set} \hookrightarrow \cat{RSet} \hookrightarrow
    \unrhd\cat{RSet} \hookrightarrow \boxminus\cat{RSet}
\]
All have Finite Products inherited from $\cat{Set}$

All but $\unrhd\cat{RSet}$ are Cartesian Closed
(\S\ref{sec:cartesian_closed}): in $\cat{RSet}$, $\sinceeq$
(with its Arguments flipped) is Left-adjoint to $\unrhd$ so
$\cat{RSet}$ has a Closed Structure for $\unrhd$ even if
$\unrhd\cat{RSet}$ does not.


$\cat{RSet}$ inherits Coproducts from $\cat{Set}$

$\unrhd\cat{RSet}$ has Weak Coproducts

$\boxminus\cat{RSet}$ does not have Coproducts

\fist Note that the Embedding of $\unrhd\cat{RSet} \hookrightarrow
\boxminus\cat{RSet}$ requires the existence of a Least Element of Time
$-\infty$.

$\mathsf{C}$ -- Chop Modality on Paths; Interval Temporal Logic
(\S\ref{sec:interval_temporal})


\asterism


\textbf{Implementation}

Implementation uses Interval Types (\S\ref{sec:interval_type}) instead
of Reactive Types (\S\ref{sec:reactive_type}); Interval Temporal Logic
(\S\ref{sec:interval_temporal}) admits the Chop Modality $\mathsf{C}$
on Paths and may give a Cartesian Closed structure to $\unrhd$

For a Causal Function Space $A \unrhd B$ the State (???) of a Causal
Function is Modelled as a \emph{Process} of Type:
\[
  (A @ s \multimap B @ u)
\]
that has ``Received'' Input up to Time $s$ and ``Produced'' Output up
to Time $u$; initial State of a Causal Function at Time $t$ is a
Process where $s = t = u$. A Process can Terminate when $u = \infty$,
i.e. when it has ``Produced'' all its Output (even if $s \prec
\infty$).

Resumption Model of Concurrency (???)

(??? cf. Processes \S\ref{sec:process} in Process Calculus?)



\subsubsection{Interval Type}\label{sec:interval_type}

\cite{jeffrey12}:

\emph{Time Intervals}: Segments of Signals

$Time^\infty$ -- Type of Time Bounds, Extends $Time$ with $\infty$

$[s \prec t)$ -- \emph{Time Interval}

$i \sim j$ -- \emph{Concatenable Intervals}: $i = [s \prec t)$ and $j
    = [t \prec u)$

$i \frown j \because i \sim j$ -- \emph{Concatenation} of $i = [s
        \prec t)$ and $j = [t \prec u)$ is $[s \prec u)$



\emph{Interval Types}

\emph{Monotone Interval Type}

$MSet$

Non-monotone Semantics

Monotone Semantics



\subsubsection{Signal}\label{sec:signal}

\emph{Signal} (or \emph{Behavior})

$a$-valued Behavior: $Time \rightarrow a$

\cite{jeffrey12}:

gives rise to an Event Stream (\S\ref{sec:frp_event})

\begin{flalign*}
  \quad & Signal : Set \rightarrow Set & \\
  \quad & Signal(A) = Time \rightarrow A
\end{flalign*}

$Time$ forms a Decidable Total Order:
\begin{flalign*}
  \quad & Time : Set & \\
  \quad & \leq : Time \rightarrow Time \rightarrow Set \\
  \quad & + : Time \rightarrow \nats \rightarrow Time \\
  \quad & - : Time \rightarrow Time \rightarrow \nats
\end{flalign*}

assuming a Discrete Time Model: Termination Property of $fix$

Dense Time FRP: $\epsilon$-decoupled Functions for some $0 <
\epsilon$; \emph{Zeno Processes} perform Output which is successively
smaller; \emph{Zeno Event Signals}

Isomorphism with Reactive Type (\S\ref{sec:reactive_type})
Constructors:
\[
  Signal(A) \cong \llbracket \langle A \rangle \rrbracket
\]

$\llbracket \langle \rangle \rrbracket : Set \rightarrow Set$ is a
Monad (\S\ref{sec:monad}) as an Instance of the Read-only State Monad
where State is the current Time

Signals of Signals give rise to Signals

Continuous Behaviors

Discrete Behaviors: \emph{Events} (\S\ref{sec:frp_event})



\paragraph{Signal Function}\label{sec:signal_function}
\hfill \\

or \emph{Reactive Function}

\cite{jeffrey12}:

Functions from Signals to Signals

Functions required to be Causal Functions $A \unrhd B$:
\begin{flalign*}
  \quad & SF : Set \rightarrow Set \rightarrow Set & \\
  \quad & SF(A,B) = (f : Signal(A) \rightarrow
    Signal(B)) \times (Causal (f))
\end{flalign*}

Causal Functions respect Equivalence up to the current Time

$SF(A,B)$ encoded in LTL over the past:
\[
  SF(A,B) \cong \llbracket \boxminus\langle A \rangle
    \Rightarrow \langle B \rangle \rrbracket
\]
gives a Semantics for Signal Functions in $\boxminus\cat{RSet}$ and
$\boxminus\cat{RSet}$ is compatible with Hughes Arrows
(\S\ref{sec:hughes_arrow}) as any Category with Finite Products is
trivially a Freyd Category (\S\ref{sec:freyd_category})

$SF$ modified with $era$ Parameter (Jeltsch 09):
\begin{flalign*}
  \quad & SF' : Set \rightarrow Set \rightarrow Time
    \rightarrow Set & \\
  \quad & SF' (A,B,s) = (f : Signal(A) \rightarrow
    Signal(B)) \times (Causal_s(f))
\end{flalign*}
$SF'(A,B,s)$ encoded in LTL:
\[
  SF'(A,B) \cong \langle A \rangle \unrhd \langle B \rangle
\]
has a Semantics in $\unrhd\cat{RSet}$ which also satisfies the
requirements of Arrows.

Decoupled Functions are a Subset of Signal Functions:
\begin{flalign*}
  \quad & SF'' : Set \rightarrow Set \rightarrow Time
    \rightarrow Set & \\
  \quad & SF'' (A,B,s) = (f : Signal(A) \rightarrow
    Signal(B)) \times (Decoupled_s(f))
\end{flalign*}
$SF'(A,B,s)$ encoded in LTL:
\[
  SF''(A,B) \cong \langle A \rangle \rhd \langle A \rangle
\]

\fist Note that $\rhd\cat{RSet}$ is not a Category as it has
Composition but not Identities (Identity Function is only Decoupled on
Singleton Types), cf. Contraction Maps in a Complete Metric Space:
Identities are Non-expanding but not Contracting
%FIXME xref


\textbf{Combinators}

Signal Functions $f,g$:

$f \ggg g$, $f \&\&\& g$, and $loop f$ allow Dataflow Networks to be
built which can be visualized in any Traced Monoidal Category
(\S\ref{sec:traced_monoidal})



\subsubsection{Event}\label{sec:frp_event}

\cite{jeffrey12}:

Discrete Behaviors

Signal gives rise to an \emph{Event Stream}


Semantics given by Signals of Type $E A$ where:
\begin{flalign*}
  \quad & E : RSet \rightarrow RSet & \\
  \quad & E(A)(t) = Maybe(A(t))
\end{flalign*}
A Signal of Type $E A$ at Time $t$ is either $Nothing$ (no Event has
arrived) or $Just(a)$ (an Event of $a$ of Type $A(t)$ has arrived).

Example:
\[
  mouseClick : \llbracket E \langle MouseEvent \rangle \rrbracket
\]


\textbf{Event Primitives}

$never : \forall\{A,B\} \llbracket A \rhd E B \rrbracket$

$now : \forall\{A,B\} \llbracket B \Rightarrow A \rhd E B \rrbracket$

$later : \forall\{A,B\} \llbracket \lozenge B
  \Rightarrow A \rhd E B \rrbracket$

$tag : \forall\{A,B\} \llbracket \square B \Rightarrow
  E A \unrhd E B \rrbracket$

$edge : \llbracket [Bool] \unrhd E T \rrbracket$ -- converts Signals
  into Events

$hold : \forall\{A\} \llbracket A \Rightarrow E A
  \rhd \minlozenge A \rrbracket$ -- converts Events into Signals


\textbf{Switching}

starting and stopping Signal Functions based on Events

Switching Combinators:

$switch : \forall\{A,B,C\} \llbracket (A \unrhd (B \wedge E C))
  \Rightarrow \square(C \Rightarrow (A \unrhd B))
  \Rightarrow (A \unrhd B) \rrbracket$ -- only React to the first
  Switching Event

$rswitch : \forall\{A,B\} \llbracket (A \unrhd B)
  \Rightarrow (A \wedge E(A \unrhd B)) \unrhd B \rrbracket$ -- React
  on every Switching Event

Example Function which Returns True after an Event has occurred:
\[
  switch(constant[False] \&\&\& id)[\lambda x.constant[True]]
\]



% ====================================================================
\section{Homotopy Type Theory}\label{sec:homotopy_type_theory}
% ====================================================================

Homotopy Theory (\S\ref{sec:homotopy})

- Function Extensionality
- Univalence Axiom (\S\ref{sec:univalence_axiom})

- Values (Points), Paths, Homotopies

- Internal Language of Higher Categories
(\S\ref{sec:higher_category}).

Homotopy Types Model $\infty$-groupoids
(\S\ref{sec:infinity_groupoid})

Categorical Semantics (\S\ref{sec:categorical_semantics})



% --------------------------------------------------------------------
\subsection{Higher Inductive Type}\label{sec:higher_inductive_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Inference Rules}\label{sec:homotopy_rules}
% --------------------------------------------------------------------

Inference Rules (\S\ref{sec:type_inference}) have the form:
\[
  \frac{J_1 \quad \cdots \quad J_k} {J} Name
\]
where $J_i$ are provided as derived hypothetical (metatheoretical)
Judgements and $J$ is the conclusion.

A Tree constructed from Inference Rules forms a Derivation
(\S\ref{sec:typing_derivation}) of a Judgement.



\textbf{Context Rules}

The following Rules of Inference allow for the determination of a
Well-formed Context:
\begin{enumerate}
\item
\[
  {
    \frac{}{(.)ctx}
  } ctx-EMP
\]
\item
\[
  {
    \frac
    {x_1:A_1, \ldots, x_{n-1}:A_{n-1} \vdash A_n : \class{U}_i}
    {(x_1:A_1,\ldots,x_n:A_n) ctx}
  } ctx-EXT
\]
\end{enumerate}



\textbf{Structural Rules}

Given a Context, derive Typing Judgements
(\S\ref{sec:typing_judgement}) listed in the Context:
\[
  {
    \frac
    {(x_1:A_1, \ldots, x_n:A_n)ctx}
    {x_1:A_1, \ldots, x_n:A_n \vdash x_i:A_i}
  } Vble
\]

Substitution for Typing Judgements:
\[
  {
    \frac
    {\Gamma \vdash a : A \;\;\;\;\;\;\;
    \Gamma,x:A,\Delta \vdash b : B}
    {\Gamma,[a/x]\Delta \vdash [a/x]b : [a/x]B}
  } Subst_1
\]

Weakening for Typing Judgements:
\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i \;\;\;\;\;\;\;
    \Gamma,\Delta \vdash b : B}
    {\Gamma,x:A,\Delta \vdash b:B}
  } Wkg_1
\]

Substitution for Judgemental Equality:
\[
  {
    \frac
    {\Gamma \vdash a : A \;\;\;\;\;\;\;
    \Gamma,x:A,\Delta \vdash b \equiv c : B}
    {\Gamma,[a/x]\Delta \vdash [a/x]b \equiv [a/x]c : [a/x]B}
  } Subst_2
\]

Weakening for Judgemental Equality:
\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i \;\;\;\;\;\;\;
    \Gamma,\Delta \vdash b \equiv c : B}
    {\Gamma, x:A, \Delta \vdash b \equiv c : B}
  } Wkg_2
\]



\textbf{Universe Rules}

\[
  {
    \frac
    {(\Gamma) ctx}
    {\Gamma \vdash \class{U}_i : \class{U}_{i+1}}
  } \class{U}-INTRO
\]

\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i}
    {\Gamma \vdash A : \class{U}_{i+1}}
  } \class{U}-CUMUL
\]



\textbf{Dependent Function Type Rules}

\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i \;\;\;\;\;\;\;
    \Gamma,x:A \vdash B : \class{U}_i}
    {\Gamma \vdash \prod_{(x:A)} B : \class{U}_i}
  } \Pi-FORM
\]\[
  {
    \frac
    {}
    {}
  } \Pi-INTRO
\]\[
  {
    \frac
    {}
    {}
  } \Pi-ELIM
\]\[
  {
    \frac
    {}
    {}
  } \Pi-COMP
\]\[
  {
    \frac
    {}
    {}
  } \Pi-UNIQ
\]



% --------------------------------------------------------------------
\subsection{Univalence Axiom}\label{sec:univalence_axiom}
% --------------------------------------------------------------------

``Identity is Equivalent to Equivalence''

``Equivalent Types are Identical''
\[
  (A = B) \simeq (A \simeq B)
\]
where $A = B$ is notation for the Type $Id_U(A,B)$ where $U$ is the
Universe containing $A$ and $B$.



% --------------------------------------------------------------------
\subsection{Opetopic Type Theory}\label{sec:opetopic_typetheory}
% --------------------------------------------------------------------

Internal Language of $\infty$-categories
(\S\ref{sec:infinity_category})



% ====================================================================
\section{Metaprogramming}\label{sec:metaprogramming}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Reflection}\label{sec:type_reflection}
% --------------------------------------------------------------------

Type Introspection (???) + Manipulation

Monadic Reflection (\S\ref{sec:monadic_reflection})
