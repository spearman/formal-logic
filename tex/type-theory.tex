%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Type Theory}\label{sec:type_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Type Theory} is the study of Classes of Formal Systems
(\S\ref{sec:formal_system}) where each Term (\S\ref{sec:term}) has a
\emph{Type} (\S\ref{sec:type}) and Operations are restricted to Terms
of specific Types.

A Type Theory may have two Signatures: $\sigma_\tau$ for Type Symbols
and $\sigma_o$ for Object (Term) Symbols. From this one may construct
a Monad $R = R_{\sigma_o}$, a Module over $R$: $LM =
LM_{\sigma_\tau,\sigma_o}$, and a Contextual Category
(\S\ref{sec:contextual_category}) $CC(R,LM)$ describing a Class of
Sub-quotients of $CC(R,LM)$ in terms of Objects Constructed from $R$
and $LM$. \cite{voevedsky14}

As a Formal Theory (\S\ref{sec:formal_theory}), Judgements
(\S\ref{sec:judgement}) in Type Theory are of three
kinds\cite{hott13}:
\begin{enumerate}

\item \emph{Well-formed Context} (\S\ref{sec:type_context}):
  \[
    (\Gamma) ctx
  \]
  ``$\Gamma$ is a Well-formed Context''

\item \emph{Propositional Equality} (Typing Judgement
    \S\ref{sec:typing_judgement}):
  \[
    \Gamma \vdash a : A
  \]
  ``Given Contex $\Gamma$, $a$ is a Term of Type $A$''

\item \emph{Definitional (Judgemental) Equality}:
  \[
    \Gamma \vdash a \equiv b : A
  \]
  ``Given Context $\Gamma$, $a$ and $b$ are Definitionally Equal Terms
  of Type $A$''

\end{enumerate}
with a Deductive Apparatus (\S\ref{sec:deductive_apparatus})
consisting of Inference Rules (\S\ref{sec:type_inference}) only and no
Axioms. Judgemental Equality is an Equivalence Relation respected by
Typing.



\textbf{Intensional \& Extensional Type Theory}

\begin{itemize}
\item \emph{Extensional Type Theory} (\S\ref{sec:extensional_type}):
  Definitional (Computational) Equality is not distinguished from
  Propositional (Proof) Equality (Strict Equivalence) but Type Checking
  (\S\ref{sec:type_checking}) is Undecidable; see also
  \emph{Observational Type Theory} (\S\ref{sec:observational_type})
\item \emph{Intensional Type Theory}: Type Checking is Decidable but
  Extensional Reasoning must be carried out using Setoids
  (\S\ref{sec:setoid}); (Weak Equivalence)
\item \emph{Homotopy Type Theory} (\S\ref{sec:homotopy_type}): Higher
  Inductive Types (\S\ref{sec:higher_inductive_type}) allow definition
  of Higher-order Constructors
\end{itemize}

Term Rewrite System (\S\ref{sec:term_rewriting})

\emph{Conversion Rules}

\emph{Canonical Form}

\emph{Normal Form}



% ====================================================================
\section{Expression}\label{sec:type_expression}
% ====================================================================

An \emph{Expression} is an Equivalence Class of Syntactic forms which
differ in the names of \emph{Bound Variables}. That is, changing the
name of a Bound Variable everywhere within an Expression
(\emph{$\alpha$-conversion}) does not change the Expression.

A Variable is Bound in an Expression by an \emph{Abstraction}
expressing that the Variable is \emph{local} to the Expression:
\[
  \lambda x.B
\]
or
\[
  x.B
\]

\emph{Substitution}:
\[
  [a/x]B
\]
Substitute Term $a$ for Free occurrences of Variable $x$ in the Term
$B$. Generalized:
\[
  [a_1,\ldots,a_n / x_1,\ldots,x_n]B
\]



% --------------------------------------------------------------------
\subsection{Term Constant}\label{sec:term_constant}
% --------------------------------------------------------------------

A \emph{Term Constant} is a Term that is a Base Type
(\S\ref{sec:type_constant})
% FIXME ???



% --------------------------------------------------------------------
\subsection{Well-typed Term}\label{sec:well_typed}
% --------------------------------------------------------------------

A \emph{Well-typed Term} (or \emph{Typable Term}) is a Term for which
a Typing Derivation (\S\ref{sec:typing_derivation}) exists.



% ====================================================================
\section{Context}\label{sec:type_context}
% ====================================================================

A \emph{Context}, $\Gamma$, is a list of Assumptions of the form:
\[
  \Gamma = x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n
\]
where each Element $x_i : A_i$ is an Assumption that the distinct
Variable $x_i$ has type $A_i$.

Judgements are formulated under the Assumptions of a particular
Context, $\Gamma$:
\[
  \Gamma \vdash a : A
\]
For an empty Context:
\[
  \vdash a : A
\]
or
\[
  . \vdash a : A
\]



% ====================================================================
\section{Type}\label{sec:type}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Type Constant}\label{sec:type_constant}
% --------------------------------------------------------------------

\emph{Type Constant} (or \emph{Base Type} or \emph{Atomic Type})



% --------------------------------------------------------------------
\subsection{Type Order}\label{sec:type_order}
% --------------------------------------------------------------------

\emph{Order}

In Simply-typed $\lambda$-calculus ($\lambda^\rightarrow$), the Order
of a Type $\tau$, denoted $o(\tau)$, is defined Inductively as:
\begin{itemize}
\item $o(T) = 0$ if $T$ is a Base Type
\item $o(\sigma \rightarrow \tau) = \text{max}(o(\sigma) + 1,
  o(\tau))$
\end{itemize}



% --------------------------------------------------------------------
\subsection{Inhabited Type}\label{sec:inhabited_type}
% --------------------------------------------------------------------

\emph{Inhabited}

In Simply-typed $\lambda$-calculus (\S\ref{sec:simply_typed}), a Type
is Inhabited if and only if its corresponding Proposition is a
Tautology of Minimal Implicative Logic (\S\ref{sec:minimal_logic}).

In Second-order $\lambda$-calculus (\S\ref{sec:system_f}), a
Type is Inhabited if and only if its corresponding Proposition is a
Tautology of Second-order Logic (\S\ref{sec:secondorder_logic}).



% --------------------------------------------------------------------
\subsection{Finite Type}\label{sec:finite_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Infinite Type}\label{sec:infinite_type}
% --------------------------------------------------------------------

Infinite Data Type (\S\ref{sec:infinite_datatype})



% --------------------------------------------------------------------
\subsection{Equality Type}\label{sec:equality_type}
% --------------------------------------------------------------------

The \emph{Equality Type} (or \emph{Identity Type}), denoted
\emph{Propositional Equality}, represents Equality of Types and Terms.

$a =_A b$: ``$a$ and $b$ are Equal Objects of Type $A$''

Martin-L\"of Notation $I(A,a,b)$

For $a,b:A$, the Term $a = b : I(A,a,b)$ Denotes the Type of Equality
Proofs for ``$a$ is Equal to $b$''. If the Type $I(A,a,b)$ is
Inhabited (a Proof exists), then $a$ is Equal to $b$.

There is one Canonical Inhabitant of $I(A,a,a)$ (Proof of
Reflexivity):
\[
  \text{refl}: \prod_{a:A} (a=a)
\]



% --------------------------------------------------------------------
\subsection{Power Type}\label{sec:power_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Data Type}\label{sec:data_type}
% --------------------------------------------------------------------

\subsubsection{Recursive Data Type}\label{sec:recursive_datatype}

or (\emph{Inductive Data Type})

Values may contain Values of the same Type

Well-founded (\S\ref{sec:well_founded})



\paragraph{Isorecursive Data Type}\label{sec:isorecursive_datatype}

\paragraph{Equirecursive Data Type}\label{sec:equirecursive_datatype}



\paragraph{Infinite Data Type}\label{sec:infinite_datatype}
\hfill \\

(Proof Object) Definition by Recursion: Proof by Induction



\subsubsection{Composite Data Type}\label{sec:composite_datatype}

\paragraph{Algebraic Data Type}\label{sec:algebraic_datatype}
\hfill \\

Trees (\S\ref{sec:tree})

$W$ Type

Algebraic Data Types form a Semiring (\S\ref{sec:semiring})



\subparagraph{Sum Type}\label{sec:sum_type}
\hfill \\

\emph{Variant Type}

Corresponds to Disjoint Sum

Choices, Multiple ``Classes'' of Data



\subparagraph{Product Type}\label{sec:product_type}
\hfill \\

(Cartesian) Product Types: Structs, Tuples

If $\sigma$ and $\tau$ are Types, then $\sigma \times \tau$ is a Type

$x : \sigma$, $y : \tau$, $(x,y) : \sigma \times \tau$

$fst_{\sigma,\tau} : (\sigma \times \tau) \Rightarrow \sigma$

$snd_{\sigma,\tau} : (\sigma \times \tau) \Rightarrow \tau$

Corresponds to Cartesian Product



\subparagraph{Coproduct Type}\label{sec:coproduct_type}
\hfill \\



\subparagraph{Quotient Type}\label{sec:quotient_type}
\hfill \\

Set Theoretic Quotients



\subsubsection{Abstract Data Type}\label{sec:abstract_datatype}

Type defined by certain Properties %FIXME



\subsubsection{Logically Qualified Data Type}
\label{sec:logically_qualified}\cite{rondon-kawaguchi-jhala08}

\emph{Liquid Type}

Predicate Abstraction (\S\ref{sec:predicate_abstraction})

Logical Qualifier: Boolean Predicate

Dependent Type where the Refinement Predicate
(\S\ref{sec:refinement_type}) is a Conjunction of Logical Qualifiers.

Value Variable

Base Refinement:
\[
  \{ v : B | e \}
\]
where $e$ is a Boolean-valued Expression constraining $v$ called a
\emph{Refinement Predicate}.



% --------------------------------------------------------------------
\subsection{Data Constructor}\label{sec:data_constructor}
% --------------------------------------------------------------------

A \emph{Constructor} Introduces a Data Type on the right-hand side of
a definition.

A \emph{Destructor} Eliminates a Data Type on the left-hand side of a
definition.

Elimination for (Finite) Data corresponds to (Well-founded)
Recursion.

Introduction for Codata corresponds to Corecursion.



% --------------------------------------------------------------------
\subsection{Congruence Type}\label{sec:congruence_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Universe Type}\label{sec:universe_type}
% --------------------------------------------------------------------

A \emph{Universe Type} contains all other Types, see Type Universe
(\S\ref{sec:type_universe}).



% --------------------------------------------------------------------
\subsection{Inductive Type}\label{sec:inductive_type}
% --------------------------------------------------------------------

Monotonic Type Function $\Theta : \sigma \Rightarrow \tau$

Initial Algebras (\S\ref{sec:initial_algebra})

Type Constructor (\S\ref{sec:type_constructor})

Structural Recursion (\S\ref{sec:structural_recursion})

\emph{Induction Induction}

\emph{Induction Recursion}

Streams between interacting processes in Programming Languages



\subsubsection{Coinductive Type}\label{sec:coinductive_type}

\emph{Coinductive Type} (\emph{Codata}), Coinduction
(\S\ref{sec:coinduction})



\subsubsection{Initial \& Final Type}\label{sec:initial_final_type}

\emph{Initial Data Types} are defined by the Least Fixpoint
(\S\ref{sec:leastgreatest_fixpoint}), up to Isomorphism given by an
Initial Algebra (\S\ref{sec:initial_algebra}), of a Type Function
(\S\ref{sec:type_function}). Ordinary Recursion
(\S\ref{sec:recursion}) defines Recursive Functions with an Initial
Data Type for a Domain.

\emph{Final Data Types} are defined, up to Isomorphism given by a
Final Coalgebra (\S\ref{sec:final_coalgebra}) by the Greatest
Fixpoint. Corecursion (\S\ref{sec:corecursion}) defines Recursive
Functions with a Final Data Type as a Codomain.

Initial (\S\ref{sec:initial_object}) \& Terminal
(\S\ref{sec:terminal_object}) Objects

In $\mathbf{Set}$, the Final Data Types may have Infinite,
Non-well-founded (\S\ref{sec:non_wellfounded}) Values.

In $\mathbf{Cpo}$ (the Category of Complete Partial Orders
\S\ref{sec:complete_partialorder} and Continuous Functions), Final
Types coincide with Initial Types and the corresponding Initial
Algebra and Final Coalgebras are Isomorphic.



% --------------------------------------------------------------------
\subsection{Existential Type}\label{sec:existential_type}
% --------------------------------------------------------------------

Existentially Quantified Type Variable

Programming: Module Interfaces

Second-order Typed $\lambda$-calculus with Existential Quantification
(whereas System $F$ is Second-order Typed $\lambda$-calculus with
Universal Quantification.



% --------------------------------------------------------------------
\subsection{Polymorphic Type}\label{sec:polymorphic_type}
% --------------------------------------------------------------------

$\tau \mapsto \sigma$

Introduction:
\[
  {
  \frac{
    \begin{matrix}
      x : \sigma \\
      \vdots \\
      b : B
    \end{matrix}
  }
  {b : \sigma \mapsto \tau}
  }(\mapsto I)
\]

Terms depending on Types, e.g.:
\[
  x:\tau \vdash id(x):\tau
\]
where the Type of the Term $id(x)$ is $\tau$, which is dependent on
the Type $\tau$ of $x$, where the Type of $id$:
\[
  id:\sigma \rightarrow \sigma
\]
is Universally Quantified ``$\forall \sigma$''
(\S\ref{sec:parametric_polymorphism}).

Dependent Product Type (\S\ref{sec:dependent_product})

Second-order $\lambda$-calculus (\S\ref{sec:system_f})

Subtyping (\S\ref{sec:subtype})

Variance

Ad-hoc Polymorphism (\S\ref{sec:adhoc_polymorphism})

Restricted Rank

Rank-1 \emph{Prenex Polymorphism}: Type Variables may not be
instantiated with Polymorphic Types.

Rank-$k$: Quantifier may not appear to the left of $k$ or more Arrows;
Type Inference is decidable for Rank-2 but Rank-3 and above is not

Rank-$n$: Quantifier may appear to the left of arbitrarily many Arrows

Predicative: a Type $\tau$ containing a Type Variable $\alpha$ may not
have $\alpha$ Instantiated to a Polymorphic Type (Martin-L\"of Type
Theory \S\ref{sec:intuitionistic_type} and NuPRL).

Impredicative \emph{First-class Polymorphism}: Self-referential
(System F \S\ref{sec:system_f})

Parametric (\S\ref{sec:parametric_polymorphism}): Universal
Quantification

Existential (\S\ref{sec:existential_type}): Existential Quantification

The Type $(\exists x : A).B$ is inhabited by Pairs $(a,b)$ with $a:A$
and $b:B[a/x]$, i.e. the Sum of the Types $B(x)$ as $x$ ranges over
$A$ \emph{or} the Subset of $A$ consisting of those $a \in A$ with the
Property $B[a/x]$.

Bounded Quantification (\S\ref{sec:bounded_polymorphism})



\subsubsection{Subtype}\label{sec:subtype}

\emph{Intersection Type}

\emph{Subtype Polymorphism}

System $F_{<:}$ (\S\ref{sec:system_fsub})

Bounded Polymorphism (\S\ref{sec:bounded_polymorphism})

Subtyping Judgement:
\[
  \Gamma \vdash \tau_1 \preceq \tau_2
\]



\paragraph{Variance}\label{sec:variance}
\hfill \\

\emph{Variance} describes how Type Constructors either preserve,
reverse, or ignore Subtyping on input Types.

\begin{itemize}
  \item \emph{Covariant}: Preserves Subtyping
  \item \emph{Contravariant}: Reverses Subtyping
  \item \emph{Bivariant}: Both Subtypes
  \item \emph{Invariant}: No Subtyping
\end{itemize}

$(\rightarrow)$ is Contravariant on the Input Type and Covariant on
the Output Type.



\paragraph{Refinement Type}\label{sec:refinement_type}
\hfill \\

Predicate assumed to hold for any Element of Refined Type

cf. Behavioral Subtyping (\S\ref{sec:behavioral_subtype})


\subparagraph{Predicate Subtype}\label{sec:predicate_subtype}



\paragraph{Behavioral Subtype}\label{sec:behavioral_subtype}
\hfill \\

\emph{Substitutability}



\subsubsection{Parametric Polymorphism}
\label{sec:parametric_polymorphism}

\emph{Generic Function}, \emph{Generic Datatype}

Natural Transformation (\S\ref{sec:natural_transformation})

Universally Quantified Type Variable

Type-level Function Abstraction $\Lambda$

Second-order $\lambda$-calculus (\S\ref{sec:system_f})

Bounded (\S\ref{sec:bounded_polymorphism}) Parametric Polymorphism



\subsubsection{Ad-hoc Polymorphism}\label{sec:adhoc_polymorphism}

\emph{Function Overloading}, \emph{Operator Overloading}

Polymorphic Functions applied to Terms of different Types

Ad-hoc Polymorphism is contrasted with Parametric Polymorphism by
supporting a limited number of distinct Types rather than any Type
whatsoever.



\paragraph{Constrained Type}\label{sec:constrained_type}
\hfill \\

\emph{Type Class}, Ad-hoc Polymorphism (Function Overloading)



\subsubsection{Bounded Polymorphism}\label{sec:bounded_polymorphism}

\emph{Bounded Quantification} (or \emph{Bounded Polymorphism} or
\emph{Constrained Genericity})

Bounds on Type Parameters to range only over Subtypes
(\S\ref{sec:subtype}) of a particular Type

Type Class (\S\ref{sec:constrained_type})



\subsubsection{Higher-rank Impredicative Polymorphism}
\label{sec:higherrank_impredicative}

\emph{Higher-rank Impredicative Polymorphism} (most general)



\subsubsection{Predicative Prenex Polymorphism}
\label{sec:predicative_prened}

\emph{Predicative Prenex Polymorphism} (Restricted Rank and
Predicative)

``\emph{Let-polymorphism}''



\subsubsection{Polymorphic Function}\label{sec:polymorphic_function}

A Polymorphic Function has a Dependent Product Type
(\S\ref{sec:dependent_product}):
\[
  \Pi_{(A:\mathcal{U})} A \rightarrow C
\]



\paragraph{Polymorphic Recursion}\label{sec:polymorphic_recursion}
\hfill \\

Recursive Parametrically Polymorphic Function

Type Inference under Polymorphic Recursion is Undecidable (equivalent
to Semi-unification) %FIXME



% --------------------------------------------------------------------
\subsection{Type Function}\label{sec:type_function}
% --------------------------------------------------------------------

Adding additional Type Operators to Simply-typed Lambda Calculus
results in \emph{Simply-typed Lambda Calculus with Type Operators}
``$\lambda \underline{\omega}$'' (\S\ref{sec:simply_operators})

System F$_{\omega}$ (\S\ref{sec:system_fomega})

The Type Operators themselves can be viewed as a Simply-typed
$\lambda$-calculus with only one Base Type (\S\ref{sec:type_constant})
denoted `$\ast$' representing the Type of all Types in the underlying
Language which are called \emph{Proper Types} to distinguish from the
Type of the Type Operators which are called \emph{Kinds}
(\S\ref{sec:kind}).

A Type Function is an Endofunctor on the Category of Types.



\subsubsection{Type Variable}\label{sec:type_variable}

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism}):
Universally Quantified Type Variables

Existential Types (\S\ref{sec:existential_type}):
Existentially Quantified Type Variables



\subsubsection{Kind}\label{sec:kind}

A \emph{Kind} is the Type of a Type Operator, or the Type of a
Higher-order Type Operator \S\ref{sec:higherorder_typeoperator}).



\subsubsection{Higher-order Type Operator}
\label{sec:higherorder_typeoperator}

Allowing for the Type Operators to form a Simply-typed
$\lambda$-calculus with the single Base Type `$*$' allows for
Higher-order Type Operators.



\subsubsection{Function Type}\label{sec:function_type}

A \emph{Function Type} (or \emph{Arrow Type}) is Type formed by the
Higher-kinded Type Constructor $\rightarrow$, a special case of the
Dependent Product Type (\S\ref{sec:dependent_product}).



\paragraph{Exponential Type}\label{sec:exponential_type}
\hfill \\

Higher-order Functions



\subsubsection{Type Constructor}\label{sec:type_constructor}

Injective Type Function: maps all Types of a particular Kind to a new
Set of Types and Type Synonyms

\emph{Type Constructor}



\subsubsection{Type Family}\label{sec:type_family}

A \emph{Type Family} is a Partial Type Function that allows Types to
be defined by matching Terms. The Functionality of this Type Function

Generalization of Predicates (Relations) over Domains



\paragraph{Associated Type}\label{sec:associated_type}
\hfill \\

A Type Family declared inside a Type Class is an \emph{Associated
  Type}



% --------------------------------------------------------------------
\subsection{Dependent Type}\label{sec:dependent_type}
% --------------------------------------------------------------------

A \emph{Dependent Type} depends on a Term or another Type.

A Dependent Product Type (\S\ref{sec:dependent_product}) is defined by
a Dependent Function (\S\ref{sec:dependent_function}).

Logical Quantifiers (\S\ref{sec:quantifier})

Intuitionistic Type Theory (\S\ref{sec:intuitionistic_type})

Categorically, Dependent Types correspond to Morphisms regarded as
Indexed Families (Bundle or Fibration). % FIXME

A Dependent Type is the Type of a Dependent Function
(\S\ref{sec:dependent_function}).

Dependent Pairs

\textbf{First-order Dependent Type Theory} ($\lambda \Pi$):
\emph{Logical Framework} (\S\ref{sec:logical_framework}), adding the
Dependent Product Type (\S\ref{sec:dependent_product}) to Simply-typed
$\lambda$-calculus.

\textbf{Second-order Dependent Type Theory} ($\lambda \Pi 2$):
allowing Quantification over Type Constructors
(\S\ref{sec:type_constructor}), $\Pi$ operator Subsumes both
$\rightarrow$ of Simply-typed $\lambda$-calculus and $\forall$ of
System F (\S\ref{sec:system_f})

\textbf{Higher-order Dependently Typed Polymorphic $\lambda$-calculus}
($\lambda \Pi \omega$): corresponds to \emph{Calculus of
  Constructions} (\S\ref{sec:coq}); extends $\lambda \Pi 2$ to all
abstractions of the $\lambda$-cube (\S\ref{sec:lambda_cube})



\subsubsection{Dependent Function}\label{sec:dependent_function}

A \emph{Dependent Function} is a Function from Terms to Types.

Dependent Function Space: if $f:(\forall x: A).B$ then $f a : B[a/x]$

Functionality (respect for Definitional Equality
\S\ref{sec:proof_equality}):
\[
  x : A \vdash B_x \;\text{type}
\]\[
  m : A \mapsto B[m/x] \;\text{type}
\]\[
  m \equiv n : A \mapsto B[m/x] \equiv B[n/x] \;\text{type}
\]

Doubly-indexed Type:
\[
  x : A, y : B_x \vdash C_{x,y} \;\text{type}
\]

Example: Family of Types Indexed by $\mathbb{N}$:
\[
  x : \mathbb{N} \vdash even(x) \;\text{type}
\]
is a Propositional Function (takes a Natural Number and yields a
Proposition). For each Natural Number, either $even(x)$ is Inhabited
(if $x$ is Even) or Uninhabited (if $x$ is Odd).\cite{harper12}



\subsubsection{Dependent Product Type}\label{sec:dependent_product}

The \emph{Dependent Product Type} (or \emph{$\Pi$-type}) generalizes
the idea of a Polymorphic Function.

For a Type $A : \mathcal{U}$ in Type Universe $\mathcal{U}$, a Family
of Types
\[
  B : A \rightarrow \mathcal{U}
\]
can be defined by a Dependent Function which assigns a Type $B(a) :
\mathcal{U}$ to Each Term $a : A$. The Type of this Function is a
Dependent Product Type (\S\ref{sec:dependent_product}):
\[
  \Pi_{(a:A)}B(a)
\]
If $B$ is Constant, then $\Pi_(a:A)B$ is Judgementally Equal to the
Function Type $A \rightarrow B$:
\[
  \Pi_{(a:A)}B \equiv A \rightarrow B
\]

By Curry-Howard, $\Pi$-types model Implication and Universal
Quantification.

Polymorphic Function (\S\ref{sec:polymorphic_function})



\subsubsection{Dependent Sum Type}\label{sec:dependent_sum}

\emph{Dependent Sum Type} (or \emph{$\Sigma$-type} or \emph{Dependent
  Pair Type}

\[
  \Sigma_{(x:A)} B(x)
\]
If $B$ is Constant, then $\Sigma_{(x:A)}B$ is Judgementally Equal to
the Product Type (\S\ref{sec:product_type}) $A \times B$:
\[
  \Sigma_{(x:A)} B \equiv A \times B
\]

By Curry-Howard, $\Sigma$-types model Conjunction and Existential
Quantification.

Analagous to Coproduct or Disjoint Union.



% --------------------------------------------------------------------
\subsection{Partial Type}\label{sec:partial_type}
\cite{thompson99}
% --------------------------------------------------------------------

Non-terminating Computations

Total Objects are Identified at Simple Types

Undefined Object ``Bottom'' $\uparrow$ is a Member of every Type

\[
  \sigma \rightarrow \tau \quad
  \sigma \rightarrow \overline{\tau} \quad
  \overline{\sigma} \rightarrow \overline{\tau} \quad
  \overline{\sigma \rightarrow \tau} \quad
  \overline{\sigma \rightarrow \overline{\tau}} \quad
  \overline{\overline{\sigma} \rightarrow \overline{\tau}} \quad
\]



% --------------------------------------------------------------------
\subsection{Type Conversion}\label{sec:type_conversion}
% --------------------------------------------------------------------

\subsubsection{Type Promotion}\label{sec:type_promotion}

Special case of Implicit Type Conversion



% ====================================================================
\section{Type Universe}\label{sec:type_universe}
% ====================================================================

A \emph{Type Universe} is a Type whose Elements are Types.

Small Type %FIXME

Type Theory analogue of Inaccessible Cardinal
(\S\ref{sec:inaccessible_cardinal})

$\mathcal{U}_0$ is the Universe of all Small Types. Every Name
(\S\ref{sec:name}) $a:\mathcal{U}_0$ has an associated Type $El(a)$
giving its Extension or Meaning ($El$ is a Dependent Type
\S\ref{sec:dependent_type} that maps each Object to its corresponding
Type).

A Predicative \emph{Cumulative Hierarchy}:
\[
  \mathcal{U}_0, \mathcal{U}_1, \mathcal{U}_2, \ldots
\]
is such that any Type in $\mathcal{U}_n$ is also in
$\mathcal{U}_{n+1}$:
\[
  u_n:\mathcal{U}_n+1
\]
with (Cumulative Property):
\[
  El(u_n) \equiv \mathcal{U}_n
\]

See $\mathcal{U}-INTRO$ and $\mathcal{U}-CUMUL$
\S\ref{sec:homotopy_rules}.



% --------------------------------------------------------------------
\subsection{Girard's Paradox}\label{sec:girards_paradox}
% --------------------------------------------------------------------



% ====================================================================
\section{Typing Environment}\label{sec:typing_environment}
% ====================================================================

A \emph{Typing Environment} (or \emph{Context} or \emph{Variable
  Assignment}) $\Gamma$ is a Set of Typing Assumptions.

Closed Terms are those Terms that are Typable
(\S\ref{sec:typing_derivation}) in an Empty Context, e.g. the I, S,
and K Combinators (\S\ref{sec:combinator}).



% --------------------------------------------------------------------
\subsection{Typing Assumption}\label{sec:typing_assumption}
% --------------------------------------------------------------------

\emph{Typing Assumption})

\[
  e : \tau
\]
``Term $e$ has Type $\tau$''



% --------------------------------------------------------------------
\subsection{Type Annotation}\label{sec:type_annotation}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Type Erasure}\label{sec:type_erasure}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Reification}\label{sec:reification}
% --------------------------------------------------------------------

* opposite of Type Erasure
* see Type Inference (\S\ref{sec:type_inference})



% ====================================================================
\section{Typing Judgement}\label{sec:typing_judgement}
% ====================================================================

A \emph{Typing Judgement} is an instance of a \emph{Typing Relation}
(\S\ref{sec:typing_relation}).

A Typing Judgement expresses Propositional Equality. % FIXME

The Validity of a Typing Judgement is given by a Typing Derivation
(\S\ref{sec:typing_derivation}).



% --------------------------------------------------------------------
\subsection{Typing Relation}\label{sec:typing_relation}
% --------------------------------------------------------------------

\emph{Typing Relation} between Terms and Types

\[
  \Gamma \vdash e : \tau
\]
``$e$ is a (Well-typed \S\ref{sec:well_typed}) Term of Type $\tau$ in
Context $\Gamma$'',

Terms that are Well-typed in the Empty Context are Closed Terms.

Under a Proof Theoretic Interpretation, $p : P$ may be read as ``$p$
is a Proof of Proposition $P$''



% --------------------------------------------------------------------
\subsection{Typing Rule}\label{sec:typing_rule}
% --------------------------------------------------------------------

A \emph{Typing Rule} (or \emph{Type Rule}) describes how a Type is
assigned to a Syntactic Construction.

Corresponding to Introduction and Elimination Rules of Proof Theory
(\S\ref{sec:structural_rule}).

Introduction and Elimination corresponds to Data Constructors
(\S\ref{sec:data_constructor}).

The notation for Type Rules is that of Sequent Notation
(\S\ref{sec:sequent}):
\[
  {
    \frac
    { \Gamma_1 \vdash e_1:\tau_1 \quad \cdots
      \quad \Gamma_n \vdash e_n:\tau_n }
    { \Gamma \vdash e:\tau }
  }
\]
where $\Gamma$ are Typing Environments and $e:\tau$ are Typing
Judgements.



% --------------------------------------------------------------------
\subsection{Typing Derivation}\label{sec:typing_derivation}
% --------------------------------------------------------------------

A \emph{Typing Derivation} shows the Validity of a Typing Judgement
and is constructed from Typing Rules (\S\ref{sec:typing_rule}).

A Term for which a Typing Derivation exists is called a
\emph{Well-typed Term} (\S\ref{sec:well_typed}).



\subsubsection{Type Witness}\label{sec:type_witness}

\emph{Witnessing Information} gives verification of a Typing
Assumption



% ====================================================================
\section{Type Inference}\label{sec:type_inference}
% ====================================================================



% ====================================================================
\section{Typed $\lambda$-Calculus}\label{sec:typed_lambda}
% ====================================================================

\emph{Typed $\lambda$-Calculus} allows for Lambda Terms to be assigned
Types (\S\ref{sec:type}).

Simply-typed $\lambda$-calculus (\S\ref{sec:simply_typed}) has only
one Type Constructor (\S\ref{sec:type_constructor}), $\rightarrow$
(see Function Type \S\ref{sec:function_type}).

Untyped $\lambda$-calculus (\S\ref{sec:untyped_lambda}) may be
considered a Typed $\lambda$-calculus with only one Type.

A Denotational Semantics can be given by a \emph{B\"ohm Tree}
(\S\ref{sec:bohm_tree}).



% --------------------------------------------------------------------
\subsection{Simply-typed $\lambda$-calculus}\label{sec:simply_typed}
% --------------------------------------------------------------------

\emph{Simply-typed $\lambda$-calculus} ($\lambda^\rightarrow$) is a
Typed Interpretation of $\lambda$-calculus with one Type Constructor
for Function Types: $\rightarrow$ (\S\ref{sec:function_type}).

Strongly Normalizing, not Turing Complete: addition of $fix_\alpha$
Operator or Recursive Types (\S\ref{sec:recursive_datatype}) gives
Turing Completeness

``Simply-typed'' is to distinguish from extensions such as:
\begin{itemize}
  \item System F (\S\ref{sec:system_f}): Polymorphic Types
  \item Logical Framework (\S\ref{sec:logical_framework}): Dependent
    Types
\end{itemize}
because Polymorphism and Dependency cannot be encoding using only
$\rightarrow$ and Type Variables. Adding Record Types
(\S\ref{sec:product_type}) to Simply-typed $\lambda$-calculus allows
for Subtyping (\S\ref{sec:subtype}), and the resulting System
(\S\ref{sec:conjunctive_lambda}) is no longer ``Simply-typed'' because
it allows for Terms to have more than one Type.

The following extensions are still considered ``Simply-typed''
systems:
\begin{itemize}
  \item System T (\S\ref{sec:system_t}): Products, Coproducts, Natural
    Numbers
  \item PCF (\S\ref{sec:pcf}): Full Recursion
\end{itemize}

Simply-typed $\lambda$-calculus has the same Equational Theory of
$\beta\eta$-equivalence (\S\ref{sec:beta_reduction},
\S\ref{sec:eta_conversion}) as Untyped $\lambda$-calculus, subject to
Type restrictions.

$\beta$-reduction:
\[
  (\lambda x:s.t)u =_\beta t[x := u]
\]
holds in Context $\Gamma$ when $\Gamma$, $x:\sigma \rightarrow t:\tau$
and $\Gamma \vdash u:\sigma$.

$\eta$-reduction:
\[
  \lambda x:\sigma .t x =_\eta t
\]
holds when $\Gamma \vdash t : \sigma \rightarrow \tau$ and $x$ is not
Free in $t$.

With the Function Type Constructor $\rightarrow$ and the Base Types
$B$, the Types of a Simply-typed $\lambda$-calculus are defined (with
BNF Notation):
\[
  \tau ::= \tau \rightarrow \tau \;|\; T \in B
\]

\emph{Term Constant}

That is, Expressions of Simply-typed $\lambda$-calculus are defined
as:
\[
  e ::= x \;|\; \lambda x:t.e \;|\; e e \;|\; c
\]
where $x$ is a Variable and $\tau$ is a Type, and $c$ is a Term
Constant. These Expressions are, in order:
\begin{itemize}
  \item Variable Reference
  \item Abstraction
  \item Application
  \item Constant
\end{itemize}



\textbf{Intrinsic Interpretation}: \emph{Church-style}

* Only Well-typed Terms have Meaning (Meaning assigned to Typing
Derivations), therefore equivalent Terms having different Annotations
may have different Meanings, cf. Reification
(\S\ref{sec:reification}):



\textbf{Extrinsic Interpretation}: \emph{Curry-style}

* Terms Interpreted as in an Untyped Language, cf. Type Erasure
(\S\ref{sec:type_erasure})



\subsubsection{Simply-typed $\lambda$-calculus Typing Rules}
\label{sec:simplytyped_rules}

Typing Rules (\S\ref{sec:typing_rule}):
\begin{enumerate}
\item
  \[
    {
      \frac
      {x : \tau \in \Gamma}
      {\Gamma \vdash x : \tau}
    }
  \]
\item
  \[
    {
      \frac
      {c \;\text{is a constant of Base Type}\; T}
      {\Gamma \vdash c:T}
    }
  \]
\item
  \[
    {
      \frac
      {\Gamma, x:\sigma \vdash e:\tau}
      {\Gamma \vdash (\lambda x:\sigma.e):(\sigma \rightarrow \tau)}
    }
  \]
\item
  \[
    {
      \frac
      {\Gamma \vdash e_1:\sigma \rightarrow \tau \quad
        \Gamma \vdash e_2:\sigma}
      {\Gamma \vdash e_1 e_2 : \tau}
    }
  \]
\end{enumerate}



\textbf{Operational Semantics}

\textbf{Categorical Semantics}

Simply-typed $\lambda$-calculus is the Internal Language
(\S\ref{sec:internal_language}) of the Cartesian Closed Categories
(\S\ref{sec:cartesian_closed}).



\textbf{Proof-theoretic Semantics}

Simply-typed $\lambda$-calculus is Isomorphic by Curry-Howard
(\S\ref{sec:curry_howard}) to Minimal Logic
(\S\ref{sec:minimal_logic}):
\begin{itemize}
  \item Terms correspond to Proofs in Natural Deduction
    (\S\ref{sec:natural_deduction})
  \item (Inhabited) Types correspond to Tautologies in Minimal Logic
\end{itemize}



Minimal Logic $\leftrightarrow$ Simply-typed $\lambda$-calculus:
\[
  \supset \leftrightarrow \rightarrow
\] \[
  \wedge \leftrightarrow \times
\] \[
  \vee \leftrightarrow +
\] \[
  False \leftrightarrow \bot
\]



\emph{Type Assignment}:
\[
  \frac{
    f:A \rightarrow B \quad x:A
  }{
    f x : B
  }(\rightarrow e)
\]\[
  \frac{
    x:A \quad y:B
  }{
    \lambda x.y : A \rightarrow B
  }(\rightarrow i)
\]



\subsubsection{System T}\label{sec:system_t}

G\"odel

Proof Interpretation of Heyting Arithmetic into a Finite-type
Extension of Primitive Recursive Arithmetic
(\S\ref{sec:primitive_recursion})

All Recursive Functions in Peano Arithmetic are definable



\subsubsection{PCF}\label{sec:pcf}



\subsubsection{Reflexive Domain}\label{sec:reflexive_domain}

Dana Scott % FIXME



% --------------------------------------------------------------------
\subsection{$\lambda$-calculus with Conjunctive Types}
\label{sec:conjunctive_lambda}
% --------------------------------------------------------------------

Subtyping (\S\ref{sec:subtype})

System $F_{<:}$ (\S\ref{sec:system_fsub})



% --------------------------------------------------------------------
\subsection{Simply-typed $\lambda$-calculus with Type Operators}
\label{sec:simply_operators}
% --------------------------------------------------------------------

$\lambda\underline{\omega}$

Types depending on Types

System F$_\omega$ (\S\ref{sec:system_fomega})



% --------------------------------------------------------------------
\subsection{System F}\label{sec:system_f}
% --------------------------------------------------------------------

\emph{System F} (or \emph{Second-order $\lambda$-calculus})

Universal Quantification over all Types (cf. Existential Type Theory
\S\ref{sec:existential_type})

By Curry-Howard Isomorphism, System F corresponds to the fragment of
Second-order Intuitionistic Logic using only Universal Quantification;
can describe all Functions that are Provably Total in Second-order
Logic (\S\ref{sec:secondorder_logic})

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism}):
Type-level Function Abstraction $\Lambda$



\subsubsection{System F$_{<:}$}\label{sec:system_fsub}

\subsubsection{System F$_\omega$}\label{sec:system_fomega}



% --------------------------------------------------------------------
\subsection{LF Logical Framework}
\label{sec:logical_framework}
% --------------------------------------------------------------------

Dependent Types (\S\ref{sec:dependent_type})

Dependently-typed $\lambda$-calculus is base of Intuitionistic Type
Theory (\S\ref{sec:intuitionistic_type}), Calculus of Constructions
(\S\ref{sec:coq})

By Curry-Howard Isomorphism Dependent Types correspond to Propositions
of First-order Predicate Logic (\S\ref{sec:firstorder_logic})

Dependently-typed $\lambda$-calculus with a Type of all Types (the
simplest Pure Type System \S\ref{sec:pure_type_system}) is not
Strongly Normalizing due to Girard's Paradox
(\S\ref{sec:girards_paradox})

Contextual Category (\S\ref{sec:contextual_category})



% --------------------------------------------------------------------
\subsection{Linear $\lambda$-calculus}\label{sec:linear_lambda}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{$\kappa$-calculus}\label{sec:kappa_calculus}
% --------------------------------------------------------------------

First-order fragment of Typed $\lambda$-calculus



% --------------------------------------------------------------------
\subsection{B\"ohm Tree}\label{sec:bohm_tree}
% --------------------------------------------------------------------

A \emph{B\"ohm Tree} is a Possibly Infinite Directed Acyclic Graph
where some Vertices are Labelled by $\lambda$-terms and all Vertices
besides the Root have exactly one Parent, every Vertex has a finite
number of Children, and every Unlabelled Vertex has no Children.



% ====================================================================
\section{Calculus of Constructions}\label{sec:coq}
% ====================================================================

% ====================================================================
\section{Pure Type System}\label{sec:pure_type_system}
% ====================================================================

Arbitrary number of Sorts and Dependencies

Generalization of the \emph{Lambda Cube} to more sorts than Terms and
Types

Not necessarily Strongly Normalizing (\S\ref{sec:normalization})

Barendregt-Geuvers-Klop Conjecture



% --------------------------------------------------------------------
\subsection{Lambda Cube}\label{sec:lambda_cube}
% --------------------------------------------------------------------

All Strongly Normalizing

$\lambda\rightarrow$: Simply-typed $\lambda$-calculus; Terms depending
on Terms

$\lambda\underline{\omega}$: Simply-typed $\lambda$-calculus with Type
Operators (\S\ref{sec:simply_operators}); Types depending on Types

$\lambda2$: Second-order $\lambda$-calculus (System F
\S\ref{sec:system_f}); Terms depending on Types (Parametric
Polymorphism \S\ref{sec:parametric_polymorphism})

$\lambda\Pi$: Dependently-typed $\lambda$-calculus
(Logical Framework \S\ref{sec:logical_framework}); Types depending on
Terms



% ====================================================================
\section{Intuitionistic Type Theory}\label{sec:intuitionistic_type}
\cite{martinlof84}
% ====================================================================

\emph{Intuitionistic Type Theory} (also \emph{Constructive Type
  Theory} or \emph{Martin-L\"of Type Theory})

Inductive Types (\S\ref{sec:inductive_type})

Modelled by Locally Cartesian Closed Category
(\S\ref{sec:locally_cartesian})

Extensional Martin-L\"of Type Theory: Internal Language
(\S\ref{sec:internal_language}) for Cartesian Closed Quasi-categories
(\S\ref{sec:quasicategory})

Four forms of Judgements:
\begin{description}
  \item [Well-formed Type]: $A$ is a Set, $A$ is a Proposition, $A$ is
    an Expectation, $A$ is a Task; Types (encodes Syntax of Formulas
    ``A is a Proposition''; note some Formulas are only Well-formed if
    certain Judgements are Derivable \cite{thompson99}):
    \[
      A \text{ type}
    \]
  \item [Equality of Types]: $A$ and $B$ are Equal Sets:
    \[
      A \equiv B \text{ type}
    \]
  \item [Well-formed Term of Type]: $a$ is an Element of $A$, $a$ is a
    Proof of $A$, $a$ is a Realization of $A$, $a$ is a Method for
    doing $A$:
    \[
      a : A
    \]
  \item [Equality of Terms]: $a$ and $b$ are Equal Elements of Set $A$:
    \[
      a \equiv b : A
    \]
\end{description}

Dependent Type (\S\ref{sec:dependent_type}):
\[
  (x:A)B
\]
Removal of Dependency by Substitution:
\[
  [x/a]B
\]
Abstracted Object:
\[
  [x]b
\]
Removal of Abstration on Object:
\[
  b[x/a]
\]
Well-formed Context of Typing Assumptions
(\S\ref{sec:typing_assumption}):
\[
  \vdash \Gamma \textsf{ Context}
\]
Context (\S\ref{sec:type_context}) Judgements:
\begin {itemize}
\item Well-formed Type $\sigma$:
  \[
    \Gamma \vdash \sigma \mathsf{ Type}
  \]
\item Well-formed Term $t$ of Type $\sigma$:
  \[
    \Gamma \vdash t : \sigma
  \]
\item Type Equivalence:
  \[
    \Gamma \vdash \sigma \equiv \tau
  \]
\item Term Equivalence:
  \[
    \Gamma \vdash t \equiv u : \sigma
  \]
\end {itemize}
\hfill\\
Type Universe:
\[
  \mathcal{U}
\]
Dependent Type mapping Objects to Types:
\[
  \textrm{El}
\]

Definitional Equality (\S\ref{sec:proof_equality})

Structural Rules (\S\ref{sec:structural_rule})



\hfill \\
\textbf{Identity Types} (\S\ref{sec:equality_type})
\\
Identity Type Introduction:
\[
  \frac{
    \Gamma \vdash m : A
  }{
    \Gamma \vdash refl_A(m) : Id_A(m,m)
  } (Id_A\text{-I})
\]
Identity Type Elimination:
\[
  \frac{
    \Gamma \vdash p : Id_A (m,n) \quad
    \Gamma, x:A, y:A, z : Id_A(x,y) \vdash C_{x,y,z} \text{ type}\quad
    \Gamma, x : A \vdash q : [x, x, refl_A(x)/x,y,z]C
  }{
    \Gamma \vdash refl_A(m) : Id_A(m,m)
  } (Id_A\text{-E})
\]
\hfill \\
\textbf{Dependent Product Types} (\S\ref{sec:dependent_product})
\\
Logical Implication and Universal Quantification
\\
Dependent Product Formation:
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma, x:A \vdash B \text{ type}
  }{
    \Gamma \vdash \Pi_{x:A} B \text{ type}
  } (\Pi\text{-F})
\]
Dependent Product Introduction:
\[
  \frac{
    \Gamma, x : A \vdash m_x : B_x \quad
  }{
    \Gamma \vdash (\lambda x:A.m_x : B_x) : \Pi_{x:A} B
  } (\Pi\text{-I})
\]
Dependent Product Elimination:
\[
  \frac{
    \Gamma \vdash m : \Pi_{x:A} B \quad
    \Gamma \vdash n : A
  }{
    \Gamma \vdash m\;n : [n/x]B
  } (\Pi\text{-E})
\]
Dependent Product Computation (cf. $\beta$-reduction
\S\ref{sec:beta_reduction}):
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma , x : A \vdash m : B
  }{
    \Gamma \vdash (\lambda x : A.m)\;n \equiv [n/x]m : [n/x]B
  } (\Pi\text{-C})
\]


\hfill \\
\textbf{Dependent Sum Types} (\S\ref{sec:dependent_sum})
\\
Logical Conjunction and Existential Quantification
\\
Dependent Sum Formation:
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma, x : A \vdash B_x \text{ type}
  }{
    \Gamma \vdash \Sigma_{x:A} B_x \text{ type}
  } (\Sigma\text{-F})
\]
Dependent Sum Introduction:
\[
  \frac{
    \Gamma \vdash m : A \quad
    \Gamma \vdash n : [m/x]B
  }{
    \Gamma \vdash (m,n) : \Sigma_{x:A} B_x
  } (\Sigma\text{-I})
\]
Dependent Sum Elimination 1:
\[
  \frac{
    \Gamma \vdash m : \Sigma_{x:A} B_x
  }{
    \Gamma \vdash \pi_1\;m : A
  } (\Sigma\text{-E$_1$})
\]
Dependent Sum Elimination 2:
\[
  \frac{
    \Gamma \vdash m : \Sigma_{x:A} B_x
  }{
    \Gamma \vdash \pi_2\;m : B[\pi_1\;m/x]
  } (\Sigma\text{-E$_2$})
\]
\hfill \\
\textbf{Binary Sum Types} (\S\ref{sec:sum_type})
\\
Disjunction
\\
Binary Sum Introduction 1:
\[
  \frac{
    \Gamma \vdash m : A
  }{
    \Gamma \vdash inl(m) : A + B
  } (+\text{-I}_1)
\]
Binary Sum Introduction 2:
\[
  \frac{
    \Gamma \vdash n : B
  }{
    \Gamma \vdash inr(n) : A + B
  } (+\text{-I}_2)
\]
Binary Sum Elimination:
\[
  \frac{
    \Gamma \vdash m : A + B \quad
    \Gamma, z : A + B \vdash C \text{ type} \quad
    \Gamma, x : A \vdash n : [inl(x)/z]C \quad
    \Gamma, y : B \vdash p : [inr(y)/z]C
  }{
    \Gamma \vdash case (m, x\;n, y\;p) : [m/z]C
  } (+\text{-E})
\]



Categorical Model, ``Category with Families'':

\begin{itemize}
  \item Category $\mathsf{C}$ of Contexts: Objects are Contexts,
    Morphisms are Substitutions
  \item Functor $T : \mathsf{C}^{op} \rightarrow \mathbf{Fam(Set)}$
    where $\mathbf{Fam(Set)}$ is the Category of Families
    (\S\ref{sec:family}) of Sets where Objects are Pairs $(A,B)$ of an
    Index Set $A$ and a Function $B: X \rightarrow A$ and Morphisms
    are Pairs of Functions $f: A \rightarrow A$ and $g: X \rightarrow
    X'$ such that $B' \circ g = f \circ B$, i.e. $f$ maps $B_a$ to
    $B'_{g(a)}$
\end{itemize}

The Functor $T$ assigns a Context $\Gamma$ to a Set of Types
$Ty(\Gamma)$, and for each $A : Ty(\Gamma)$ a Set of Terms
$Tm(\Gamma,A)$.

The Empty Context is the Terminal Object of $\mathsf{C}$.

Final Object for \emph{Comprehension} (or \emph{Context Extension}) % FIXME



\textbf{Alternate description}\cite{bastenhof09}

Language $L$:
\begin{enumerate}
  \item $1$ (Unity Type), $\Omega$ (Truth Value Type)
  \item Base Types $\tau_1, \tau_2, \tau_3, \ldots$
  \item Function Symbols $f, g, h, \ldots$
\end{enumerate}
The Types of a System are given by the smallest Set including $1$,
$\Omega$, and the Base Types closed under $\times$ (Product Types
\S\ref{sec:product_type}) and Unary Type Operator $P$ (Power Types
\S\ref{sec:power_type}).

Terms of Type $\Omega$ represent Formulas, e.g. $\tau_1 = \tau_2$.



% --------------------------------------------------------------------
\subsection{Constructive Type}\label{sec:constructive_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Meaning Explanation}\label{sec:meaning_explanation}
% --------------------------------------------------------------------

Martin-L\"of, a Proof-theoretic Semantics
(\S\ref{sec:proof_semantics}) for Type Theory



% --------------------------------------------------------------------
\subsection{Extensional Type Theory}\label{sec:extensional_type}
\cite{harper12}
% --------------------------------------------------------------------

\emph{Extensional Type Theory} (\emph{ETT})

Strict Equivalence

``Homotopy Set Theory'' (Homotopically Discrete)

\emph{NuPRL}

Equality Reflection Principle



\subsubsection{Observational Type Theory}\label{sec:observational_type}

``Homotopy Set Theory''

Setoid (\S\ref{sec:setoid})



% --------------------------------------------------------------------
\subsection{Intensional Type Theory}\label{sec:intensional_type}
\cite{harper12}
% --------------------------------------------------------------------

Weak Equivalence



% ====================================================================
\section{Homotopy Type Theory}\label{sec:homotopy_type}
% ====================================================================

Homotopy Thoery (\S\ref{sec:homotopy})

- Function Extensionality
- Univalence Axiom (\S\ref{sec:univalence_axiom})

- Values (Points), Paths, Homotopies

- Internal Language of Higher Categories
(\S\ref{sec:higher_category}).

$\infty$-groupoid (\S\ref{sec:infinity_groupoid})



% --------------------------------------------------------------------
\subsection{Higher Inductive Type}\label{sec:higher_inductive_type}
% --------------------------------------------------------------------



% --------------------------------------------------------------------
\subsection{Inference Rules}\label{sec:homotopy_rules}
% --------------------------------------------------------------------

Inference Rules (\S\ref{sec:type_inference}) have the form:
\[
  \frac{J_1 \quad \cdots \quad J_k} {J} Name
\]
where $J_i$ are provided as derived hypothetical (metatheoretical)
Judgements and $J$ is the conclusion.

A Tree constructed from Inference Rules forms a Derivation
(\S\ref{sec:typing_derivation}) of a Judgement.



\textbf{Context Rules}

The following Rules of Inference allow for the determination of a
Well-formed Context:
\begin{enumerate}
\item
\[
  {
    \frac{}{(.)ctx}
  } ctx-EMP
\]
\item
\[
  {
    \frac
    {x_1:A_1, \ldots, x_{n-1}:A_{n-1} \vdash A_n : \mathcal{U}_i}
    {(x_1:A_1,\ldots,x_n:A_n) ctx}
  } ctx-EXT
\]
\end{enumerate}



\textbf{Structural Rules}

Given a Context, derive Typing Judgements
(\S\ref{sec:typing_judgement}) listed in the Context:
\[
  {
    \frac
    {(x_1:A_1, \ldots, x_n:A_n)ctx}
    {x_1:A_1, \ldots, x_n:A_n \vdash x_i:A_i}
  } Vble
\]

Substitution for Typing Judgements:
\[
  {
    \frac
    {\Gamma \vdash a : A \;\;\;\;\;\;\;
    \Gamma,x:A,\Delta \vdash b : B}
    {\Gamma,[a/x]\Delta \vdash [a/x]b : [a/x]B}
  } Subst_1
\]

Weakening for Typing Judgements:
\[
  {
    \frac
    {\Gamma \vdash A : \mathcal{U}_i \;\;\;\;\;\;\;
    \Gamma,\Delta \vdash b : B}
    {\Gamma,x:A,\Delta \vdash b:B}
  } Wkg_1
\]

Substitution for Judgemental Equality:
\[
  {
    \frac
    {\Gamma \vdash a : A \;\;\;\;\;\;\;
    \Gamma,x:A,\Delta \vdash b \equiv c : B}
    {\Gamma,[a/x]\Delta \vdash [a/x]b \equiv [a/x]c : [a/x]B}
  } Subst_2
\]

Weakening for Judgemental Equality:
\[
  {
    \frac
    {\Gamma \vdash A : \mathcal{U}_i \;\;\;\;\;\;\;
    \Gamma,\Delta \vdash b \equiv c : B}
    {\Gamma, x:A, \Delta \vdash b \equiv c : B}
  } Wkg_2
\]



\textbf{Universe Rules}

\[
  {
    \frac
    {(\Gamma) ctx}
    {\Gamma \vdash \mathcal{U}_i : \mathcal{U}_{i+1}}
  } \mathcal{U}-INTRO
\]

\[
  {
    \frac
    {\Gamma \vdash A : \mathcal{U}_i}
    {\Gamma \vdash A : \mathcal{U}_{i+1}}
  } \mathcal{U}-CUMUL
\]



\textbf{Dependent Function Type Rules}

\[
  {
    \frac
    {\Gamma \vdash A : \mathcal{U}_i \;\;\;\;\;\;\;
    \Gamma,x:A \vdash B : \mathcal{U}_i}
    {\Gamma \vdash \prod_{(x:A)} B : \mathcal{U}_i}
  } \Pi-FORM
\]\[
  {
    \frac
    {}
    {}
  } \Pi-INTRO
\]\[
  {
    \frac
    {}
    {}
  } \Pi-ELIM
\]\[
  {
    \frac
    {}
    {}
  } \Pi-COMP
\]\[
  {
    \frac
    {}
    {}
  } \Pi-UNIQ
\]



% --------------------------------------------------------------------
\subsection{Univalence Axiom}\label{sec:univalence_axiom}
% --------------------------------------------------------------------

``Identity is Equivalent to Equivalence''

``Equivalent Types are Identical''
\[
  (A = B) \simeq (A \simeq B)
\]
where $A = B$ is notation for the Type $Id_U(A,B)$ where $U$ is the
Universe containing $A$ and $B$.



% ====================================================================
\section{Curry-Howard Correspondence}\label{sec:curry_howard}
% ====================================================================

\emph{Curry-Howard Correspondence}

Type Theory, Proof Theory, Algebra (Preorders: $\leq$ is a Reflexive
and Transitive Relation)
\\
\begin{tabular}{| l | l |}
\hline
\textbf{Logic} & \textbf{Type Theory} \\ \hline \hline
Proposition & $A$ (Type) \\ \hline
Proof & $a : A$ (Term) \\
\hline
\end{tabular}
\\
\cite{harper12}
\\
\begin{tabular}{| p{2cm} | p{3cm} | p{4.5cm} | p{3cm} |}
\hline
& \textbf{Logic} & \textbf{Type} & \textbf{Algebra}\\ \hline \hline
Trivial Proposition
  & \begin{center} $\overline{A \vdash \top}$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $\overline{A \leq \top}$ \end{center} \\ \hline
Bottom
  & \begin{center} $\overline{\bot \vdash A}$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $\overline{\bot \leq A}$ \end{center} \\ \hline
Reflexivity
  & \begin{center} $A \vdash A$ \end{center}
  & \begin{center} $x : A \vdash x : A$ \end{center}
  & \begin{center} $A \leq A$ \end{center} \\ \hline
Negation Elimination
  & \begin{center} $\neg A \vdash A \rightarrow \bot$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $A \wedge \neg A = \bot$ \end{center} \\ \hline
Negation Introduction
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\underline{C \wedge A \leq \bot}$\newline
      $C \leq \overline{A}$
    \end{center} \\ \hline
Elimination Rules
  & \begin{center}
      $\overline{A \wedge B \vdash A}$,\newline\newline
      $\overline{A \wedge B \vdash B}$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\overline{A \wedge B \leq A}$,\newline\newline
      $\overline{A \wedge B \leq B}$
    \end{center} \\ \hline
Introduction Rules
  & \begin{center}
      $\overline{A \vdash A \vee B}$,\newline\newline
      $\overline{B \vdash A \vee B}$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\overline{A \leq A \vee B}$,\newline\newline
      $\overline{B \leq A \vee B}$
    \end{center} \\ \hline
Conjunction
  & \begin{center}
    $\underline{C \vdash A \quad C \vdash B}$\newline
    $C \vdash A \wedge B$
    \end{center}
  & \begin{center}
    $\underline{x:C \vdash m:A \quad x:C \vdash n:B}$\newline
    $x:C \vdash (m,n):A \times B$
    \end{center}
  & \begin{center}
    $\underline{C \leq A \quad C \leq B}$\newline
    $C \leq A \wedge B$
    \end{center} \\ \hline
Disjunction
  & \begin{center}
    $\underline{A \vdash C \quad B \vdash C}$\newline
    $A \vee B \vdash C$
    \end{center}
  & \begin{center}
    ???
    \end{center}
  & \begin{center}
    $\underline{A \leq C \quad B \leq C}$\newline
    $A \vee B \leq C$
    \end{center} \\ \hline
Transitivity
  & \begin{center}
      $\underline{A \vdash B \quad B \vdash C}$\newline
      $A \vdash C$
    \end{center}
  & \begin{center}
    $\underline{x:A \vdash m:B \quad y:B \vdash n:C}$\newline
    $x:A \vdash [m/y]n:C$
    \end{center}
  & \begin{center}
    $\underline{A \leq B \quad B \leq C}$\newline
    $A \leq C$
    \end{center} \\ \hline
\hline
\end{tabular}
\\
\begin{tabular}{| p{2cm} | p{3cm} | p{4.5cm} | p{3cm} |}
\hline
& \textbf{Logic} & \textbf{Type} & \textbf{Algebra}\\ \hline \hline
Implication Elimination
  & \begin{center} $A, (A \rightarrow B) \vdash B$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Implication Introduction
  & \begin{center}
      $\underline{A \wedge C \vdash B}$\newline
      $C \vdash A \rightarrow B$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Weakening
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Contraction
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Exchange
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
\hline
\end{tabular}

Proofs and Propositions form the Object Language; Derivations are used
to infer Judgements about the Object Language

***

$p : P$ ``$p$ is a Proof of Proposition $P$''

A Proof of $A \wedge B$ is a Pair of Proofs $p : A$ and $q : B$ (holds
in both Classical and Constructive Systems)

A Proof of $A \vee B$ is a Proof $p : A$ or a Proof $q : B$ with an
indication of which Formula is Proved (differs from Classical Logic)

A Proof of $A \Rightarrow B$ is a Function that Transforms a Proof $p
: A$ into a Proof $q : B$.

No Proof for the Contradictory Proposition $\bot$

$(\exists x : A).P$ where $P$ is a Witness (\S\ref{sec:type_witness})
$w : A$ with a Proof that $P$ holds of $w$, i.e. $[w/x]P$

$(\forall x : A).P$ implies that $[a/x]P$ is Valid for every $a$ in
$A$; a Function mapping any Proof of $A$ to a Proof of $P$.

Introduction Rule for $\forall$:
\[
  {
    \frac{
      \begin{matrix}
        [x : A]\\
        \vdots\\
        p : P
      \end{matrix}
    }{
      (\lambda x : A).p : (\forall x : A).P
    }
  } (\forall I)
\]

Computation Rule for $\forall$:
\[
  ((\lambda x : A).p) \rightarrow [a/x]p
\]

Introduction Rule for $\exists$:
\[
  {
    \frac{
      a : A \quad\quad p : [a/x]P
    }{
      (a,p) : (\exists x : A).P
    }
  } (\exists I)
\]

Computation Rules for $\exists$:
\[
  fst (p,q) \rightarrow p
\]\[
  snd (p,q) \rightarrow q
\]

The Formation Rule for Equality Types (\S\ref{sec:equality_type})
requires other Judgements (Type Assumptions) in addition to
Well-typing Judgements:
\[
  {
    \frac{ A \mathsf{ Type} \quad\quad a : A \quad\quad b:A }
    { I (A,a,b) \mathsf{ Type}}
  } (I F)
\]

Introduction Rule for $I$:
\[
  {
    \frac{ a : A }
    { r(a) : I(A,a,a)}
  } (II)
\]

Elimination Rule for $I$:
\[
  {
    \frac{ c : I (A, a, b) \quad\quad d : C(a,a,r(a)) }
    { J(c,d) : C(a,b,c) }
  } (I E)
\]

Computation Rule for $I$:
\[
  J (r(a), d) \rightarrow d
\]

Leibniz Law

***

Formation Rules : Defines what the Types of the System are (Syntax)

Introduction \& Elimination Rules : Define which Terms are Members of
which Types; Typing Rules (\S\ref{sec:typing_rule})

Computation Rules : How Objects can be Reduced, i.e. Evaluated
(Computation)

Natural Deduction - Typed Lambda Calculus

Minimal Logic - Simple Types (Simply-typed $\lambda$-calculus
\S\ref{sec:simply_typed})

Predicate Logic - Dependent Types (Intuitionistic Type Theory
\S\ref{sec:intuitionistic_type})

Modal Logic - Monads

Classical-Intuitionistic Embedding - Continuation Passing Style

Subset Type $(\exists x:A).B$ (Pairs of Objects and the Proofs that
they have Property): $\{ x : A | B \}$ consisting of those $a$ in $A$
with Property $[a/x]B$, i.e. $[a/x]B$ is Inhabited.



% ====================================================================
\section{Type System}\label{sec:type_system}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Type Checking}\label{sec:type_checking}
% --------------------------------------------------------------------

\subsubsection{Bi-directional Type Checking}
\label{sec:bidirectional_checking}

\emph{Checking}

\emph{Synthesis}



\subsubsection{Extended Static Checking}\label{sec:extended_static}



% --------------------------------------------------------------------
\subsection{Substructural Type System}\label{sec:substructural_type}
% --------------------------------------------------------------------

Substructural Logic (\S\ref{sec:substructural_logic})

Substructural Type Systems are categorized by allowing or disallowing
Structural rules of Exchange (\S\ref{sec:exchange_rule}), Weakening
(\S\ref{sec:weakening_rule}), or Contraction
(\S\ref{sec:contraction_rule}):

\begin{itemize}
  \item Linear Type Systems (\S\ref{sec:linear_type}): Allow Exchange,
    not Weakening or Contraction; Every Variable used exactly once
  \item Affine Type Systems (\S\ref{sec:affine_type}): Allow Exchange
    and Weakening, not Contraction; Every occurrence of a Variable
    used at most once
  \item Relevant Type System (\S\ref{sec:relevant_type}): Allow
    Exchange and Contraction, not Weakening; Every variable used at
    least once
  \item Ordered Type System (\S\ref{sec:ordered_type}): Disallow
    Exchange, Contraction and Weakening; Every Variable is used
    Exactly once in the order it was introduced
\end{itemize}



\subsubsection{Linear Type System}\label{sec:linear_type}

Linear Logic (\S\ref{sec:linear_logic}) allows safe Deallocation
(Objects used exactly once)

Linear $\lambda$-calculus (\S\ref{sec:linear_lambda})

Internal Language (\S\ref{sec:internal_language}) of Closed Symmetric
Monoidal Categories (\S\ref{sec:closed_monoidal})

Allows References but not Aliases

Modelling of Heap-based Memory Allocation

No-cloning Theorem (Quantum States):
\begin{itemize}
  \item No Diagonal Functor (\S\ref{sec:diagonal_functor})
    which could duplicate States
  \item No $K$-combinator which can destroy States
  \item A Variable $x$ can appear at most once in a $\lambda$-term
\end{itemize}



\paragraph{Affine Type System}\label{sec:affine_type}
\hfill \\

Affine Logic (\S\ref{sec:affine_logic})



\subsubsection{Relevant Type System}\label{sec:relevant_type}

Relevant Logic (\S\ref{sec:relevance_logic})



\subsubsection{Ordered Type System}\label{sec:ordered_type}

Noncommutative Logic (\S\ref{sec:noncommutative_logic})

modelling Stack-based Memory Allocation

only Objects on top of modelled Stack may be used, after which it is
popped off



% --------------------------------------------------------------------
\subsection{Hindley-Milner Type System}\label{sec:hindley_milner}
% --------------------------------------------------------------------

$\lambda$-calculus with Parametric Polymorphism



\subsubsection{Algorithm W}\label{sec:algorithm_w}
