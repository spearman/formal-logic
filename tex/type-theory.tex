%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Type Theory}\label{sec:type_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Type Theory} is the study of Classes of Formal Systems
(\S\ref{sec:formal_system}) where each Term (\S\ref{sec:term}) has a
\emph{Type} (\S\ref{sec:type}) and Operations are restricted to Terms
of specific Types.

As a Formal Theory (\S\ref{sec:formal_theory}), Judgements
(\S\ref{sec:judgement}) in Type Theory are of three
kinds\cite{hott13}:
\begin{enumerate}

\item \emph{Well-formed Context} (\S\ref{sec:type_context})
\[
  (\Gamma) ctx
\]
``$\Gamma$ is a Well-formed Context''

\item \emph{Propositional Equality}
\[
  \Gamma \vdash a : A
\]
``Given Contex $\Gamma$, $a$ is a Term of Type $A$''

\item \emph{Definitional (Judgemental) Equality}
\[
  \Gamma \vdash a \equiv b : A
\]
``Given Context $\Gamma$, $a$ and $b$ are definitionally equal Terms
of Type $A$''

\end{enumerate}
with a Deductive Apparatus (\S\ref{sec:deductive_apparatus})
consisting of Inference Rules only and no Axioms. Judgemental Equality
is an Equivalence Relation respected by Typing.

Inference Rules have the form:
\[
  \frac{J_1 \quad \cdots \quad J_k} {J} Name
\]
where $J_i$ are provided as derived hypothetical (metatheoretical)
Judgements and $J$ is the conclusion.

A tree constructed from Inference Rules forms a \emph{Derivation} of a
Judgement.

\textbf{Intensional \& Extensional Type Theory}

\begin{itemize}
\item \emph{Extensional Type Theory}: Definitional (Computational)
  Equality is not distinguished from Propositional (Proof) Equality
  but Type Checking (\S\ref{sec:type_checking}) is Undecidable
\item \emph{Intensional Type Theory}: Type Checking is Decidable but
  Extensional Reasoning must be carried out using Setoids
  (\S\ref{sec:setoid})
\item \emph{Homotopy Type Theory} (\S\ref{sec:homotopy_type}): Higher
  Inductive Types (\S\ref{sec:higher_inductive_type}) allow definition
  of Higher-order Constructors
\end{itemize}

Term Rewrite System (\S\ref{sec:term_rewriting})

\emph{Conversion Rules}

\emph{Canonical Form}

\emph{Normal Form}



% ====================================================================
\section{Expression}\label{sec:type_expression}
% ====================================================================

An \emph{Expression} is an Equivalence Class of Syntactic forms which
differ in the names of \emph{Bound Variables}. That is, changing the
name of a Bound Variable everywhere within an Expression
(\emph{$\alpha$-conversion}) does not change the Expression.

A Variable is Bound in an Expression by an \emph{Abstraction}
expressing that the Variable is \emph{local} to the Expression:
\[
  \lambda x.B
\]
or
\[
  x.B
\]

\emph{Substitution}:
\[
  B[a/x]
\]
Substitute Term $a$ for Free occurrences of Variable $x$ in the Term
$B$. Generalized:
\[
  B[a_1,\ldots,a_n / x_1,\ldots,x_n]
\]



% ====================================================================
\section{Context}\label{sec:type_context}
% ====================================================================

A \emph{Context}, $\Gamma$, is a list of Assumptions of the form:
\[
  \Gamma = x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n
\]
where each Element $x_i : A_i$ is an Assumption that the distinct
Variable $x_i$ has type $A_i$.

Judgements are formulated under the Assumptions of a particular
Context, $\Gamma$:
\[
  \Gamma \vdash a : A
\]
For an empty Context:
\[
  \vdash a : A
\]
or
\[
  . \vdash a : A
\]



% ====================================================================
\section{Type}\label{sec:type}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Function Type}\label{sec:function_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Inhabited Type}\label{sec:inhabited_type}
% --------------------------------------------------------------------

\emph{Inhabited}

In Simply-typed $\lambda$-calculus (\S\ref{sec:simply_typed}), a Type
is Inhabited if and only if its corresponding Proposition is a
Tautology of Minimal Implicative Logic (\S\ref{sec:minimal_logic}).

In Second-order $\lambda$-calculus (\S\ref{sec:system_f}), a
Type is Inhabited if and only if its corresponding Proposition is a
Tautology of Second-order Logic (\S\ref{sec:secondorder_logic}).



% --------------------------------------------------------------------
\subsection{Equality Type}\label{sec:equality_type}
% --------------------------------------------------------------------

The \emph{Equality Type} (or \emph{Identity Type}), denoted
\emph{Propositional Equality}, represents Equality of Types and Terms.



% --------------------------------------------------------------------
\subsection{Universe Type}\label{sec:universe_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Inductive Type}\label{sec:inductive_type}
% --------------------------------------------------------------------

Type Constructor (\S\ref{sec:type_operator})

Structural Recursion (\S\ref{sec:structural_recursion})

\emph{Coinductive Type}, Coinduction (\S\ref{sec:coinduction})

\emph{Induction Induction}

\emph{Induction Recursion}



% --------------------------------------------------------------------
\subsection{Polymorphic Type}\label{sec:polymorphic_type}
% --------------------------------------------------------------------

Second-order $\lambda$-calculus (\S\ref{sec:system_f})

Subtyping

Function Overloading

Parametric Polymorphism

Variance

Bounded Quantification

Parametricity



% --------------------------------------------------------------------
\subsection{Type Operator}\label{sec:type_operator}
% --------------------------------------------------------------------

Adding additional Type Operators to Simply-typed Lambda Calculus
results in \emph{Simply-typed Lambda Calculus with Type Operators}
``$\lambda \underline{\omega}$''

System F$_{\omega}$



\subsubsection{Type Constructor}\label{sec:type_constructor}

\emph{Type Constructor}



% --------------------------------------------------------------------
\subsection{Subtype}\label{sec:subtype}
% --------------------------------------------------------------------

System $F_<$ (System $F$ with Subtyping)



% --------------------------------------------------------------------
\subsection{Dependent Type}\label{sec:dependent_type}
% --------------------------------------------------------------------

A \emph{Dependent Type} depends on a Term or another Type.

Logical Quantifiers (\S\ref{sec:quantifier})

Intuitionistic Type Theory (\S\ref{sec:intuitionistic_type})

Examples: Dependent Functions, Dependent Pairs



\subsubsection{Dependent Sum Type}\label{sec:dependent_sum}

\emph{$\Sigma$-type}



% ====================================================================
\section{Type Universe}\label{sec:type_universe}
% ====================================================================

A \emph{Type Universe} is a Type whose Elements are Types. A hierarchy:
\[
  \mathcal{U}_0, \mathcal{U}_1, \mathcal{U}_2, \ldots
\]
is such that any Type in $\mathcal{U}_i$ is also in
$\mathcal{U}_{i+1}$. See $\mathcal{U}-INTRO$ and $\mathcal{U}-CUMUL$
\S\ref{sec:universe_rules}.



% ====================================================================
\section{Inference Rules}\label{sec:type_inference}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Context Rules}
% --------------------------------------------------------------------

The following Rules of Inference allow for the determination of a
Well-formed Context:
\begin{enumerate}
\item
\[
  {
    \frac{}{(.)ctx}
  } ctx-EMP
\]
\item
\[
  {
    \frac
    {x_1:A_1, \ldots, x_{n-1}:A_{n-1} \vdash A_n : \mathcal{U}_i}
    {(x_1:A_1,\ldots,x_n:A_n) ctx}
  } ctx-EXT
\]
\end{enumerate}



% --------------------------------------------------------------------
\subsection{Structural Rules}
% --------------------------------------------------------------------

Given a Context, derive Typing Judgements listed in the Context:
\[
  {
    \frac
    {(x_1:A_1, \ldots, x_n:A_n)ctx}
    {x_1:A_1, \ldots, x_n:A_n \vdash x_i:A_i}
  } Vble
\]

Substitution for Typing Judgements:
\[
  {
    \frac
    {\Gamma \vdash a : A \;\;\;\;\;\;\;
    \Gamma,x:A,\Delta \vdash b : B}
    {\Gamma,\Delta[a/x] \vdash b[a/x] : B[a/x]}
  } Subst_1
\]

Weakening for Typing Judgements:
\[
  {
    \frac
    {\Gamma \vdash A : \mathcal{U}_i \;\;\;\;\;\;\;
    \Gamma,\Delta \vdash b : B}
    {\Gamma,x:A,\Delta \vdash b:B}
  } Wkg_1
\]

Substitution for Judgemental Equality:
\[
  {
    \frac
    {\Gamma \vdash a : A \;\;\;\;\;\;\;
    \Gamma,x:A,\Delta \vdash b \equiv c : B}
    {\Gamma,\Delta[a/x] \vdash b[a/x] \equiv c[a/x] : B[a/x]}
  } Subst_2
\]

Weakening for Judgemental Equality:
\[
  {
    \frac
    {\Gamma \vdash A : \mathcal{U}_i \;\;\;\;\;\;\;
    \Gamma,\Delta \vdash b \equiv c : B}
    {\Gamma, x:A, \Delta \vdash b \equiv c : B}
  } Wkg_2
\]



% --------------------------------------------------------------------
\subsection{Universe Rules}\label{sec:universe_rules}
% --------------------------------------------------------------------

\[
  {
    \frac
    {(\Gamma) ctx}
    {\Gamma \vdash \mathcal{U}_i : \mathcal{U}_{i+1}}
  } \mathcal{U}-INTRO
\]

\[
  {
    \frac
    {\Gamma \vdash A : \mathcal{U}_i}
    {\Gamma \vdash A : \mathcal{U}_{i+1}}
  } \mathcal{U}-CUMUL
\]



% --------------------------------------------------------------------
\subsection{Dependent Function Type Rules}\label{sec:dependent_rules}
% --------------------------------------------------------------------

\[
  {
    \frac
    {\Gamma \vdash A : \mathcal{U}_i \;\;\;\;\;\;\;
    \Gamma,x:A \vdash B : \mathcal{U}_i}
    {\Gamma \vdash \prod_{(x:A)} B : \mathcal{U}_i}
  } \Pi-FORM
\]\[
  {
    \frac
    {}
    {}
  } \Pi-INTRO
\]\[
  {
    \frac
    {}
    {}
  } \Pi-ELIM
\]\[
  {
    \frac
    {}
    {}
  } \Pi-COMP
\]\[
  {
    \frac
    {}
    {}
  } \Pi-UNIQ
\]



% ====================================================================
\section{Typed $\lambda$-Calculus}\label{sec:typed_lambda}
% ====================================================================

\emph{Typed $\lambda$-Calculus} allows for Lambda Terms to be assigned
Types (\S\ref{sec:type}).

Simply-typed $\lambda$-calculus (\S\ref{sec:simply_typed}) has only
one Type Constructor (\S\ref{sec:type_constructor}), $\rightarrow$
(see Function Type \S\ref{sec:function_type}).

Untyped $\lambda$-calculus (\S\ref{sec:untyped_lambda}) may be
considered a Typed $\lambda$-calculus with only one Type.



% --------------------------------------------------------------------
\subsection{Simply-typed $\lambda$-calculus}\label{sec:simply_typed}
% --------------------------------------------------------------------

\emph{Simply-typed $\lambda$-calculus} ($\lambda^\rightarrow$) is a
Typed Interpretation of $\lambda$-calculus with one Type Constructor
(\S\ref{sec:type_constructor}), $\rightarrow$, for Function Types
(\S\ref{sec:function_type}).

``Simply-typed'' is to distinguish from extensions such as:
\begin{itemize}
  \item System F (\S\ref{sec:system_f}): Polymorphic Types
  \item Logical Framework (\S\ref{sec:logical_framework}): Dependent
    Types
\end{itemize}
because Polymorphism and Dependency cannot be encoding using only
$\rightarrow$ and Type Variables.

The following extensions are still considered ``Simply-typed'':
\begin{itemize}
  \item System T (\S\ref{sec:system_t}): Products, Coproducts, Natural
    Numbers
  \item PCF (\S\ref{sec:pcf}): Full Recursion
\end{itemize}

Simply-typed $\lambda$-calculus is the Internal Language
(\S\ref{sec:internal_language}) of the Cartesian Closed Categories
(\S\ref{sec:cartesian_closed}).

Isomorphic by Curry-Howard (\S\ref{sec:curry_howard}) to
Minimal Logic (\S\ref{sec:minimal_logic}):
\begin{itemize}
\item Terms correspond to Proofs in Natural Deduction
  (\S\ref{sec:natural_deduction})
\item (Inhabited) Types correspond to Tautologies in Minimal Logic
\end{itemize}

Minimal Logic $\leftrightarrow$ Simply Typed $\lambda$-Calculus:
\[
  \supset \leftrightarrow \rightarrow
\] \[
  \wedge \leftrightarrow \times
\] \[
  \vee \leftrightarrow +
\] \[
  False \leftrightarrow \bot
\]



\subsubsection{Simply-typed $\lambda$-calculus with Conjunctive Types}
\label{sec:simplytyped_conjunctive}

Subtyping (\S\ref{sec:subtype})

System $F_<$



\subsubsection{System T}\label{sec:system_t}

G\"odel

Proof Interpretation of Heyting Arithmetic into a Finite-type
Extension of Primitive Recursive Arithmetic
(\S\ref{sec:primitive_recursion})

All Recursive Functions in Peano Arithmetic are definable



\subsubsection{PCF}\label{sec:pcf}



% --------------------------------------------------------------------
\subsection{System F}\label{sec:system_f}
% --------------------------------------------------------------------

\emph{System F} (or \emph{Second-order $\lambda$-calculus})

Universal Quantification over all Types

Can describe all Functions that are Provably Total in Second-order
Logic (\S\ref{sec:secondorder_logic})



% --------------------------------------------------------------------
\subsection{Dependently-typed $\lambda$-Calculus}
\label{sec:dependently_typed}
% --------------------------------------------------------------------

Dependent Types (\S\ref{sec:dependent_type})

Dependently-typed $\lambda$-calculus is base of Intuitionistic Type
Theory (\S\ref{sec:intuitionistic_type}), Calculus of Constructions
(\S\ref{sec:coq}), and Logical Framework
(\S\ref{sec:logical_framework}).

Dependently-typed $\lambda$-calculus with a Type of all Types (the
simplest Pure Type System \S\ref{sec:pure_type_system}) is not
Strongly Normalizing due to Girard's Paradox
(\S\ref{sec:girards_paradox})



\subsubsection{Logical Framework}\label{sec:logical_framework}



% --------------------------------------------------------------------
\subsection{$\kappa$-calculus}\label{sec:kappa_calculus}
% --------------------------------------------------------------------

First-order fragment of Typed $\lambda$-calculus



% ====================================================================
\section{Intuitionistic Type Theory}\label{sec:intuitionistic_type}
% ====================================================================

\emph{Intuitionistic Type Theory} (also \emph{Constructive Type
  Theory} or \emph{Martin-L\"of Type Theory})

Inductive Types



% --------------------------------------------------------------------
\subsection{Constructive Type}\label{sec:constructive_type}
% --------------------------------------------------------------------

\emph{Function Type}

\emph{Higher-order Function}

\emph{Product Type}

\subsubsection{Empty Type $\mathbf{0}$}

\subsubsection{Unit Type $\mathbf{1}$}

\subsubsection{Natural Number Type}

\subsubsection{Identity Type}

\subsubsection{Dependent Function Type ($\Pi$-type)}

\[
  A \rightarrow B :\equiv \prod_{x:A} B
\]

\subsubsection{Dependent Pair Type ($\Sigma$-type)}

In Set Theory: Indexed Sum over a given Type.

\subsubsection{Coproduct Type}



% ====================================================================
\section{Calculus of Constructions}\label{sec:coq}
% ====================================================================



% ====================================================================
\section{Homotopy Type Theory}\label{sec:homotopy_type}
% ====================================================================

Homotopy Thoery (\S\ref{sec:homotopy_theory})

- Function Extensionality
- Univalence Axiom

- Values (Points), Paths, Homotopies


% --------------------------------------------------------------------
\subsection{Higher Inductive Type}\label{sec:higher_inductive_type}
% --------------------------------------------------------------------



% ====================================================================
\section{Pure Type System}\label{sec:pure_type_system}
% ====================================================================

Arbitrary number of Sorts and Dependencies

Generalization of the \emph{Lambda Cube} to more sorts than Terms and
Types

Not necessarily Strongly Normalizing (\S\ref{sec:normalization})

Barendregt-Geuvers-Klop Conjecture



% --------------------------------------------------------------------
\subsection{Lambda Cube}\label{sec:lambda_cube}
% --------------------------------------------------------------------

Simply-typed $\lambda$-calculus allows only Terms to depend on Types.

All Strongly Normalizing



% --------------------------------------------------------------------
\subsection{Girard's Paradox}\label{sec:girards_paradox}
% --------------------------------------------------------------------



% ====================================================================
\section{Curry-Howard Correspondence}\label{sec:curry_howard}
% ====================================================================

\begin{tabular}{| l | l |}
\hline
\textbf{Type Theory} & \textbf{Logic} \\ \hline \hline
$A$ (Type) & Proposition \\ \hline
$a : A$ (Term) & Proof \\
\hline
\end{tabular}

Natural Deduction - Typed Lambda Calculus

Minimal Logic - Simple Types (Simply-typed $\lambda$-calculus
\S\ref{sec:simply_typed})

Predicate Logic - Dependent Types (Intuitionistic Type Theory
\S\ref{sec:intuitionistic_type})

Modal Logic - Monads

Classical-Intuitionistic Embedding - Continuation Passing Style



% ====================================================================
\section{Type System}\label{sec:type_system}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Hindley-Milner Type System}\label{sec:hindley_milner}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Type Checking}\label{sec:type_checking}
% --------------------------------------------------------------------
