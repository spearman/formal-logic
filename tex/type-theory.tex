%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Type Theory}\label{part:type_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Type Theory} is the study of Classes of Formal Systems
(\S\ref{sec:formal_system}) where each Term (\S\ref{sec:term}) has a
\emph{Type} (\S\ref{sec:type}) and Operations are restricted to Terms
of specific Types.

A Type Theory may have two Signatures: $\sigma_\tau$ for Type Symbols
and $\sigma_o$ for Object (Term) Symbols. From this one may construct
a Monad $R = R_{\sigma_o}$, a Module over $R$: $LM =
LM_{\sigma_\tau,\sigma_o}$, and a Contextual Category
(\S\ref{sec:contextual_category}) $CC(R,LM)$ describing a Class of
Sub-quotients of $CC(R,LM)$ in terms of Objects Constructed from $R$
and $LM$. \cite{voevedsky14}

For Multi-sorted Type Theory see Pure Type Systems
(\S\ref{sec:pts})

As a Formal Theory (\S\ref{sec:formal_theory}), Judgements
(\S\ref{sec:judgement}) in Type Theory are of three
kinds\cite{hott13}:
\begin{enumerate}

\item \emph{Well-formed Context} (\S\ref{sec:type_context}):
  \[
    (\Gamma) \ctx
  \]
  ``$\Gamma$ is a Well-formed Context''

\item \emph{Propositional Equality} (Typing Judgement
    \S\ref{sec:typing_judgement}):
  \[
    \Gamma \vdash a : A
  \]
  ``Given Contex $\Gamma$, $a$ is a Term of Type $A$''

\item \emph{Definitional (Judgemental) Equality}:
  \[
    \Gamma \vdash a \equiv b : A
  \]
  ``Given Context $\Gamma$, $a$ and $b$ are Definitionally Equal Terms
  of Type $A$''

\end{enumerate}
with a Deductive Apparatus (\S\ref{sec:deductive_apparatus})
consisting of Inference Rules (\S\ref{sec:type_inference}) only and no
Axioms. Judgemental Equality is an Equivalence Relation respected by
Typing.

every Type Theory gives rise to a Cartesian Multicategory
(\S\ref{sec:cartesian_multicategory}) with Objects as Types and
Multimorphisms as Terms



\textbf{Intensional \& Extensional Type Theory}

\begin{itemize}
\item \emph{Extensional Type Theory} (\S\ref{sec:extensional_type}):
  Definitional (Computational) Equality is not distinguished from
  Propositional (Proof) Equality (Strict Equivalence) but Type Checking
  (\S\ref{sec:type_checking}) is Undecidable

\item \emph{Intensional Type Theory}: Type Checking is Decidable but
  Extensional Reasoning must be carried out using Setoids
  (\S\ref{sec:setoid}); (Weak Equivalence)

\item \emph{Observational Type Theory}
  (\S\ref{sec:observational_type}): Definitional (Intensional)
  Equality and Type Checking are Decidable, Propositional Equality is
  Extensional and Substitutive; a first-approximation of Homotopy Type
  Theory where OTT Propositions are $h$-propositions
  (\S\ref{sec:h_proposition}) and OTT Types are $h$-sets
  (\S\ref{sec:h_set})

\item \emph{Homotopy Type Theory} (\S\ref{sec:hott}):
  Higher Inductive Types (\S\ref{sec:higher_inductive_type}) allow
  definition of Higher-order Constructors
\end{itemize}

Term Rewrite System (\S\ref{sec:term_rewriting})

\emph{Conversion Rules}

\emph{Canonical Form} (\S\ref{sec:canonical_form})

\emph{Normal Form}


Meaning Explanation (\S\ref{sec:meaning_explanation})


\asterism


Intuitionistic Type Theory (\S\ref{sec:intuitionistic_type}): Agda

Calculus of Constructions (\S\ref{sec:coc}): Coc


\asterism

Harper16 - Computational Higher Type Theory:

two traditions:

\begin{itemize}
  \item Formal (Axiomatic): Intuitionistic Type theory
    (\S\ref{sec:intuitionistic_type}), Homotopy Type Theory
    (\S\ref{sec:hott})
  \item Computational (Semantic): CMCP (???) %FIXME
\end{itemize}

%FIXME xrefs

\textbf{Formal}

Univalence Axiom: Function Extensionality

Higher Inductive Types


\textbf{Semantic}

Meaning-explanations:
\begin{itemize}
  \item Computational: Programs with Deterministic Dynamics (Type
    Theory as a Programming Language)
  \item Mathematical: Sets, Functions
\end{itemize}

\emph{Computational}

Types are Behavioral Specifications

Types and Objects are Programs that Execute

Judgements not intended to be decidable

Cubical Type Theory (\S\ref{sec:cubical_type_theory})


\asterism


2016 - Shulman - ``What is a Formal Proof'': %FIXME

In Type Theory, Derivation Trees (Concrete Syntax Trees
\S\ref{sec:concrete_syntax}) are Inductively Defined Structures that
can be used to Prove a Soundness Theorem.

Terms as One-dimensional Syntactic Representations of Derivation Trees
(or parts of them)

Notion of ``Term'' plays the role of Informal ``Argument'';
``Type-checking'' is about getting from Argument to Proof

``Well-typed Terms'' (those that represent Derivation Trees) are
distinguished from larger Class of ``Untyped Terms''

Untyped Terms are a sort of Argument that may or may not give rise to
a Proof

\emph{Decidable Static Type-Checking}: Decision Algorithm on Untyped
Terms determining whether the Term represents a Derivation Tree or not
in a Finite amount of time

``Decidable Checking'' is not a fundamental Property of a Proofs in a
Formal System but a Property of a certain Class (???) of Arguments
that might or might not represent Proofs.

``Elaborators'' of Theorem Provers fill in implicit arguments of
incomplete Terms that do not represent Derivation Trees to generate
instructions for a Proof Checker to easily reconstruct the Proof using
a specific Algorithm



% ====================================================================
\section{Expression}\label{sec:type_expression}
% ====================================================================

An \emph{Expression} (Syntactic Expression \S\ref{sec:expression}) is
an Equivalence Class of Syntactic Forms which differ in the Names of
\emph{Bound Variables}. That is, changing the Name of a Bound Variable
everywhere within an Expression (\emph{$\alpha$-conversion}
\S\ref{sec:alpha_conversion}) does not change the Expression.

some Expressions:
\begin{itemize}
  \item Term (\S\ref{sec:term})
  \item Type (\S\ref{sec:type})
  \item Proposition (\S\ref{sec:proposition})
  \item Context (\S\ref{sec:context})
\end{itemize}

\fist See also $\lambda$-expression (\S\ref{sec:lambda_expression})

A Variable is Bound in an Expression by an \emph{Abstraction} (e.g.
$\lambda$-abstraction \S\ref{sec:lambda_abstraction}) expressing that
the Variable is \emph{Local} to the Expression:
\[
  \lambda x.B
\]
or:
\[
  x.B
\]

\emph{Substitution} (e.g. $\lambda$-substitution
\S\ref{sec:lambda_substitution}):
\[
  [a \backslash x]B
\]
or:
\[
  B[a/x]
\]

Substitute Term $a$ for Free occurrences of Variable $x$ in the Term
$B$. Generalized:
\[
  B[x_1,\ldots,x_n / a_1,\ldots,a_n]
\]

\fist See also Substitution (Logic \S\ref{sec:substitution})


\asterism

nLab:

$\beta$-reduction (\S\ref{sec:beta_reduction}) -- how to Simplify a Term
that involves an Eliminator Applied to a Constructor, e.g.
$\lambda$-application (Eliminator) Applied to $\lambda$-abstraction
(Constructor):
\[
  (\lambda x.b)(a):B
\]
$\beta$-reduces (or Evaluates or Computes) to:
\[
  b[a/x]
\]
where $b : A \rightarrow B$, $a:A$

$\eta$-reduction (\S\ref{sec:eta_reduction}) -- how to Simplify a Term
that involves a Constructor applied to an Eliminator, e.g.
$\lambda$-abstraction (Constructor) Applied to $\lambda$-application
(Eliminator):
\[
  \lambda x.f(x)
\]
$\eta$-reduces to:
\[
  f
\]



% --------------------------------------------------------------------
\subsection{Term Constant}\label{sec:term_constant}
% --------------------------------------------------------------------

A \emph{Term Constant} is a Term that is a Base Type
(\S\ref{sec:type_constant})
% FIXME ???



% --------------------------------------------------------------------
\subsection{Well-typed Term}\label{sec:well_typed}
% --------------------------------------------------------------------

A \emph{Well-typed Term} (or \emph{Typable Term}) is a Term for which
a Typing Derivation (\S\ref{sec:typing_derivation}) exists.



% --------------------------------------------------------------------
\subsection{Term Constructor}\label{sec:term_constructor}
% --------------------------------------------------------------------

(or \emph{Data Constructor})

\fist Cf. Type Constructor (\S\ref{sec:type_constructor})



% --------------------------------------------------------------------
\subsection{$\alpha$-conversion}\label{sec:alpha_conversion}
% --------------------------------------------------------------------

\emph{$\alpha$-conversion} (or \emph{$\alpha$-renaming}) is a renaming
of Bound Variables in a Term that results in an $\alpha$-equivalent
(\S\ref{sec:alpha_equivalence}) Term:
\[
  \lambda x.x =_\alpha \lambda y.y
\]

\emph{Variable Convention}:
\begin{enumerate}
  \item Bound Variables are distinct from Free Variables
  \item ``Binders'' only Bind Variables not already in Scope % FIXME
\end{enumerate}

When represented as De Bruijn Indices (\S\ref{sec:debruijn_index}),
$\alpha$-equivalent Expressions are Syntactically identical.

\fist See also Nominal Logic (\S\ref{sec:nominal_logic})



\subsubsection{$\alpha$-equivalence}\label{sec:alpha_equivalence}

\subsubsection{De Bruijn Index}\label{sec:debruijn_index}

\emph{De Bruijn Indices} ``name-free''

Higher-order Abstract Syntax (\S\ref{sec:hoas})

used in Idris $\mono{Core/TT.hs}$ explicit minimal core language to
provide ``locally nameless representation''



% --------------------------------------------------------------------
\subsection{$\beta$-conversion}\label{sec:beta_conversion}
% --------------------------------------------------------------------
\cite{seldin03}

A \emph{$\beta$-conversion} is a Sequence of Zero or more
\emph{$\beta$-reductions} (Contractions \S\ref{sec:contraction}) or
\emph{$\beta$-expansions} (reverse Contractions). A $\beta$-conversion
from Term $M$ to Term $N$ is denoted $M =_\beta^* N$.

$\beta$-reduction (\S\ref{sec:beta_reduction}):
\[
  (\lambda x.b)(a) \rightarrow_\beta b[a/x]
\]

$\beta$-expansion (\S\ref{sec:beta_expansion}):
\[
  b[a/x] \rightarrow_\beta (\lambda x.b)(a)
\]



\subsubsection{$\beta$-reduction}\label{sec:beta_reduction}

A \emph{$\beta$-reduction} is a Sequence of Zero or more Contractions
(\S\ref{sec:contraction}). A Term $M$ that Reduces to a Term $N$ is
written $M \rhd N$. $\beta$-reduction may not Terminate but
$\beta$-reduction is Confluent (\S\ref{sec:rewrite_confluence}).

Dual to $\eta$-expansion (\S\ref{sec:eta_expansion})

As a Semantics for Functional Programming, a $\beta$-reduction
corresponds to a Computational Step.

for Function Types (\S\ref{sec:function_type})

for Inductive Types (\S\ref{sec:inductive_type}): $\iota$-reduction
(\S\ref{sec:iota_reduction})

Synchronization in Session Calculus (\S\ref{sec:session_calculus})
\cite{orchard-yoshida16}



\paragraph{$\iota$-reduction}\label{sec:iota_reduction}\hfill

analogous reduction for Inductive Types (\S\ref{sec:inductive_type})



\subsubsection{$\beta$-expansion}\label{sec:beta_expansion}



% --------------------------------------------------------------------
\subsection{$\eta$-conversion}\label{sec:eta_conversion}
% --------------------------------------------------------------------

\emph{$\eta$-abstraction} ($\eta$-expansion \S\ref{sec:eta_expansion}):
\[
  y \rightarrow_\eta \lambda x.y(x)
\]
\emph{$\eta$-reduction} (\S\ref{sec:eta_reduction}):
\[
  \lambda x.y(x) \rightarrow_\eta y
\]

Extensional (\S\ref{sec:extension}) Equivalence of Expressions



\subsubsection{$\eta$-expansion}\label{sec:eta_expansion}

Dual to $\beta$-reduction (\S\ref{sec:beta_reduction})

introducing a Constructor/Eliminator Pair



\subsubsection{$\eta$-reduction}\label{sec:eta_reduction}



% --------------------------------------------------------------------
\subsection{Purity}\label{sec:pure_function}
% --------------------------------------------------------------------

\url{http://stackoverflow.com/questions/602444/functional-declarative-and-imperative-programming}

\emph{Purity} of a \emph{Pure Function} applies to the
\emph{Implementations} of Functions:
\begin{itemize}
  \item the only observable Output is the Return Value
  \item the only Output Dependency is the Arguments
  \item the Arguments are fully determined before any Output is
    generated
\end{itemize}

\fist Cf. Referential Transparency
(\S\ref{sec:referential_transparency}): applies to \emph{Expressions}
the condition that replacing an Expression with the Value it Evaluates
to will not change the Behavior of a Program

Impure Functions may make Referentially Transparent Expressions in a
Concurrent Computation (\S\ref{sec:concurrent_computation}): Purity is
broken at the \emph{Interrupt Abstraction Layer} %FIXME

if:
\begin{itemize}
  \item all Identifiers are Immutable
  \item there is no accessible External State (i.e. I/O)
  \item there is no \emph{Abstraction Layer} breakage
\end{itemize}
then Functions are always Pure



% --------------------------------------------------------------------
\subsection{Referential Transparency}\label{sec:referential_transparency}
% --------------------------------------------------------------------

%FIXME move to recursion theory, effect systems ?

A \emph{Referentially Transparent Expression} can always be replaced
with the Value it Evaluates to without changing Program Behavior

no Side-effects (\S\ref{sec:effect})

Functional Programming

Value calculated only based on the Expression that
denotes it

allows for:
\begin{itemize}
\item Reuse -- reduced Code Duplication
\item Refactoring -- freedom from Side-effects
\item Equational Reasoning
\end{itemize}

Referential Transparency applies to \emph{Expressions} (e.g. Function
Calls)

\emph{Purity} (\S\ref{sec:pure_function}) applies to
\emph{Implementations} of Functions:
\begin{itemize}
  \item the only observable Output is the Return Value
  \item the only Output Dependency is the Arguments
  \item the Arguments are fully determined before any Output is
    generated
\end{itemize}

Impure Functions may make Referentially Transparent Expressions in a
Concurrent Computation (\S\ref{sec:concurrent_computation})



\subsubsection{Declarative Expression}\label{sec:declarative_expression}

\url{http://stackoverflow.com/questions/602444/functional-declarative-and-imperative-programming}

an Expression is \emph{Declarative} if all of its Sub-expressions are
Referentially Transparent

Declarative Languages:
\begin{itemize}
  \item no Looping Control Structures: due to Immutability the Loop
    Condition would never change
  \item only Control-flow is nested Function order (\emph{Logical
    Dependencies})
  \item nested Functions may be of a ``higher-level'' Semantics but
    due to Immutability the results cannot depend on Mutable State but
    only the order of nesting the Function Calls (i.e.
    Sub-expressions)
\end{itemize}

thus Evaluation Order of Sub-expressions can only give a varying
result when any of the Function Calls are not Referentially
Transparent (i.e. the Function is not Pure)

%FIXME



\subsubsection{Imperative Expression}\label{sec:imperative_expression}

%FIXME



% ====================================================================
\section{Type}\label{sec:type}
% ====================================================================

Formula (\S\ref{sec:formula})

Proposition (\S\ref{sec:proposition})

%FIXME move dependent types?

Dependent Types (\S\ref{sec:dependent_type})

\emph{Proper Type}, Inhabited Type (\S\ref{sec:inhabited_type}) a Type
which has Values (Terms?)

\fist Cf. Kind (\S\ref{sec:kind})


``Datatypes'' as Fixed Points of Endofunctors: $F$-algebra
(\S\ref{sec:f_algebra}), $F$-coalgebra (\S\ref{sec:f_coalgebra})
%FIXME

``Data Types'' (\S\ref{sec:data_type}) assigned to Values

``Classes'' (\S\ref{sec:type_class}) assigned to Objects

``Kinds'' (\S\ref{sec:kind}) assigned to Types



% --------------------------------------------------------------------
\subsection{Data Type}\label{sec:data_type}
% --------------------------------------------------------------------

Type of a Value



% --------------------------------------------------------------------
\subsection{Well-formed Type}\label{sec:wellformed_type}
% --------------------------------------------------------------------

%FIXME

Type Expression (\S\ref{sec:type_expression}) is Well-formed if given
Constructor (? Type Operator \S\ref{sec:type_operator}) Expression has
Kind (\S\ref{sec:kind}) $\star$



% --------------------------------------------------------------------
\subsection{Type Variable}\label{sec:type_variable}
% --------------------------------------------------------------------

Type Operator (\S\ref{sec:type_operator})

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism}):
Universally Quantified Type Variables

Abstract (Existential) Types (\S\ref{sec:abstract_type}):
Existentially Quantified Type Variables



% --------------------------------------------------------------------
\subsection{Type Constant}\label{sec:type_constant}
% --------------------------------------------------------------------

\emph{Type Constant} (also \emph{Primitive Type} or \emph{Base Type}
or \emph{Atomic Type})

Uninterpreted (\S\ref{sec:uninterpreted_function}) % FIXME ?



% --------------------------------------------------------------------
\subsection{Composite Type}\label{sec:composite_type}
% --------------------------------------------------------------------

Algebraic Types (\S\ref{sec:algebraic_type})



% --------------------------------------------------------------------
\subsection{Type Order}\label{sec:type_order}
% --------------------------------------------------------------------

In Simply-typed $\lambda$-calculus ($\lambda^\rightarrow$
\S\ref{sec:simply_typed})), the \emph{Order} of a Type $\tau$, denoted
$o(\tau)$, is defined Inductively as:
\begin{itemize}
\item $o(T) = 0$ if $T$ is a Base Type (\S\ref{sec:type_constant})
\item $o(\sigma \rightarrow \tau) = \text{max}(o(\sigma) + 1,
  o(\tau))$
\end{itemize}



% --------------------------------------------------------------------
\subsection{Type Polarity}\label{sec:type_polarity}
% --------------------------------------------------------------------

Constructors (\S\ref{sec:constructor})

Deconstructors (\S\ref{sec:deconstructor})


\asterism


Data Constructor

A \emph{Constructor} Introduces a Data Type on the right-hand side of
a definition.

A \emph{Destructor} Eliminates a Data Type on the left-hand side of a
definition.

Elimination for (Finite) Data corresponds to (Well-founded)
Recursion.

Introduction for Codata corresponds to Corecursion.

%FIXME



\subsubsection{Constructor}\label{sec:constructor}

Term Constructor (\S\ref{sec:term_constructor})

Type Constructor (\S\ref{sec:type_constructor})



\subsubsection{Deconstructor}\label{sec:deconstructor}

(or \emph{Eliminator})



\subsubsection{Positive Type}\label{sec:positive_type}

\url{https://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/}:

a \emph{Positive Type} is one that is defined by its ``Membership
Conditions'' (Constructors) -- Positive Types are Colimits
(\S\ref{sec:colimit})

nLab:

\emph{Constructors} regarded as ``primary'': Eliminators are Derived
from Constructors by the Rule that to ``Use'' (Eliminate) an Element
of a Positive Type it is necessary and sufficient to specify what
should be done for all possible ways the Element could have been
Constructed

e.g. Inductive Types (\S\ref{sec:inductive_type}): Sum Type, Product
Type$^*$, Dependent Sum Type, Empty Type, Unit Type, Identity Type
%FIXME

Lists

Categorical Semantics: ``From the left'' Universal Properties, i.e.
``Mapping out'' ???

Denotational Semantics: well-behaved with respect to Strict Evaluation
Strategies (\S\ref{sec:strict_evaluation})



\subsubsection{Negative Type}\label{sec:negative_type}

\url{https://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/}:

a \emph{Negative Type} is one that is defined by its ``Behavioral
Conditions'' (Destructors) -- Negative Types are Limits
(\S\ref{sec:limit})

nLab:

\emph{Eliminators} regarded as ``primary'': Constructors are Derived
from Eliminators by the Rule that to Construct an Element of a
Negative Type it is necessary and sufficient to specify how that
Element ``behaves'' when Applying all of the Eliminators to it

e.g. Coinductive Types (\S\ref{sec:coinductive_type}), Dependent
Product Types (\S\ref{sec:dependent_product}): Function Type
%FIXME

Streams

Categorical Semantics: ``From the right'' Universal Properties, i.e.
``Mapping in'' ???

Denotational Semantics: well-behaved with respect to Non-strict
Evaluation Strategies (\S\ref{sec:nonstrict_evaluation})



% --------------------------------------------------------------------
\subsection{Inhabited Type}\label{sec:inhabited_type}
% --------------------------------------------------------------------

\emph{Inhabited}

$\Gamma \vdash A\;\mathrm{true}$

$\Gamma \vdash a:A \Rightarrow \Gamma \vdash A\;\mathrm{true}$

In Simply-typed $\lambda$-calculus (\S\ref{sec:simply_typed}), a Type
is Inhabited if and only if its corresponding Proposition is a
Tautology of Minimal Implicative Logic (\S\ref{sec:minimal_logic}).

In Second-order $\lambda$-calculus (\S\ref{sec:system_f}), a
Type is Inhabited if and only if its corresponding Proposition is a
Tautology of Second-order Logic (\S\ref{sec:secondorder_logic}).

Empty Type (\S\ref{sec:empty_type})



% --------------------------------------------------------------------
\subsection{Finite Type}\label{sec:finite_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Infinite Type}\label{sec:infinite_type}
% --------------------------------------------------------------------

Infinite Data Type (\S\ref{sec:infinite_datatype})



% --------------------------------------------------------------------
\subsection{Universe Type}\label{sec:universe_type}
% --------------------------------------------------------------------

A \emph{Universe Type} contains all other Types, see Type Universe
(\S\ref{sec:type_universe}).



% --------------------------------------------------------------------
\subsection{Empty Type}\label{sec:empty_type}
% --------------------------------------------------------------------

Type with no Terms

\[
  \frac{}
  {\emptyset:\Type}
\]

%FIXME

Positive Type (\S\ref{sec:positive_type}): no Constructors

Negative Type (\S\ref{sec:negative_type}): Eliminator for any Term of
any Type ???

since the Empty Type contains no Elements, there are no Constructor
Rules; given an Element of $\emptyset$ one can Construct an Element of
any Type

the Positive and Negative definitions are Provably Equivalent, but
only using Contraction and Weakining Rules; therefore in Linear Type
Systems (\S\ref{sec:linear_type}) they are distinct with the Positive
Empty Type $0$ and Negative Empty Type $\bot$.

Dhall: Empty Variant $<>$, cf. Empty Tuple ${}$ for Unit Type



% --------------------------------------------------------------------
\subsection{Unit Type}\label{sec:unit_type}
% --------------------------------------------------------------------

``the'' Type with a Unique Term; special case of Product: Nullary
Product

\[
  \frac{}
  {():\Unit}
\]

Positive Type (\S\ref{sec:positive_type}): single Constructor $()$

Negative Type (\S\ref{sec:positive_type}): no Eliminators

Equivalence of Positive and Negative definitions uses Contraction and
Weakening Rules; therefore in Linear Type Systems
(\S\ref{sec:linear_type}) they are distinct with the Positive Unit
Type $1$ and Negative Unit Type $\top$.

Homotopy, Contractible Type %FIXME

Dhall: Empty Tuple ${}$, cf. Empty Variant $<>$ for the Empty Type



% --------------------------------------------------------------------
\subsection{Equality Type}\label{sec:equality_type}
% --------------------------------------------------------------------

The \emph{Equality Type} (or \emph{Identity Type}), denoted
\emph{Propositional Equality}, represents Equality of Types and Terms.

$a =_A b$: ``$a$ and $b$ are Equal Objects of Type $A$''

Martin-L\"of Notation $I(A,a,b)$

For $a,b:A$, the Term $a = b : I(A,a,b)$ Denotes the Type of Equality
Proofs for ``$a$ is Equal to $b$''. If the Type $I(A,a,b)$ is
Inhabited (a Proof exists), then $a$ is Equal to $b$.

There is one Canonical Inhabitant of $I(A,a,a)$ (Proof of
Reflexivity):
\[
  \text{refl}: \prod_{a:A} (a=a)
\]



\subsubsection{Congruence Type}\label{sec:congruence_type}

%FIXME equality type?



% --------------------------------------------------------------------
\subsection{Quotient Type}\label{sec:quotient_type}\hfill
% --------------------------------------------------------------------

Set Theoretic Quotients

Categorical Semantics: Quotient Object (\S\ref{sec:quotient_object}) /
Coequalizer (\S\ref{sec:coequalizer})



% --------------------------------------------------------------------
\subsection{Algebraic Type}\label{sec:algebraic_type}
% --------------------------------------------------------------------

Trees (\S\ref{sec:tree})

All standard Algebraic Data Types are Functors (\S\ref{sec:functor}).
A Parametrically Polymorphic (\S\ref{sec:parametric_polymorphism})
Function between two such Functors is a Natural Transformation
(\S\ref{sec:natural_transformation}).

Algebraic Types form a Semiring (\S\ref{sec:semiring})

\emph{Algebraic}: not involving Quantifiers %FIXME



\subsubsection{Product Type}\label{sec:product_type}

(or \emph{Record Type})

(Cartesian) Product Types: Structs, Tuples

several Values called \emph{Fields}

If $\sigma$ and $\tau$ are Types, then $\sigma \times \tau$ is a Type

$x : \sigma$, $y : \tau$, $(x,y) : \sigma \times \tau$

$fst_{\sigma,\tau} : (\sigma \times \tau) \Rightarrow \sigma$

$snd_{\sigma,\tau} : (\sigma \times \tau) \Rightarrow \tau$

Corresponds to Cartesian Product (\S\ref{sec:cartesian_product})

Product Type $A \times B$ is a special case of Dependent Sum Type
(\S\ref{sec:sigma_type}) $(\Sigma x:A)B$ with a Constant Codomain
Type $B$:
\[
  (\Sigma x:A) B \equiv A \times B
\]
where $\equiv$ is Judgemental Equality.



\subsubsection{Sum Type}\label{sec:sum_type}

(also \emph{Coproduct Type} or \emph{Variant Type} or \emph{Tagged
  Union})

several Classes of Values called \emph{Variants}

Corresponds to Disjoint Union (\S\ref{sec:disjoint_union})

Coproduct (\S\ref{sec:coproduct})

Choices, Multiple ``Classes'' of Data



% --------------------------------------------------------------------
\subsection{Inductive Type}\label{sec:inductive_type}
% --------------------------------------------------------------------

\emph{Inductive Type} (or \emph{Recursive Type})

W-type

Monotonic Type Operators $\Theta : \sigma \Rightarrow \tau$

``Tree-like''

Initial Algebras (\S\ref{sec:initial_algebra})

Type Constructor (\S\ref{sec:type_constructor})

Structural Recursion (\S\ref{sec:structural_recursion})

Streams between interacting processes in Programming Languages
Recursive Data Type

Calculus of Inductive Constructions (\S\ref{sec:cic})


\asterism

Recursive Data Type

Values may contain Values of the same Type

Well-founded (\S\ref{sec:well_founded})

general form:
\[
  \mu\alpha.T
\]

$\alpha$ -- Type Variable: may appear in the Type $T$ and stands for
the entire Type itself

example Natural Numbers:
\[
  nat = \mu\alpha.1 + \alpha
\]

$roll : T[\mu\alpha.T/\alpha] \rightarrow \mu\alpha.T$

$unroll : \mu\alpha.T \rightarrow T[\mu\alpha.T/\alpha]$

Isorecursive (\S\ref{sec:isorecursive_type}): $roll$ and $unroll$
are Inverses

Equirecursive (\S\ref{sec:equirecursive_type}): $unroll$ is the
Identity



\subsubsection{Isorecursive Type}\label{sec:isorecursive_type}

$roll$ and $unroll$ are Inverse Functions



\subsubsection{Equirecursive Data Type}\label{sec:equirecursive_type}

$unroll$ is an Identity



\subsubsection{Mutually Recursive Type}
\label{sec:mutually_recursive}\hfill

a Forest (\S\ref{sec:forest_type}) is a Mutually Recursive Definition
of a Tree (\S\ref{sec:tree_type})



\subsubsection{Guarded Recursive Data Type}
\label{sec:grdt}

\emph{GRDT}

\fist GADTs (\S\ref{sec:gadt})

\fist Equality Constrained Types (Phantom Types
\S\ref{sec:equality_constrained})

Xi16:

GRDTs can be thought of as an \emph{Impredicative} form of Dependent
Type where Type Indices themselves are Types



\subsubsection{Induction Induction}\label{sec:induction_induction}

\emph{Induction Induction}



\subsubsection{Induction Recursion}\label{sec:induction_recursion}

\emph{Induction Recursion}

a principle for mutually defining Types of the form:
\[
  A : \Type
\]
and:
\[
  B : A \rightarrow Type
\]
where $A$ is an Inductive Type and $B$ is defined by Recursion on $A$
and the definition of $A$ may use $B$

Universes (\S\ref{sec:type_universe}) defined Internally via
Induction-recursion are (Strongly) Tarskian

Dybjer-Setzer99



\subsubsection{Initial \& Final Type}\label{sec:initial_final_type}

\emph{Initial Data Types} are defined by the Least Fixed Point
(\S\ref{sec:least_fixedpoint}), up to Isomorphism given by an Initial
Algebra (\S\ref{sec:initial_algebra}), of a Type Operator
(\S\ref{sec:type_operator}). Ordinary Recursion
(\S\ref{sec:recursion}) defines Recursive Functions with an Initial
Data Type for a Domain.

\emph{Final Data Types} are defined, up to Isomorphism given by a
Final Coalgebra (\S\ref{sec:terminal_coalgebra}) by the Greatest
Fixpoint. Corecursion (\S\ref{sec:corecursion}) defines Recursive
Functions with a Final Data Type as a Codomain.

Initial (\S\ref{sec:initial_object}) \& Terminal
(\S\ref{sec:terminal_object}) Objects

In $\mathbf{Set}$, the Final Data Types may have Infinite,
Non-well-founded (\S\ref{sec:non_wellfounded}) Values.

In $\mathbf{Cpo}$ (the Category of Complete Partial Orders
\S\ref{sec:complete_partialorder} and Continuous Functions), Final
Types coincide with Initial Types and the corresponding Initial
Algebra and Final Coalgebras are Isomorphic.



\subsubsection{Infinite Data Type}\label{sec:infinite_datatype}

(Proof Object) Definition by Recursion: Proof by Induction



\subsubsection{Tree}\label{sec:tree_type}

Tree (Graph Theory \S\ref{sec:tree})

Mutally Recursive Definition: Forest (\S\ref{sec:forest_type})



\subsubsection{Forest}\label{sec:forest_type}

Mutually Recursive Definition of a Tree (\S\ref{sec:tree_type})



% --------------------------------------------------------------------
\subsection{Coinductive Type}\label{sec:coinductive_type}
% --------------------------------------------------------------------

\emph{Coinductive Type} (\emph{Codata}), Coinduction
(\S\ref{sec:coinduction})

Terminal Coalgebras (\S\ref{sec:terminal_coalgebra})



% --------------------------------------------------------------------
\subsection{Concrete Type}\label{sec:concrete_type}
% --------------------------------------------------------------------

\fist Cf. Abstract (Existential) Type (\S\ref{sec:abstract_type})



% --------------------------------------------------------------------
\subsection{Abstract Type}\label{sec:abstract_type}
% --------------------------------------------------------------------

\emph{Abstract Type} (or \emph{Existential Type})

Type in a Nominal Type System (\S\ref{sec:nominal_type_system}) that
cannot be Instantiated (\S\ref{sec:instantiation}) directly.

wiki: Type defined by its Semantics from the point of view of a
\emph{User} of the Data (as opposed to the \emph{Implementor} as in
Concrete Data Structures \S\ref{sec:concrete_type})

Existentially Quantified Type Variable

Programming: Module Interfaces

Rust: ``Trait Objects''

Type Erasure (\S\ref{sec:type_erasure}), Dynamic Dispatch (???)

Second-order Typed $\lambda$-calculus with Existential Quantification
(whereas System $F$ is Second-order Typed $\lambda$-calculus with
Universal Quantification.

a Type that is not Abstract is a Concrete Type
(\S\ref{sec:concrete_type})

Abstract Type with no Implementation: Protocol, Interface, etc.

examples:

\emph{Monads} (\S\ref{sec:monad}) define an Interface for the Abstract
Type of ``Program Fragments''


\asterism


Abstract Data Type

Type defined by certain Properties %FIXME

Type (with associated Operations) whose Representation is hidden

Co-algebra (\S\ref{sec:coalgebra})

\begin{itemize}
  \item Primitive (Base) Types (\S\ref{sec:type_constant}) -- in
    certain Programming Languages (e.g. Haskell)
  \item Parameterized (Generic) Types (\S\ref{sec:generic_type}) -- a
    weak form of Abstract Type; an instance of Parametric Polymorphism
    \S\ref{sec:parametric_polymorphism})
  \item Type Class (Constrained Type \S\ref{sec:constrained_type})
\end{itemize}

Monads (\S\ref{sec:monad}) give the Interface to the Abstract Data
Type of ``Program Fragments'' (\fist Cf. Algebraic Effects
\S\ref{sec:algebraic_effect})



\subsubsection{Generic Type}\label{sec:generic_type}

\emph{Generic Type} (also \emph{Parameterized} or \emph{Parametric
  Type})

Weak form of Abstract Data Type

Universally Quantified Type Variable

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism})



\subsubsection{Guarded Type}\label{sec:guarded_type}

$P \Rightarrow T$ -- for Proposition $P$ and Type $T$

Xi16 -- Qualified Types (as in Haskell's Type Class mechanism) cannot
be Guarded Types as the Proof of a Guard cannot affect Run-time
behavior of a Program while a Dictionary (a Proof of some Predicate on
Types) for Qualified Types can affect the Run-time behavior



\subsubsection{Constrained Type}\label{sec:constrained_type}

Existentially Quantifid Type Variable

Ad-hoc Polymorphism (\S\ref{sec:adhoc_polymorphism}), Function
Overloading

\emph{Type Class} (\S\ref{sec:type_class})

\emph{Constructor Class} (\S\ref{sec:constructor_class})

Constraint Kind (???) %FIXME

Restricted Polymorphic Type %FIXME

Type Classes are used to define Overloaded Functions, Type Families
(\S\ref{sec:type_family}) are used to defined Overloaded Data

A Type Family declared in the definition of a Type Class is called an
\emph{Associated Type} (\S\ref{sec:associated_type}).

Type Classes define Partial Functions from Types to a collection of
Named Values by Pattern Matching on the Input Types

\fist Type Families define Partial Functions from Types to Types by
Pattern Matching on the Input Types

\fist Type Constructors (\S\ref{sec:type_constructor}) define
Injective Functions from all Types of a particular Kind
(\S\ref{sec:kind}) to a new Set of Types

\fist Type Synonyms (\S\ref{sec:type_synonym}) define Functions from
all Types of a particular Kind to another Set of Types using a single
``Case'' (???) %FIXME



\paragraph{Equality Constrained Type}
\label{sec:equality_constrained}\hfill

\emph{Phantom Type}

\fist GRDTs (\S\ref{sec:grdt})



\paragraph{Type Class}\label{sec:type_class}\hfill

\emph{Qualified Types} -- \cite{jones94} Jones94 \emph{Qualified
  types: Theory and Practice} -- underlies Haskell type class
mechanism

Xi16 -- Qualified Types (as in Haskell's Type Class mechanism) cannot
be Guarded Types (\S\ref{sec:guarded_type}) as the Proof of a Guard
cannot affect Run-time behavior of a Program while a Dictionary (a
Proof of some Predicate on Types) for Qualified Types can affect the
Run-time behavior

\cite{jones95}

intermediate between Monomorphic Types (Kind \S\ref{sec:kind} $\star$)
and fully Polymorphic Types (\S\ref{sec:polymorphic_type})

use Classes to represent Sets of Types, i.e. (Nullary?) Type
Constructors (\S\ref{sec:type_operator}) of Kind $\star$

special case of Constructor Classes (\S\ref{sec:constructor_class})
representing Sets of Types of any fixed Kind $\kappa$



\paragraph{Functional Dependency}\label{sec:functional_dependency}\hfill

used to Constrain the Parameters (dependencies between the Parameters)
of a (Multi-parameter) Type Class

%FIXME xref relational database theory



% --------------------------------------------------------------------
\subsection{Generalized Algebraic Data Type}\label{sec:gadt}
% --------------------------------------------------------------------

\fist GRDTs (\S\ref{sec:grdt})



% --------------------------------------------------------------------
\subsection{Logically Qualified Data Type}
\label{sec:logically_qualified}
% --------------------------------------------------------------------

\cite{rondon-kawaguchi-jhala08}

\emph{Liquid Type}

Predicate Abstraction (\S\ref{sec:predicate_abstraction})

Logical Qualifier: Boolean Predicate

Dependent Type where the Refinement Predicate
(\S\ref{sec:refinement_type}) is a Conjunction of Logical Qualifiers.

Value Variable

Base Refinement:
\[
  \{ v : B | e \}
\]
where $e$ is a Boolean-valued Expression constraining $v$ called a
\emph{Refinement Predicate}.



% --------------------------------------------------------------------
\subsection{Partial Type}\label{sec:partial_type}
% --------------------------------------------------------------------

\cite{thompson99}

Non-terminating Computations

Total Objects are Identified at Simple Types

Undefined Object ``Bottom'' $\uparrow$ is a Member of every Type

\[
  \sigma \rightarrow \tau \quad
  \sigma \rightarrow \overline{\tau} \quad
  \overline{\sigma} \rightarrow \overline{\tau} \quad
  \overline{\sigma \rightarrow \tau} \quad
  \overline{\sigma \rightarrow \overline{\tau}} \quad
  \overline{\overline{\sigma} \rightarrow \overline{\tau}} \quad
\]



% --------------------------------------------------------------------
\subsection{Type Synonym}\label{sec:type_synonym}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Type Conversion}\label{sec:type_conversion}
% --------------------------------------------------------------------

\subsubsection{Type Promotion}\label{sec:type_promotion}

Special case of Implicit Type Conversion



% ====================================================================
\section{Polymorphic Type}\label{sec:polymorphic_type}
% ====================================================================

Adding Polymorphic Types to Simply-typed $\lambda$-calculus
($\lambda\kern-5pt\rightarrow$ \S\ref{sec:simply_typed}) results in
\emph{Second-order $\lambda$-calculus} ($\lambda2$
\S\ref{sec:secondorder_lambda})

Terms depending on Types


Ad-hoc Polymorphism (\S\ref{sec:adhoc_polymorphism})

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism})

Subtype Polymorphism (\S\ref{sec:subtype_polymorphism})

Bounded Polymorphism (\S\ref{sec:bounded_polymorphism})


\asterism

%FIXME

$\tau \mapsto \sigma$

Introduction:
\[
  {
  \frac{
    \begin{matrix}
      x : \sigma \\
      \vdots \\
      b : B
    \end{matrix}
  }
  {b : \sigma \mapsto \tau}
  }(\mapsto I)
\]


\asterism


Restricted Rank

Rank-1 \emph{Prenex Polymorphism}: Type Variables may not be
instantiated with Polymorphic Types.

Rank-$k$: Quantifier may not appear to the left of $k$ or more Arrows;
Type Inference is decidable for Rank-2 but Rank-3 and above is not

Rank-$n$: Quantifier may appear to the left of arbitrarily many Arrows

Predicative: a Type $\tau$ containing a Type Variable $\alpha$ may not
have $\alpha$ Instantiated to a Polymorphic Type (Martin-L\"of Type
Theory \S\ref{sec:intuitionistic_type} and NuPRL).

Impredicative \emph{First-class Polymorphism}: Self-referential
(System F \S\ref{sec:system_f})

Parametric (\S\ref{sec:parametric_polymorphism}): Universal
Quantification

Abstract (Existential) Type (\S\ref{sec:abstract_type}): Existential
Quantification

The Type $(\exists x : A).B$ is inhabited by Pairs $(a,b)$ with $a:A$
and $b:B[a/x]$, i.e. the Sum of the Types $B(x)$ as $x$ ranges over
$A$ \emph{or} the Subset of $A$ consisting of those $a \in A$ with the
Property $B[a/x]$.

Bounded Quantification (\S\ref{sec:bounded_polymorphism})

\fist See also Polymorphic Kinds (\S\ref{sec:polymorphic_kind})



% --------------------------------------------------------------------
\subsection{Ad-hoc Polymorphism}\label{sec:adhoc_polymorphism}
% --------------------------------------------------------------------

\emph{Function Overloading}, \emph{Operator Overloading}

Polymorphic Functions (\S\ref{sec:polymorphic_function}) applied to
Terms of different Types

Ad-hoc Polymorphism is contrasted with Parametric Polymorphism by
supporting a limited number of distinct Types rather than any Type
whatsoever

Constrained Type (Type Class \S\ref{sec:constrained_type})



% --------------------------------------------------------------------
\subsection{Parametric Polymorphism}\label{sec:parametric_polymorphism}
% --------------------------------------------------------------------

Universally Quantified Type Variable

\emph{Parametricity}: Abstract Uniformity Property; captures the
intuition that all instances of a Polymorphic Function
(\S\ref{sec:polymorphic_function}) behave the same way for all Types
(``for all''); used to define Natural Transformations
(\S\ref{sec:natural_transformation}) in Programming Languages

Parametric (Generic) Type (\S\ref{sec:generic_type}): a weak form of
Abstract Type (\S\ref{sec:abstract_type})

Parametric (Generic) Function (\S\ref{sec:generic_function})

Example:
\[
  x:\tau \vdash id(x):\tau
\]
where the Type of the Term $id(x)$ is $\tau$, which is dependent on
the Type $\tau$ of $x$, where the Type of $id$:
\[
  id:\sigma \rightarrow \sigma
\]
is Universally Quantified ``$\forall \sigma$'':
\[
  id:\forall \sigma.\sigma \rightarrow \sigma
\]


having Pattern Matching on Types in a Type System would break
Parametricity (idris stackoverflow user Xash) %FIXME link

Type-level Function Abstraction $\Lambda$ (\S\ref{sec:type_operator})

Second-order $\lambda$-calculus (System F \S\ref{sec:system_f})

Bounded Polymorphism (\S\ref{sec:bounded_polymorphism}): Bounded
Quantification; Polymorphism restricted to Subtypes


\asterism


$\forall a.a \rightarrow a$ -- $id$

$\forall a.(a \rightarrow a) \rightarrow a$ -- $fix$

$\forall a.a \rightarrow (a \rightarrow a) \rightarrow a$ -- $eval$


$\forall a.a \rightarrow a \times a$ -- $\delta$

$\forall a.a \times a \rightarrow a$ -- $\pi_1$, $\pi_2$

$\forall a.a \times a \rightarrow a \times a$ -- $id$, $swap$


$\forall a.a \rightarrow a + a$ -- $inl$, $inr$

$\forall a.a + a \rightarrow a$ -- $match$

$\forall a.a + a \rightarrow a + a$ -- $id$, $retag$


$\forall a.a \rightarrow (a \rightarrow a)$ -- $true$, $false$


$\forall a.(a \rightarrow a) \rightarrow (a \rightarrow a)$ -- $f^n$
for $n \in \nats$


\asterism


\emph{Higher-rank Impredicative Polymorphism} (Impredicative
\S\ref{sec:impredicative_polymorphism}) -- most general

\emph{Predicative Prenex Polymorphism} (Restricted Rank and
Predicative \S\ref{sec:predicative_polymorphism}) --
``\emph{Let-polymorphism}''



\subsubsection{Predicative Polymorphism}
\label{sec:predicative_polymorphism}

Type $\tau$ containing Type Variable $\alpha$ may not be used such
that $\alpha$ is instantiated to a Polymorphic Type.

Martin-L\"of Type Theory, NuPRL



\subsubsection{Impredicative Polymorphism}
\label{sec:impredicative_polymorphism}

(or \emph{First-class Polymorphism})

most powerful

Impredicative Typed $\lambda$-calculi: Lambda Cube
(\S\ref{sec:lambda_cube}), esp. System F (\S\ref{sec:system_f})



% --------------------------------------------------------------------
\subsection{Subtype Polymorphism}\label{sec:subtype_polymorphism}
% --------------------------------------------------------------------

\subsubsection{Subtype}\label{sec:subtype}

\emph{Intersection Type}

\emph{Subtype Polymorphism}

$S <: T$

System $F_{<:}$ (\S\ref{sec:system_fsub})

Bounded Polymorphism (\S\ref{sec:bounded_polymorphism})

Subtyping Judgement:
\[
  \Gamma \vdash \tau_1 \preceq \tau_2
\]

Power Type (\S\ref{sec:power_type}) $P A$: Type of all Subtypes of $A$

Coherence



\paragraph{Conjunctive Type}\label{sec:conjunctive_type}\hfill

$\lambda$-calculus with Conjunctive Types
(\S\ref{sec:conjunctive_lambda})

System F$_{<:}$ (\S\ref{sec:system_fsub})

System F$_{<:}^\omega$ (\S\ref{sec:system_fsub}) -- Higher-order
Bounded Quantification



\subsubsection{Variance}\label{sec:type_variance}

\emph{Variance} describes how Type Constructors either preserve,
reverse, or ignore Subtyping on input Types.

\begin{itemize}
  \item \emph{Covariant}: Preserves Subtyping
  \item \emph{Contravariant}: Reverses Subtyping
  \item \emph{Bivariant}: Both Subtypes
  \item \emph{Invariant}: No Subtyping
\end{itemize}

$(\rightarrow)$ is Contravariant on the Input Type and Covariant on
the Output Type.



\subsubsection{Power Type}\label{sec:power_type}

$P A$ the Type of all Subtypes of $A$



\subsubsection{Intersection Type}\label{sec:intersection_type}

\paragraph{Refinement Type}\label{sec:refinement_type}\hfill

Predicate assumed to hold for any Element of Refined Type

\fist Cf. Behavioral Subtyping (\S\ref{sec:behavioral_subtype})

Type Targeted Testing, Liquid Types (Logically Qualified Types
\S\ref{sec:logically_qualified})


\asterism


\cite{mcbride13}:

Ornaments (\S\ref{sec:ornament}): Refinements as a ``Decoration'' with
``Logical Data''? %FIXME

Algebraic Ornament (\S\ref{sec:algebraic_ornament}): Type Refinement
Induced by Algebras over a Datatype's Structure



\paragraph{Predicate Subtype}\label{sec:predicate_subtype}\hfill



\subsubsection{Behavioral Subtype}\label{sec:behavioral_subtype}

\emph{Substitutability}

\fist Behavioral Types (\S\ref{sec:behavioral_type})



\subsubsection{Principal Type}\label{sec:principal_type}

Type System with Principal Type Property

given a Term, all other Types are instances of the Principal Type

Type Inference

%FIXME xref
Robinson's Unification Algorithm, used by Hindley-Milner Type
Inference

Polymorphic Recursion makes Inference of the Principal Type Undecidable

Generalized Algebraic Data Types negates the Principal Type Property



\subsubsection{Algebraic Subtyping}\label{sec:algebraic_subtyping}

Dolan16 - \emph{Algebraic Subtyping}:

difficulty integrating Type Inference with Subtyping due to the
Unification ``Engine'' accepts only \emph{Equations} not
\emph{Subtyping Constraints}

Dolan16 presents a Type System with:
\begin{itemize}
  \item (ML-style) Parametric Polymorphism
  \item (ML-style) Subtyping
  \item Type Inference based on \emph{Biunification}
    (\S\ref{sec:biunification})
  \item Principal Types
  \item Decidable Type Subsumption
\end{itemize}

exploints connections between Algebra of Regular Languages and
Polymorphic Subtyping



% --------------------------------------------------------------------
\subsection{Bounded Polymorphism}\label{sec:bounded_polymorphism}
% --------------------------------------------------------------------

\emph{Bounded Quantification} (or \emph{Bounded Polymorphism} or
\emph{Constrained Genericity})

Bounds on Type Parameters to range only over Subtypes
(\S\ref{sec:subtype}) of a particular Type

Type Class (\S\ref{sec:constrained_type})

Conjunctive Type (\S\ref{sec:conjunctive_type})



% --------------------------------------------------------------------
\subsection{Value Polymorphism}\label{sec:value_polymorphism}
% --------------------------------------------------------------------

Polymorphism restricted to \emph{Values}: a Subclass of Expressions
that can have no Computational Effects
(\S\ref{sec:computational_effect})



% --------------------------------------------------------------------
\subsection{Polymorphic Function}\label{sec:polymorphic_function}
% --------------------------------------------------------------------

A Polymorphic Function has a Dependent Product Type
(\S\ref{sec:pi_type}):
\[
  (\Pi A:\class{U}) F(A)
\]



\subsubsection{Polymorphic Recursion}\label{sec:polymorphic_recursion}

Recursive Parametrically Polymorphic Function

Type Inference under Polymorphic Recursion is Undecidable (equivalent
to Semi-unification) %FIXME



\subsubsection{Free Theorem}\label{sec:free_theorem}



% ====================================================================
\section{Behavioral Type}\label{sec:behavioral_type}
% ====================================================================

\url{http://www.behavioural-types.eu/}

Orchard-Yoshida16 \cite{orchard-yoshida16} -- ``(Intensional)
Behavioral Types'': Effect Types (\S\ref{sec:effect_system}) and
Session Types (\S\ref{sec:session_type}); two-way Embedding: Processes
(\S\ref{sec:process}) as Effect Handlers (\S\ref{sec:effect_handler}),
Session Types as Effects

H\"uttel et al. 2016 \emph{Foundations of Session Types and
  Behavioural Contacts} -- e.g. Types for Non-uniform Objects (Objects
with \emph{Non-uniform Method Availability}: Methods that can be
Enabled/Disabled depending on internal State)
\begin{itemize}
  \item Nierstrasz95 -- Traces of Menus \emph{Offered} by Objects as a
    notion of Behavioral Types with notion of Subtyping, \emph{Request
    Substitutability}, generalizing \emph{Liskov Substitution
    Principle} from Object-oriented Programming
  \item ... TODO
  \item Ravara-Vasconcelos00 -- Algebra of Behavioral Types (ABT
    \S\ref{sec:abt})
\end{itemize}

\fist Behavioral Subtyping (\S\ref{sec:behavioral_subtype})

\fist Bisimulations (\S\ref{sec:bisimulation}) -- Process
(\S\ref{sec:process_calculus}) Equivalences

\begingroup

\renewcommand{\End}{\mathsf{end}}
\newcommand{\actors}{\mathsf{actors}}
\newcommand{\balanced}{\mathsf{balanced}}
\newcommand{\fullmrk}{\mathsf{fullmrk}}

Crafa12 -- \emph{Behavioural Types for Actor Systems}

Actor Calculus (\S\ref{sec:actor_calculus})

Scala Actors API -- Actors can:
\begin{itemize}
  \item Send Asynchronous Messages, including Messages with Actor
    Names as Parameters
  \item Process Received Messages (Pattern Matching)
  \item Dynamically create new Actors (cf. Scope Extrusion in
    $\pi$-calculus ???)
\end{itemize}

Safety Property -- Determinism of Actor Communication: Well-typed and
\emph{Balanced} Actor Systems are Deadlock-free (in the case of Finite
Computation) and guarantees Eventual Handling of Messages and no Actor
will indefinitely wait for an Expected message

AC -- Actor Calculus (\S\ref{sec:actor_calculus})

Actor Types -- encode the intended Communication Protocol

Type-checking Statically guarantees that Runtime Computation correctly
implements the Protocol

Session Types describe the ``Flow'' of Communications within a single
Conversation Session

a Behavioral Actor Type describes the Actor's point of view as an
entity that might Concurrently participate in different, interleaved
Conversations with different Participants (cf. Conversation Calculus
\S\ref{sec:conversation_calculus})

Behavioral Types for Actor Calculus:
\begin{flalign*}
  \quad T ::=&\ [S] & \\
  \quad S ::=&\ \End \ |\ !m(\tilde{T}).S
          \ |\ \&_{i \in I} \{ ?m_i(\tilde{T}_i).S_i \} & \\
          \ |&\ \&^\bullet_{i \in I}
            \{^\bullet ?m(\tilde{T}).S, ?m_i(\tilde{T}_i).S_i \}
          \ \text{with}\ \forall i \in I, \mathsf{NoMark}(S_i) &
\end{flalign*}
Types $T$ are Finite Sequences of Input and output Actions $S$

\fist unlike Session Types (\S\ref{sec:session_type}), \emph{Output
  Selection} is not considered -- the aim of Behavioral Types is not
to provide a Calculus for \emph{Protocol Specification}, but to
provide a Type-based technique to Statically Verify the \emph{Protocol
  Conformance} of Actors -- an extension for Output Selection could be
made $\oplus_{i \in I}\{ !m_i(\tilde{T}_i).S_i \}$ along the same
lines as Input Branches

\emph{Linear Type} assumptions: guarantees each Input is eventually
matched by exactly one Output in the System -- denoted by
\emph{Markings}

$!m(\tilde{T})$ -- the Type of an Output Expression that Sends the
Message $m$ with Parameter Tuple of Type $\tilde{T}$

$\&_{i \in I}\{ ?m_i(\tilde{T}_i).S_i \}$ -- type of the Input Action
that offers the Choice of Receiving one of the Message $m_i$ and
Continuing with the Sequence $S_i$

$\&^\bullet_{i \in I} \{^\bullet ?m (\tilde{T}).S,
?m_i(\tilde{T}_i).S_i \}$ -- \emph{Marked Action}: specifies an Input
that is ``Consumed'' by one Output Expression where
$\mathsf{NoMark}(S)$ means $S$ does not contain any Marking %FIXME

Parallel Threads must assume the same Type Assumptions but with
\emph{Disjoint Markings}

Def. \emph{Merge-mark} -- $\uplus$: Function used to Linearly Compose
Type Assumptions %FIXME

$\Gamma$ -- \emph{Type Environment}: Partial Function assigning Types
to Names and Variables

$\Gamma_1 \uplus \Gamma_2$ -- Type Environment obtained by Merging the
Markings of two Environments $\Gamma_1$ and $\Gamma_2$ such that
$Dom(\Gamma_1) = Dom(\Gamma_2)$:
\[
  \Gamma_1 \uplus \Gamma_2 =
    \{ u:\Gamma_1(u) \uplus \Gamma_2(u)
    \ |\ u \in Dom(\Gamma_1) = Dom(\Gamma_2) \}
\]

$\Gamma;a:T$ -- \emph{Environment Update}:
\[
  \Gamma \backslash \{a:\Gamma(a)\} \cup \{a:T\}
\]

Def. \emph{Escape Environment} $\Delta$ is a choice between
alternative Type Environments:
\[
  \Delta ::=\ \&_{i \in I}\Gamma_i \ |\ \&_{i \in I}\Delta_i
\]
where $Dom(\Gamma_i) \cap Dom(\Gamma_j) = \varnothing$ and
$Dom(\Delta_i) \cap Dom(\Delta_j) = \varnothing$ for $i,j \in I$

Escape Environment Extension:
\[
  (\&_{i \in I}\Delta_i), u:T \overset{\triangle}{=}
    \&_{i \in I}(\Delta_i, u:T)
\]
and:
\[
  (\&_{j \in J}\Delta_j), (\&_{i \in I}\Delta_i) \overset{\triangle}{=}
    \&_{j \in J}\&_{i \in I}(\Delta_j, \Delta_i)
\]

\emph{Typing Judgements}:
\[
  \Gamma \vdash F \rhd \Delta
\]
for $Dom(\Gamma) \cap Dom(\Delta) = \varnothing$, $fn(F) \subseteq
Dom(\Gamma)$ and $bn(F) \subseteq Dom(\Delta)$, where Environment
$\Gamma$ collects the Type Assumptions of the Free Names and Variables
of $F$ and Escape Environment $\Delta$ collects the Type Assumptions
of the Bound Names and Bound Variables of $F$ -- the Actors in $F$
execute the Sequence of Actions described by their Types and the
Marked Input Actions in $\Gamma$ and $\Delta$ are exactly those that
are consumed by the Actors in $F$

$\Gamma \vdash \diamond$ -- Judgement that $\Gamma$ is Well-formed

$\Gamma \vdash a:T$ -- Judgement that Actor $a$ has Type $T$ in
$\Gamma$

$\Gamma \vdash [a \mapsto M]$ -- Judgement that the Mailbox $M$ only
contains Messages that are Well-typed according to the Type that
$\Gamma$ assigns to $a$

$\Gamma \vdash_a e \rhd \Delta$ -- Judgement that $e$ is Well-typed as
the Body of Actor $a$

\emph{Actor Typing Rules}:
\begin{itemize}
  \item (TypeIdentif)
  \item (CtxEmpty)
  \item (CtxIdentif)
  \item (TypeSpawn) -- Actor $a$ Spawns a new Actor $b$
  \item (TypeSend) -- Actor $a$ Sends the Message $m(u')$ to the Actor
    $u$; the Behavioral Type for an Actor changes (decreases) as long
    as the Actor advances in its Computation %FIXME
  \item (TypeReceive) -- to Type an Input Expression, (TypeReceive)
    requires the Type of $a$ to indicate that the next Action is a
    Non-marked matching Input Action; the Names and the Types of the
    formal Parameters are recorded in the Escape Environment of the
    Conclusion of the Rule, preserving the ``Branching Structure''
    of the Computation %FIXME
  \item (TypeEnd) -- Expression $0$ is Well-typed if the Type of $a$
    contains no more Actions and $\Gamma$ contains no Marked Input
\end{itemize}
%FIXME

(typing of message parameters) %FIXME

$S \ll S'$ -- $S$ is a Suffix of $S'$, independent of any Markings

$\Gamma(u')\lfloor_m$ -- \emph{the Type of $u'$ after $m$}:
\[
  T \ll \Gamma(u')\lfloor_m \overset{\triangle}{=}
  \begin{cases}
    T \ll [S_a]      &\ \text{if}\ u' = a \\
    T \ll [S]        &\ \text{if}\ u' = u \\
    T \ll \Gamma(u') &\ \text{otherwise} \\
  \end{cases}
\]

\emph{Configuration Typing Rules}:
\begin{itemize}
  \item (TypeResConf) -- when a new Name is introduced, a
    corresponding Type must be \emph{guessed}; new Name is local to
    the Configuration $F$, but it is ``globally collected'' in the
    Escape Environment %FIXME
  \item (TypeActor) -- Type an Active Actor: requires that the
    Residual Actor Body $e$ comply with the Residual Sequence of
    Actions in $\Gamma(a)$ and the Mailbox $[a \mapsto M]$ contains
    the List of Messages $M$ that have been Received but not yet
    Handled by the Actor $a$; a Message in $M$ will be Processed by
    the Actor only if the Type $\Gamma(a)$ constains a matching Input
    Action
  \item (TypeNoMail)
  \item (TypeMailbox) -- does not require that every Message has a
    corresponding Handler in $\Gamma(a)$, but in \emph{Well-typed
      Systems} Mailboxes only contain Messages that will
    \emph{eventually} be Handled by the Receiving Actor
  \item (TypePara) -- \emph{Parallel Composition}: splits the Type
    Environment and the Escape Environment to ensure that the
    resources consumed by $F_1 \ |\ F_2$ are consumed by either $F_1$
    or $F_2$
  \item (TypeDead)
  \item (TypeTopSpawn)
\end{itemize}

extended Merge-mark -- Partial Function $S' \inplus S$

a Type with a Marked Action must be Composed with a Type Containing
the same Non-marked Action to ensure that the Input consumed by a
Thread is actually offered by a Parallel Thread

\emph{Type Environment Composition}:
\[
  (\Gamma_1,F_1 \odot \Gamma_2,F_2)(u) \overset{\triangle}{=}
    \begin{cases}
      \Gamma_2(u) \uplus \Gamma_1(u)
        &\ \text{if}\ u \notin \actors(F_1) \cup \actors(F_2) \\
      \Gamma_1(u) \inplus \Gamma_2(u)
        &\ \text{if}\ u \in \actors(F_1) \\
      \Gamma_2(u) \inplus \Gamma_1(u)
        &\ \text{if}\ u \in \actors(F_2) \\
    \end{cases}
\]
where $\actors(F)$ are the Free Names of Active Actors in $F$


\textbf{Preventing Deadlocks}

\fist Deadlocks (\S\ref{sec:deadlock})

modification of Type Syntax %FIXME

$T!m(\tilde{T}).S$ -- Output Actions where the additional component
$T$ describes the Sequence of Actions performed by the Target Actor
\emph{after Processing the Message $m$}

$a : [[S_b]!m(T).\End]$ -- the Type of an Actor $a$ that Sends the
Message $m$ to an Actor that eventually Reads the Message $m$ and then
Continues as described by $S_b$; a corresponding Target: $b :
[S.?m(T).S_b]$

\emph{Asynchronous Communication}: when $a$ Sends the Message to $b$ it
cannot know when $b$ will Process the Message but it can assume that
after the Input of $m$, $b$ will Continue as $S_b$ -- is enough to
ensure \emph{Deadlock Freedom}

modified Actor Typing Rule (TypeSend) %FIXME

modified $\uplus$, $\inplus$ %FIXME


\emph{Type System Respects Semantics of AC}

Well-typed Configurations Reduce to Well-typed Configurations

Def. \emph{Environmental Consumption}:
\begin{itemize}
  \item $\Gamma' \ll \Gamma$ -- when $Dom(\Gamma) = Dom(\Gamma')$ and
    $\forall u \in Dom(\Gamma), \Gamma'(u) = [S'], \Gamma(u) =
    [S]$ such that $S' \ll S$
  \item $\Delta' \ll \Delta$ -- when $\Delta = \&_{i \in
    I}\Gamma_i,\Delta' = \&_{j \in J}\Gamma'_j$ with $J \subseteq I$,
    $\Gamma'_j \subseteq \Gamma_j$ and $\forall u \in Dom(\Gamma'_j),
    \forall_j \in J.\Gamma'_j(u) \ll \Gamma_j(u)$
\end{itemize}
%FIXME a better presentation of the above ???

Lem. \emph{Substitution}

Thm. \emph{Subject Reduction} If $\Gamma \vdash F \rhd \Delta$ and $F
\longrightarrow F'$ then there exists $\Gamma'$ such that $\Gamma'
\vdash F' \rhd \Delta'$ with $\Gamma' \ll \Gamma$ and $\Delta' \ll
\Delta$


\emph{Balanced Well-typed Actor System}

$\varnothing \vdash F \rhd \Delta$ -- $F$ is a Well-typed Closed
System

then any Input Action that is Marked in $\Delta$ exactly corresponds
to one Output Expression in $F$ that \emph{eventually} consumes that
Input

a Well-typed Actor System is \emph{Balanced} when \emph{every} Input
in the System appears Marked in the Escape Environment

in Balanced Systems every Input has a matching Output and \emph{vice
  versa}

Finite Balanced Systems eventually Terminate in the Empty
Configuration after correctly implementing the Communication Protocol
given by the Typing

%FIXME xref closed system ???

$\fullmrk([S]) = [S']$ -- where $S$ and $S'$ are the same Sequence of
Actions but in $S'$ every Top-level Input is Marked

Def. \emph{Balanced Environment} -- $\balanced(\Delta)$ %FIXME

Lem. (during Computation of Well-typed Actor Systems, Mailboxes only
contain Messages that are Eventually Handled by the Receiving Actor)
%FIXME

$\longrightarrow^*$ -- Transitive Closure of $\longrightarrow$

Thm. \emph{Safety} If $\varnothing \vdash Pr \rhd \Delta$ with
$\balanced(\Delta)$. If $Pr \longrightarrow^* F$ then either $F = 0$
or $F \Rightarrow F'$ for some $F'$.


\endgroup



% --------------------------------------------------------------------
\subsection{Algebra of Behavioral Types}\label{sec:abt}
% --------------------------------------------------------------------

Ravara-Resende-Vasconcelos12 \emph{An Algbra of Behavioural Types}

Ravara-Vasconcelos00 \emph{Typing Non-uniform Concurrent objects}



% --------------------------------------------------------------------
\subsection{Behavioral Separation Type}
\label{sec:behavioral_separation}
% --------------------------------------------------------------------

Caires-Seco13 \emph{The Type Discipline of Behavioral Separation}

Separation Logic (\S\ref{sec:separation_logic})

Spatial-behavioral Types -- Caires08



% ====================================================================
\section{Type Operator}\label{sec:type_operator}
% ====================================================================

\emph{Type Operator} (or \emph{Type-level Function})

Adding additional Type Operators to Simply-typed $\lambda$-calculus
($\lambda\kern-5pt\rightarrow$ \S\ref{sec:simply_typed}) results in
\emph{Higher-order $\lambda$-calculus} ($\lambda\underline{\omega}$
\S\ref{sec:higherorder_lambda})

a Type Operator is a Kind (\S\ref{sec:kind}), i.e. its ``members'' are
Types

The Type Operators themselves can be viewed as forming a Simply-typed
$\lambda$-calculus with only one Base Type (\S\ref{sec:type_constant})
denoted `$\ast$' representing the Type of all Types in the underlying
Language which are called \emph{Proper Types} to distinguish from the
Type of the Type Operators which are called \emph{Kinds}
(\S\ref{sec:kind}).

A Type Operator is an Endofunctor on the Category of Types.

$\Lambda$ -- Type-level Function Abstraction

Monotonic Type Operators: Inductive Types (\S\ref{sec:inductive_type})



% --------------------------------------------------------------------
\subsection{Kind}\label{sec:kind}
% --------------------------------------------------------------------

A \emph{Kind} is the Type of a Type Operator
(\S\ref{sec:type_operator}), or the Type of a Dependent Type
(\S\ref{sec:dependent_type}).

(Meta-)Type of a Type

\fist Proper Type (\S\ref{sec:type})

Super-kind

Pure Type System (\S\ref{sec:pts})


\cite{jones95}

%FIXME sections, xrefs

\emph{Kind System}

Kind Inference

\begin{align*}
  \kappa ::= &\; \star \mid \kappa_1 \Rightarrow \kappa_2
\end{align*}

$\star$ -- Monotypes (Nullary Type Constructors)

$\kappa_1 \Rightarrow \kappa_2$ -- Function Kinds

Type Expressions (\S\ref{sec:type_expression}) are Well-formed
(\S\ref{sec:wellformed_type}) if the given Type Constructor (? Type
Operator \S\ref{sec:type_operator}) has Kind $\star$

Constructor Classes (\S\ref{sec:constructor_class})



\subsubsection{Polymorphic Kind}\label{sec:polymorphic_kind}



% --------------------------------------------------------------------
\subsection{Higher-order Type Operator}
\label{sec:higherorder_typeoperator}
% --------------------------------------------------------------------

Allowing for the Type Operators to form a Simply-typed
$\lambda$-calculus with the single Base Type `$*$' allows for
Higher-order Type Operators.



% --------------------------------------------------------------------
\subsection{Constructor Class}\label{sec:constructor_class}
% --------------------------------------------------------------------

use Classes to represent Sets of Constructors of any fixed Kind
$\kappa$

Type Classes (\S\ref{sec:type_class}) as a specific case of
Constructor Classes

Classes of Monads, Effects ?



% --------------------------------------------------------------------
\subsection{Function Type}\label{sec:function_type}
% --------------------------------------------------------------------

A \emph{Function Type} (or \emph{Arrow Type}) is Type formed by the
Higher-kinded Type Constructor $\rightarrow$

The Function Type $A \rightarrow B$ is a special case of Dependent
Product Type (\S\ref{sec:pi_type}) $(\Pi a:A)B$ with a Constant
Codomain Type $B$:
\[
  (\Pi a:A)B \equiv A \rightarrow B
\]
where $\equiv$ is Judgemental Equality.

In a Category without Products, the Function Type can't be defined.

Function Types are Covariant Functors on the Return Type and
Contravariant Functors on the Argument Type. Cf. Hughes Arrows
(\S\ref{sec:hughes_arrow}).



\subsubsection{Exponential Type}\label{sec:exponential_type}

Higher-order Functions

Function Space

Function Type (\S\ref{sec:function_type})



\subsubsection{Generic Function}\label{sec:generic_function}

Parametric Polymorphism (\S\ref{sec:parametric_polymorphism})



% --------------------------------------------------------------------
\subsection{Type Constructor}\label{sec:type_constructor}
% --------------------------------------------------------------------

A \emph{Type Constructor} (or \emph{Type Schema}) is an Injective Type
Function: maps all Types of a particular Kind to a new Set of Types
and Type Synonyms

\emph{Linear Type Constructor} %FIXME



% --------------------------------------------------------------------
\subsection{Type Family}\label{sec:type_family}
% --------------------------------------------------------------------

A \emph{Type Family} is a Partial Type Operator that allows Types to
be defined by matching Terms.

%FIXME

Type Classes (Constrained Type \S\ref{sec:constrained_type}) are used
to define Overloaded Functions, Type Families are used to defined
Overloaded Data.

Type Classes define Partial Functions from Types to a collection of
Named Values by Pattern Matching on the Input Types

Type Families define Partial Functions from Types to Types by Pattern
Matching on the Input Types

Generalization of Predicates (Relations) over Domains



\subsubsection{Associated Type}\label{sec:associated_type}

A Type Family declared inside a Type Class is an \emph{Associated
  Type}



% --------------------------------------------------------------------
\subsection{Polymorphic Type Operator}
\label{sec:polymorphic_type_operator}
% --------------------------------------------------------------------

(or \emph{Generic Type Constructor})



% ====================================================================
\section{Dependent Type}\label{sec:dependent_type}
% ====================================================================

A \emph{Dependent Type} depends on a Term or another Type.

\[
  x : A \vdash B(x):\mathrm{Types}
\]

a Dependent Type is actually a Kind (\S\ref{sec:kind}), i.e. its
``members'' are Types

A Dependent Product Type (\S\ref{sec:pi_type}) is defined by
a Dependent Function (\S\ref{sec:dependent_function}).

Logical Quantifiers (\S\ref{sec:quantifier})

Intuitionistic Type Theory (\S\ref{sec:intuitionistic_type})

Type Checking in a Dependent Type Theory is Undecidable -- Dowek05
\emph{The undecidability of typability in the Lambda-Pi-calculus}

Categorically, Dependent Types correspond to Morphisms regarded as
Indexed Families (Bundle or Fibration), represented by a \emph{Display
  Map} (\S\ref{sec:display_map}) which is a Morphism $p : B
\rightarrow A$ where $B(x)$ is the Fiber (\S\ref{sec:fiber}) of $p$
over $x:A$.

Classifying Morphism (\S\ref{sec:classifying_morphism}),
Classifying Space (\S\ref{sec:classifying_space})

A Dependent Type is the Type of a Dependent Function
(\S\ref{sec:dependent_function}).

Dependent Pairs (Dependent Sum Type \S\ref{sec:sigma_type})


\textbf{First-order Dependent Type Theory} ($\lambda \Pi$):
\emph{Logical Framework} (\S\ref{sec:logical_framework}), adding the
Dependent Product Type (\S\ref{sec:pi_type}) to Simply-typed
$\lambda$-calculus.


\textbf{Second-order Dependent Type Theory} ($\lambda \Pi 2$):
allowing Quantification over Type Constructors
(\S\ref{sec:type_constructor}), $\Pi$ operator Subsumes both
$\rightarrow$ of Simply-typed $\lambda$-calculus and $\forall$ of
System F (\S\ref{sec:system_f})


\textbf{Higher-order Dependently Typed Polymorphic $\lambda$-calculus}
($\lambda \Pi \omega$): corresponds to \emph{Calculus of
  Constructions} (\S\ref{sec:coc}); extends $\lambda \Pi 2$ to all
abstractions of the $\lambda$-cube (\S\ref{sec:lambda_cube})


\asterism


$x:A \vdash B(x):\Type$

$B : A \rightarrow \Type$

$B : (\Pi X:\Type) A \rightarrow X$



% --------------------------------------------------------------------
\subsection{Dependent Function}\label{sec:dependent_function}
% --------------------------------------------------------------------

A \emph{Dependent Function} is a Function from Terms to Types
(Codomain varies depending on Argument). The Type of a Dependent
Function is a \emph{Dependent Product Type}
(\S\ref{sec:pi_type}).

Dependent Function Space: if $f:(\forall x: A).B$ then $f a : B[a/x]$

Functionality (respect for Definitional Equality
\S\ref{sec:proof_equality}):
\[
  x : A \vdash B_x \;\text{type}
\]\[
  m : A \mapsto B[m/x] \;\text{type}
\]\[
  m \equiv n : A \mapsto B[m/x] \equiv B[n/x] \;\text{type}
\]

Doubly-indexed Type:
\[
  x : A, y : B_x \vdash C_{x,y} \;\text{type}
\]

Example: Family of Types Indexed by $\mathbb{N}$:
\[
  x : \mathbb{N} \vdash even(x) \;\text{type}
\]
is a Propositional Function (takes a Natural Number and yields a
Proposition). For each Natural Number, either $even(x)$ is Inhabited
(if $x$ is Even) or Uninhabited (if $x$ is Odd).\cite{harper12}



% --------------------------------------------------------------------
\subsection{Dependent Sum Type ($\Sigma$-type)}\label{sec:sigma_type}
% --------------------------------------------------------------------

\emph{$\Sigma$-type} (or \emph{Dependent Sum Type} or \emph{Dependent
  Pair Type} or \emph{Records})

Dependent Sum (\S\ref{sec:dependent_sum})

\[
  (\Sigma x:A) B(x)
\]

If $B$ is Constant, then $(\Sigma x:A)B$ is Judgementally Equal to
the Product Type (\S\ref{sec:product_type}) $A \times B$:
\[
  (\Sigma x:A) B \equiv A \times B
\]

By Curry-Howard, $\Sigma$-types model Conjunction and Existential
Quantification.

Analagous to Coproduct or Disjoint Union.



% --------------------------------------------------------------------
\subsection{Dependent Product Type ($\Pi$-type)}\label{sec:pi_type}
% --------------------------------------------------------------------

The \emph{$\Pi$-type} (or \emph{Dependent Product Type} or
\emph{Dependent Function Type}) is the Type of a Dependent Function,
i.e. a Dependent Function Space. By Curry-Howard, $\Pi$-types model
Implication and Universal Quantification.

Dependent Product (\S\ref{sec:dependent_product})

For a Type $A : \class{U}$ in Type Universe
(\S\ref{sec:type_universe}) $\class{U}$, a Family of Types:
\[
  B : A \rightarrow \class{U}
\]
can be defined by a Dependent Function which assigns a Type $B(a) :
\class{U}$ to Each Term $a : A$. The Type of this Function is a
Dependent Product Type:
\[
  (\Pi x:A)B(x)
\]

If $B$ is Constant, then $(\Pi x:A)B$ is Judgementally Equal to the
Function Type (\S\ref{sec:function_type}) $A \rightarrow B$:
\[
  (\Pi x:A)B \equiv A \rightarrow B
\]

Generalizes the idea of a Polymorphic Function
(\S\ref{sec:polymorphic_function})

\cite{hott13}:

Example $id$:
\[
  id : (\Pi A:\class{U}) A \rightarrow A
\]

Example 2 $swap$:
\[
  swap : (\Pi A:\class{U}) (\Pi B:\class{U}) (\Pi C:\class{U})
  (A \rightarrow B \rightarrow C) \rightarrow (B \rightarrow A
  \rightarrow C)
\]
Type arguments may be written as subscripts: $id_A$, $swap_{A,B,C}$

A Polymorphic Function returning elements of Type $C$ has Polymorphic
Type (\S\ref{sec:polymorphic_type}):
\[
  (\Pi A:\class{U}) A \rightarrow C
\]



% --------------------------------------------------------------------
\subsection{Dependent Equality Type}\label{sec:dependent_equality}
% --------------------------------------------------------------------



% ====================================================================
\section{Type Universe}\label{sec:type_universe}
% ====================================================================

A \emph{Type Universe} is a Type whose Elements are Types.

Type of (Small) Types

Type Theory analogue of Inaccessible Cardinal
(\S\ref{sec:inaccessible_cardinal})

\fist cf. Unified Type System (\S\ref{sec:unified_type_system})

$\class{U}_0$ is the Universe of all Small Types. Every Name
(\S\ref{sec:name}) $a:\class{U}_0$ has an associated Type $El(a)$
giving its Extension or Meaning ($El$ is a Dependent Type
\S\ref{sec:dependent_type} that maps each Object to its corresponding
Type).

A Predicative Cumulative Hierarchy (\S\ref{sec:cumulative_hierarchy}):
\[
  \class{U}_0, \class{U}_1, \class{U}_2, \ldots
\]
is such that any Type in $\class{U}_n$ is also in
$\class{U}_{n+1}$:
\[
  u_n:\class{U}_n+1
\]
with (Cumulative Property):
\[
  El(u_n) \equiv \class{U}_n
\]

\fist See $\class{U}-INTRO$ and $\class{U}-CUMUL$
\S\ref{sec:homotopy_rules}.

\asterism

nCatlab -- \url{https://ncatlab.org/nlab/show/type+of+types} -- Type of
Type

$\Type$ -- \emph{Universe}; Type of Small Types: Terms of $\Type$ are
(Small) Types

$\Type$ is a \emph{Reflection} (\S\ref{sec:reflection_principle}) of
the Type System in itself

$\vdash A:\Type$ -- Judgement that $A$ is a Term of ``Type'' $\Type$,
i.e. $A$ is a Small Type

$x:X \vdash A(x):\Type$ -- $A$ is an ($X$-) Dependent Type

$\Type$ in Homotopy Type Theory is assumed to Satisfy the Univalence
Axiom

by Girard's Paradox (\S\ref{sec:girards_paradox}) it is Inconsistent
for $\Type : \Type$ (as in the original Martin-L\"of Type Theory);
therefore modern Type Theories usually contain a \emph{Hierarchy} of
Types:
\[
  \Type_0 : \Type_1, \Type_1 : \Type_2, \ldots
\]

``Russell'' Type Universe -- a Type whose Terms are Types; a Judgement
$A \type$ can be formulated as a Deduction Rule of the Form:
\[
  \frac{A:U}{A \type}
\]
Russell formulation (approach taken by HoTT, Coq) is an informal
version of the Tarski formulation

``Tarski'' Type Universe -- a Type $U$ together with an
\emph{Interpretation Operation} allowing Terms to serve as ``Codes''
or \emph{Names} for ``actual'' Types; the Rule:
\[
  \frac{A:U}{El(A) \type}
\]
states that for each Term $A$ of the Type Universe $U$, there is an
``actual'' Type $El(A)$

Universes defined Internally via Induction-recursion
(\S\ref{sec:induction_recursion}) are (Strongly) Tarskian


\asterism

\begingroup %palmgren98

\newcommand{\sett}{\;\mathrm{set}}

%FIXME can we replace ``set'' with type ???

Palmgren98 -- \emph{On universes in type theory} -- Universe-forming
Operator, Super Universe closed under Universe-forming Operator

two roles of Type Universes (Martin-L\"of):
\begin{itemize}
  \item a collection of Types closed under certain Type Constructions
  \item a Set of Constructively given Infinitary Fomulas
\end{itemize}

Universe Constructions give an Intuitionistic analogue of Large
Cardinals

\emph{Type Universe} -- Type of Types closed under certain Type
Constructions

Tarski Formulation:
\[
  U \type \quad\quad\quad \frac{a \in U}{T(a) \type}
\]

two conceptions of Universes in Martin-L\"of Type Theory:
\begin{itemize}
  \item Reflection of the Judgement forms $A \sett$ and $A = B$ into a
    Hierarchy of Universes $(U_n,T_n)$, externally Indexed by $n =
    1,2,3,\ldots$ -- whenever $A \sett$, then in some Universe $U_n$
    there is a Code (Name) $a$ such that $T_n(a) = A$ and if $A = B$
    with $T_n(a) = A$ and $T_n(b) = B$ then $a = b \in U_n$
\end{itemize}

(note: skipping over details in the following...) %FIXME


\textbf{Universes as Full Reflections}

Universe $U_1$ of Codes for all ``Basic'' Sets:
\[
  U_1 \sett \quad\quad\quad \frac{x \in U_1}{T_1(x) \sett}
\]
with:
\[
  n_0^1,n_1^1,n^1 \in U_1 \quad\quad T_1(n_0^1) = \varnothing
    \quad\quad T_1(n_1^1) = \{*\} \quad\quad T_1(n^1) = \nats
\]
closed under $\Pi$-formation, $\Sigma$-formation, $I$, $+$ and other
Set formers

the next Universe $(U_2,T_2)$ has new Codes:
\[
  n_0^2,n_1^2,n^2 \in U_1 \quad\quad T_1(n_0^2) = \varnothing
    \quad\quad T_1(n_1^2) = \{*\} \quad\quad T_1(n^2) = \nats
\]
and to account for the Sets $U_1$, $T_1(x)$ from the previous stage:
\[
  u_1^2 \in U_2 \quad\quad T_2(u^2_1)=U_1 \quad\quad
    \frac{x \in U_1}{t_1^2(x) \in U_2}
\]
where $t_1^2$ is a Homomorphism with respect to Set (Type)
Constructors

(equalities between codes) %FIXME

any Proof in the completed Hierarchy can use only Finitely many
Universes (Proofs are Finite, and Universes are externally Indexed):
therefore the Reflection Principle (\S\ref{sec:reflection_principle})
holds for both Sets and Set Equalities

the Transfinite iteration:
\[
  u_1^\omega, u_2^\omega, u_3^\omega, \ldots \in U_\omega
\]
a Universe with Infinitely many Introduction Rules-- it is impossible
to formulate an Elimination Rule without having some kind of
\emph{internal} Indexing of the Universes


\textbf{Universes as Uniform Constructions}

not Reflecting Set Equalities allows the ``injection'' of Codes for
Sets from an earlier Universe into the next

Judgement form $A \sett$ still Reflected

for an already constructed $(U_n,T_n)$, then:
\[
  U_{n+1} \sett \quad\quad\quad \frac{x \in U_{n+1}}{T_{n+1}(x) \sett}
\] \[
  u_n \in U_{n+1} \quad\quad\quad T_{n+1}(u_n) = U_n
\] \[
  \frac{x \in U_n}{t_n(x) \in U_{n+1}} \quad\quad\quad
    \frac{x \in U_n}{T_{n+1}(t_n(x)) = T_n(x)}
\]
so that $t_n(a)$ is now considered a \emph{Canonical Element} in
$U_{n+1}$ and is regarded as a \emph{copy} of $a$ in $U_{n+1}$; the
code for $U_j, j < n+1$ in $U_{n+1}$ is $t_n(t_{n-1}(\ldots
t_{j+1}(u_j) \ldots))$

the construction of $(U_{n+1},T_{n+1})$ depends \emph{only} on the
Family $(U_n,T_n)$ -- \emph{Universe Formation Operation}


\textbf{Super Universes}

Universe closed under Universe Formation Operator

Universe Formation Operator acts on \emph{Families of Sets}, i.e. any
$(A, (x)B)$ -- FIXME: this is a Pi-type term (the Sets indexed by A)
???

%FIXME

Impredicative Theories

Classical Universes within Type Theory-- extended Type Theory with a
Universe of Propositions for which Classical Logic holds

FIXME: this sounds somewhat like a multi-sorted type theory (cf. Pure
Type System, or ATS)



\endgroup %palmgren98



% --------------------------------------------------------------------
\subsection{Girard's Paradox}\label{sec:girards_paradox}
% --------------------------------------------------------------------

Type-theoretic analogue of Russell's Paradox
(\S\ref{sec:russells_paradox}) in Set Theory

example Inconsistent Pure Type System (\S\ref{sec:pts}): System U
(\S\ref{sec:system_u}) -- allows the assignment of Polymorphic Kinds
(\S\ref{sec:polymorphic_kind}) to Generic Constructors
(\S\ref{sec:polymorphic_type_operator}); analogy to Polymorphic Types
(\S\ref{sec:polymorphic_type}) of Terms in ordinary Polymorphic
$\lambda$-calculi, e.g. System F (\S\ref{sec:system_f})

example Generic Constructor:
\[
  \lambda k^\square \lambda \alpha^{k \rightarrow k}\lambda\beta^k.
    \alpha(\alpha\beta) :
  \Pi k:\square((k \rightarrow k) \rightarrow k \rightarrow k)
\]

using this mechanism is sufficient to Construct a Term with the Type:
\[
  (\forall p:\star,p) = \bot)
\]
which Implies that every Type is Inhabited and by Curry-Howard
Correspondence all Logical Propositions are Provable, i.e. the System
is Inconsistent



% ====================================================================
\section{Context}\label{sec:type_context}
% ====================================================================

A \emph{Context} (or \emph{Typing Environment} or \emph{Variable
  Assignment}), $\Gamma$, is a list of \emph{Typing Assumptions}
(\S\ref{sec:typing_assumption}) of the form:
\[
  \Gamma = x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n
\]
where each Element $x_i : A_i$ is an Assumption that the distinct
Variable $x_i$ has type $A_i$.

\emph{Typing Judgements} (\S\ref{sec:typing_judgement}) are formulated
under the Assumptions of a particular Context, $\Gamma$:
\[
  \Gamma \vdash a : A
\]
For an empty Context:
\[
  \vdash a : A
\]
or:
\[
  . \vdash a : A
\]

Closed Terms are those Terms that are Typable
(\S\ref{sec:typing_derivation}) in an Empty Context, e.g. the I, S,
and K Combinators (\S\ref{sec:combinator}).



% --------------------------------------------------------------------
\subsection{Typing Assumption}\label{sec:typing_assumption}
% --------------------------------------------------------------------

\emph{Typing Assumption})

\[
  e : \tau
\]
``Term $e$ has Type $\tau$''



% --------------------------------------------------------------------
\subsection{Type Annotation}\label{sec:type_annotation}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Type Erasure}\label{sec:type_erasure}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Reification}\label{sec:reification}
% --------------------------------------------------------------------

* opposite of Type Erasure
* see Type Inference (\S\ref{sec:type_inference})

Abstract idea about a computer program turned into an explicit Data
Model or Object

(Hypostatize) %FIXME

Monadic Reification (\S\ref{sec:monadic_reification})



% ====================================================================
\section{Typing Judgement}\label{sec:typing_judgement}
% ====================================================================

A \emph{Typing Judgement} is an instance of a \emph{Typing Relation}
(\S\ref{sec:typing_relation}).

A Typing Judgement expresses Propositional Equality. % FIXME

The Validity of a Typing Judgement is given by a Typing Derivation
(\S\ref{sec:typing_derivation}).

Constant Type % FIXME empty context



% --------------------------------------------------------------------
\subsection{Typing Relation}\label{sec:typing_relation}
% --------------------------------------------------------------------

\emph{Typing Relation} between Terms and Types

\[
  \Gamma \vdash e : \tau
\]
``$e$ is a (Well-typed \S\ref{sec:well_typed}) Term of Type $\tau$ in
Context $\Gamma$'',

Terms that are Well-typed in the Empty Context are Closed Terms.

Under a Proof Theoretic Interpretation, $p : P$ may be read as ``$p$
is a Proof of Proposition $P$''



% --------------------------------------------------------------------
\subsection{Typing Rule}\label{sec:typing_rule}
% --------------------------------------------------------------------

A \emph{Typing Rule} (or \emph{Type Rule}) describes how a Type is
assigned to a Syntactic Construction.

Corresponding to Introduction and Elimination Rules of Proof Theory
(\S\ref{sec:structural_rule}).

Introduction and Elimination corresponds to Constructors
(\S\ref{sec:constructor}).

The notation for Type Rules is that of Sequent Notation
(\S\ref{sec:sequent}):
\[
  {
    \frac
    { \Gamma_1 \vdash e_1:\tau_1 \quad \cdots
      \quad \Gamma_n \vdash e_n:\tau_n }
    { \Gamma \vdash e:\tau }
  }
\]
where $\Gamma$ are Typing Environments and $e:\tau$ are Typing
Judgements.



% --------------------------------------------------------------------
\subsection{Typing Derivation}\label{sec:typing_derivation}
% --------------------------------------------------------------------

A \emph{Typing Derivation} shows the Validity of a Typing Judgement
and is constructed from Typing Rules (\S\ref{sec:typing_rule}).

Derivation (\S\ref{sec:formal_proof})

Undischarged Assumptions in Formal Proofs correspond to Free Variables
in Typing Derivations, Discharged Assumptions to Bound Variables

A Rewrite Rule maps a Valid Typing Derivation to another Valid Typing
Derivation (\emph{Subject Reduction} \S\ref{sec:subject_reduction},
\emph{Type Soundness}) \cite{wadler14}

A Term for which a Typing Derivation exists is called a
\emph{Well-typed Term} (\S\ref{sec:well_typed}).



\subsubsection{Type Witness}\label{sec:type_witness}

\emph{Witnessing Information} gives verification of a Typing
Assumption



\subsubsection{Subject Reduction}\label{sec:subject_reduction}

A Type System has \emph{Subject Reduction} (or \emph{Type
  Preservation}) if Evaluation (\S\ref{sec:evaluation_strategy}) of
Expressions leaves their Types unchanged.



% ====================================================================
\section{Type Inference}\label{sec:type_inference}
% ====================================================================

% ====================================================================
\section{Type System}\label{sec:type_system}
% ====================================================================

\emph{Type System} (or \emph{Typing Discipline})

Internal Logic (\S\ref{sec:internal_logic}), Categorical Semantics
(\S\ref{sec:categorical_semantics})

Simple Types (\S\ref{sec:simply_typed}) -- (Zeroth-order) Minimal
Logic (\S\ref{sec:minimal_logic}) -- Cartesian-closed Category
(\S\ref{sec:cartesian_closed})

Dependent Types (\S\ref{sec:dependent_type_theory}) -- (First-order)
Predicate Logic (\S\ref{sec:firstorder_logic}) -- Comprehension
Category (\S\ref{sec:comprehension_category}), Contextual Category
(\S\ref{sec:contextual_category})

$\lambda\mu$-calculus (\S\ref{sec:lambda_mu}) -- Classical Logic
(\S\ref{sec:classical_logic}) -- Control Category
(\S\ref{sec:control_category})

Linear Type System (\S\ref{sec:linear_type}) -- Linear Logic
(\S\ref{sec:linear_logic}) -- Closed Monoidal Categories
(\S\ref{sec:closed_monoidal})

Reactive Type System (\S\ref{sec:reactive_type}) -- Linear Temporal
Logic (\S\ref{sec:linear_temporal}) -- Traced Monoidal Categories
(\S\ref{sec:traced_monoidal})

Homotopy Types (\S\ref{sec:hott}) -- ??? -- Higher Categories
(\S\ref{sec:higher_category})

assigning a Data Type (\emph{Typing} \S\ref{sec:typing_judgement})
gives \emph{Meaning} (\S\ref{sec:meaning}) to a sequence of Bits (e.g.
a Value in Memory or an Object such as a Variable)

``Hierarchical Type Systems'' -- e.g. ATS (Applied Type System)

``Cyclic Type Systems'' -- e.g. Martin-Lof Type Theory



% --------------------------------------------------------------------
\subsection{Type Checking}\label{sec:type_checking}
% --------------------------------------------------------------------

2016 - Shulman - ``What is a Formal Proof'': %FIXME

In Type Theory, Derivation Trees (Concrete Syntax Trees
\S\ref{sec:concrete_syntax}) are Inductively Defined Structures that
can be used to Prove a Soundness Theorem.

Terms as One-dimensional Syntactic Representations of Derivation Trees
(or parts of them)

Notion of ``Term'' plays the role of Informal ``Argument'';
``Type-checking'' is about getting from Argument to Proof

``Well-typed Terms'' (those that represent Derivation Trees) are
distinguished from larger Class of ``Untyped Terms''

Untyped Terms are a sort of Argument that may or may not give rise to
a Proof

\emph{Decidable Static Type-Checking}: Decision Algorithm on Untyped
Terms determining whether the Term represents a Derivation Tree or not
in a Finite amount of time

``Decidable Checking'' is not a fundamental Property of a Proofs in a
Formal System but a Property of a certain Class (???) of Arguments
that might or might not represent Proofs.

``Elaborators'' of Theorem Provers fill in implicit arguments of
incomplete Terms that do not represent Derivation Trees to generate
instructions for a Proof Checker to easily reconstruct the Proof using
a specific Algorithm



\subsubsection{Phase Distinction}\label{sec:phase_distinction}

\emph{Phase Distinction} --
\url{https://en.wikipedia.org/wiki/Phase_distinction}



\subsubsection{Bi-directional Type Checking}
\label{sec:bidirectional_checking}

\emph{Checking}

\emph{Synthesis}



\subsubsection{Extended Static Checking}\label{sec:extended_static}

\subsubsection{Elaborator}\label{sec:elaborator}

2016 - Shulman - ``What is a Formal Proof'': %FIXME

``Elaborators'' of Theorem Provers fill in implicit arguments of
incomplete Terms that do not represent Derivation Trees
(\S\ref{sec:concrete_syntax}) to generate instructions for a Proof
Checker to easily reconstruct the Proof using a specific algorithm

http://math.andrej.com/2016/08/09/what-is-a-formal-proof/ %FIXME

Proof Assistants %FIXME



% --------------------------------------------------------------------
\subsection{Nominal Type System}\label{sec:nominal_type_system}
% --------------------------------------------------------------------

Names



% --------------------------------------------------------------------
\subsection{Unified Type System}\label{sec:unified_type_system}
% --------------------------------------------------------------------

every Type Inherits from a single ``Root'' Type



\subsubsection{Type Unification}\label{sec:type_unification}

%FIXME



\paragraph{Higher-order Unification}
\label{sec:higherorder_unification}\hfill

Formally Undecidable



\paragraph{Biunification}\label{sec:biunification}\hfill

Dolan16 - \emph{Algebraic Subtyping}:

difficulty integrating Type Inference with Subtyping due to the
Unification ``Engine'' accepts only \emph{Equations} not
\emph{Subtyping Constraints} (\S\ref{sec:subtype})

Dolan16 presents Type System with Type Inference based on
\emph{Biunification} (\S\ref{sec:biunification}) is an analogue of
Unification that works with Subtyping Constraints



% --------------------------------------------------------------------
\subsection{Structural Type System}\label{sec:structural_type_system}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Substructural Type}
\label{sec:substructural_type}
% --------------------------------------------------------------------

Substructural Logic (\S\ref{sec:substructural_logic})

Substructural Type Systems are categorized by allowing or disallowing
Structural rules of Exchange (\S\ref{sec:exchange_rule}), Weakening
(\S\ref{sec:weakening_rule}), or Contraction
(\S\ref{sec:contraction_rule}):

\begin{itemize}
  \item Linear Type Systems (\S\ref{sec:linear_type}): Allow Exchange,
    not Weakening or Contraction; Every Variable used exactly once
  \item Affine Type Systems (\S\ref{sec:affine_type}): Allow Exchange
    and Weakening, not Contraction; Every occurrence of a Variable
    used at most once
  \item Relevant Type System (\S\ref{sec:relevant_type}): Allow
    Exchange and Contraction, not Weakening; Every variable used at
    least once
  \item Ordered Type System (\S\ref{sec:ordered_type}): Disallow
    Exchange, Contraction and Weakening; Every Variable is used
    Exactly once in the order it was introduced
\end{itemize}

Languages with Substructural Type Systems:

\begin{itemize}
  \item Clean
  \item Rust -- Affine Types (\S\ref{sec:affine_type}), Borrowed
    Types (\S\ref{sec:borrowed_type})
  \item Mezzo
  \item Idris -- `UniquenessTypes`, `LinearTypes`
  \item ATS (\S\ref{sec:ats}) -- Views (Linear Proofs
    \S\ref{sec:view}), Viewtypes (Linear Types \S\ref{sec:viewtype})
\end{itemize}

In Rust:

\begin{itemize}
  \item $\mono{Copy}$ -- Contraction
  \item FIXME
\end{itemize}



\subsubsection{Linear Type System}\label{sec:linear_type}

Values used exactly once; guarantees that no more References can be
made to a Value

\fist Cf. Uniqueness Types (\S\ref{sec:uniqueness_type}): guarantees
that only one \emph{Reference} to a Value exists

Linear Type Theory -- Co-modality (???) %FIXME

Linear Logic (\S\ref{sec:linear_logic}) allows safe Deallocation
(Objects used exactly once)

Distribution and Concurrency (Session Types \S\ref{sec:session_type})

Linear $\lambda$-calculus (\S\ref{sec:linear_lambda})

Stateful Views: ATS/SV (\S\ref{sec:ats_sv}) -- Proofs of Views are
treated as \emph{Resources} which can be Generated and Consumed

Internal Language (\S\ref{sec:internal_logic}) of Closed Symmetric
Monoidal Categories (\S\ref{sec:closed_symmetric_monoidal})

Allows References but not Aliases

Modelling of Heap-based Memory Allocation

No-cloning Theorem (Quantum States):
\begin{itemize}
  \item No Diagonal Functor (\S\ref{sec:diagonal_functor})
    which could duplicate States
  \item No $K$-combinator which can destroy States
  \item A Variable $x$ can appear at most once in a $\lambda$-term
\end{itemize}

\emph{Linear Type Constructor} %FIXME


Shi-Xi13 \emph{A Linear Type System for Multicore Programming in ATS} --

\fist Viewtypes (\S\ref{sec:viewtype})

examples of Functions that would not be Well-typed if $\mono{T}$ were
a Linear Type:
\begin{verbatim}
  fun ignore    (x:T) : ()    = ()
  fun duplicate (x:T) : (T,T) = (x,x)
  fun saying    (x:T) : T     = (eat(x); x)
\end{verbatim}



\paragraph{Uniqueness Type}\label{sec:uniqueness_type}\hfill

(De Vries, Plasmeijer, Abrahamson 08 - \emph{Uniqueness Typing
  Simplified})

\emph{Uniqueness Type} -- guarantees that a Value has a single
\emph{Reference}

\fist Cf. Linear Types (\S\ref{sec:linear_type}): guarantees that no
more References can be made to a Value

Programming Languages: Clean, Mercury, Idris ($\mono{UniqueType}$), Rust
(``Ownership Types'', ``Borrowed Pointers'')



\subparagraph{Borrowed Type}\label{sec:borrowed_type}\hfill

Programming Languages: Idris ($\mono{BorrowedType}$), Rust (Borrowed
Pointers???)
%FIXME

Idris $\mono{BorrowedType}$:

Uniqueness Type which can be ``inspected'' at ``top level'' by Pattern
Matching or \emph{Lending} to another Function (but no further)
%FIXME



\paragraph{View}\label{sec:view}\hfill

ATS/SV (\S\ref{sec:ats_sv}) -- Zhu-Xi05 \emph{Safe Programming with
  Pointers through Stateful Views} -- (\emph{Note}: this paper was
written for an earlier version of ATS than the implementation
described in \S\ref{sec:ats})

Shi-Xi13 \emph{A Linear Type System for Multicore Programming in ATS}
-- Views can be seen as Linear Types for classifying Capabilities
(\S\ref{sec:capability})

Linear Proposition



\subparagraph{Viewtype}\label{sec:viewtype}\hfill

A \emph{Viewtype} is a pair $(V,T)$ of a Linear Proof of a Linear
Proposition (a \emph{View}), $V$, and a (``Data'') Value of
(Non-linear) Type, $T$.

ATS (\S\ref{sec:ats})

Shi-Xi13 \emph{A Linear Type System for Multicore Programming in ATS}:

viewed ``\emph{Negatively}'' (???), Viewtypes are for classifying
Capabilities (Spaces) of Consuming (Storing) Resources %FIXME

(example Views for Socket Programming) %FIXME

\emph{Datasorts} -- like a Datatype Declaration (ML) but the Declared
``Sort'' is only for classifying \emph{Terms to be used as Indexes}
for forming \emph{Dependent Types}

$\mono{absview}$

$\mono{dataview}$

a Type is always considered a Viewtype ??? %FIXME

$\mathcal{L}^\parallel_0$

$\mathcal{L}^\parallel_{\forall, \exists}$

\fist $\mathcal{L}^\parallel_{\forall,\exists}$
(\S\ref{sec:l_par_quant}) -- Parallel Reduction Calculus
(\S\ref{sec:parallel_reduction_calculus}) with Universally and
Existentially Quantified (Polymorphic and Dependent) Viewtypes

Views and Viewtypes in ATS have counterpats in the Clay Programming
Language (Hawblitzel-Wei-Huang-Krupski-Wittie2004 \emph{Low-level
  linear memory management})



\paragraph{Linear Dependent Type}\label{sec:dependent_linear}\hfill

Vakar14 \emph{Syntax and Semantics of Linear Dependent Types} --
Intuitionistic Linear Dependent Type Theory (ILDTT)

McBride16 \emph{I Got Plenty o' Nuttin'}

Resource Annotations provided by a Rig (Semiring \S\ref{sec:semiring},
i.e. a Ring without Negation)



\paragraph{Session Type}\label{sec:session_type}\hfill

\fist cf. Conversation Type (\S\ref{sec:conversation_type})

\emph{Session Types} are a Typing Discipline (\S\ref{sec:type_system})
for Heterogenous Bidirectional Communication Channels defining the
possible Sequences of Messages (\S\ref{sec:message}) determined by the
Channel's Session Type (e.g. Stream-based Internet Protocols)
\cite{neubauer-thiemann04}

\fist MTLC$_{ch}$ (\S\ref{sec:mtlc_ch}): Multi-threaded
$\lambda$-calculus (\S\ref{sec:mtlc}) with support for Session Types

Crafa12 -- \emph{Behavioral Types for Actor Systems}:

Session Types describe the ``Flow'' of Communications within a single
Conversation Session

a Behavioral Actor Type describes the Actor's point of view as an
entity that might Concurrently participate in different, interleaved
Conversations with different Participants

Behavioral Types (\S\ref{sec:behavioral_type})

\fist Actor Model (\S\ref{sec:actor_model})

\asterism


correspondence between Communicating Automata
(\S\ref{sec:communicating_fsm}) and Session Types:

Danielou, Yoshida - 2013 - \emph{Multiparty Compatibility in
  Communicating Automata: Synthesis and Characterisation of Multiparty
  Session Types}

Lange, Yoshida, Tuosto - 2015 -
\emph{From Communicating Machines to Graphical Choreographies}


\asterism


An Embedding of Simply-typed $\lambda$-calculus
(\S\ref{sec:simply_typed}) into Session-typed $\pi$-calculus (Session
Calculus \S\ref{sec:sessiontyped_pi}) is given in
Toninho-Caires-Pfenning12 \cite{caires-pfenning-toninho12}

\cite{orchard-yoshida16} -- ``(Intensional) Behavioral Types''
(\S\ref{sec:behavioral_type}): Effect Types and Session Types; two-way
Embedding: Effect Systems (\S\ref{sec:effect_system}) Embedded in
Session Calculus (\S\ref{sec:session_calculus}) and vice
versa--Processes as Effect Handlers (\S\ref{sec:effect_handler}),
Session Types as Effects (\S\ref{sec:computational_effect})

Dominic Orchard (youtube) -- Simple Types (\S\ref{sec:simply_typed}):
``What'', Effect Systems (\S\ref{sec:effect_system}): ``How'', Session
Types: ``What \& How''

\cite{orchard-yoshida16}: Communication Effects
(\S\ref{sec:communication_effect}) can be encoded in Session Types,
but there is no reverse encoding of Session Types into Communication
Effects because Session Types do not describe the relative
``Causality'' between Channels (recorded by Communication Effects).
Session Types are more expressive with respect to Higher-order
Communication (Delegation \S\ref{sec:delegation}).

Message Sequences are Described by a Regular Language
(\S\ref{sec:regular_language}) on Atomic Communication Actions
(\S\ref{sec:communication}); Channel Type (\S\ref{sec:channel_type})
specifies the Language with a Fix-point Expression ($\mu$). Operations
peel off the ``outermost'' Action (???) of the Channel Type and change
the Channel Type (Linearity). \cite{neubauer-thiemann04}

Implementation requirements: \cite{neubauer-thiemann04}
\begin{itemize}
  \item Type Constraints (Type Classes \S\ref{sec:constrained_type})
    with Functional Dependencies (\S\ref{sec:functional_dependency}):
    modelling the progression of the current state of the Channel
  \item Functions with Polymorphic Parameters
    (\S\ref{sec:parametric_polymorphism}): models Client and Server
    side of a Communication with one specification
\end{itemize}

Static Analysis of the Communication Behavior (???) of Agents (???) in
a Distributed System \cite{gay-vasconcelos10}

(Communication) Protocol

Distribution and Concurrency

$\parr$

$\otimes$

Curry-Howard (\S\ref{sec:curry_howard}) for Process Calculi
(\S\ref{sec:process_calculus}):
\begin{itemize}
  \item Propositions as Session Types
  \item Proofs as Processes (\S\ref{sec:process})
  \item Cut-elimination (\S\ref{sec:cut_elimination}) as Communication
    (\S\ref{sec:communication})
\end{itemize}

Linear Propositions (\S\ref{sec:linear_logic})

Dual Intuitionistic Linear Logic \cite{caires-pfenning10} (Shared ???,
Linear)

\cite{honda-yoshida-carbone08}: Multiparty Asynchronous Session Types
(\S\ref{sec:multiparty_session})

Xi-Wu16: \emph{Propositions in Linear Multirole Logic as
  Multiparty Session Types} (\S\ref{sec:lmrl})

% FIXME ???
Session: a ``unit'' of a Communication

Session Type: ``structure'' of a Communication

Only Processes with Dual Protocols can Interact

Cotype


\cite{honda-vasconcelos-kubo98}:

Session: a Sequence of Dyadic Interactions

Program: a Collection of Dyadic Interactions in a Session \emph{or} a
Process with no Free Variables % FIXME

Channel: Private Port Designating a Session (cf. Information Theory
\S\ref{sec:channel} Channels)

Session Protocol (\S\ref{sec:session_protocol})


\cite{orchard-yoshida15}: foundation for reasoning about Concurrent
Side-effects using Sessions


\cite{neubauer-thiemann04}:
\begin{enumerate}
  \item First-order Base Type Values
  \item Functions
  \item Labels (cf. Labels in Record (\S\ref{sec:product_type}) or
    Variant Types (\S\ref{sec:sum_type})
\end{enumerate}


\textbf{Primitives}

\begin{itemize}
  \item \emph{Send}
  \item \emph{Receive}
  \item \emph{Sequence}
  \item \emph{Choice}
  \item \emph{Recursion}
\end{itemize}



\subparagraph{Channel Type}\label{sec:channel_type}\hfill

\subparagraph{Label}\label{sec:channel_label}\hfill



\paragraph{Multi-party Session Type}\label{sec:multiparty_session}\hfill

Honda-Yoshida-Carbone08 -- \emph{Asynchronous Multiparty Session
  Types} \cite{honda-yoshida-carbone08}

Bejleri-Yoshida09 -- \emph{Synchronous Multiparty Session Types}

Xi-Wu16 -- \emph{Propositions in Linear Multirole Logic as
  Multiparty Session Types}:

Linear Multirole Logic (\S\ref{sec:lmrl})

$\pi LMRL$ (\S\ref{sec:pi_lmrl})

Danielou-Yoshida11 -- \emph{Dynamic Multirole Session Types}

\fist Scribble (Protocol Description Language)

\fist WS-CDL (Web Service Choreography Description Language)

\fist Choreography BPMN (Business Process Model and Notation)


\asterism


Honda,Yoshida,Carbone08 \cite{honda-yoshida-carbone08}:

\emph{Global Type} (\S\ref{sec:global_type}) provides shared agreement among
Communication Peers

efficient Type Checking through Projection of Global Type onto
individual Peers

Safety and Progress guarantees for general $n$-party Asynchronous
Interactions

Safety, Linearity, Progress (Deadlock free in a ``single'' Session)

Predictability: Communication follows scenario declared in Session
Type

$\pi$-calculus

Session established among Multiple Parties via a \emph{Shared Name}
(``public'' Interaction point) and \emph{Session Channels} are
generated and shared through which Communication Actions are performed


\textbf{Syntax}

\begin{flalign*}
  \quad P ::=& \; \overline{a}[2 \ldots n](\tilde{s}).P \;
    | \; a[i](\tilde{s}).P &
      \text{(multicast) session request/session accept} \\
    |&\; s!\langle\tilde{e}\rangle;P \;|\; s?(\tilde{x});P &
      \text{value send/value receive} \\
    |&\; s!\langle\langle\tilde{s}\rangle\rangle;P \;|\; s?((\tilde{s}));P &
      \text{session delegate/session receipt} \\
    |&\; s \lhd l;P \;|\; s \rhd \{l_i : P_i\}_{i \in I} &
      \text{label selection/label branching} \\
    |&\; \mono{if}\; e \;\mono{then}\; P \;\mono{else}\; Q &
      \text{conditional branch} \\
    |&\; P | Q & \text{parallel composition} \\
    |&\; \mathbf{0} & \text{inaction} \\
    |&\; (\nu n) P & \text{hiding} \\
    |&\; \mono{def}\; D \;\mono{in}\; P & \text{recursion} \\
    |&\; X \langle \tilde{x}\tilde{s} \rangle & \text{process call} \\
    |&\; s : \tilde{h} & \text{message queue} \\
  \quad e ::=& \; v \;|\; e \;\mono{and}\; e' \;
    | \;\mono{not}\; e \;\ldots \; & \text{expressions} \\
  \quad v ::=& \; a \;|\; \true \;|\; \false & \text{values} \\
  \quad h ::=& \; l \;|\; \tilde{v} \;|\; \tilde{s} &
    \text{messages-in-transit} \\
  \quad D ::=& \; \{X_i(\tilde{x}_i\tilde{s}_i) = P_i\}_{i \in I} &
    \text{recursion declaration}
\end{flalign*}


\textbf{Operational Semantics} -- Structural Congruences + Reductions

\emph{Structural Congruences}


\emph{Reductions}

\begin{itemize}
  \item \emph{Link}
  \item \emph{Send}
  \item \emph{Deleg}
  \item \emph{Label}
  \item \emph{Recv}
  \item \emph{SRec}
  \item \emph{Branch}
  \item \emph{IfT}
  \item \emph{IfF}
  \item \emph{Def}
  \item \emph{Scop}
  \item \emph{Par}
  \item \emph{Defin}
  \item \emph{Str}
\end{itemize}


\textbf{Global Session Types}

Global Types $G, G', \ldots$

Value Types $U, \ldots$

Sorts $S, S', \ldots$

\begin{flalign*}
  \quad G ::=& \; p \rightarrow p' : k \langle U \rangle.G' &
      \text{values} \\
    |&\; p \rightarrow p' : k \{ l_j : G_j \}_{j \in J} &
      \text{branching} \\
    |&\; G,G' & \text{parallel} \\
    |&\; \mu \mathbf{t}.G & \text{recursive} \\
    |&\; \mathbf{t} & \text{type variable} \\
    |&\; \mathsf{end} & \text{session termination} \\
  \quad U ::=& \; \tilde{S} \;|\; T @ p \\
  \quad S ::=& \; \mathsf{bool} \;|\; \mathsf{nat} \;|\;
    \ldots \;|\; \langle G \rangle
\end{flalign*}

$\tilde{S}$ -- a Vector of Types for Shared Names (\emph{Sorts})

$T @ p$ -- a Vector of Session Channels

$p \rightarrow p' : k \langle U \rangle.G'$ -- Participant $p$ Sends
Message of Type $U$ to Channel $k$, Received by Participant $p'$ and
then Interactions described in $G'$ follows

$p \rightarrow p' : k$ is a \emph{Prefix} from $p$ to $p'$ at $k$;
$\langle U \rangle$ is a \emph{Carried Type} of the Prefix

$p \neq p'$ -- i.e. no Reflexive Interaction

\emph{Prefix Ordering} $\prec$: a Global Type $G$ is regarded as an
Acyclic Directed Graph given by the Standard Regular Tree
(\S\ref{sec:regular_tree_grammar}) Presentation (Pierce04 \emph{Types
  and Programming Languages}) with Ordering of Nodes induced by
Prefixes; imposes Sequencing only on actions of the same participant
in Prefixes Ordered by $\prec$

remaining Causal Ordering according to Lamport78 - \emph{Time, clocks,
  and the ordering of events}


\emph{Safety Principle} for Global Types-- a necessary and sufficient
condition to prevent conflict (racing) at Session Channels: when a
common Channel is used in two Communications, Send and Receive actions
should Temporally Ordered (i.e. the pair of Prefixes become active in
a Strict Temporal Order)


\textbf{Causal Analysis}

IO, II, OO

II or IO (alone) -- only safe when the two Channels are different

II,OO (combined) -- having the same Sender and Channel, Outputs are
ordered by Message Order-preservation

OI -- no Ordering from Output to Input due to Asynchrony

\emph{Dependency Relations}

Input Dependency, Output Dependency

\emph{Linearity}

$G$ is \emph{Linear} if whenever $n_i = p_i \rightarrow p'_i : k (i =
1,2)$ are in $G$ for some $k$ and do not occur in different Branches,
then both Input and Output Dependencies exist from $n_1$ to $n_2$, or
if not, both exist from $n_2$ to $n_1$ (and Inductively for any Global
Types Carried by $G$)

a Global Type is Linear if and only if its One-time Unfolding is Linear

Linearity of a Global Type is decidable by a Quadratic Algorithm in
the size of the Graph

%FIXME


\textbf{Local Types}

\emph{Local Types} represent the \emph{Local Behavior} of Processes
and act as a link between Global Types and Processes

\begin{flalign*}
  \quad T ::=& \; k! \langle U \rangle;T & \text{send} \\
    |&\; k? \langle U \rangle;T & \text{receive} \\
    |&\; k \oplus \{ l_i : T_i \}_{i \in I} & \text{selection} \\
    |&\; k \& \{ l_i : T_i \}_{i \in I} & \text{branching} \\
    |&\; \mu \mathbf{t}.T \;|\; \mathbf{t} \;|\; \mathsf{end} \\
  \quad U ::=& \; \tilde{S} \;|\; T @ p \\
  \quad S ::=& \; \mathsf{bool} \;|\; \ldots \;|\; \langle G \rangle
\end{flalign*}

$T @ p$ -- Local Type $T$ for Participant $p$

a Sort can either be an Atomic Type (Communication of Constants) or a
Global Type (Communication of Initiating Names)
%FIXME ``initiating %names'' ?

Type Isomorphism: allow Permutation of two consecutive Outputs with
different Subjects (Asynchronous Communication) %FIXME


\textbf{Projection}

$G \upharpoonright p$

Projection Function of Global Types to Local Types: extracts the part
of a given Global Type that concerns the Local Behavior of a specific
Participant

\emph{Inductive Definition} %FIXME


\textbf{Coherence}

$\mathsf{pid}(G)$ -- Set of Participants occurring in $G$ (but not in
Carried Types)

$G$ is \emph{Coherent} if it is Linear and $G \upharpoonright p$ is
Well-defined for each $p \in \mathsf{pid}(G)$ and similarly for each
Carried Global Type Inductively

$\{ T_p @ p \}_{p \in I}$ is \emph{Coherent} if for some Coherent $G$
such that $I = \mathsf{pid}(G)$, $G \upharpoonright p = T_p$ for each
$p \in I$

Coherence of $G$ is Decidable by Quadratic Algorithm

\fist Decidability of Coherence of $\{ T_p @ p \}_p$ is not proved in
\cite{honda-yoshida-carbone08}


\textbf{Programs}

A Proces $P$ is a \emph{Program Phrase} if $P$ has no Queues and no
Hidden Session Channels

$P$ is a \emph{Program} if $P$ is a Program Phrase with no Free
Session Channels and Process Variables


\textbf{Environments}

other than Atomic Types, a Sort has the shape $\langle G \rangle$
where $G$ is Coherent

Grammar of \emph{Sortings} (Environemnts) and \emph{Typings}:

\begin{flalign*}
  \quad \Gamma ::=& \varnothing \;|\; \Gamma, u : S \;
    |\; \Gamma,X : \tilde{S}\tilde{T} \\
  \quad \Delta ::=& \Delta,\tilde{s} : \{ T @ p \}_{p \in I}
\end{flalign*}

a Sorting $(\Gamma,\Gamma',\ldots)$ is a Finite Map from Names
to Sorts and from Process Variables to Sequences of Sorts and Types

a Typing $(\Delta,\Delta',\ldots)$ records a Linear Usage of Session
Channels

in Binary Sessions, each Channel is mapped to a Type; here in
Multiparty Sessions each Vector of Session Channels is mapped to a
Family of Located Types

$\tilde{s} : T @ p$ -- Singleton Typing $\tilde{s} : \{ T @ p \}$

$\Delta,\Delta'$ -- denotes Typing from Disjoint Union of $\Delta$ and
$\Delta'$ (assuming Domains contain Disjoint Sets of Session Channels)

$\mathsf{sid}(G)$ -- Set of Session Channel IDs of $G$

$\circ$ -- Partial Operator:
\[
  \{ T_p @ p \}_{p \in I} \circ \{ T'_{p'} @ p' \}_{p' \in J} =
    \{ T_p @ p \}_{p \in I} \cup \{ T'_{p'} @ p' \}_{p' \in J}
\]

$\Delta_1 \asymp \Delta_2$ -- \emph{Compatibility Relation}: for all
$\tilde{s}_i \in \mathsf{dom}(\Delta_i)$ such that $\tilde{s}_1 \cap
\tilde{s}_2 \neq \varnothing$, $\tilde{s} = \tilde{s}_1 = \tilde{s}_2$
and $\Delta_1(\tilde{s}) \circ \Delta_2(\tilde{s})$ is Defined

$\Delta_1 \circ \Delta_2$ -- the \emph{Compostion} of $\Delta_1$ and
$\Delta_2$ is Defined when $\Delta_1 \asymp \Delta_2$ as:
\[
  \Delta_1 \circ \Delta_2 =
    \{ \Delta_1(\tilde{s}) \circ \Delta_2(\tilde{s})
      \;|\; \tilde{s} \in
      \mathsf{dom}(\Delta_1) \cap \mathsf{dom}(\Delta_2) \}
    \cup \Delta_1 \setminus \mathsf{dom}(\Delta_2)
    \cup \Delta_2 \setminus \mathsf{dom}(\Delta_1)
\]


\textbf{Typing System}

Typing Judgement:
\[
  \Gamma \vdash P \rhd \Delta
\]
denotes that Process $P$ has Typing $\Delta$ under Environment
$\Gamma$

Typing Rules:
\begin{itemize}
  \item \emph{Mcast}
  \item \emph{Macc}
  \item \emph{Send}
  \item \emph{Rcv}
  \item \emph{Deleg} -- passes the whole capability to participate in
    a Multiparty Session: operationally sending the whole Vector of
    Session Channels
  \item \emph{SRec}
  \item \emph{Sel}
  \item \emph{Branch}
  \item \emph{Conc}
  \item \emph{If}
  \item \emph{Inact}
  \item \emph{NRes}
  \item \emph{Var}
  \item \emph{Def}
  \item \emph{Name}
  \item \emph{Bool}
  \item \emph{Or}
\end{itemize}

\fist Typing Rules are essentially the same as Binary Session Typing
Rules with $|\tilde{s}| = 1$, $n = 2$, and $p$ deleted from Located
Type

\emph{Thm.}: given an \emph{Annotated} Program Phrase $P$ and
Environment $\Gamma$, it is decidable by Quadratic Algorithm if there
is a $\Delta$ such that $\Gamma \vdash P \rhd \Delta$ or not

\emph{Cor.}: given an Annotated Program Phrase $P$ and Environment
$\Gamma$, it is decidable if $\Gamma \vdash P \rhd \varnothing$


\textbf{Safety and Progress}

Subject Reduction (\S\ref{sec:subject_reduction}): Reduction of
Types follows Reduction of Processes; \emph{Safety}

Progress is guaranteed by the Reduction of Processes following from
Reduction of Types


\emph{Runtime Typing}

Message Queues

Type Contexts


\emph{Type Reduction}

Causal Edges %FIXME

\emph{Def.} Full Projection $\llbracket G \rrbracket$

Coherent Typing, Partial Coherence


\emph{Subject Reduction and Communication Safety}

\emph{Thm.} Subject Congruence and Reduction -- guarantees Type Safety

Reduction Context

\emph{Thm.} Communication Safety -- Linearity, Error-freedom: if a
Process ever does a Reduction, it conforms to the Typing and is Linear


\emph{Progress}

\emph{Def.} Queue-full Process -- a Process is Queue-full when it has
a Queue for each Session Channel

\emph{Def.} Simple Process

\emph{Def.} Well-linked Process

\emph{Thm.} Progress -- a Simple, Well-linked Program $P$ has the
\emph{Progress Property}: $P \rightarrow^* P'$ Implies either $P'$ is
Empty or $P' \rightarrow P''$ for some $P''$


\textbf{Extensions}

removing Order-preservation (``Pure'' Asynchrony -- Honda-Tokoro91):
remove $\mathsf{OO}$-edges %FIXME datagram UDP ?

Multicast Primitives


\asterism


Castagna,Dezani-Ciancaglini,Padovani11 -- \emph{On Global Types and
  Multi-Party Sessions}

Global Types with Trace-based Semantics

Liveness Property

Soundness and Completeness with respect to the Set of Traces of the
Global Type

allows different Implementations (Interleaving), cf.
Bravetti,Lanese,Zavattaro08 \emph{Contract-driven implementation of
  choreographies} where there is a \emph{Strong Bisimulation} between
Choreography and its Projection

\emph{Verification}: Implementation Satisfies Specification

\emph{Implementability}: automatically produce Implementation from
Specification

``Behavioral Type (\S\ref{sec:behavioral_type})/Process Algebra
(\S\ref{sec:process_calculus})'' approaches to the
\emph{Implementability Problem}:
\begin{itemize}
  \item Automata/Model Checking -- Message Sequence Charts (MSC),
    Message Sequence Graphs (MSC with Branching and Iteration:
    High-level MSC), Projected into Communicating Finite State
    Machines (\S\ref{sec:communicating_fsm})
  \item Cryptographic Protocols -- MSC as Global Descriptions (less
    emphasis on Control and more on Message Processing)
  \item Web-services -- WS-CDL (Web Service Choreography Description
    Language); Dynamic (sending Channels)
\end{itemize}

three-layered structure (from higher to lower):
\begin{enumerate}
  \item Global Types (\emph{Choreographic Description})
  \item Session Types (Type-check Process Implementations)
  \item Processes (Implementation)
\end{enumerate}

\emph{Implementability} -- between layers (1) and (2): Projections
are Sound and Complete with respect to Global Specifications and
Deadlock-free

\emph{Typeability} -- between layers (2) and (3): Subject Reduction
(Well-typed Processes only Reduce to Well-typed Processes); Progress
(Deadlock-freedom)


\emph{Multiparty Session}: a ``Place of Interaction'' for a restricted
number of \emph{Participants} that Communicate via \emph{Messages}

Protocol: connects basic Communication Actions with Flow Control, or
in general a \emph{Possibly Infinite Set of Finite Sequences of
  Interactions between a fixed Set of Participants}

Language for describing Sequences that characterize a Protocol: 1
Atomic Action and 3 Composition Operations

\emph{Atomic Action}: Sender, Receiver, Content (Interaction)

\emph{Composition}:

\begin{itemize}
  \item Sequential -- \emph{Then}; imposes \emph{Order} on Actions
  \item Parallel -- \emph{And}; Order not specified
  \item Alternative -- \emph{Xor}; free Choice
\end{itemize}

``Decision Makers'' required for Liveness (Alternative always needs an
Offer/Choose pairing) -- depends on absence of \emph{Covert Channels}

to Verify an Implementation against a Protocol:

\begin{enumerate}
  \item Sequentiality -- Order of Specification respected in all
    possible Executions
  \item Alternativeness -- for Alternative Interactions, every
    Execution exhibits one and only one of them
  \item Shuffling -- for Parallel Composition of Sequences all
    Executions must exhibit some interleaving of those Sequences
  \item Fitness -- any Sequence of Interactions exhibited by an
    Implementation must ``fit'' the Specification
  \item Exhaustivity -- for any Sequence of Interactions described by
    the Specification, there must be at least one Execution of the
    Implementaiton that exhibits that Sequence
\end{enumerate}

checking Implementation against Specification: Projection of Gobal
Type Satisfying certain Well-formedness Conditions to Local Session
Type of each Participant and Type-check against Implementation

\emph{Session Environments} -- mappings from Participants to their
Session Types

\emph{Flawed Global Types} -- Global Types that do not admit any
Implementations without Covert Channels:

\begin{enumerate}
  \item No Sequentiality -- e.g. Sequencing Events that cannot be
    Causally Related (without Covert Communication)
  \item No Knowledge for Choice -- e.g. an Action depends on some
    previous Action in the Execution Trace
  \item No Knowledge, No Choice -- Incompatible Behavior, e.g.
    Input/Output in Mutual Exclusion %FIXME
\end{enumerate}


\textbf{Types}

$A$ -- Set of \emph{Message Types} $a, b, \ldots$

$\Pi$ -- Set of \emph{Roles}

$\pi, \pi', \ldots$ -- Sets of Roles

$p, q, \ldots$ -- \emph{Participants}

$G, G', \ldots$ -- \emph{Global Types}

\textbf{Global Types} -- Global Types denote a \emph{Language}
(defined over an Alphabet of Interactions) of allowed Interactions
that can occur in a Multiparty Session; Regular Language with a
``Shuffling'' (Interleaving ???) Operator and Semantics defined as
Sequences of Interactions (Traces ???); Consequence of chosen
Semantics ensures every Implementation of a Global Type preserves the
possibility to reach a State where every Participant has Terminated
successfully; Well-formed Global Types are characterized in terms of
their Semantics
%FIXME

Syntax:

\begin{flalign*}
  \quad G ::=& \; \mathsf{skip} & \text{skip} \\
    \ |\ & \pi \xrightarrow{a} p & \text{interaction} \\
    \ |\ & G;G' & \text{sequence} \\
    \ |\ & G \vee G' \ |\ G \wedge G' & \text{either/both} \\
    \ |\ & G^* & \text{loop}
\end{flalign*}

$\pi \xrightarrow{a} p$ -- Participant $p$ awaits an $a$ Message from
\emph{all} Participants whose ``tags'' are in $\pi$

Interaction could be generalized to $\pi \xrightarrow{a} \pi'$
(\emph{Broadcast}) by encoding as $\bigwedge_{i \in I} (\pi
\xrightarrow{a} p_i)$, assuming Asynchronous (Non-blocking) Output

$\pi \xrightarrow{a} p$ -- \emph{Join} Activities involving
Participants $\pi \cup {p}$

$\bigwedge_{i \in I} (p_i \xrightarrow{a} q)$ -- \emph{Fork} of
Parallel Activities

$p \notin \pi$ -- Participants cannot send Messages to themselves


\textbf{Interactions}

Alphabet of Interactions:
\[
  \Sigma = \{ \pi \xrightarrow{a} p
    \ |\ \pi \subset_{fin} \Pi, p \in \Pi, p \notin \pi, a \in A \}
\]

$\alpha$ -- shorthand for Interaction $\pi \xrightarrow{a} p$

$\varphi, \psi, \ldots$ -- Strings in $\Sigma^*$

$\varepsilon$ -- Empty String

$;$ -- String Concatenation

\emph{Shuffle} (Interleaving) of Languages $L_1$, $L_2$:
\[
  \mono{shuffle}(L_1, L_2) \defeq \{ \varphi_1\psi_1 \cdots
    \varphi_n\psi_n \ |\ \varphi_1 \cdots \varphi_n \in L_1 \wedge
    \psi_1 \cdots \psi_n \in L_2
  \}
\]
in that the Order of Interactions from each Language is preserved but
Interleaved with those of the other

\emph{Traces} -- Set of Traces of a Global Type defined Inductively:
\begin{align*}
  & tr(\mathsf{skip}) =& \{ \varepsilon \} \\
  & tr(\pi \xrightarrow{a} p) =& \{ \pi \xrightarrow{a} p \} \\
  & tr(G_1;G_2) =& tr(G_1)tr(G_2) \\
  & tr(G^*) =& (tr(G))^* \\
  & tr(G_1 \vee G_2) =& tr(G_1) \cup tr(G_2) \\
  & tr(G_1 \wedge G_2) =& \mono{shuffle} (tr(G_1), tr(G_2)) \\
\end{align*}
where by $tr(G)$ is a Regular Language as Regular Languages are closed
under Shuffling

because Regular Languages consist of \emph{Finite} Strings, all
Participants may Terminate -- Infinite Interactions not allowed ???
%FIXME


\textbf{Session Types}

$X, \ldots$ -- \emph{Recursion Variables}

$T,S,\ldots$ -- \emph{Pre-session Types} describe Behavior of
Participants of a Multiparty Session, with Grammar:
\begin{flalign*}
  \quad T ::=& \mathsf{end} & \text{termination} \\
    \ |\ & X & \text{variable} \\
    \ |\ & \pi?a.T \ |\ p!a.T & \text{input/output} \\
    \ |\ & T \oplus T' \ |\ T + T' & \text{internal/external choice} \\
    \ |\ & \mono{rec} X.T & \text{recursion}
\end{flalign*}
modulo Associativity, Commutativity, and Idempotence of Internal and
External Choice, Fold/Unfold of Recursions and Equalities:
\[
  \pi!a.T \oplus \pi!a.S = \pi!a.(T \oplus S) \quad\quad\quad
  \pi?a.T + \pi?a.S = \pi?a.(T+S)
\]
and such that all Recursion is Guarded by at least one Input or Output
Prefix %FIXME clarify

$\mathsf{end}$ -- a Participant that has successfully Terminated (no
longer Participates in the Session)

$p!a.T$ -- a Participant that Sends an $a$ Message to Participant $p$
and afterwards Behaves according to $T$

$\pi?a.T$ -- a Participant that waits for an $a$ Message from all
Participants in $\pi$ and upon arrival Behaves as $T$

$T \oplus S$ -- a Participant that internally decides (Chooses)
whether to Behave according to $T$ or $S$

$T + S$ -- a Participant that Offers other Participants the Behaviors
$T$ and $S$ depending on Messages Sent by the other Participant
%FIXME which participant enacts the chosen behavior ?

\emph{Session Types} are Pre-session Types where Internal Choices are
used to combine Outputs and External Choices are used to combine
Inputs and the \emph{Continuation} after every Prefix is uniquely
determined by the Prefix, that Pre-session Type $T$ is a Session Type
if one of:
\begin{itemize}
  \item $T = \mathsf{end}$
  \item $T = \oplus_{i \in I} p_i!a_i.T_i$ and $\forall i,j \in I$,
    $p_i!a_i = p_j!a_j$ Imples that $i = j$ and each $T_i$ is a
    Session Type
  \item $T = \Sigma_{i \in I} \pi_i ? a_i.T_i$ and $\forall i, j \in
    I$, $\pi_i \subseteq \pi_j$ and $a_i = a_j$ Implies $i = j$ and
    each $T_i$ is a Session Type
\end{itemize}


\textbf{Session Environments}

a \emph{Session Environment} (or \emph{Session}) is the Set of Session
Types of its Participants where each Participant is uniquely
identified by a Role, that is a Finite Map:
\[
  \{ p_i : T_i \}_{i \in I}
\]

$\Delta, \Delta', \ldots$ -- Session Environments (Sessions)

$\Delta \uplus \Delta'$ -- Union of Sessions with Disjoint Domains

$p \xrightarrow{a} q$ -- Message of Type $a$ with Sender $p$ and
Receiver $q$

Asynchronous Communication: Messages are stored in a Buffer

$\mathbf{B}, \ldots$ -- Buffers:
\[
  p_1 \xrightarrow{a_1} q_1 :: \cdots :: p_n \xrightarrow{a_n} q_n
\]
of Messages considered under Congruence of Order preservation for
Messages having the same Sender and Receiver:
\[
  p \xrightarrow{a} q :: p' \xrightarrow{b} q' \cong
  p' \xrightarrow{b} q' :: p \xrightarrow{a} q
\]
for $p \neq p'$ or $q \neq q'$; that is each pair of Participants in
the Session is connected by a distinct \emph{FIFO Buffer}

\emph{Session Reduction} -- two possible Reductions: %FIXME
\begin{enumerate}
  \item Effect of an Output Operation by a Participant, storing the
    Message in a Buffer and leaving Sender with residual Session Type
  \item Effect of an Input Operation of Messages from Particpants, and
    if enough Messages are received, continues as residual Session
    Type
\end{enumerate}

$\Rightarrow$ -- Reflexive, Transitive Closure of $\rightarrow$

$\xRightarrow{\alpha}$ -- Composition $\Rightarrow
\xrightarrow{\alpha} \Rightarrow$

$\xRightarrow{\alpha_i\cdots\alpha_n}$ -- Composition
$\xRightarrow{\alpha_i}\cdots\xRightarrow{\alpha_n}$

\emph{Liveness Property} -- for all Reductions it is always possible to
reach a State where all Participants have Successfully Terminated and
the Buffer has been depleted; $\Delta$ is a \emph{Live Session} if:
\[
  \varepsilon ; \Delta \xRightarrow{\varphi} B; \Delta'
\]
Implies:
\[
  B ; \Delta' \xRightarrow{\psi} \varepsilon ;
    \{ p_i : \mathsf{end} \}_{i \in I}
\]
for some $\phi$


\emph{Session Traces} -- the Set of Sequences of Interactions that can
occur in every possible Reduction with the Trace of an Incorrect
(Non-live) Session as the Empty Set:
\[
  tr(\Delta) \defeq
    \begin{cases}
      \{ \varphi \ |\ \varepsilon ;
        \Delta \xRightarrow{\varphi} \varepsilon;
        \{ p_i : \mathsf{end} \}_{i \in I} \}
        & \text{if} \ \Delta\ \text{is a Live Session} \\
      \varnothing & \text{otherwise}
    \end{cases}
\]

for every Global Type $G$, $tr(G) \neq \varnothing$


\textbf{Semantic Projection}

\emph{which} Global Types are able to be Projected

Project a Global Type to the Session Types of its Participants, i.e.
to a Session

$\Delta$ and $G$ are not required in general to have the same Traces

Correctness is a Relationship between the Traces of $\Delta$ and the
Traces of $G$:
\begin{enumerate}
  \item \emph{Soundness} -- every Trace of $\Delta$ is a Trace of $G$
  \item \emph{Completeness} -- every Trace of $G$ is a Permutation of
    a Trace of $\Delta$
\end{enumerate}
that is:
\[
  tr(\Delta) \subseteq tr(G) \subseteq tr(\Delta)^\circ
\]
where $L^\circ$ is the Closure of $L$ under Permutation of Strings in
$L$

\emph{Rules}
\begin{itemize}
  \item \emph{SP-Action}
  \item \emph{SP-Skip}
  \item \emph{SP-Sequence}
  \item \emph{SP-Alternative}
  \item \emph{SP-Iteration}
  \item \emph{SP-Subsumption}
\end{itemize}

\emph{Implementation Pre-order}

$\Delta \leq G$ -- $\Delta$ is both Sound and Complete with respect to
$G$, i.e. $\Delta$ is a Correct Implementation of the Specification
$G$

\emph{Judgement with Continuation} -- $\Delta'$ is the Projection of
$G$ with \emph{Continuation} $\Delta$:
\[
  \Delta \vdash G \rhd \Delta'
\]
meaning if $\Delta$ is the Projection of some $G'$, then $\Delta'$ is
the Projection of $G;G'$

no Rule for $\wedge$ -- eliminated by the Subsumption Rule

\emph{Judgement without Continuation} -- if:
\[
  \vdash G \rhd \Delta
\]
is Derivable, then $G$ is \emph{Projectable}

\emph{Def.} Well-formed Global type: a Set of Traces $L$ is
Well-formed if $\varphi; \pi \xrightarrow{a} p; \pi' \xrightarrow{b}
p'; \psi \in L$ Implies either $p \in \pi' \cup \{p'\}$ or $\varphi;
\pi' \xrightarrow{b} p'; \pi \xrightarrow{a} p; \psi \in L$

if $G$ is Well-formed so is $tr(G)$

Well-formedness of $G$ is Decidable by building an Automaton that
Recongizes the Language $tr(G)$

Projection and Well-formedness are separate Properties: it is possible
to Project an Ill-formed Global Type

if a Global Type is Projectable (i.e. $\vdash G \rhd \Delta$ is
Derivable) then Well-formedness is a Necessary and Sufficient
Condition for Soundness and Completeness of its Projection (i.e.
$\Delta \leq G$

\emph{Thm.} If $G$ is Well-formed and $\vdash G \rhd \Delta$, then
$\Delta \leq G$

if a Global Type is Well-formed and Projectable then its Projection is
a (Non-empty) \emph{Live Projection}


\textbf{Algorithmic Projection}

\emph{how} Global Types are Projected

given a Session Continuation $\Delta$ and a Global Type $G$ produces a
Projection $\Delta'$ such that $\Delta \vdash G : \Delta'$

Rules: \emph{AP-Skip}, \emph{AP-Action}, \emph{AP-Sequence},
\emph{AP-Alternative}, \emph{AP-Iteration}

no \emph{Completeness} -- can't return a Projection for \emph{every}
Global Type that is Semantically Projectable

\emph{Compatibility}: cf. Danielou-Yoshida13 %FIXME

\emph{Merge} -- Session Types, Sessions: defined locally for pairs of
Session Types (as opposed to $\leq$ which is ``global'')

\emph{$k$-Exit Iterations} -- generalization of Binary Kleene Star


\asterism


Danielou-Yoshida13 - \emph{Multiparty Compatibility in Communicating
  Automata: Characterisation and Synthesis of Global Session Types}

construct a Global Specification from a Set of Distributed
Uncontrolled Behaviors

fully characterize Multiparty Session Types in terms of Communicating
Automata exactly corresponding to Projected Local Types

Communicating Finite State Machines (\S\ref{sec:communicating_fsm})

Labelled Transition Systems (\S\ref{sec:labelled_transition})

Global and Local Session Types equipped with Labelled Transition
Systems with Asynchronous Communication through Unbounded Buffered
Channels

Sythesis of Global Type from a collection of Communicating Automata

\emph{Multiparty Compatibility} -- non-trivial extension of Duality
Condition for Binary Session Types

\emph{Conditions for Synthesis} as a Sound and Complete
characterisation of Multiparty Session Types with respect to
Communicating Finite State Machines: guarantees the \emph{Global
  Safety Property} of Multiparty Session Types


\textbf{Communicating Automata}

Subclass of Communicating Automata characterizing Binary Session Types
was proposed in Gouda-Manning-Yu84, and independently in Villard11 in
the context of \emph{Channel Contracts} (???); characteristics:
\begin{enumerate}
  \item Communications are Deterministic
  \item no ``Mixed States'', i.e. States are only given all Send
    Actions or all Receive Actions
  \item \emph{Compatible} Traces (i.e. Dual)
\end{enumerate}

all three required to prevent Deadlocks, breaking (1) or (2) would
make Compatibility Checking Undecidable

\emph{Multiparty Compatibility} -- Synthesis approach: characterizes a
Synthesis Condition under which a Global Choreography can be
constructed from Local Machine Behavior

check Duality between each Automaton and ``the Rest'' up to the
Internal Communications (1-bounded Executions) that the other Machines
will independently perform

Generalised Multiparty Session Types
(\S\ref{sec:generalized_multiparty}) -- Danielou-Yoshida13 (Appendix)

\fist \emph{Note}: in Danielou-Yoshida13 the Set of Machine States is
defined as $Q = \{q_0,\ldots\}$; to avoid confusing with Participants
$q \in P$ in the following $M = \{m_0, \ldots\}$ is used instead and
$\mathbf{M}$ will be used to denote the Machine itself


\textbf{Communicating Systems}

\fist Communicating System (\S\ref{sec:communicating_system})

assuming \emph{Connected}, \emph{Deterministic} CFSMs: for every
Non-initial State $q \neq q_0$, there is a Path from $q_0$ to $q$

a \emph{Communicating System} $\class{S}$ is a Tuple:
\[
  \class{S} = (\mathbf{M}_p)_{p \in P}
\]
of Machines such that:
\[
  \mathbf{M}_p = (M_p, C, m_{0p}, \Lambda, \delta_p)
\]
and $P = \{p, q, \ldots\}$ is a Set of Participants (Roles ???) %FIXME

$\Lambda$ -- Actions (Labels) $\ell, \ell', \ldots$

\emph{Configuration} of $\class{S}$ is a Tuple:
\[
  s = (\vec{m};\vec{w})
\]
where $\vec{m} = (m_p)_{p \in P}$ with $m_p \in M_p$ and $\vec{w} =
(w_{pq})_{p \neq q \in P}$ with $w_{pq} \in \Lambda^*$ where $\vec{m}$
is the \emph{Control State} and $m \in M_i$ is the \emph{Local State}
of Machine $\mathbf{M}_i$, and $\vec{w}$ is the \emph{Buffer State}

Reachable States

\emph{Initial Configuration}:
\[
  s_0 = (\vec{m_0};\vec{\varepsilon})
\]
with $\vec{m_0} = (m_{0p})_{p \in P}$

\emph{Final Configuration}:
\[
  s_f = (\vec{m}, \vec{\varepsilon})
\]
with all $m_p \in \vec{m}$ Final

\emph{Reachable Configuration} -- $s_0 \rightarrow^* s$

\emph{Reachable Set} -- $RS(\class{S}) = \{ s\ |\ s_0 \rightarrow^* s\}$

\emph{Traces}:
\[
  Tr(\class{S}) = \{ act(\varphi) \ |\
    \exists s \in RS(\class{S}), s_0 \xrightarrow{\varphi} s \}
\]


\textbf{Configuration Properties}

\emph{Stable} -- all Buffers are Empty

\emph{Deadlock} -- Non-final Configuration where all Machines are in a
Receiving State (Blocked waiting)

\emph{Orphan Message} -- all Machines are in Final State but there are
still Messages in the Buffer

\emph{Unspecified Reception} (\emph{Reception Error}) -- there is a
State prevented from Receiving any Messages %FIXME needs details from
paper


\emph{$k$-bounded Sequence} of Transitions: no Channel in any
Intermediate Configuration has more than $k$ Messages

\emph{$k$-reachability} -- largest Subset $RS_k(\class{S})$ of
$RS(\class{S})$ within which each Configuration is reached by a
$k$-bounded Execution from $s_0$

for every $\class{S}$ and Integer $k$, $RS_k(\class{S})$ is Finite and
Computable

\emph{$n$-bound Trace} -- $bound(\varphi) = n$ if the number of Send
Actions in the Trace $\varphi$ never exceeds the number of Receive
Actions by $n$

$\class{S} \approx \class{S'}$ -- Equivalence such that:
\[
  \forall \varphi, \varphi \in Tr(\class{S}) \Leftrightarrow
    \varphi \in Tr(\class{S'})
\]

$\class{S} \approx_n \class{S'}$ -- Equivalence such that:
\[
  \forall \varphi, bound(\varphi) \leq n \Rightarrow
    (\varphi \in Tr(\class{S}) \Leftrightarrow
      \varphi \in Tr(\class{S'}))
\]

\emph{Safety}: Deadlock-free (Orphan Message-free and Unspecified
Reception-free) if for all $s \in RS(\class{S})$, $s$ is not a
Deadlock (Orphan Message, Unspecified Reception) Configuration

\emph{Liveness}: if for all $s \in RS(\class{S})$, there exists $s
\rightarrow^* s'$ such that $s'$ is Final


\textbf{Multiparty Session Types}

\fist Notation from
Bettini-Coppo-D'Antoni-DeLuca-DezaniCiancaglini-Yoshida08 -
\emph{Global Progress in Dynamically Interleaved Multiparty Sessions}
-- ``most widely used notation''

Labelled Transition Systems (\S\ref{sec:labelled_transition}) for
Global Types and Local Types

Equivalence of Local Types and Communicating Automata
(\S\ref{sec:communicating_fsm})


$G,G',\ldots$ -- \emph{Global Types}:
\begin{flalign*}
  \quad G ::=& p \rightarrow p' : \{ a_j.G_j \} \ |\ \mu\mathbf{t}.G
    \ |\ \mathbf{t} \ |\ \mathsf{end}
\end{flalign*}

$p,q,\cdots \in P$ -- Participants

$a_j \in \Lambda$ -- Message Labels

$\mathbf{t,t',\ldots}$ -- Type Variables

$p \rightarrow p' : \{a_j.G_j\}_{j \in J}, p \neq p'$ -- Participant
$p$ can Send a Message with one of $a_j$ Labels to Participant $p'$
and Actions in $G_j$ follow

$\mu\mathbf{t}.G$ -- Recursion where Type Variables are Guarded in the
``standard way'' (only occurring under Branches) %FIXME


$T,T',\ldots$ -- \emph{Local Types}:
\begin{flalign*}
  \quad T ::=& p?\{a_i.T_i\}_{i \in I} \ |\ p!\{a_i.T_i\}_{i \in I}
  \ |\ \mu\mathbf{t}.T \ |\ \mathbf{t} \ |\ \mathsf{end}
\end{flalign*}

$p?\{a_i.T_i\}_{i \in I}$ -- Receive from $p$ a Message from among the
$a_i$ Labels (\emph{Branching})

$p!\{a_i.T_i\}_{i \in I}$ -- Send to $p$ a Message from among the
$a_i$ Labels (\emph{Selection})


\emph{Projection}

$G \upharpoonright p$ -- Projection of Global Type $G$ onto
Participant $p$:
\begin{align*}
  p \rightarrow p' : \{a_j.G_j\}_{j \in J} \upharpoonright q = &
    \begin{cases}
      p!\{a_j.G_j \upharpoonright q\}_{j \in J} & q = p \\
      p?\{a_j.G_j \upharpoonright q\}_{j \in J} & q = p' \\
      \sqcup_{j \in J}G_j \upharpoonright q & otherwise
    \end{cases} \\
  (\mu\mathbf{t}.G) \upharpoonright p = &
    \begin{cases}
      \mu\mathbf{t}.G \upharpoonright p &
        G \upharpoonright p \neq \mathbf{t} \\
      \mathsf{end} & otherwise
    \end{cases} \\
  \mathbf{t} \upharpoonright p = &\ \mathbf{t} \\
  \mathsf{end} \upharpoonright p = &\ \mathsf{end}
\end{align*}

$G$ is \emph{Well-formed} if $G \upharpoonright p$ is defined for all
$p \in P$

\emph{Mergeability Relation} $\bowtie$ over Local Types -- extends
Projection to allow each Branch of a Global Type to contain different
Interaction Patterns; Smallest Congruence Relation over Local Types
such that:
\[
  \frac{
    \forall i \in (K \cap J).T_i \bowtie T_i' \quad\quad
      \forall k \in (K \setminus J),
      \forall j \in (J \setminus K).a_k \neq a_j
  }{
    p?\{a_k.T_k\}_{k \in K} \bowtie p?\{a_j.T_j'\}_{j \in J}
  }
\]

when $T_1 \bowtie T_2$, $\sqcup$ is a Partial Commutative Operator
over two Local Types such that $T \sqcup T = T$ for all $T$ and:
\[
  p?\{a_k.T_k\}_{k \in K} \sqcup p?\{a_j.T_j'\}_{j \in J} =
    p?(\{a_k.(T_k \sqcup T_k')\}_{k \in K \cap J} \cup
    \{a_k.T_k\}_{k \in K \setminus J} \cup
    \{a_j.T_j'\}_{j \in J \setminus K})
\]
and is Homomorphic for other Types, i.e. $\class{C}[T_1] \sqcup
\class{C}[T_2] = \class{C}[T_1 \sqcup T_2]$ where $\class{C}$ is a
Context for Local Types


\textbf{Labelled Transition System Semantics for Global and Local
  Types}

$\ell, \ell', \ldots$ -- \emph{Observables} denoting Sending or
Receiving a Message of Label $a \in \Lambda$ from $p$ to $p'$:
\begin{flalign*}
  \quad \ell ::=\ pp'!a \ |\ pp'?a
\end{flalign*}

$p \rightsquigarrow p' : a_j.G_j$ -- \emph{Intermediate Execution
  State} in which Message $a_j$ has been Sent but not yet Received

LTS over Global Types is defined by a Transition Relation $G
\xrightarrow{\ell} G'$ %FIXME definition

LTS over Local Types is defined by a Transition Relation $T
\xrightarrow{\ell} T'$ for Local Type Role $p$

\emph{LTS over Collections of Local Types (Configurations)}

$s = (\vec{T};\vec{w})$ -- Configuration of a System of Local Types
$\{T_p\}_{p \in P}$ with:
\[
  \vec{T} = (T_p)_{p \in P}
\]
and:
\[
  \vec{w} = (w_{pq})_{p \neq q \in P}, w_{pq} \in \Lambda^*
\]

$w_{pq}$ -- FIFO Queue at Channel $pq$

\emph{Visible Transitions} %FIXME def

$Tr(G)$ -- Set of Visible Traces that can be obtained by Reducing
Global Type $G$

$Tr(T)$ -- Set of Visible Traces that can be obtained by Reducing
Local Type $T$

$Tr(s)$ ??? %FIXME

Trace Equivalences $\approx$, $\approx_n$ (same for Communicating
Systems above)

\emph{Thm.} Soundness, Completeness of Projection with respect to
Global and Local LTSs: for Global Type $G$, Participants $P$, and
$\vec{T} = \{G \upharpoonright p\}_{p \in P}$, then $G \approx
(\vec{T}; \vec{\varepsilon})$ -- Implies that Processes Typed by
Global Type $G$ follow the LTS of $G$


\textbf{Translation from Local Types to CFSM}

for Local Type $T_0$ of Participant $p$ Projected from $G$, the
corresponding Automaton is:
\[
  \mathbf{M}(T_0) = (M,C,m_0,\Lambda,\delta)
\]
where:
\begin{itemize}
  \item $M = \{ T' \ |\ T' \in T_0, T' \neq \mathbf{t},
    T' \neq \mu\mathbf{t}.T \}$
  \item $m_0 = T'_0$ with $T_0 = \mu\vec{\mathbf{t}}.T_0'$ and $T_0'
    \in M$
  \item $C = \{ pq \ |\ p,q \in G \}$
  \item $\Lambda$ is the Set of $\{ a \in G \}$
  \item $\delta$ defined as:
    \begin{itemize}
      \item if $T = p'!\{a_j.T_J\}_{j \in J} \in M$ then:
\[
  \begin{cases}
    (T,(pp'!a_j),T_j) \in \delta & T_j \neq \mathbf{t} \\
    (T,(pp'!a_j),T') \in \delta & T_j = \mathbf{t},
      \mu\mathbf{t}\vec{\mathbf{t}}.T' \in T_0, T' \in M
  \end{cases}
\]
      \item if $T = p'?\{a_j.T_J\}_{j \in J} \in M$ then:
\[
  \begin{cases}
    (T,(p'p?a_j),T_j) \in \delta & T_j \neq \mathbf{t} \\
    (T,(p'p?a_j),T') \in \delta & T_j = \mathbf{t},
      \mu\mathbf{t}\vec{\mathbf{t}}.T' \in T_0, T' \in M
  \end{cases}
\]
    \end{itemize}
\end{itemize}

for Local Type $T_p$, $\mathbf{M}(T_p)$ is Deterministic, Directed,
and has no Mixed States, i.e. a \emph{Basic CFSM} (generalization of
Half-duplex Communication Systems; \emph{note} in general the notion
of Safety defined for Multiparty Session Types is Undecidable for
Basic CFSMs: see \emph{Synthesis} section below for
\emph{Compatibility} Property to enforce Behavior of CFSMs to be as if
they were Projections of Global Types)


\textbf{Translation from Basic CFSM to Local Types}

for Basic $\mathbf{M}_p = (M,C,m_0,\Lambda,\delta)$, the translated
Local Type $\class{T}(\mathbf{M}_p)$ is defined such that
$\class{T}(\mathbf{M}_p) = \class{T}_{\varepsilon}(m_0)$ and
$\class{T}_{\tilde{m}}(m)$ defined as:
\begin{align*}
  \class{T}_{\tilde{m}}(m) = &
    \begin{cases}
      \mu\mathbf{t}_m.p'!
        \{ a_j.\class{T}^\circ_{\tilde{m} \cdot m}(m_j) \}_{j \in J}
        & (m,pp'!a_j,m_j) \in \delta \\
      \mu\mathbf{t}_m.p'?
        \{ a_j.\class{T}^\circ_{\tilde{m} \cdot m}(m_j) \}_{j \in J}
        & (m,p'p?a_j,m_j) \in \delta
    \end{cases} \\
  \class{T}^\circ_{\tilde{m}}(m) = &
    \begin{cases}
      \class{T}_\varepsilon(m) = \mathsf{end} & m\ \text{is Final} \\
      \mathbf{t}_{m_k} & (m,\ell,m_k) \in \delta, m_k \in \tilde{m} \\
      \class{T}_{\tilde{m}}(m) & otherwise
    \end{cases}
\end{align*}
where $\tilde{m}$ in $\class{T}_{\tilde{m}}$ records Visited States
%FIXME clarify visited states

the preservation of Semantics by these translations is described in
terms of Trace Equivalences: for Basic CFSM $\mathbf{M}$, $\mathbf{M}
\approx \class{T}(\mathbf{M})$ and for Local Type $T$, $T \approx
\mathbf{M}(T)$


\textbf{Synthesis}

Completeness, Soundness

Safety for general Basic CFSMs is Undecidable

\emph{Compatibility Property} is introduced to ensure that Basic CFSMs
have the Decidable Safety Property of Multiparty Session Types as if
they were the result of a Projection from Global Types

\emph{Machine Compatibility} -- Sound and Complete Condition: two
Machines are Compatible if their Traces are exactly Dual

\emph{Multiparty Compatibility} -- for a single Participant $p$, the
remaining Machines $(\mathbf{M}_q)_{q \in P \setminus p}$ viewed
together as a single CFSM should offer Compatible (Dual) Traces to
$Tr(\mathbf{M_p})$ \emph{up to ``Internal Synchronizations'' (i.e.
  1-bounded Executions)} %FIXME 1-bounded executions

for a collection of Machines $\mathbf{M}_i = (M_i, C_i, m_{0i},
\Lambda_i, \delta_i)$ and System $\class{S} = (\mathbf{M}_1, \ldots,
\mathbf{M}_n)$, the associated CFSM is $\mathbf{M} =
(M,C,m_0,\Sigma,\delta)$ such that:
\begin{itemize}
  \item $M = M_1 \times \cdots \times M_n$
  \item $m_0 = (m_{0i}, \ldots, m_{0n})$
  \item $\delta$ is the least Relation such that
    $((m_1,\ldots,m_i,\ldots,m_n), \ell,
    (m_1,\ldots,m_i',\ldots,m_n)) \in \delta$ if $(m_i,\ell,m_i') \in
    \delta_i$ for $1 \leq i \leq n$
\end{itemize}


\emph{Def.} Multiparty Compatible System $\class{S} = (\mathbf{M}_1,
\ldots, \mathbf{M}_2)$ -- for each Machine $\mathbf{M}_i$ the rest of
the Machines ($\class{S}^{-i}$) can produce the Compatible (Dual)
Actions by Executing \emph{Alternations} (Send/Receive Actions) in
$\class{S}^{-i}$ where, from the viewpoint of $\mathbf{M}_i$,
intermediate Alternations can be seen as Non-observable Internal
Actions of $\class{S}^{-i}$


\emph{Thm.} if a System $\class{S} = (\mathbf{M}_p)_{p \in P}$ is
Basic and Multiparty Compatible then $\class{S}$ Satisfies the Safety
Properties (Deadlock-free, Orphan Message-free, Reception Error-free)
and if at least one $\mathbf{M}_q$ has a Final State then $\class{S}$
also Satisfies the Liveness Property

\emph{Prop.} if all $\mathbf{M}_p$ are Basic, there is an Algorithm to
check whether $(\mathbf{M}_p)_{p \in P}$ is Multiparty Compatible

\emph{Thm.} (Synthesis): if $\class{S}$ is a Basic System and
Multiparty Compatible then there is an Algorithm which constructs a
Well-formed $G$ such that $\class{S} \approx G$ if $G$ exists
otherwise it Terminates

\emph{Thm.} (Soundness and Completeness in CMSA ???): if $G$ is
Well-formed there exists $\class{S}$ Satisfying the three Safety
Properties and $\class{S} \approx G$
%FIXME cmsa



\subparagraph{Local Type}\label{sec:local_type}\hfill

Equivalence with Communicating Automata
(\S\ref{sec:communicating_fsm})



\subparagraph{Global Type}\label{sec:global_type}\hfill

\emph{Choreographic Specification} of an Interaction
(\S\ref{sec:interaction_geometry})

\fist Choreography (\S\ref{sec:choreography})

Projected to Local (End-point) Types against which Processes can be
Statically Verified (Type-checked)

2008 - Honda, Yoshida, Carbone - \emph{Multiparty Asynchronous Session
  Types} \cite{honda-yoshida-carbone08}

2011 - Castagna, Dezani-ciancaglini, Padovani - \emph{On Global Types
  and Multi-party Sessions}: Global Types with Trace-based Semantics--
Global Types denote a \emph{Language} (over an Alphabet of
Interactions) of allowed Interactions that can occur in a Multiparty
Session

2013 - Danielou Yoshida - \emph{Multiparty Compatibility in
  Communicating Automata: Characterisation and Synthesis of Global
  Session Types} -- \emph{Conditions for Synthesis} as a Sound and
Complete characterisation of Multiparty Session Types with respect to
Communicating Finite State Machines (\S\ref{sec:communicating_fsm})
guarantees the \emph{Global Safety Property} of Multiparty Session
Types



\subparagraph{Dynamic Multirole Session Types}
\label{sec:multirole_session}\hfill

Danielou-Yoshida11 -- \emph{Dynamic Multirole Session Types}

\emph{Multirole Participants}

\fist Cf. \emph{Multirole Channels}: Xi-Wu16 -- \emph{Propositions in
  Linear Multirole Logic as Multiparty Session Types}
(\S\ref{sec:lmrl})

Peer-to-peer Protocols, Cloud-computing Algorithms

WS-CDL

\emph{Roles} are defined as Classes of Local Behaviors that an
arbitrary number of Participants can Dynamically Join and Leave

\emph{Polling Operation}: current Set of a Role's Participants in
order to Fork Processes -- \emph{Universal Types}

\emph{Locking Mechanism}: Communication Safety and stronger Progress
Property for Joining Participants

Danielou-Yoshida11 -- ML Extension

$\forall x : r.G'$ -- Polls Participants $p_1, \ldots, p_n$ of Role
$r$ and Binds $x$ to each Participant in subsequent Actions:
\[
  G' \{ p1 \backslash x \} \ |\ \ldots \ |\ G' \{ p_n \backslash x \}
\]

\fist Multirole Session Calculus
(\S\ref{sec:multirole_session_calculus})

\emph{Global Types}:
\begin{flalign*}
  \quad G ::=&\ p \rightarrow p'
    \{l_i \langle\vec{p_i}\rangle\langle{U_i}\rangle.T_i\}_{i \in I}
    & \text{Labelled Message Exchange} \\
  |&\ \forall x:r \setminus \vec{p}.G
    & \text{Universal Quantification} \\
  |&\ G|G \ |\ G;G' & \text{Paralell/Sequential} \\
  |&\ \mu X.G \ |\ X & \text{Recursion/Variable} \\
  |&\ \varepsilon \ |\ \mathsf{end} & \text{Inaction/End}
\end{flalign*}

\emph{Local Types}:
\begin{flalign*}
  \quad T ::=&\ !\langle
    p, \{l_i\langle{\vec{p_i}}\rangle\langle{U_i}\rangle.T_i\}_{i \in I}
    \rangle & \text{Selection} \\
  |&\ ?\langle
    p, \{l_i\langle{\vec{p_i}}\rangle\langle{U_i}\rangle.T_i\}_{i \in I}
    \rangle & \text{Branching} \\
  |&\ \forall x:r \setminus \vec{p}.T
    & \text{Universal Quantification} \\
  |&\ T|T' \ |\ T;T' & \text{Parallel/Sequential} \\
  |&\ \mu X.G \ |\ X \ |\ \varepsilon \ |\ \mathsf{end}
    & \text{Recursion/Variable/Inaction/End}
\end{flalign*}

\emph{Sorts} (Value Types):
\begin{flalign*}
  \quad S ::=&\ \langle{G}\rangle & \text{Shared Channel Types} \\
  |&\ \mathsf{bool} \ |\ \mathsf{unit} \ |\ \ldots & \text{Base Types}
\end{flalign*}

\emph{Message Types}:
\begin{flalign*}
  \quad U ::=&\ S \ |\ T & \text{}
\end{flalign*}


Global Types describe Role-based Global Communication Scenarios
between Multiple Participants as a Type Signature

a Participant that agrees with a Global Type $G$ has Behavior defined
by a Local Type $T_i$ generated by the \emph{Projection} of $G$ onto
the Role for that Participant

if each Local Programs $P_1, \ldots, P_n$ can be Type Checked against
the corresponding Projected Local Types $T_1, \ldots, T_n$ then they
are guaranteed to Interact following the intended Scenario

extensions from ``Standard'' Multiparty Session Types
(Bettini-Coppo-D'Antoni-DeLuca-DezaniCiancaglini-Yoshida08):
\begin{enumerate}
  \item association of each Participant to a Role -- $p$ above is
    $q:r$ or $x:r$
  \item Universal Quantifiers to Bind Participant Identities --
    $\forall x:r \setminus \vec{p}.G$: all Participants of Role $r$
    Bind Free occurences of $x$ in $G$ (cf. Multirole Session Calculus
    Operational Semantics of $s[q:r']\forall(x:r
    \setminus\vec{p}).\{P\}$, i.e. a Parallel Composition $G\{q_1 /
    x\} | \cdots | G\{q_k / x\}$ for some List of Participants from
    which $\vec{p}$ has been excluded
  \item Parallel Composition for Local Types
  \item Labels that can be extended by a List of Participants
\end{enumerate}

\emph{Projection Operation} -- computes the Local Type a Participant
$z$ with an assigned Role $r$ has to conform to within a Global
Session $G$

$G \uparrow z:r$ -- \emph{(End-point) Projection} of $G$ onto $z:r$:
the Local Type that $z$ must conform to as Role $r$ in Session $G$

Projection of $\forall x:r.G$ for a Participant $q_i$ with Role $r$:
\begin{align*}
    & \forall x:r.G \uparrow q_i:r \\
  = & (G\{q_1/x\} \uparrow q_i:r) | \cdots |
    (G\{q_k/x\} \uparrow q_i:r) \\
  = & (G\{q_i/x\} \uparrow q_i:r) |
    \forall x:r \setminus q_i.(G \uparrow q_i:r)
\end{align*}

Projection is \emph{Role-based}: for each Role $r$ in a Session $G$, a
Local Type $T = G \uparrow p$ is computed with $p = z:r$ and the case
$p = q:r$ is defined by replacing $z$ by $q$

%FIXME definition of projection function

Communication Case Analysis:
\begin{itemize}
  \item if the Participant $p$ Projected to is Sender, then the
    Projection is a Selection Sent to $p'$
  \item if the Participant $p$ Projected to is Receiver, then the
    Projection is an Input from $p'$
  \item if the Participant $p$ Projected to is both Sender and
    Receiver, then the Projection is an Output followed by an Input
  \item otherwise the Communication is not Observed Locally and is
    \emph{skipped}
\end{itemize}

$\sqcup$ -- \emph{Merge Operator} (Yoshida-Danielou-Bejleri-Hu10):
Merges different ``Remote Branches'' ensuring that Locally Observable
Behaviors are either (a) \emph{Independent} of the Remotely Chosen
Branch, or (b) can be properly Identified through their Labels
%FIXME more explanation, definition

\fist if Labels are used ``ambiguously'', Merge may not return a
result %FIXME

Projection of a Quantified Global Type $(\forall x:r \setminus
\vec{p}.G) \uparrow p$ %FIXME

$G$ is \emph{Projectible} if it can be Projected for each of its Roles


\emph{Well-formed Global Types} -- set of Rules that Global Types need
to follow in order to ensure ``Reliable'' and ``Unambiguous'' Session
Behavior; a Global Type $G$ is \emph{Well-formed} when:
\begin{itemize}
  \item \emph{Syntax Correctness} -- $G$ is Syntactically Correct;
    \emph{Kinding Rules} %FIXME def in on-line appendix to paper
  \item \emph{Projectability} -- $G \uparrow z:r$ is defined for each
    Role $r$ of $G$
  \item \emph{Linearity} -- $G$ is Linear (relaxed compared to
    Honda-Yoshida-Carbone08 to allow Parallel Compositions and
    Branching; \emph{Dequantification}) %FIXME
\end{itemize}


\textbf{Typing System}

\emph{Environments}:
\begin{flalign*}
  \quad \Gamma ::=&\ \varnothing \ |\ \Gamma, u:S
    \ |\ \Gamma, y:r \ |\ \Gamma,D:\Delta
    & \text{Standard Environment} \\
  \quad \Delta ::=&\ \varnothing \ |\ \Delta, c:T
    & \text{Session Environment}
\end{flalign*}
Standard Environment $\Gamma$ -- associates Variables to Sorts or
Roles

Session Environment $\Delta$ -- associates Channels to Session Types

$;$ -- Sequential Composition

$\circ$ -- Parallel Composition

Judgement for Expression Typing:
\[
  \Gamma \vdash e : S
\]

Judgement for Process Typing:
\[
  \Gamma \vdash P \rhd \Delta
\]

Typing Rules %FIXME

\emph{Prop.} for Process $P$ with Typed Bound Names and Variables,
Type-checking of $\Gamma \vdash P \rhd \varnothing$ Terminates


\emph{Subject Reduction} -- $\Rightarrow$: Type Reduction Relation on
Session Environments formalising the Dynamism (Join/Interact/Leave) of
Session Participants
%FIXME

\emph{Type Evaluation Contexts}:
\[
  \mathscr{E} ::=\ [\_] \ |\ \mathscr{E}|T \
    |\ T|\mathscr{E} \ |\ \mathscr{E};T
\]

\emph{Thm.} (Subject Reduction): if $\Gamma \vdash_\Sigma P \rhd
\Delta$ and $P \rightarrow^* P'$ then $\Gamma \vdash_\Sigma P' \rhd
\Delta'$ for some $\Delta'$ such that $\Delta \Rightarrow^* \Delta'$

Type Error, Label Error

\emph{Thm.} (Type Safety): given $\Gamma \vdash P \rhd \Delta$, for
any $P'$ such that $P \rightarrow^* P'$, $P'$ has no Type Error


\textbf{Runtime Process Typing}

\emph{Runtime Typing System}

%FIXME

keeps track of intermediate Invariants to Prove Theorems; extend
Judgements to:
\[
  \Gamma \vdash_\Sigma P \rhd \Delta
\]
meaning Process $P$ contains the Message Buffers with Session Names in
$\Sigma$

Register $R$

\emph{Message Selection Type} -- an indeterminate Type for Labelled
Values stored in the Message Buffer %FIXME


\textbf{Locking}

limitation: in Operational Semantics, \emph{Quit} allows a Participant
to Leave a Session at any time, but in Typing Rules, \emph{Leave} only
allows a Participant to Leave when its Local Type is $\mathsf{end}$

\emph{Locking Mechanism} -- more flexibility in Leaving a Session and
guarantees Communication Safety

\emph{Polling Synchronization} -- temporarily Block late Participants
from Joiningin the middle of a Session Execution to prevent any
interference with Polling

\emph{Starting Points} and \emph{Ending Points} of a Global Session
\emph{Interaction Round}

Session Initialization ensures all Participants are ``eventually''
present (a fixed-number of Participants have Joined); Typing System
guarantees the Safety of Communication when the Session starts but not
in the presence of Joining, Leaving, and Polling

$\mono{lock}\{G\}$ -- \emph{Locked Global Type}: Interactions
Specified by $G$ are ``protected'' from late Joining Participants;
Implementable using a standard Two-phase Commit Protocol

extended Process Syntax (Multiparty Session Calculus):
\begin{flalign*}
  \quad P ::=&\ \cdots \ |\ c\ \mono{lock}\ |\ c\ \mono{unlock}
    \ |\ a^\circ[R,L] \ |\ a^\bullet[R,L] \\
  \quad L ::=&\ \varnothing \ |\ L \cup \{q:r\}
\end{flalign*}

\emph{Locking State}: $a^\circ[R,L]$ -- Registry in the process
of being Locked where $L$ is the Set of Participants that have been
Locked so far

\emph{Interaction State}: $a^\bullet[R,L]$ -- Registry that is Locked
and Participants $L$ are still ``involved'' %FIXME clarify

Global Types extension:
\begin{flalign*}
  \quad G ::=&\ \cdots \ |\ \mono{lock}\{G\}
    & \text{Locked Global Type}
\end{flalign*}

Local Types extension:
\begin{flalign*}
  \quad T ::=&\ \cdots \ |\ \mono{lock} \ |\ \mono{unlock}
    & \text{Lock/Unlock}
\end{flalign*}

$\mono{lock}\{G_0\}$ -- single Locked Multiparty Session

$\mu X.\mono{lock}\{G_0\};X$ -- Multiparty Session that is
Persistently (Repeatedly) Locked which ensures if a new Participant
$q$ wants to Join, it can Join at the beginning of the Interaction
$G_0$ and if a Participant wants to Quit it can Quit at the end of the
Session

Projection:
\[
  \mono{lock}\{G\} \uparrow z:r
  = \mono{lock};(G \uparrow z:r);\mono{unlock}
\]

a Global Type $G$ is \emph{Terminable} if there is at least one Finite
Path (with Leaf $\varepsilon$) up to the Unfolding of $G$
%FIXME clarify, defined by kinding system

$G$ is \emph{Well-locked} if $G$ is Closed (no Free Participant or
Recursive Type Variables) and has form $\mono{lock}\{G_0\};\mono{end}$
and $G_0$ does not include any $\mono{lock}$

$G$ is \emph{Persistently Well-locked} if $G$ is of the form $\mu
X.\mono{lock}\{G_0\};X;\mathsf{end}$ with
$\mono{lock}\{G_0\};\mathsf{end}$ Well-locked and $G_0$ is Terminable

$\Gamma$ is Well-locked if for all $\Gamma(u) = \langle{G}\rangle$,
$G$ is either Well-locked or Persistently Well-locked

$\Gamma$ is Persistently Well-locked if for all $\Gamma(u) =
\langle{G}\rangle$, $G$ is Persistently Well-locked

(Typing Rules) %FIXME


\textbf{Communication Safety and Progress}

\emph{Communication Safety Property}: in a Session Execution no
Receiver waits for a Message that will never be Received and no
Messages are Sent but never Received

Single-session Join

\emph{Thm.} (Communication Safety): given $a : \langle{G}\rangle
\vdash^* P \rhd \varnothing$ and $P$ is Initial and assuming $a :
\langle{G}\rangle$ is Well-locked and $P$ does not contain any Shared
Name Restriction then for any $P'$ such that $P \rightarrow^* P'$,
$P'$ is Communication Safe

\emph{Progress Property}: $\Gamma \vdash P \rhd \varnothing$ can
Progress if whenever $P \rightarrow^*P'$ then either $P' \equiv
\mathbf{0}$, $P' \rightarrow P'''$ or for some Single-session Join $a
\langle{G}\rangle \vdash P''$ with $a : \langle{G}\rangle \in \Gamma$
such that $P' | P'' \rightarrow P'''$ and $P'''$ can Progress meaning
that a Process Satisfying the Progress Property can never reach a
Deadlock State

\emph{Thm.} (Progress): given $\Gamma \vdash^* P \rhd \varnothing$ and
$P$ is Initial, assuming $\Gamma$ is Well-locked and $P$ does not
contain any Shared Name Restriction, then $P$ can Progress


\textbf{Join Progress}

\emph{Join Progress Property}

\emph{Thm.} (Join Progress): given $a : \langle{G}\rangle \vdash^* P
\rhd \varnothing$ and $P$ Initial, assuming $a \langle{G}\rangle$ is
Persistently Well-locked and $P$ does not contain any Shared Name
Restriction then $P$ Satisfies the Join Progress Property


\textbf{ML Implementation}

Global Types are Compiled into an End-point Function for each Role (as
in Corin-Danielou08, Bhargavan-Corin-Danielou-Fournet-Leifer09)

Session Semantics generated and Implemented by Communication Libraries

TCP Channels

Distributed Registries

special handling of Singly-instantiated Roles to eliminate
unneccessary Polling



\subparagraph{Generalized Multiparty Session Types}
\label{sec:generalized_multiparty}\hfill

Danielou-Yoshida13 (Appendix)



\subparagraph{Timed Multiparty Session Types}
\label{sec:timed_multiparty}\hfill

\begingroup

\newcommand{\bool}{\mathsf{bool}}
\newcommand{\nat}{\mathsf{nat}}
\newcommand{\enndd}{\mathsf{end}}

Bocchi-Yang-Yoshida14 - \emph{Timed Multiparty Session Types}

\fist Timed Multiparty Session Calculus
(\S\ref{sec:timed_multiparty_session_calculus})

Communicating Timed Automata (\S\ref{sec:communicating_timed_fsm})

Global and Local Types extended with \emph{Constraints on Clocks}:

\emph{Timed Global Types}

\emph{Timed Local Types}

$X = \{x_1, \ldots, x_n\}$ -- Set of \emph{Clocks}

$\nu : X \rightarrow \reals_{0\leq}$ -- \emph{Clock Assignment}
returning the Time of Clocks in $X$

$\nu + t = x \mapsto \nu(x) + t$ -- Assignment mapping all $x \in X$
to $\nu(x) + t$

$\nu_0 = x \mapsto 0$ -- \emph{Initial Assignment} mapping all Clocks
to $0$

$\Phi(X)$ -- Set of \emph{Clock Constraints} over $X$, with Syntax:
\[
  \delta ::=\ true \ |\ c < x \ |\ x = c \ |
    \ \neg\delta \ |\ \delta_1 \wedge \delta_2
\]
where $c$ is a Bound Time Constant in $\rats_{0\leq}$; note $false$,
$>$, $\leq$, $\geq$, and $\vee$ are derived from the above

$fn(\delta)$ -- Set of \emph{Free Clocks} in $\delta$, defined
Inductively:
\begin{itemize}
  \item $fn (true) = \varnothing$
  \item $fn (c < x) = fn(x = c) = {x}$
  \item $fn (\neg\delta) = fn (\delta)$
  \item $fn (\delta_1 \wedge \delta_2)
    = fn (\delta_1) \cup fn (\delta_2)$
\end{itemize}

$\nu \vDash \delta$ -- the Clock Assignment $\nu$ Satisfies the Clock
Constraint $\delta$

$\lambda$ -- a \emph{Reset Predicate} over a Subset of $X$ where each
$x \in \lambda$ is set to $0$; Resets allow scenarios such as when a
Time Constraint must be repeatedly Satisfied for an unbounded number
of times

$[\lambda \mapsto 0]\nu$ -- the Clock Assignment like $\nu$ with $0$
assigned to all Clocks in $\lambda$

$(p, q, p_1, \ldots \in \nats)$ -- Participants

\emph{Communication}: Point-to-point Asynchronous Message Passing

\emph{Interaction}: a Send Action and a Receive Action each annotated
with a Clock Constraint (specifying when that Action can be executed)
and a Reset Predicate (specifying which Clocks must be Reset)


\textbf{Syntax}

``Sorts'':
\begin{flalign*}
  \quad S ::=&\ \bool \ |\ \nat \ |\ \ldots \ |\ G \ |\ (T,\delta) &
\end{flalign*}
includes $G$ for Shared Name Passing and $(T,\delta)$ for
Session Delegation %FIXME

Timed Global Types:
\begin{flalign*}
  \quad G ::=&\ 
    p \rightarrow q : \{l_i\langle{S_i}\rangle\{A_i\}.G_i\}_{i \in I}
    \ |\ \mu\mathbf{t}.G \ |\ \mathbf{t} \ |\ \enndd & \\
  \quad A ::=&\ \{\delta_O, \lambda_O, \delta_I, \lambda_I\} &
\end{flalign*}
where $A$ is a \emph{Time Assertion}

$p \rightarrow q : \{l_i\langle{S_i}\rangle\{A_i\}.G_i\}_{i \in I}$ --
an Interaction where $p$ chooses Branch $i \in I$ and Sends $q$ the
Branching Label $l_i$ with a Message of Sort $S_i$ and the Session
continues as specified by $G_i$

$\mathbf{t}$ -- Type Variable

$\mu\mathbf{t}.G$ -- Recursive Type

Timed Local Types:
\begin{flalign*}
  \quad T ::=&\ p \oplus \{l_i\langle{S_i}\rangle\{B_i\}.T_i\}_{i \in I}
    \ |\ p \& \{l_i\langle{S_i}\rangle\{B_i\}.T_i\}_{i \in I}
    \ |\ \mu\mathbf{t}.T \ |\ \mathbf{t} \ |\ \enndd & \\
  \quad B ::=&\ \{\delta,\lambda\} &
\end{flalign*}

$p \oplus \{l_i\langle{S_i}\rangle\{B_i\}.T_i\}_{i \in I}$ --
Selection Types

$p \& \{l_i\langle{S_i}\rangle\{B_i\}.T_i\}_{i \in I}$ -- Branching
Types

$\class{P}(G)$ -- Set of Participants of $G$

$G\downarrow_p$ -- \emph{Projection} of $G$ onto Participant $p \in
\class{P}(G)$


\textbf{Timed Global Type Semantics}

Labelled Transition System (LTS)

$(\nu, G)$ -- States

Labels:
\[
  \ell ::=\ pq!l\langle{S}\rangle \ |\ pq?l\langle{S}\rangle \ |\ t
\]

$pq!l\langle{S}\rangle$ -- $p$ Sends $l\langle{S}\rangle$ to $q$

$pq?l\langle{S}\rangle$ -- $q$ Receives $l\langle{S}\rangle$ from $p$

$t$ -- a \emph{Time Action} $t \in \reals_{0\leq}$ (models ``time
passing'')

$\class{L}$ -- Set of Labels

$subj(\ell)$:
\begin{itemize}
  \item $subj(pq!l\langle{S}\rangle) = p$
  \item $subj(pq?l\langle{S}\rangle) = q$
  \item $subj(t) = \varnothing$
\end{itemize}

$p \rightsquigarrow q : l\langle{S}\rangle\{A\}.G$ -- extended Syntax
of $G$ indicating a state in which $l\langle{S}\rangle$ has been Sent
but not yet Received

\emph{Ready Action} -- an Action that has no causal relationship with
other Actions that occur earlier (syntactically)

$ready(G,D)$ -- for each Ready Action in $G$, returns the Set of
Constraints $\{\delta_i\}_{i\in I}$ of the Branches of that Ready
Action, and $D$ is a Set of Participants tracking the causal
dependencies between Actions. (detailed definition) %TODO

Def. (Satisfiability of Ready Actions) $\nu \vDash^* ready(G)$ -- the
Constraints of all Ready Actions of $G$ are Satisfiable under $\nu$ or
some time in the future:
\[
  \nu \vDash^* read(G) \text{ if and only if }
    \forall\{\{\delta_i\}_{i \in I}\} \in ready(G) \exists t \geq 0,
    j \in I . \nu + t \vDash \delta_j
\]

LTS Transitions:
\begin{itemize}
  \item $[Select]$
  \item $[Branch]$
  \item $[Rec]$
  \item $[Async1]$
  \item $[Async2]$
  \item $[Time]$
\end{itemize}

Execution is assumed to begin with the Initial Assignment $\nu_0$


\textbf{Timed Local Type Semantics}

$(\nu, T)$ -- States

$\class{L}$ -- Labels

Rules:
\begin{itemize}
  \item $[LSelect]$ -- Send
  \item $[LBranch]$ -- Receive
  \item $[LRec]$
  \item $[LTime]$
\end{itemize}

$T$ always has only one Ready Action

$ready(T)$

$\nu + t \vDash^* ready(T)$

$(T_1, \ldots, T_n, \vec{w})$ -- \emph{Configurations}

$\vec{w} ::=\ \{w_{ij}\}_{i \neq j \in I}$ -- Unidirectional (possibly
empty) Unbounded Channels with Messages of the form
$l\langle{S}\rangle$

(LTS for Configurations) %TODO

$Tr(G)$ -- Set of ``visible'' Traces obtained by Reducing $G$ under
the Initial Assignment $\nu_0$

$\approx$ -- Trace Equivalence

Thm. (Soundness and Completeness of Projection) \emph{For Timed Global
  Type $G$ and Set of Projections $\{T_1,\ldots,T_n\} =
  \{G\downarrow_p\}_{p \in \class{P}(G)}$, $G \approx
  (T_1,\ldots,T_n,\vec{\varepsilon})$}


\textbf{Proof Rules}

Proof Rules for Validating Timed Multiparty Session Calculus
(\S\ref{sec:timed_multiparty_session_calculus}) Programs
against Timed Local Type specifications

Judgements:

$\Gamma \vdash P \rhd \Delta$

$\Gamma \vdash e : S$

Type Environments:
\begin{flalign*}
  \quad \Gamma ::=&\ \varnothing \ |\ \Gamma, u:S \ |\ \Gamma,X:\Delta & \\
\end{flalign*}
map Shared Variables/Names to Sorts and Process Variables to their
Types

Session environments:
\begin{flalign*}
  \quad \Delta ::=&\ \varnothing \ |\ \Delta, c:(\nu,T) &
\end{flalign*}
holds information on ongoing Sessions, e.g.:

$\Delta(s[p]) = (\nu,T)$ -- the Proess being Validated is acting as
$p$ in Session $s$ specified by $T$ and $\nu$ is a ``virtual'' Clock
Assignment built during the Validation

Def. (Infinite Satisfiability) -- needed to ensure Sound Typing in the
presence of Recursive Protocols; guarantees ``regularity'' accross
different instances of Recursion %TODO

Proof Rules:

$[VRequest]$, $[VAccept]$, $[VBranch]$, $[VSelect]$, $[VDelegate]$,
$[VParallel]$, $[VConditional]$, $[VTime]$, $[VEnd]$, $[VDefine]$,
$[VCall]$

extended Rules for Errors and Clocks %TODO

Thm. (Type Preservation) \emph{If $\Gamma \vdash P \rhd \varnothing$
  and $P \rightarrow P'$, then $\Gamma \vdash P' \rhd \varnothing$}

where $P$ is a Process Reduced from a Program (i.e. $\Delta =
\varnothing$)

Thm. (Time-error Freedom) \emph{If $\Gamma \vdash P \rhd \Delta$ and
  $P \rightarrow^* P'$, then $P' \not\equiv \mathsf{error}$}


\textbf{Progress}

Subclass of Timed Global Types Characterized by Decidable Properties:
\begin{enumerate}
  \item \emph{Feasibility}
  \item \emph{Wait-freedom}
\end{enumerate}
as sufficient conditions for Progress of Validated Processes and
Communicating Timed Automata.

\emph{Feasibility} -- a Timed Global Type $G$ is \emph{Feasible} if
and only if $(\nu_0,G_0) \rightarrow^* (\nu, G)$ Implies $(\nu,G)
\rightarrow^* (\nu', \enndd)$ for some $\nu'$, i.e. $G_0$ is Feasible
if every Partial Execution can be extended to a Terminated Session

\emph{Wait-freedom} %TODO

Prop. (Decidability) -- if $G$ is Infinitely Satisfiable then there is
a Terminating Algorithm checking that it is Feasible and Wait-free
based on a Directed Acyclic Graph annotated with Clock Constraints and
Reset Predicates with Edges modelling the causal dependencies between
Actions in the one-time unfolding of $G$

$erase(P)$ -- the \emph{Time Erasure} of a Timed Process $P$, defined
Inductively by removing the Delays in $P$

Prop. (Conformance) \emph{If $P \rightarrow P'$, then $erase(P)
  \rightarrow^* erase(P')$}

Def. (\emph{Session Delay}) \emph{$P$ is Session Delay if for each
  Process occurring in $P$ of the form $delay(t).P'$ there are no
  Session Request and Session Accept in $P'$} -- requires all
Processes to only initiate Sessions before any Delay occurs

Feasibility and Wait-freedom (regulating the exchange of Messages
within an established Session) are sufficient conditions for Progress
of Session Delay Processes

$P$ is a \emph{Deadlock Process} if $P \rightarrow^* P'$ where $P'
\not\rightarrow$ and $P' \not\equiv \mathbf{0}$ and $\Gamma$ is
Feasible (resp. Wait-free) if $\Gamma(u)$ is Feasible (resp.
Wait-free) for all $u \in dom(\Gamma)$

Thm. (Timed Progress in Interleaved Sessions) \emph{For Feasible and
  Wait-free mapping $\Gamma$, $\Gamma \vdash P_0 \rhd \varnothing$ and
  $P_0 \rightarrow^+ P$, if $P_0$ is Session Delay and $erase(P)$ is
  not a Deadlock Process and if $erase(P)\rightarrow$, then
  $P\rightarrow$}

\emph{Simple Processes} -- Processes implementing single Sessions

Cor. (Time Progress in Single Sessions) \emph{For Feasible and
  Wait-free $G$ and Simple Process $P$ with $a : G \vdash P \rhd
  \varnothing$, if $erase(P) \rightarrow$, then there exists $P'$ and
  $P''$ such that $erase(P) \rightarrow P'$, $P \rightarrow^+ P''$ and
  $erase(P'') = P'$}


\textbf{Correspondence of Timed Global Types and Communicating Timed
  Automata}

$\class{A} = (Q,q_0,A,X,E,F)$ -- Timed Automaton
(\S\ref{sec:timed_fsm})

$\class{C} = (\class{A}_1,\ldots,\class{A}_n,\vec{w})$ -- Network of
CTAs where $\vec{w}$ is a Set of Unidirectional Unbounded Channels


Specified Time Transitions

Specified Semantics

Sound and Complete Encoding

$\class{A}(T)$ -- \emph{Encoding} from $T$ into $\class{A}$

$\class{A}(\{T_i\}_{i \in I}) =
(\class{A}(T_1),\ldots,\class{A}(T_n),\vec{\varepsilon})$ -- Encoding
a Set of Timed Local Types into a Network of CTAs

$\class{A}(G)$ -- same as above for Timed Global Type having
Projections $\{T_i\}_{i \in I}$

\emph{Stable State} -- a State in which all Channels are Empty

a Network of CTAs $\class{C}$ is \emph{Basic} when all its Timed
Automata are Deterministic and all outgoing Actions from each
$(q_i,C_i)$ are all Sending or all Receiving Actions to/from the same
Co-participant

$\class{C}$ is \emph{Multiparty Compatible} when in all its Reachable
Stable States, all possible Input/Ouptut Actions of each Timed
Automaton can be matched with a corresponding complementary
Output/Input Action of the rest of the System after some $1$-bounded
Execution (i.e. Executions where the size of each Buffer contains at
most 1 message)

\emph{Session CTA} -- a Basic and Multiparty Compatible CTA with
specified Semantics

Thm. (Soundness and Completeness) \emph{Given a Projectable Timed
  Global Type $G$, then $\class{A}(G)$ is Basic and Multiparty
  Compatible with a specified Semantics $G \approx \class{A}(G)$ and
  if $\class{C}$ is a Session CTA then there exists a $G$ such that
  $\class{C} \approx \class{A}(G)$}

Time Divergence Condition: Time-progress

$Tr(\class{C})$ -- Set of (``visible'') Traces obtained by Reducing
$\class{C}$; Trace Equivalence $\approx$

Thm. (Progress and Liveness for CTAs) \emph{If $\class{C}$ is a
  Session CTA and there exists a Feasible $G$ such that $\class{C}
  \approx \class{A}(G)$, then $\class{C}$ Satisfies Progress and
  Liveness}


\endgroup



\paragraph{Conversation Type}\label{sec:conversation_type}\hfill

Caires,Vieira 2011 - \emph{Conversation Types}

%FIXME

\fist Conversation Calculus (\S\ref{sec:conversation_calculus}) --
Vieira-Caires-Seco08

a Conversation models the Interactions between a Client and various
Services with Dynamic Joining of possibly unknown number of Processes

\fist cf. Session Types (\S\ref{sec:session_type}), \fist cf.
Multirole Session Types \S\ref{sec:multirole_session}

\fist cf. Behavioral Types \S\ref{sec:behavioral_type}

Session Types describe the ``flow'' of Communications in a single
Conversation Session while Behavioral Types and Conversation Types
take the point of view of an entity Participating in many interleaved
Conversations with multiple other Participants

Distributed Behaviors among \emph{Places}

Named Entities are \emph{Conversation Contexts}



\subsubsection{Affine Type System}\label{sec:affine_type}\hfill

Variables used at most once; allows a Resource to be \emph{Discarded}

Affine Logic (\S\ref{sec:affine_logic})

Rust



\subsubsection{Relevant Type System}\label{sec:relevant_type}

Variables used at least once

Relevant Logic (\S\ref{sec:relevance_logic})



\subsubsection{Ordered Type System}\label{sec:ordered_type}

\fist Ordered Logic (\S\ref{sec:ordered_logic})

models Stack-based Memory Allocation

only Objects on top of modelled Stack may be used, after which it is
popped off



\subsubsection{Alias Type}\label{sec:alias_type}

%FIXME this is part of the line of research on region-based memory
%management and the calculus of capabilities

``Pseudo-linear Types''

Walker-Morrisett00 \emph{Alias Types for Recursive Data Structures}

Smith-Walker-Morrisett00 \emph{Alias Types} -- (Rust ???) %FIXME

Calculus of Capabilities (\S\ref{sec:capabilities_calculus})

cf. Ownership Type (\S\ref{sec:ownership_type})



\subsubsection{Ownership Type}\label{sec:ownership_type}

cf. Alias Type (\S\ref{sec:alias_type})

Clarke-Potter-Noble98

Clarke-Wrigstad02 \emph{External Uniqueness is Unique Enough} -- Rust
bibliography

Clarke-Ostlund-Sergey-Wrigstad13 \emph{Ownership Types: A Survey}



% --------------------------------------------------------------------
\subsection{Hindley-Milner Type System}\label{sec:hindley_milner}
% --------------------------------------------------------------------

$\lambda$-calculus with Parametric Polymorphism



\subsubsection{Algorithm W}\label{sec:algorithm_w}



% ====================================================================
\section{Effect System}\label{sec:effect_system}
% ====================================================================

going beyond associating Value-Type pairs, Effect Systems associate
Virtual ``Regions'' of Code with an ``Effect'' Component describing
\emph{what} is to be done \emph{with what}

Henglein-Makholm-Niss -- \emph{Effect Types and Region-based Memory
Management}

Dominic Orchard (youtube) -- Simple Types (\S\ref{sec:simply_typed}):
``What'', Effect Systems: ``How'', Session Types
(\S\ref{sec:session_type}): ``What \& How''

\cite{orchard-yoshida16} -- ``(Intensional) Behavioral Types''
(\S\ref{sec:behavioral_type}): Effect Types and Session Types; two-way
Embedding: Session Types (\S\ref{sec:session_type}) to and from Effect
Systems--Processes as Effect Handlers (\S\ref{sec:effect_handler}),
Session Types as Effects

Effect System for Session Types is Partial: some Operations may not be
defined for all Arguments, Modelling the Program-logic Behavior of
Session Types \cite{orchard-yoshida16} %FIXME

\fist Orchard-Yoshida16 \cite{orchard-yoshida16} distinguishes the
Effect Systems of Nielson-Nielson99 \cite{nielson-nielson99} from
``traditional'' Effect Systems by distinguishing Sequential Control
Flow from Branching Control Flow (Alternation). See FPCF
(\S\ref{sec:fpcf}) for the \emph{Effect Algebra} of this type defined
there.

Effect Systems: general Class of Static Program Analysis for
collecting information on Effects (e.g. State, Exceptions, Resource
Use, etc.) \cite{orchard-yoshida16}

Control-flow Algebra/Semantics (Mycroft-Orchard-Petricek16
\cite{mycroft-orchard-petricek16})

``Impure'' Effects

subsumed by Monads: ``Lazy State'' and ``Lazy Writer'' cannot be
captured by any Effect System (E. Kmett)

\cite{mycroft-orchard-petricek16} -- Graded Joinads (???): Effect
Control-flow Algebras \& Types

in a Control Category (\S\ref{sec:control_category}), Central
Morphisms (\S\ref{sec:central_morphism}) Model Effect-free
Computations or \emph{Values} %FIXME

wiki:

in addition to simple Value/Type Pairs, a \emph{Region} of Code is
associated with an \emph{Effect Component} describing ``what'' is
being done ``with what''
%FIXME xref Region

Region Ownership, Region Aliasing


\emph{Capabilities} (\S\ref{sec:capability}):

\fist see slides:
\url{http://gallium.inria.fr/~fpottier/slides/fpottier-2007-05-linear-bestiary.pdf}
(2007)

Calculus of Capabilities (\S\ref{sec:capabilities_calculus})

Capabilities are \emph{prescriptive}

Effects are \emph{descriptive}

analogy between a Capability and a Forumula of Separation Logic
(\S\ref{sec:separation_logic})

Capabilities: Linear or Non-linear

Zhu-Xi05 -- Views (\S\ref{sec:view}): a Linear Type for classifying
Capabilities

Values: Non-linear

Memory Blocks: Possibly Linear

recovering standard Linear Types via a Capability + Value --
??? (Shi-Xi13) \emph{Viewtypes} (\S\ref{sec:viewtype})
%FIXME

Alias Types (\S\ref{sec:alias_type}) -- no Regions
(Walker-Morrisett00)
%FIXME

Uniqueness Types (Clean programming language)

Borrowing, Adoption, Focus %FIXME

Strong Update: modifies a (Linear) Capability (modifies an Object's
Type)



\asterism


\cite{wadler-thiemann03}:

Types $\tau$, $\tau'$


\textbf{Monad Language}

$T \tau$ represents a Computation that yields a Value
of Type $\tau$ and may have Side-effects

Call-by-value (\S\ref{sec:call_by_value}) Translation of $\tau$ is
$\tau^\dag$.

$(\tau \rightarrow \tau')^\dag$ where $\rightarrow$ represents a
Function that may have Side-effects is equal to $\tau^\dag \rightarrow
T \tau'^\dag$ where $\rightarrow$ is a Pure Function (no Side-effects).

Effects appear in two places:
\begin{enumerate}
  \item Unit ($\mathsf{return}$) of the Monad -- Labelled with the
    Empty Effect
  \item Bind Operation ($T^\sigma\tau \bindop (\tau \rightarrow
    T^{\sigma'}\tau')$) of the Monad -- Labelled with the Union of two
    Effects: %FIXME union
    \begin{enumerate}
      \item $\sigma$: the Effect of $T^\sigma\tau$
      \item $\sigma'$: the Effect of $\tau \rightarrow
        T^{\sigma'}\tau'$
    \end{enumerate}
\end{enumerate}

Translation of Variables and $\lambda$-abstractions introduce Unit, so
they are Labelled with the Empty Effect

Translation of Application introduces two occurrences of Bind, so it
is Labelled with the Union of three Effects: $\sigma \cup \sigma' \cup
\sigma''$ %FIXME union


\textbf{Effect System}

Effect $\sigma$

$\tau \xrightarrow{\sigma} \tau'$ -- a Function that may have
Side-effects delimited by $\sigma$

Variables and $\lambda$-abstractions are Labelled with the Empty
Effect

%FIXME union
Applications are Labelled with the ``Union'' (???) of three Effects:
\begin{enumerate}
  \item Effects of Evaluating the Function
  \item Effects of Evaluating the Argument
  \item Effects of Evaluating the Function Body
\end{enumerate}
%FIXME clarify


\textbf{Effects + Monads}

$T^\sigma\tau$ -- Computation that yields a Value in $\tau$ and may
have Effects delimited by $\sigma$

$(\tau \xrightarrow{\sigma} \tau')^\dag$
$\rightsquigarrow$
$\tau^\dag \rightarrow T^\sigma \tau'^\dag$


\asterism


Effect (\S\ref{sec:computational_effect}): Monads (\S\ref{sec:monad});
how a Program \emph{Influences} its Environment

\emph{Coeffect System} (\S\ref{sec:coeffect_system}):
Context-dependent Computations

Coeffect (\S\ref{sec:coeffect}): Comonads (\S\ref{sec:comonad});
\emph{Requirements} of a Program with respect to its Environment

Term $M$, Type $A$, Effect $e$
\[
  \vdash M :(A,e)
\]

$T_e A$ -- Effect-graded Monad (\S\ref{sec:graded_monad}), $e$ Element
of an Effect Preordered Monoid (???)

``Indexing''

Coeffect-graded Comonad (???)



% --------------------------------------------------------------------
\subsection{Effect}\label{sec:effect}
% --------------------------------------------------------------------

(or \emph{Side-effects})

``Not-functional Programming''

\fist Cf. Referential Transparency: no Side-effects (Functional
Programming \S\ref{sec:referential_transparency})



\subsubsection{Subeffect}\label{sec:subeffect}

Layered Monad (\S\ref{sec:layered_monad}) \cite{filinski99}

allows Effects of an Expression to be ``over-approximated''
\cite{orchard-yoshida16}

\fist Cf. (traditional) Subtyping in Session Types allows an
approximation on Branch and Select \cite{orchard-yoshida16}



\subsubsection{Layered Monad}\label{sec:layered_monad}
\cite{filinski99}

each Effect specified independently by a Formal Monadic Translation

Proto-operations: Monadic Reflection (\S\ref{sec:monadic_reflection}),
Monadic Reification (\S\ref{sec:monadic_reification})

\fist Cf. Algebraic Effects (\S\ref{sec:algebraic_effect}):
\emph{Effect Constructors} (Algebraic Operations
\S\ref{sec:algebraic_operation}) and \emph{Effect Deconstructors}
(Effect Handlers \S\ref{sec:effect_handler})


establishes a (Trivial) Bijection between ``Opaque'' and
``Transparent'' Representations of an Effectful Computation

Effect Operations defined using the Transparent Representation

General Programs written using the Opaque Abstraction

each Monadic Translation can be simulated by a Continuation-passing
(\S\ref{sec:continuation}) Translation: original Transparent
Representation but with a different Opaque Representation substituted

$e ::= \mathfrak{n} | \mathfrak{p} | \cdots$ Effect Names

$E$ Expressions

$\tau$ Types

$\Gamma$ Context (Assumptions)

Typing Judgement:
\[
  \Gamma \vdash E : \tau / e
\]
Expression $E$ has Type $\tau$ and possible Effects $e$

$\mathfrak{n}$: \emph{None}: Evaluation of $E$ has no Effects

$\mathfrak{p}$: \emph{Partiality} (\S\ref{sec:partiality_effect};
Evaluation of $E$ may Diverge (\S\ref{sec:divergence}); all
Recursively Defined Functions (\S\ref{sec:recursive_function}) have
Partiality

$\mathfrak{ex}$: \emph{Exceptions} (\S\ref{sec:exception_effect}

$\mathfrak{st}$: \emph{State} (\S\ref{sec:state_effect}

Effect-layering Relation $e_1 \prec e_2$: typically $e_2$ was defined
by a Formal Translation into a Language with $e_1$-effects; Subeffect
(\S\ref{sec:subeffect})

$\preceq$ Reflexive, Transitive Closure of $\prec$

$\tau_1 \xrightarrow{\mathfrak{n}} \tau_2$ may be written $\tau_1
\rightarrow \tau_2$

$\Gamma \vdash E : \tau / \mathfrak{n}$ may be written as

$\Gamma \vdash E : \tau$ may be written as

\emph{Complete Program}: Closed Term of Base Type

``Escaping'' Effects (disallowed)

Signature $\Sigma$ assigns (potentially Polymorphic) Types to the Base
Constants of the Language (e.g. standard Arithmetic Functions,
Call-by-value Fix-point Operators, etc.)

Implicit Subtyping (\S\ref{sec:subtype}), Implicit Subeffect
(\S\ref{sec:subeffect})

Coercion Terms

Chain-complete Posets (CPO \S\ref{sec:cpo})

Monad (\S\ref{sec:monad}) $T$ Maps a CPO $A$ to a CPO of
$A$-computations

Elements of $T A$ are Effectful Computations yielding Values in $A$

\emph{Layering} of Monad $(T,\eta,\mu)$ Over another Monad
$(\overline{T}, \overline{\eta}, \overline{\mu})$ is a Family of
Functions:
\[
  \zeta_A : \overline{T}(T A) \rightarrow T A
\]
such that each $(T A, \zeta_A)$ is a $\overline{T}$-algebra
(\S\ref{sec:t_algebra}) %FIXME

Any Monad can be Layered over itself %FIXME

For Monad $T$ Layered over Monad $\overline{T}$, a Family of
\emph{Computation-inclusion} (or \emph{Lifting}) Functions:
\[
  i_A = \zeta_A \circ \overline{T} \eta_A :
    \overline{T} A \rightarrow T A
\]

For Monad Morphism (\S\ref{sec:monad_morphism}) $i : \overline{T}
\rightarrow T$, a Layering is obtained by:
\[
  \zeta_A = id^*_{T A} \circ i_A
\]

(Trivial) Layering of a Monad $T$ over the Identity Monad
(\S\ref{sec:identity_monad}) by taking $\zeta_A t = t$

Semantics $\class{L}$ of Effect-language $L$:
\begin{itemize}
  \item Base Types $b$: CPO $\class{B}(b)$
  \item Effects $e$: Monad $\class{E}(e) = (T^e,\eta^e,\mu^e)$
    \begin{itemize}
      \item if $e' \prec e$ then $\class{E}(e)$ is Layered over
        $\class{E}(e')$ by $\zeta^e$
    \end{itemize}
\end{itemize}

$\class{E}(\mathfrak{n})$ Identity Monad $I$

$\class{E}(\mathfrak{p})$ Lifting Monad $L$

Definitional Translation: ``explaining away'' and Effect

Syntactic Extension: \emph{Formal Monad} $\mathsf{T}$ over Effect
$\bar{e}$ in $L$ is a Type Constructor with 3 ``Polymorphic Terms''
(???):
\begin{align*}
  \mathsf{T} - &: Type \rightarrow Type \\
  glue_\alpha &: (1 \xrightarrow{\bar{e}} \mathsf{T} \alpha)
    \rightarrow \mathsf{T} \alpha \\
  unit_\alpha &: \alpha \rightarrow \mathsf{T} \alpha \\
  bind_{\alpha_1,\alpha_2} &: \mathsf{T} \alpha_1 \times (\alpha_1
    \rightarrow \mathsf{T} \alpha_2) \rightarrow \mathsf{T} \alpha_2
\end{align*}
denotes an (actual) Monad:
\[
  \class{L}\llbracket \mathsf{T} \rrbracket^m = (T,\eta,\mu,\zeta)
\]
Layered over $\class{E}(\bar{E})$ in a Semantics $\class{L}$ of
Effect-language $L$ if: %FIXME
\begin{enumerate}
  \item
  \item
  \item
  \item
\end{enumerate}

\fist $\mathsf{T}$ does not necessarily denote a Monad for all
Interpretations of the Effect $\bar{e}$, e.g. the List Monad can only
be properly Layered over a Commutative Monad (???) such as Partiality
%FIXME

Given $\mathsf{T}$, $L^\mathsf{T}$ is an (Proper) Extension of $L$
with new Effect $t$ and new Proto-operations \emph{Monadic Reflection}
(\S\ref{sec:monadic_reflection}) and \emph{Monadic Reification}
(\S\ref{sec:monadic_reification}):
\begin{align*}
  \mono{reflect}_\alpha^t &: \mathsf{T} \alpha \xrightarrow{t} \alpha \\
  \mono{reify}_\alpha^t &: (1 \xrightarrow{t} \alpha) \rightarrow
    \mathsf{T} \alpha
\end{align*}

\fist Cf. Algebraic Effects (\S\ref{sec:algebraic_effect}):
\emph{Effect Constructors} (Algebraic Operations
\S\ref{sec:algebraic_operation}) and \emph{Effect Deconstructors}
(Effect Handlers \S\ref{sec:effect_handler})

Any $L$-program is still a Valid $L^\mathsf{T}$-program with the same
Meaning: Semantics of $L^\mathsf{T}$ can be defined by a Formal
Monadic Translation $|-|_\mathsf{T}$ back into $L$ by expanding only
the new Type and Term Constructors into their $L$-definitions

Explicit Effect-passing (???)

Effect-ordering: Hierarchical, Translation-based Definition

different orderings correspond to different intended Semantics

Example ordering:
\[
\mathfrak{p} \prec \mathfrak{st} \prec \mathfrak{ex}
\]
with State persistent across Exceptions, corresponds to Effect Type:
\[
  ||\alpha / \mathfrak{ex}|_{EX}|_{ST} = |1
  \xrightarrow{\mathfrak{st}} \alpha + exn|_{ST} = 1 \rightarrow state
  \xrightarrow{\mathfrak{p}} (\alpha + exn) \times state
\]
$\mathfrak{st}$-computations always Implicitly Coercible (with
Subtyping Definitions) into an
$\mathfrak{ex}$-computation

Each individual Monadic Translation can be ``uniformly simulated'' by
a Layer of Continuation-passing

Any hierarchy of Continuation-passing Layers can be simulated by a
single Effect comprising First-class Continuations and Mutable State

$\mono{shift}$

$\mono{reset}$

$T$-$K$ Simulation Theorem

$K$-$CS$ Simulation Theorem

$T^*$-$CS^*$ Simulation Theorem

Metacontinution (???)

Resumption-computation (\S\ref{sec:resumption})

Effect-recursive Monads (???): new Effect being defined is implicitly
used in its own Specification



\paragraph{Monadic Reflection}\label{sec:monadic_reflection}\hfill
\[
  \mono{reflect}_\alpha^t : \mathsf{T} \alpha \xrightarrow{t} \alpha
\]

\emph{Effect Deconstructor}: Algebraic Effects
(\S\ref{sec:algebraic_effect}), Effect Handler
(\S\ref{sec:effect_handler})



\paragraph{Monadic Reification}\label{sec:monadic_reification}\hfill
\[
  \mono{reify}_\alpha^t : (1 \xrightarrow{t} \alpha) \rightarrow
    \mathsf{T} \alpha
\]

\emph{Effect Constructor}: Algebraic Effects
(\S\ref{sec:algebraic_effect}), Algebraic Operation
(\S\ref{sec:algebraic_operation})



\subsubsection{Graded Monad}\label{sec:graded_monad}

(or \emph{Effect-graded Monad})

%FIXME equivalent to a parametric effect monad?

\cite{orchard-yoshida16}:

\fist Note the following uses a Haskell-like notation, an actual
implementation is available in the hackage $\mono{effect-monad}$ package
\url{http://hackage.haskell.org/package/effect-monad}

carry Effect information as a Type Index

\fist See Session Effects (\S\ref{sec:session_effect}) for an
implementation of Session Effects using the following Effect-graded
Monad

Effect-graded Monad:
\begin{flalign*}
  & \quad\mono{class}\;\mathsf{Effect}
    (m : \eff \rightarrow * \rightarrow *)
    \;\mono{where} & \\
  & \quad\quad
    \mono{type}\;\mathsf{Unit}\;m : \eff & \\
  & \quad\quad
    \mono{type}\;\mathsf{Plus}\;m\;(f : \eff)
      \;(g : \eff) : \eff & \\
  & \quad\quad
    \mathsf{return} : a \rightarrow
      m\;(\mathsf{Unit\;m})\;a & \\
  & \quad\quad
    (\bindop) : m\;f\;a \rightarrow (a \rightarrow m\;g\;b)
        \rightarrow m\;(\mathsf{Plus}\;m\;f\;g)\;b &
\end{flalign*}

$\eff$ -- Domain, \emph{Kind} of Effects, i.e. $\eff$ Models a Set of
Effect Annotations $\class{F}$

$\mathsf{Plus}\;m$ -- Type-level Binary Function implementing $\bullet$
of the Effect Algebra for $\class{F}$

$\mathsf{Unit}\;m$ -- Constant providing the Unit Element $I$

$\mathsf{return}$ -- Lifts a Value to a Trivially Effectful
Computation marked with $I$

$(\bindop)$ -- Sequential Composition of Effectful Computations;
(\emph{Bind}) Rule Models the $\lett$-binding of FPCF
(\S\ref{sec:fpcf})

an FPCF Judgement:
\[
  \Gamma \vdash M:\tau,F
\]
Maps to a ``Monadic Metalanguage Judgement'': %FIXME
\[
  \Gamma \vdash [M]:m\;[F]\;\tau
\]
Embedding Effects into Types. \cite{wadler-thiemann03}




\paragraph{Parametric Effect Monad}
\label{sec:parametric_effect_monad} \hfill

(or \emph{Indexed Monad})

Katsumata14, Orchard-Petricek-Mycroft14

Semantic ``marriage'' of Effects and Monads

Indexed Joinad (\S\ref{sec:indexed_joinad})

Type-level Sets (???): Implementation in Haskell using ``data kinds''
and ``closed type families'' (Orchard-Petricek14) %FIXME

intermediate between Monads and Effect Handlers (Orchard-Petricek14)


Orchard-Petricek-Mykroft14:

Semantics for Moggi's Computational $\lambda$-calculus in terms of
(Strong) Indexed Monads, giving a one-to-one correspondence between
Indices of the Denotations and the Effect Annotations of traditional
Effect Systems

Dual: Indexed Comonads give a ``unified'' Semantics and Effect System
to Coeffects (\S\ref{sec:coeffect}), i.e. Contextual notion of Effects

Wadler-Thiemann03 -- Syntactic correspondence between Type-and-effect
Systems and the Monadic Semantics by Annotating Monadic Type
Constructors with Effect Sets of the Type-and-effect System

Functor:
\[
  \mathsf{T} : \cat{I} \rightarrow [\cat{C},\cat{C}]
\]
where $\cat{I}$ is a Strict Monoidal Category
(\S\ref{sec:monoidal_category}) $(\cat{I}, \otimes, 1)$ and
$\mathsf{T}$ is a Lax Monoidal Functor
(\S\ref{sec:lax_monoidal_functor}) mapping the Strict Monoidal
Structure of $\cat{I}$ to the Strict Monoid of Endofunctor
Composition: $([\cat{C},\cat{C}],\circ,\Id_\cat{C})$



\subsubsection{Joinad}\label{sec:joinad}

Extending Monads with Operations for Modelling Alternation
(Conditionals) and Parallelism



\paragraph{Graded Joinad}\label{sec:graded_joinad}\hfill

Effect Control-flow Algebras \& Types



\paragraph{Indexed Joinad}\label{sec:indexed_joinad}\hfill

Indexed Monad (Parametric Effect Monad
\S\ref{sec:parametric_effect_monad})



% --------------------------------------------------------------------
\subsection{Computational Effect}\label{sec:computational_effect}
% --------------------------------------------------------------------

Computational Effects

e.g. Exceptions, Non-determinism, Interactive Input/Output,
Concurrency, State, Time, Continuations, etc. \cite{plotkin-pretnar09}

Monad (\S\ref{sec:monad})

Computation (Monad) $T$ Returning Value of Type $A$:
\[
  T A
\]

Return

Bind

Value Polymorphism (\S\ref{sec:value_polymorphism})

\cite{plotkin-pretnar13}:

In the Category $\cat{Set}$, a Computation that Returns Values from a
Set $A$ is Modelled by an Element $T A$ for a ``suitable'' Monad $T$.

e.g. Exceptions, State, Non-determinism, Interactive Input/Output,
Time, Continuations, etc. (and combinations thereof)

Algebraic Effects (\S\ref{sec:algebraic_effect}):
\begin{itemize}
  \item Set of Operations representing Sources of Effects
  \item Equational Theory describing Properties of the Operations
\end{itemize}



\subsubsection{Partiality Effect}\label{sec:partiality_effect}

an Effect that all Recursively Defined Functions have
(\S\ref{sec:recursive_function})

possible Semantics:

Lifting Monad (\S\ref{sec:lifting_monad})

Continuation-based (\S\ref{sec:continuation})



\subsubsection{Exception Effect}\label{sec:exception_effect}

Thielecke01

Continuations (\S\ref{sec:continuation})

Continuations: Classical -- Exceptions: Intuitionistic

$\lambda + \mathbf{cont}$

$\lambda + \mathbf{exn}$

$\lambda + \mathbf{state}$

$\lambda + \mathbf{cont} + \mathbf{exn}$

in a base Language without State, Exceptions cannot express
Continuations

in a base Language without State, Continuations cannot express
Exceptions; Exceptions can break a Contextual Equivalence that holds
in the presence of Continuations--Exceptions can detect parts of the
``Dynamically Enclosing Evaluation Context'' by means of Handlers
contained inside it, first-class Continuations can only be Invoked
with some Value to find out anything about them
%FIXME

Exceptions and Continuations combined in a Language cannot express
State

\fist Note that depending on how Exceptions and Continuations are
combined, this may not be the case and State may be expressable

Exceptions and State cannot express Continuations

Continuations allow Backtracking which breaks an Equivalence that
holds in the presence of Exceptions; in the presence of Exceptions,
Continuations are used \emph{Linearly} (whereas general Continuations
can be used multiple times)

$\mono{raise}\;e\;V$ -- Raise Exception $e$ with some Value $V$

$\mono{handle}\;e\;M\;N$ -- $M$ acts as Handler for Raising of $e$ in
the Evaluation of $N$

An Uncaught Exception $\mono{raise}\;e\;V$ without a ``Dynamically
Enclosing Handler'' has no Reduction

An Exception Name $e$ can be passed like any other Value

An Exception Handler (an Evaluation Context, i.e. as a Continuation)
cannot be made into a Value

in $\lambda + \mathbf{cont} + \mathbf{exn}$, ``Reification'' of the
Current Continuation includes the Exception Handler in that
Continuation; ``Throwing'' to the Continuation later ``re-installs''
the Exception Handler

an Exception is a form of ``jump'' whose target is determined
Dynamically %FIXME

Contextual Equivalence, Separation %FIXME

there are Expressions which are Contextually Equivalent in $\lambda +
\mathbf{exn}$ but can be Separated in $\lambda + \mathbf{cont}$


\cite{plotkin-pretnar13}:

Finite Set of Exceptions $\mathbf{exc}$

Exception Monad

\begin{align*}
     T A & \defeq A + \mathbf{exc} \\
  \eta_A & \defeq in_1 : A \rightarrow A + \mathbf{exc}
\end{align*}

Computations:

$\mono{return}\; V$ Interpreted by $\eta_A(V) = in_1(V)$

$\mono{raise}_e()$ Interpreted by $in_2(e)$

Effect Handler (\S\ref{sec:effect_handler})

Exception Handling

Computation $M \in A + \mathbf{exc}$
\[
  M \;\mono{handled\;with}\;
    \{\mono{raise}_e \mapsto M_e \}_{e\in\mathbf{exc}}
\]
where $\{\cdots\}_{e\in\mathbf{exc}}$ is a Set of Computations, one
for each Exception $e \in \mathbf{exc}$

carries out $M$, ``Intercepting'' Exceptions $e \in \mathbf{exc}$ by
carrying out predefined Computations $M_e \in A + \mathbf{exc}$
instead

Un-handled Exceptions take $M_e$ to be $\mono{raise}_e()$

Handling Construct Satisfies two Equations:
\begin{enumerate}
  \item $\mono{return}\; V \;\mono{handled\;with}\;
    \{\mono{raise}_e \mapsto M_e\}_{e \in \mathbf{exc}}
    = in_1(V)$
  \item $\mono{raise}_{e'}() \;\mono{handled\;with}\;
    \{\mono{raise}_e \mapsto M_e\}_{e \in \mathbf{exc}}
    = M_{e'}$
\end{enumerate}

the Computations $M_e$ give a new Model $\mathcal{M}$ for the Theory
of Exceptions with same Carrier (i.e. Domain \S\ref{sec:domain}) $A +
\mathbf{exc}$ and for each $e$, each $\mono{raise}_e ()$ is instead
Interpreted by $M_e$

\[
  h(M) \defeq M \;\mono{handled\;with}\;
    \{\mono{raise}_e \mapsto M_e\}_{e \in \mathbf{exc}}
\]
is a Unique Homomorphism (Preserving Operations) from $A +
\mathbf{exc}$ to $\mathcal{M}$ that Extends $in_1 : A \rightarrow A +
\mathbf{exc}$, i.e. such that:
\[
  A \xrightarrow{in_1} \mathcal{M} =
    A \xrightarrow{\eta_A} A + \mathbf{exc} \xrightarrow{h} \mathcal{M}
\]

Extended Handling Construct:
\[
  M \;\mono{handled\;with}\;
    \{\mono{raise}_e() \mapsto M_e \}_{e\in\mathbf{exc}}
    \;\mono{to}\; x : A.N(x)
\]

\begin{enumerate}
  \item $\mono{return}\; V \;\mono{handled\;with}\;
    \{\mono{raise}_e() \mapsto N_e\}_{e \in \mathbf{exc}}
    \;\mono{to}\; x:A.N(x)
    = N(V)$
  \item $\mono{raise}_{e'}() \;\mono{handled\;with}\;
    \{\mono{raise}_e() \mapsto N_e\}_{e \in \mathbf{exc}}
    \;\mono{to}\; x:A.N(x)
    = N_{e'}$
\end{enumerate}
\[
  A \xrightarrow{N} \mathcal{M} =
    A \xrightarrow{\eta_A} A + \mathbf{exc} \xrightarrow{h} \mathcal{M}
\]

Homomorphisms from the Free Model to a Model on a given Carrier

Effect Handler (\S\ref{sec:effect_handler}): Exceptions replaced by
Handling Computations



\subsubsection{State Effect}\label{sec:state_effect}

\subsubsection{Communication Effect}\label{sec:communication_effect}

Communication \S\ref{sec:communication}

Jouvelot-Gifford89

\cite{nielson-nielson99}

\cite{orchard-yoshida16}: Communication Effects can be encoded in
Session Types (\S\ref{sec:session_type}), but there is no reverse
encoding of Session Types into Communication Effects because Session
Types do not describe the relative ``Causality'' between Channels
(recorded by Communication Effects).



\subsubsection{Session Effect}\label{sec:session_effect}

Session (\S\ref{sec:session})

Session Type (\S\ref{sec:session_type})

Embedding of Session Calculus (\S\ref{sec:session_calculus}) into FPCF
(\S\ref{sec:fpcf})

\[
  \begin{tabular}{|l r|l r|}
    \hline \textbf{Effects} & & \textbf{Sessions} & \\
    \hline \hline
      $\bullet$ & \emph{sequential}
        & $?[\tau].-$ \quad $![\tau].-$ & \emph{prefixing} \\
    \hline
      $I$ & \emph{pure} & $\mathsf{end}$ & \emph{inaction} \\
    \hline
      $\oplus$ & \emph{conditional}
        & $\oplus[l_1:S_1, \ldots, l_n:S_n]$ & \emph{selection}/ \\
      \hfill & \hfill
        & $\&[l_1:S_1, \ldots, l_n:S_n]$ & \emph{branching} \\
    \hline
      $*$ & \emph{repetition}
        & $\mu a.S$ \quad $a$ & \emph{fixed points} \\
      \hfil & \hfill
        & $*![\tau]$ \quad $*?[\tau]$ & \emph{replication} \\
    \hline
      $\sqsubseteq$ & \emph{sub-effecting}
        & $\leqq$ & \emph{sub-typing} \\
    \hline
      $\&$ & \emph{parallelism} & $\odot$ & \emph{balancing} \\
    \hline
  \end{tabular}
\]


\textbf{Implementation}

\fist Note the following uses a Haskell-like notation, an actual
Haskell implementation is available at
\url{http://dorchard.co.uk/popl16}

Effect-graded Monad (\S\ref{sec:graded_monad}):
\begin{flalign*}
  \quad & \quad\mono{class}\;\mathsf{Effect}
    (m : \eff \rightarrow * \rightarrow *)
    \;\mono{where} & \\
  & \quad\quad
    \mono{type}\;\mathsf{Unit}\;m : \eff & \\
  & \quad\quad
    \mono{type}\;\mathsf{Plus}\;m\;(f : \eff)
      \;(g : \eff) : \eff & \\
  & \quad\quad
    \mathsf{return} : a \rightarrow
      m\;(\mathsf{Unit\;m})\;a & \\
  & \quad\quad
    (\bindop) : m\;f\;a \rightarrow (a \rightarrow m\;g\;b)
        \rightarrow m\;(\mathsf{Plus}\;m\;f\;g)\;b &
\end{flalign*}

\emph{Session Effects} (\S\ref{sec:session_effect}) are Modelled by
the $\mathsf{Session}$ Datatype:
\begin{align*}
  \mono{data}\;\mathsf{Session}
    =\; & \mono{forall}\;a . a :! \;\mathsf{Session}
      \quad\quad\quad & \text{\emph{send}} \\
    \mid\; & \mono{forall}\;a . a :? \;\mathsf{Session}
      \quad\quad\quad & \text{\emph{receive}} \\
    \mid\; & \mono{forall}\;a . a :\kern-2pt*! \;\mathsf{Session}
      \quad\quad\quad & \text{\emph{output}} \\
    \mid\; & \mathsf{Session} \altop \mathsf{Session}
      \quad\quad\quad & \text{\emph{alternation}} \\
    \mid\; & \mathsf{Bal\;Session}
      \quad\quad\quad & \text{\emph{balanced}} \\
    \mid\; & \mathsf{End}
      \quad\quad\quad & \text{\emph{end}} \\
    \mid\; & \mathsf{Fix\;Session\;Session}
      \quad\quad\quad & \text{\emph{-* prefix}}
\end{align*}

Explicit Subtyping Class: \textturnt
\begin{flalign*}
  \quad\quad &
  \mono{class}\;\mathsf{Sub}\;m\;f\;g\;\mono{where}\;
    \mathsf{sub} : \mathsf{Sub}\;f\;g \Rightarrow
      m\;f\;a \rightarrow m\;g\;a &
\end{flalign*}

Graded Monad Instance for $\mathsf{Process}$ (\S\ref{sec:process})
Datatype:
\begin{flalign*}
  \quad\quad
  & \mono{data}\;\mathsf{Process}\;(s:[\mathsf{Map\;Name\;Session}])\;a
    = \mathsf{Proc}\;(\mathsf{IO}\;a) & \\
  \quad\quad & \hfill & \\
  \quad\quad
  & \mono{instance}\;\mathsf{Effect\;Process}\;\mono{where} & \\
  \quad\quad
  & \quad \mono{type}\;\mathsf{Plus\;Process}\;f\;g
    = \mathsf{SeqUnion}\;f\;g & \\
  \quad\quad
  & \quad \mono{type}\;\mathsf{Unit\;Process} = '[] & \\
  \quad\quad & \hfill & \\
  \quad\quad
  & \mono{instance}\;\mathsf{Sub\;Process}\;f\;g \Rightarrow & \\
  \quad\quad
  & \quad \mathsf{Sub\;Process}\;((c :\rightarrow s) \hastypef f)\;
    ((c :\rightarrow s \altop t) \hastypef g) & \\
\end{flalign*}

$s$ -- Type-level Finite Map Modelling an Environment of Session Type
information of the form:
\[
  '[c :\rightarrow s, d :\rightarrow t, \ldots]
\]
describing an Environment where a Channel $c$ has Session Type $s$, a
Channel $d$ has Session Type $t$, etc.

Session Environments are Composed Sequentially via the
$\mathsf{SeqUnion}$ Type-level Function (Modelling $\bullet$ for
Effect Algebras \S\ref{sec:effect_system})

Operations from Embedding of Session Calculus in FPCF: %FIXME

$\mathsf{send}$

$\mathsf{rsend}$

$\mathsf{chSend}$

$\mathsf{recv}$

$\mathsf{chRecv}$

$\mathsf{new}$

(duality type-class)

\fist Haskell does not have Equirecursive Types
(\S\ref{sec:equirecursive_type}) so the Implementation restricts
Recursion to only definitions that Induce an \emph{Affine Effect
  Equation} (???). %FIXME

(specialized affineFix combinator) %FIXME



% --------------------------------------------------------------------
\subsection{Algebraic Effect}\label{sec:algebraic_effect}
% --------------------------------------------------------------------

\cite{nielson-nielson99}
\cite{plotkin-pretnar09}
\cite{plotkin-pretnar13}
\cite{pretnar15}

\fist The paper \emph{Handlers of Algebraic Effects}
\cite{plotkin-pretnar09} (Plotkin, Pretnar 2009) is a preliminary
version of \emph{Handling Algebraic Effects} \cite{plotkin-pretnar13}
(Plotkin, Pretnar 2013). In \cite{plotkin-pretnar09}, there are
restricted facilities for defining Handlers (the \emph{Minimal}
approach). Two levels of Language are considered: in the first there
are no Handlers but it is used to define Handlers, and if they give
Models then they are used in Handling Constructs in the second level
(with no facilities for further definition of Handlers). In
\cite{plotkin-pretnar13} Handlers and Handling may be nested
arbitrarily deeply (the \emph{Maximal} approach).


\fist Orchard-Yoshida16 \cite{orchard-yoshida16} distinguishes the
Effect Systems of Nielson-Nielson99 \cite{nielson-nielson99} from
``traditional'' Effect Systems by distinguishing Sequential Control
Flow from Branching Control Flow (Alternation).


(Countable) Equational Theories (Algebraic Theory
\S\ref{sec:algebraic_theory})

Algebraic Operation (\S\ref{sec:algebraic_operation})


as an alternative to using Monads (\S\ref{sec:monad}) to Model
Side-effects, most often seen in Strict Languages

Continuations (\S\ref{sec:continuation}) are not representable as
Algebraic Effects


Call-by-value, Call-by-push-value %FIXME


\cite{plotkin-pretnar08}:

Effectful Programs (1) cause Effects (Computation Terms combined by an
Operation), (2) Return Values (Returned Value Terms), (3) have an
Evaluation Order (Computations Sequenced with a $\mono{let}$ Binding)

$a$-calculus: Values, Effects, Computations

Operations: ``sources'' of Effects

Value Theory $\thy{V}$

$\Sigma_{\mathrm{fun}}$

Value Contex $\Gamma$

Effect Theory $\thy{E}$

$\Sigma_{\mathrm{op}}$

Effect Contex $\Xi$

Computations Returning Value of Type $\sigma$: $F \sigma$

Evaluation of Computation $\mono{let}\; x \;\mono{be}\; \mono{op}(t_1,
\ldots, t_n) \;\mono{in}\; t'$ begins with Occurrence of Effect
represented by $\mono{op}:n$ and then based on the Outcome (???) of an
Effect, proceeds by Evaluating one of the Computation Terms $t_1,
\ldots, t_n$ and Binding its Result to $x$ in Computation Term $t'$

Effect Theory $\thy{E}$ gives rise to a Lawvere Theory
(\S\ref{sec:lawvere_theory}) $\cat{L}$

\textbf{Semantics}

Value Terms Interpreted in $\cat{Set}$

Effect Terms Interpreted in a Lawvere Theory $\cat{L}$

Computation Terms Interpreted in the Category of Models
(\S\ref{sec:category_of_models}) $\cat{Mod}_\cat{L}(\cat{Set})$ of
Models of $\cat{L}$ in $\cat{Set}$.



\cite{plotkin-pretnar13}:

Algebraic Effects:
\begin{itemize}
  \item Set of Operations representing Sources of Effects
  \item Equational Theory (\S\ref{sec:equational_theory}) describing
    Properties of the Operations
\end{itemize}

Each Computation either Returns a Value, or performs an Operation with
an Outcome that determines a Continuation (\S\ref{sec:continuation})
of the Computation with Arguments of the Operation representing
possible Continuations (possible Computations after the occurrence of
an Effect).



\cite{plotkin-pretnar09}:

$T X$: Computations $T$ that Return Values in $X$, for ``suitable''
Monad (\S\ref{sec:monad}) $T$

Subclass of Computational Effects (\S\ref{sec:computational_effect}):
Effects that allow Representation by Operations and Equations.

Equational Logic (\S\ref{sec:equational_logic})

Computational Effects representable by an Algebraic Theory:
Nondeterminism, Interactive Input/Output, Concurrency, State, Time,
Stream Redirection, Backtracking, Co-operative Multi-threading,
Delimited Continuations (\S\ref{sec:delimited_continuation}), etc.

Sets of Operations

Operations give rise to Effects

Arguments of an Operation represent possible Computations after an
Occurrence (???) of an Effect

Example Non-deterministic Boolean $\mono{or}$ Operator:
\[
  \mono{or}(\mono{return}\;true, \mono{return}\;false)
  : F \mathrm{Bool}
\]

$F \sigma$: Type of Computations with Return Values of Type $\sigma$

Computation Monad: Free-model Monad (???, Free Monad
\S\ref{sec:free_monad}) of the Algebraic Theory; Equations of the
Theory Generate the Free-model Functor (exactly the corresponding
Monad for the Effect, Modulo the Forgetful Functor): used to Interpret
the Type $F \sigma$.

Operations Interpreted by the Model Structure

Family of Functions Parametric in $X$ (Algebraic Operation),
characterized by a Naturality Condition %FIXME

Example Parametric Operation:
\[
  \mono{or}_X : T X^2 \rightarrow T X
\]

Algebraic Operations \S\ref{sec:algebraic_operation} (\emph{Effect
  Constructors}) and Effect Handlers \S\ref{sec:effect_handler}
(\emph{Effect Destructors}) are Dual

\fist Cf. Monadic Reflection (\S\ref{sec:monadic_reflection})
and Monadic Reification (\S\ref{sec:monadic_reification})

Handlers (\S\ref{sec:effect_handler}) correspond to a Model of the
Algebraic Theory

Handling a Computation is Composing it with a Unique Homomorphism
(defined Universally) with Domain a Free Model
(\S\ref{sec:free_model}) of the Algebraic Theory of the Effects ``at
hand'', and Range the Programmer-defined Model (???) of the Algebraic
Theory, Extending a Programmer-defined Map on Values.

Instances of Handlers: Exception Handling, Stream Redirection,
Renaming and Hiding, Timeout, Rollback, etc.

\fist Note that some Handlers (e.g. for Backtracking) do not
respect the Equations of an Algebraic Theory. \cite{pretnar15}

\cite{plotkin-pretnar09}:

Parts of an Effect System detailed below:
\begin{itemize}
  \item Base Signature $\Sigma_\mathrm{base}$:
    \begin{itemize}
      \item Base Types
      \item Function Symbols
      \item Relation Symbols
    \end{itemize}
  \item Base Terms
  \item Base Formulas
  \item Effect Signature $\Sigma_\mathrm{eff}$:
    \begin{itemize}
      \item Operations
    \end{itemize}
  \item Effect Terms
  \item (Conditional) Effect Theory (\S\ref{sec:effect_theory})
    $\thy{E}$:
    \begin{itemize}
      \item Conditional Equations
    \end{itemize}
  \item Handler (\S\ref{sec:effect_handler}) Signature
    $\Sigma_\mathrm{hand}$:
    \begin{itemize}
      \item Handler Symbols
    \end{itemize}
  \item Handler Types
  \item Handler Terms
  \item Computation Types
  \item Computation Terms
\end{itemize}


\emph{Base Signature} $\Sigma_{\mathrm{base}}$:
\begin{itemize}
  \item Base Types $\beta_1, \beta_2, \ldots$
  \begin{itemize}
    \item Arity Types $\alpha_1, \alpha_2, \ldots$
  \end{itemize}
  \item Function Symbols $f : (\vec{\beta}) \rightarrow \beta$
  \item Relation Symbols $R : (\vec{\beta})$
\end{itemize}

Variables $x,y,z,\ldots$

Function Symbols $f,g,h,\ldots$

\emph{Base Terms}:
\begin{flalign*}
  \quad v ::=& x \; | \; f (\vec{v}) &
\end{flalign*}

\emph{Base Formulas} $\varphi$: Equations $v_1 = v_2$, Relation
Symbols $R (\vec{v})$, Logical Connectives, Quantifiers
applied to Base Types

\emph{Context} $\Gamma$: Variables Bound to Base Types

A Context $\Gamma$ Types Base Terms as $\Gamma \vdash v:\beta$ and
Base Formulas as $\Gamma \vdash \varphi : \mathbf{form}$

\emph{Interpretation} of the Base Signature:
\begin{itemize}
  \item Sets $\llbracket \beta \rrbracket$ for each Base Type
    (Countable when $\beta$ is an Arity Type)
  \item Maps $\llbracket f \rrbracket : \llbracket \vec{\beta}
    \rrbracket \rightarrow \llbracket \beta \rrbracket$ for each
    Function Symbol
  \item Subsets $\llbracket R \rrbracket \subseteq \llbracket
    \vec{\beta} \rrbracket$ for each Relation Symbol
  \item Maps $\llbracket v \rrbracket : \llbracket \Gamma \rrbracket
    \rightarrow \llbracket \beta \rrbracket$ for Terms
  \item Subsets $\llbracket \varphi \rrbracket \subseteq \llbracket
    \Gamma \rrbracket$ for Formulas
\end{itemize}
where $\llbracket \vec{\beta} \rrbracket = \llbracket \beta_1
\rrbracket \times \cdots \times \llbracket \beta_n \rrbracket$

\emph{Effect Signature} $\Sigma_{\mathrm{eff}}$:
\begin{itemize}
  \item Operation Symbols $\mono{op} : \vec{\beta}; \vec{\alpha}_1,
    \ldots, \vec{\alpha}_n$ where $\vec{\beta}$ is a list of Parameter
    Base Type and $\vec{\alpha}_1, \ldots, \vec{\alpha}_n$ are Lists
    of Argument Arity Types (``;'' is ommitted if the List of Base
    Types is Empty and $n$ is used if all $\vec{\alpha}_i$ Lists of
    Argument Arities are Empty)
\end{itemize}

\emph{Effect Variables} $w$

\emph{Effect Terms}:
\begin{flalign*}
  \quad T ::=& w(\vec{v}) \; | \; \mono{op}_{\vec{v}}
  (\vec{x}_1:\vec{\alpha}_1.T_1, \ldots, \vec{x}_n:\vec{\alpha}_n.T_n)
  &
\end{flalign*}
where $\vec{x}_i:\vec{\alpha}_i$ are Lists of Base Terms of Arity
Types.

$\Delta$ is a Set of Effect Variables $w:(\vec{\alpha})$ with rules:
\begin{enumerate}
  \item $(w:(\vec{\alpha}) \in \Delta)$:
  \[
    {\Gamma \vdash \vec{v}:\vec{\alpha}}
    \over{\Gamma;\Delta \vdash w(\vec{v})}
  \]
  \item $(\mono{op} : \vec{\beta}; \vec{\alpha}_1, \ldots,
    \vec{\alpha}_n \in \Sigma_\mathrm{eff})$:
    \[
      {\Gamma \vdash \vec{v}:\vec{\beta} \quad\quad
        \Gamma, \vec{x}_i:\vec{\alpha}_i;
        \Delta \vdash T_i \quad (i = 1, \ldots, n)}
      \over{\Gamma; \Delta \vdash
        \mono{op}_{\vec{v}(\vec{x}_i:\vec{\alpha}_i.T_i)_i}}
    \]
\end{enumerate}

Typing Effect Terms: $\Gamma; \Delta \vdash T$

\emph{Conditional Equations}: $\Gamma; \Delta \vdash T_1 = T_2
(\varphi)$ given that $\Gamma; \Delta \vdash T_1$, $\Gamma; \Delta
\vdash T_2$, and $\Gamma \vdash \varphi:\mathbf{form}$

\emph{Conditional Effect Theory} (\S\ref{sec:effect_theory}):
$\thy{E}$ is a collection of Conditional Equations

Equational Theory (\S\ref{sec:equational_theory}) given by Effect
Theory:
\begin{itemize}
  \item For each Operator $\mono{op}:\vec{\beta}; \vec{\alpha}_1,
    \ldots, \vec{\alpha}_n \in \Sigma_\mathrm{eff}$ and $\vec{b} \in
    \llbracket \vec{\beta} \rrbracket$ take an Operation Symbol
    $\mono{op}_{\vec{b}}$ of (Countable) Arity $\sum_{i}|\llbracket
    \vec{\alpha}_i \rrbracket|$
  \item Each Effect Term $\Gamma; \Delta \vdash T$ and each $\vec{c}
    \in \llbracket \Gamma \rrbracket$ gives rise to a Term $\Delta'
    \vdash T_{\vec{c}}$ with $\Delta'$ consisting of Effect Variables
    $w_{\vec{a}}$ for each $w:(\vec{\alpha}) \in \Delta$ and $\vec{a}
    \in \llbracket \vec{\alpha} \rrbracket$
  \item Equations:
    \[
      \Delta' \vdash T_{\vec{c}} = T_{\vec{c'}}
    \]
    for any Conditional Equations $\Gamma; \Delta \vdash T =
    T'(\varphi)$ in $\thy{E}$ and any $\vec{c} \in \llbracket \varphi
    \rrbracket$
\end{itemize}

Model of the Effect Theory:
\begin{itemize}
  \item Set $M$
  \item Family of Maps $\{ \mono{op}_M : \llbracket \vec{\beta}
    \rrbracket \times \prod_i M^{\llbracket \vec{\alpha}_i
      \rrbracket} \rightarrow M \}_{\mono{op}:\vec{\beta};
      \vec{\alpha}_1, \ldots, \vec{\alpha}_n \in
      \Sigma_{\mathrm{eff}}}$
\end{itemize}
such that the corresponding Maps $\mono{op}_M(\vec{b})$ (where
$\vec{b} \in \llbracket \vec{\beta} \rrbracket$) Satisfy
(\S\ref{sec:satisfaction}) the Equations of the Induced Infinitary
Effect Theory.

A Homomorphism between Models $M$ and $N$ is a Map $f : M \rightarrow
N$ such that $\mono{op}_N \circ (id_{\llbracket \vec{\beta}
  \rrbracket} \times \prod_i f^{\llbracket \vec{\alpha}_i \rrbracket})
= f \circ \mono{op}_M$

Category of Models and Homomorphisms $\cat{Mod}_\thy{E}$

Forgetful Functor $U : \cat{Mod}_\thy{E} \rightarrow \cat{Set}$

Left-adjoint to $U$ Free-model Functor $F$: constructs the Free Model
(\S\ref{sec:free_model}) $F A$ on a Set of Generators $A$.

$U F A$: Set of Computations Returning Values in $A$

$U F$: Monad used to Model the corresponding Effect

\emph{Handler Types}:
\begin{flalign*}
  \quad \chi &::= X \; | \; F \sigma \; | \; 1 \;
    | \; \chi_1 \times \chi_2 \; | \; \sigma \rightarrow \chi &
\end{flalign*}

\emph{Handler Terms}:
\begin{flalign*}
  \quad h ::=& \; z(\vec{v}) \;
    | \; \mono{op}_{\vec{v}}
      (\vec{x}_1:\vec{\alpha}_1.h_1, \ldots, \vec{x}_n:\vec{\alpha}_n.h_n) & \\
    |&\; \mono{if}\; \varphi \;\mono{then}\; h_1
      \;\mono{else}\; h_2 \; | \; \mono{return}\; u \;
    | \; \mono{let}\; x \;\mono{be}\; h \;\mono{in}\; h' & \\
    |&\; \star \;
    | \; \langle h_1, h_2 \rangle \; | \; \mono{fst}\; h \;
    | \; \mono{snd}\; h \; | \; \lambda x:\sigma.h \;
    | \; h u &
\end{flalign*}

Typing Handlers

Handler (\S\ref{sec:effect_handler}) Signature $\Sigma_\mathrm{hand}$:
Set of Handler Symbols $H$

\emph{Computation Type}:
\begin{flalign*}
  \quad \underline{\tau} &::= F \sigma \; | \; 1 \;
    | \; \underline{\tau}_1 \times \underline{\tau}_2 \;
    | \; \sigma \rightarrow \underline{\tau} &
\end{flalign*}

\emph{Computation Term}:
\begin{flalign*}
  \quad t ::=& \; \mono{op}_{\vec{v}}
      (\vec{x}_1:\vec{\alpha}_1.t_1, \ldots \vec{x}_n:\vec{\alpha}_n.t_n) & \\
    |&\; \mono{if}\; \varphi \;\mono{then}\; t_1
      \;\mono{else}\; t_2 \; | \; \mono{return}\; u \;
    | \; \mono{let}\; x \;\mono{be}\; t \;\mono{in}\; t' & \\
    |&\; \mono{try}\; t \;\mono{with}\; H(\vec{u};
      \vec{t}) \;\mono{as}\; x \;\mono{in}\; t' \\
    |&\; \star \; | \; \langle t_1, t_2 \rangle \;
    | \; \mono{fst}\; t \;
    | \; \mono{snd}\; t \; | \; \lambda x:\sigma.t \;
    | \; t u &
\end{flalign*}

\fist Note that Computation Types mirror Handler Types (except
for Type Variables), and Computation Terms mirror Handler Terms
(except for Handler Variables and the addition of the
$\mono{try}\ldots\mono{with}$ Construct)

The syntax:
\[
  \mono{handle}\; t \;\mono{with}\;
  H(\vec{u};\vec{t})
\]
can be used in place of:
\[
    \mono{try}\; t \;\mono{with}\; H(\vec{u};
      \vec{t}) \;\mono{as}\; x \;\mono{in\;return}\; x
\]

When the Handler Signature consists of a single Handler Symbol $H$ it
may be ommitted:
\[
    \mono{try}\; t \;\mono{with}\; \vec{u};
      \vec{t} \;\mono{as}\; x \;\mono{in}\; t'
\]

Typing Computation Terms

a Handler:
\[
  H : (\vec{\sigma}; \vec{\chi})
    \rightarrow \chi \;\mathbf{handler} \in \Sigma_\mathrm{hand}
\]

Typing Handling Constructs

Examples: \cite{plotkin-pretnar09}

CCS (Calculus of Communicating Systems \S\ref{sec:ccs})

%FIXME



\cite{plotkin-pretnar13}:

Free Model (\S\ref{sec:free_model}) $F A$ Generated by the Equational
Theory (\S\ref{sec:equational_theory})

Computation Returning Values from a Set $A$ is an Element of the Free
Model $F A$

(Modulo the Forgetful Functor) the Free-model Functor $F$ is the Monad
(\S\ref{sec:monad}) used to Model the corresponding Effect; an
Algebraic Effect. Continuations (\S\ref{sec:continuation}) are an
example of a Non-algebraic Effect (does not arise from an Equational
Presentation).

\emph{Handlers} correspond to (not-necessarily Free) Models of the
Equational Theory

Semantics of Handling given using Universal Property of the Free Model
(it Induces Unique Homomorphisms to the Models)

Exception Handling Construct: Application of Unique Homomorphism that
Preserves Returned Values

\emph{or}

(generalizing to all Algebraic Effects, e.g. Stream Redirection,
Renaming and Hiding, Timeout, Rollback, etc.): Returned Values are
passed to a user-defined Continuation (Application of an arbitrary
Homomorphism to a Computation)

Algebraic Operations \S\ref{sec:algebraic_operation} (\emph{Effect
  Constructors}: giving rise to the Effects) are Dual to Effect
Handlers \S\ref{sec:effect_handler} (\emph{Effect Deconstructors}:
proceeding according to Effects already created)

\fist Cf. Layered Monads (\S\ref{sec:layered_monad}): Monadic
Reflection (\S\ref{sec:monadic_reflection}) and Monadic Reification
(\S\ref{sec:monadic_reification})


\textbf{Types}

\emph{Signature Types}:
\[
  \alpha, \beta ::= b \;|\; 1 \;|\; \alpha \times \beta \;|\;
    \Sigma_{\ell \in L} \alpha_\ell
\]

(Type) Signature: Base Types, Typed Function Symbols, Typed Operation
Symbols

Syntax Parameterized by choice of Signature

Base Types $b$

Labels $\ell$

$Lab$ all possible Labels

$L$ Finite Subsets of Labels

Arity Base Types

Arity Signature Type: a Signature Type that contains only Arity Base
Types

\emph{Function Symbols} $f : \alpha \rightarrow \beta$

\emph{Operation Symbols} $op : \alpha \rightarrowtriangle \beta$

\emph{Effect Theory} (\S\ref{sec:effect_theory}) $\thy{T}$

Operations: Sources of Effects

Effect Theory: Properties of Effects

Operation $op : \alpha \rightarrowtriangle \beta$:
\begin{enumerate}
  \item accepts Parameter of Type $\alpha$
  \item performs relevant Effect
  \item outcome of Type $\beta$ determines its Continuation
\end{enumerate}
%FIXME

$op$ is:
\begin{itemize}
  \item Parameterized on $\alpha$
  \item has Arity $\beta$ ($\beta$-ary)
\end{itemize}

When $\alpha = 1$, $op$ may be written $op:\beta$

\emph{Value Types} $A,B,\ldots$:
\begin{flalign*}
  \quad A,B ::=&\; b \;|\; 1 \;|\; A \times B
    \;|\; \sum_{\ell \in L}A_{\ell} \;|\; U \underline{C} &
\end{flalign*}

\emph{Computation Types} $\underline{C},\ldots$:
\begin{flalign*}
  \quad \underline{C} ::=&\; F A
    \;|\; \prod_{\ell \in L} \underline{C}_{\ell}
    \;|\; A \rightarrow \underline{C} &
\end{flalign*}

Value Types extend Signature Types by addition of Type Constructor $U
-$ classifying Computations of Type $\underline{C}$ that have been
Thunked (???) into Values (later Forced back into Evaluation).
%FIXME xref Thunk, Forced

Computation Type $F A$ classifies Computations that Return Value of
Type $A$

$\prod_{\ell \in L} \underline{C}_{\ell}$ classifies Finite Indexed
Products of Computations

$A \rightarrow \underline{C}$ Computations of Type $\underline{C}$
Parametric on Values of Type $A$


\textbf{Terms}

Value Terms, Computation Terms, Handler Terms

(``Value'', ``Computation'', or ``Handler'' may be used instead of
``Value Term'', ``Computation Term'', or ``Handler Term'')

Value Variables $x,y,\ldots$

\emph{Value Terms} $V,W,\ldots$:
\begin{flalign*}
  \quad V,W ::=&\; x \;|\; f(V) \;|\; \langle \rangle
    \;|\; \langle V,W \rangle \;|\; \ell (V) \;|\; \mono{thunk}\; M &
\end{flalign*}


Continuation Variables $k,\ldots$

\emph{Computation Terms} $M,N,\ldots$:
\begin{flalign*}
  \quad M,N ::=&\; \mono{match}\; V \;\mono{with}\;
      \langle x,y \rangle \mapsto M
    \;|\; \mono{match}\; V \;\mono{with}\; \{\ell(x_\ell) \mapsto
      M_\ell\}_{\ell \in L}
    \;|\; \mono{force}\; V & \\
    \;|\;& \mono{return}\; V \;|\; M \;\mono{to}\; x:A.N
    \;|\; \langle M_\ell \rangle_{\ell \in L} \;|\; \mono{prj}_\ell M
    \;|\; \lambda x:A.M \;|\; M V & \\
    \;|\;& op_V(x:\beta.M) \;|\; k(V)s
    \;|\; M \;\mono{handled\;with}\; H \;\mono{to}\; x:A.N &
\end{flalign*}


\emph{Handler Terms} $H,\ldots$:
\begin{flalign*}
  \quad H ::=&\; \{ op_{x:\alpha}
    (k:\beta \rightarrow \underline{C}) \mapsto
    M_{op} \}_{\mono{op:\alpha \rightarrowtriangle \beta}} &
\end{flalign*}


$\{\cdots\}_{\ell \in L}$ Set of Computations, one for each Label
$\ell \in L$

$\{\cdots\}_{op: \alpha \rightarrowtriangle \beta}$ Set of
Computations, one for each Operation Symbol $op: \alpha
\rightarrowtriangle \beta$

Value Terms involve only Constructors; corresponding Destructor Terms
are Computations

Constructor, Destructor Terms for Computation Types

For Type $F A$:
\begin{itemize}
  \item Return $\mono{return}\; V$
  \item Sequencing Construct $M \;\mono{to}\; x:A.N$
\end{itemize}

Operation Application (Computation Term):
\[
  op_V(x:\beta.M)
\]
first triggers Operation $op$ with Parameter $V$, then binds
Outcome to $x$ and Proceeds as Continuation $M$.

Handler Term:
\[
  \{ op_{x:\alpha}
    (k:\beta \rightarrow \underline{C}) \mapsto
    M_{op} \}_{\mono{op:\alpha \rightarrowtriangle \beta}}
\]
is given by a Finite Set of \emph{Handling Operation Definitions}:
\[
  op_{x:\alpha}
    (k:\beta \rightarrow \underline{C}) \mapsto
    M_{op}
\]
one for each Operation Symbol $op$

Handling Terms $M_{op}$ are dependent on their Parameters
(captured in their Parameter Values $x$) and on the Continuations of
the Handled Operations (captured in their Continuation Variables $k$)

\fist Note Continuation Variables always appear applied to a Value
$k(V)$

Handling Computation Term:
\[
  M \;\mono{handled\;with}\; H \;\mono{to}\; x:A.N
\]
Evaluates Computation $M$, Handling all Operation Application
Computations according to $H$, Binds result to $x$ and proceeds as $N$

Sequencing is a special case of Handling where $H$ Handles all
Operations ``by themselves''

Example: if $M$ triggers an Operation Application $op_V(y.M')$
and the corresponding Handling Term is $op_z(k) \mapsto
M_op \in H$, then the Operation is Handled by Evaluating
$M_op$ instead with Parameter Variable $z$ bound to $V$ and
each occurrence of a Term $k(W)$ in $M_op$ replaced by:
\[
  M'[W/y] \;\mono{handled\;with}\; H \;\mono{to}\; x:A.N
\]
and the Continuation $k$ receives an outcome $W$, determined by
$M_op$ and is Handled in the same way as $M$.

\fist Note that while Continuations are Handled by $H$, the Handling
Term $M_op$ is not; any Operations it triggers or Values it
Returns escape the Handler.

$\mono{let}$-binding abbreviation:
\[
  \mono{let}\; x:A \;\mono{be}\; V \;\mono{in}\; M
    \defeq (\lambda x:A.M)V
\]


\textbf{Typing Judgements}

\emph{Value Context}:
\[
  \Gamma = x_1:A_1, \ldots,x_m:A_m
\]
of Value Variables $x_i$ Bound to Value Types $A_i$

\emph{Continuation Context}:
\[
  K = k_1:\alpha_1 \rightarrow \underline{C}_1, \ldots,
    k_n:\alpha_n \rightarrow \underline{C}_n
\]
of Continuation Variables $k_j$ Bound to Continuation Types $\alpha_j
\rightarrow \underline{C}_j$

A Continuation Type $\alpha \rightarrow \underline{C}$ with an Arity
Signature Type $\alpha$ Types a Continuation $k$ that accepts a Value
of Type $\alpha$ and proceeds as a Computation of Type
$\underline{C}$.

Values are Typed:
\[
  \Gamma | K \vdash V:A
\]

Computations are Typed:
\[
  \Gamma | K \vdash M : \underline{C}
\]

Handlers are Typed:
\[
  \Gamma | K \vdash H : \underline{C} \;\mathbf{handler}
\]

Value Typing Rules, Computation Typing Rules, Handler Typing Rules
%FIXME

$K$ may contain more than one Continuation Variable when the Handler
being Defined is used in Handling Definitions of other Handlers

Handlers for a Subset $\Theta$ of Operation Symbols %FIXME

Handler with Identity Continuation:
\[
  M \;\mono{handled\;with}\; H
    \defeq M \;\mono{handled\;with}\; H \;\mono{to}\;
      x:A.\mono{return}\; x
\]

Binary Deconstructor (Unix Pipe, Parallel Combinator in CCS
\S\ref{sec:ccs}) %FIXME

Simple Handlers (\S\ref{sec:simple_handler})

Parameter-passing Handlers (\S\ref{sec:parameter_passing_handler})


\textbf{CCS Example}

Effect Constructors (Operations):
\begin{enumerate}
  \item Deadlock $\mono{nil} : 1 \rightarrowtriangle 0$
  \item Action Prefix $\mono{prefix} : Act \rightarrowtriangle 1$
  \item Sum $\mono{choose} : 1 \rightarrowtriangle 2$
\end{enumerate}

Effect Deconstructors (Handlers):
\begin{enumerate}
  \item Renaming $P[b/a]$
  \item Hiding $P \backslash a$
  \item Parallel $P | Q$
\end{enumerate}


\asterism


\textbf{Semantics}

Denotational Semantics (\S\ref{sec:denotational_semantics})

Cartesian-closed Category (\S\ref{sec:cartesian_closed})

First-class Functions, Finite Products and Finite Sums (Coproducts)

Free Model (\S\ref{sec:free_model}) Construction (Functor ???)

Parametric Lifting (??? Lifting Monad \S\ref{sec:lifting_monad}) of
Maps to Homomorphisms from the Free Model

Sets, $\omega$-cpos (\S\ref{sec:omega_cpo})

Lawvere Theories (\S\ref{sec:lawvere_theory})

Lawvere $\cat{V}$-theories (???)


\asterism


Template Variables $z$

\emph{Templates} $T,\ldots$:
\begin{flalign*}
  \quad T ::=& \; z(V) \;|\; \mono{match}\; V
    \;\mono{with}\; \langle x,y \rangle \mapsto T
    \;|\; \mono{match}\; V \;\mono{with}\; \{\ell(x_\ell) \mapsto
    T_\ell\}_{\ell \in L} \;|\; op_V(x:\beta.T)
\end{flalign*}
Templates describe Common Properties of Computations; they are not
Typed, but Well-formed relative to a Value Context and a Template Context

Templates are limited to Signature Values (e.g. can be Typed as
$\Gamma \vdash V:\alpha$); Typing Rules are the same as the Typing
Rules for Values with the omission of Continuation Contexts and the
Rule for Typing Thunks.

\emph{Template Context}:
\[
  Z = z_1:\alpha_1, \ldots, z_n:\alpha_n
\]
of Template Variables $z_j$ Bound to Arity Signature Types $\alpha_j$.

$z_j:\alpha_j$ represents a Computation dependent on a Value of Type
$\alpha_j$

Typing Judgements for being a Well-formed Template $\Gamma | Z \vdash
T$, given by Rules:
%FIXME


\emph{Effect Theory} $\thy{T}$ is a Finite Set of Equations:
\[
  \Gamma | Z \vdash T_1 = T_2
\]
where $T_1$ and $T_2$ are Well-formed relative to $\Gamma$ and $Z$

Effect Theories for: Exceptions, State, Read-only State,
Nondeterminism, Input/Output %FIXME

Combining Theories:
\begin{enumerate}
  \item \emph{Sum} simple Union assuming disjoint Sets of Operation
    Symbols

  \item \emph{Tensor} Commuting combinations of two Effects, e.g. two
    Independent States; given by Union again assuming disjoing Sets of
    Operation Symbols plus the Equation:
    \[
    \begin{split}
      y:\alpha,y':\alpha' | z:\beta \times \beta' \vdash
        op_y(x:\beta.op'_{y'}(x':\beta'.z(x.x'))) \\
        \quad = op'_{y'}(x':\beta'.op_y(x:\beta.z(x,x')))
    \end{split}
    \]
    for each Operation Symbol $op : \alpha \rightarrowtriangle \beta$
    from the first Theory and Operation Symbol $op' : \alpha'
    \rightarrowtriangle \beta'$ from the second Theory.
\end{enumerate}

More example Theories:
\begin{itemize}
  \item Explicit Nondeterminism
  \item CCS: Sum of Theories for Nondeterminism and Explicit
    Nondeterminism
  \item Time
  \item Destructive Exceptions (``Rollback''): Tensor Product of
    Theories for State and Exceptions
\end{itemize}


\textbf{Interpretation of an Effect Theory}

Model $\struct{M}$ for an Effect Theory $\thy{T}$

Carrier Set $|\struct{M}|$

An Operation:
\[
  op_\struct{M} : \llbracket \alpha \rrbracket \times
    |\struct{M}|^{\llbracket \beta \rrbracket} \rightarrow |\struct{M}|
\]
for each Operation Symbol $op:\alpha \rightarrowtriangle \beta$, such
that $\llbracket T_1 \rrbracket = \llbracket T_2 \rrbracket$ for all
the Equations $\Gamma | Z \vdash T_1 = T_2$ in $\thy{T}$

Homomorphism of Models $h : \struct{M}_1 \multimap \struct{M}_2$ is a
Map $h : |\struct{M}_1| \rightarrow |\struct{M}_2|$ such that:
\[
  h \circ op_{\struct{M}_1} = op_{\struct{M}_2} \circ
    (id_{\llbracket \alpha \rrbracket}
      \times h^{\llbracket \beta \rrbracket})
\]
holds for all Operation Symbols $op:\alpha \rightarrowtriangle \beta$

Category $\cat{Mod}_\thy{T}$ of Models of $\thy{T}$ and Homomorphisms
between them

Forgetful Functor $U : \cat{Mod}_\thy{T} \rightarrow \cat{Set}$ where:
\[
  \begin{split}
    U \struct{M} \defeq & |\struct{M}| \\
    U h \defeq & h
  \end{split}
\]
Left-adjoint to the Forgetful Functor is the Free-model Functor $F :
\cat{Set} \rightarrow \cat{Mod}_\thy{T}$

$F A$ Free Model over Set $A$

Homomorphism Induced by $f : A \rightarrow U \struct{M}$: Adjoint
Homomorphism $\bar{f} : F A \multimap \struct{M}$

Unit $\eta_A : A \rightarrow F A$


\textbf{Interpretation of Values and Computation Types}

given a Signature, an Effect Theory $\thy{T}$ over the Signature, and
an Interpretation of the Effect Theory

Product Models, Exponent Models (???) %FIXME

An Interpretation $\llbracket V \rrbracket$ of a Well-typed Value
$\Gamma | K \vdash V:A$ is a Map $\llbracket \Gamma \rrbracket \times
\llbracket K \rrbracket \rightarrow \llbracket A \rrbracket$

Kleene Equality $\simeq$: Equal if both sides are Defined and Equal or
both sides are Undefined %FIXME xref

\emph{Parameterized Lifting} $f^{\dagger_\struct{M}} : A
\times U F B \rightarrow U \struct{M}$ of a Map $f : A \times B
\rightarrow U \struct{M}$ given by:
\[
  f^{\dagger_\struct{M}} \defeq U \bar{f} \circ st
\]
where $\bar{f}$ is the Homomorphism Induced by $f$ and $st : A \times
U F B \rightarrow U F (A \times B)$ is the Strength
(\S\ref{sec:strong_monad}) of Monad $U F$.


\emph{Interpretation of Handlers}

Handler Correctness: for an Empty Effect Theory, any Handler is
Correct, but in general Correctness is Undecidable

Correctness of Simple Handlers (\S\ref{sec:simple_handler}) is
$\Pi_2$-complete %FIXME xref


\asterism


Equivalence of Computations

Weak Equality Judgement $\bumpeq$

Definedness Judgement $\downarrow$

Template Substitution

Capture-avoiding Substitution

Inheritance Rule

Equations for the Handling Construct state the Universal properties of
the Induced Homomorphism:
\begin{enumerate}
  \item Extends the Inducing Map on Values
  \item acts Homomorphically on Operations
\end{enumerate}

Rule for showing Handler Correctness: %FIXME
states that a Handler is Correct when its Operation Definitions
respect the Equations of the Effect Theory

\emph{Simple Handler} (\S\ref{sec:simple_handler})

\emph{Parameter-passing Handler}
(\S\ref{sec:parameter_passing_handler})

\emph{Simple Signature}: no Base Types or Function Symbols, Implies a
Unique (Trivial) Interpretation

Simple Signatures and Theories are equivalent to ones with all
Operation Symbols are $n$-ary for some $n$

Simple Signatures: Exceptions over a Finite Set, Read-only State,
Input/Output, and Nondeterminism

\emph{Uniformly Simple} Family of Handlers: Exception Handler,
Temporary-state Handler, Stream Redirection Handler

A Family of Handlers is Correct if each Handler in the Family is
Correct

Deciding whether a Uniformly Simple Family of Closed Handlers is
$\Sigma_1$-complete (Semidecidable) %FIXME xref

Effect Theories with a Simple Signature corresond to ordinary Finite
Equational Theories (i.e. Finitely many Finitary Function Symbols and
Finitely many Axioms)

For a Simple Signature, Decidable Effect Theory, and a Uniformly
Simple Family of Handlers, Correctness of the Family of Handlers is
Decidable


\textbf{Recursion}

Nondeterminism Operator:
\[
  \Omega : 1 \rightarrowtriangle 0
\]

Fixed-point Constructor $\rec\; x : U \underline{C}.M$, Typed
by:
\[
  \frac{\Gamma,x:U \underline{C} | K \vdash M : \underline{C}}
  {\Gamma | K \vdash \rec\; x : U \underline{C}.M : \underline{C}}
\]

Effect Theories become \emph{Inequations} $\Gamma | Z \vdash T_1 \leq
T_2$

always contains the Inequation:
\[
  \cdot | z:1 \vdash \Omega() \leq z
\]
stating that $\Omega$ is the Least Element

$\omega\cat{Cpo}$ Category of $\omega$-cpos and Continuous Functions
(instead of $\cat{Set}$)

Flat $\omega$-cpo

$U : \cat{Mod}_\thy{T} \rightarrow \omega \cat{Cpo}$

$F : \omega\cat{Cpo} \rightarrow \cat{Mod}_\thy{T}$

both $U$ and $F$ have Continuous Strengths and are Locally Continuous

Carriers of Models are Pointed $\omega$-cpos and Model Homomorphisms
are Strict Continuous Functions (Preserving Least Elements)

\emph{Lifting} $Q_\bot$ is the $\omega$-cpo obtained from $Q$ by
adding a new Least Element %FIXME xref?

Nondeterminism: Convex Powerdomain Monad (???)

Continuously Parameterised Countably Infinitary Inequational Theories:
equivalent to Discrete Countable Lawvere $\omega\cat{Cpo}$-theories

Value Types: Interpreted by $\omega$-cpos

Computation Types: Interpreted by Models whose Carriers are Pointed
$\omega$-cpos

Values, Computations, and Handlers are Interpreted by Continuous Maps
(such Interpretations may not be defined)

Fixed-point Constructor is Interpreted using the Least Fixed-point
Interpretation %FIXME

Correct Handlers cannot redefine $\Omega$ as the Theory of $\Omega$
fixes it Uniquely

Open question: Parallel Computations (Binary Deconstructors)



\cite{pretnar15}:

Occurence of an Effect can been seen as a Branching in the Execution
of a Program (number of Branches equal to the number of possible
outcomes of an Effect)

``Source'' of an Effect is represented by an Operation with Arity
equal to the number of outcomes and Arguments represent Branches


\textbf{Language}

\cite{pretnar15}:

\emph{Values}:
\begin{flalign*}
  \quad v ::=&\; x \; | \; \true \; | \; \false \;
            | \; \lambda x \mapsto c &\\
      \; |&\; \mono{handler}\; \{ \mono{return}\; x
              \mapsto c_r, \mono{op}_1(x;k) \mapsto c_1, \ldots,
              \mono{op}_n(x;k) \mapsto c_n \}&
\end{flalign*}

\emph{Computations}:
\begin{flalign*}
  \quad c ::=&\; \mono{return}\; v \; | \; \mono{op}(v;y.c) \;
            | \; \mono{do}\; x \leftarrow c_1 \;\mono{in}\; c_2 &\\
      \; |&\; \mono{if}\; v \;\mono{then}\; c_1
              \;\mono{else}\; c_2 \;
            | \; v_1 v_2 \; | \; \;\mono{with}\; v
              \;\mono{handle}\; c&
\end{flalign*}

Sequencing:
\[
  \mono{do}\; x \leftarrow c_1 \;\mono{in}\; c_2
\]
first Evaluate $c_1$, Bind result Value to $x$, and proceed as $c_2$;
if $x$ does not appear in $c_2$, then abbreviate to $c1; c2$.

Operation Call:
\[
  \mono{op}(v;y.c)
\]
Parameter Value $v$ (e.g. Memory Location to be Read) passed to
$\mono{op}$, $\mono{op}$ performs Effect, Result Value (e.g.
Contents of Memory Location) is Bound to $y$ and Evaluation of
Continuation $c$ resumes. (Handlers \S\ref{sec:effect_handler}) may
override this behavior).

Generic Effect (\S\ref{sec:generic_effect}):
\[
  \mono{op}\; \defeq \;\mono{fun}\; x \mapsto
    \mono{op}(x; y.\mono{return}\; y)
\]
Parameter Value $x$ passed to Operation with the Trivial Continuation;
specific Operations $\mono{op}(v;y.c)$ can be recovered by
Evaluating:
\[
  \mono{do}\; y \leftarrow \mono{op}\; v \;\mono{in}\; c
\]


\textbf{Denotational Semantics} \cite{pretnar15}

Computations as Trees:

Returned Values (or Bottom $\bot$ for Divergent Computation that does
not call any Operations) are Leaves and Branching Points are
Operations

Operation Calls create a ``Branching Point'' in the Evaluation with as
many Branches as there are possible Results that can be Yielded to the
Continuation. \cite{pretnar15}

A Divergent Computation that repeatedly Calls Operations gives a
Non-well-founded Tree. \cite{pretnar15}


\emph{Denotational Semantics Returning First-order Values and no
  Recursion}:

Value Type $A$: Set $\llbracket A \rrbracket$

Computation Type $\llbracket A!\Delta \rrbracket$: Set of Trees with
Leaves (Values) in $\llbracket A \rrbracket$ and Nodes (Operations) in
$\Delta$

Handlers: Functions between Trees defined by Structural Recursion on
Tree of the Handled Computation and Handling is Interpreted by
Application of such Functions

A \emph{Model} of $\Delta$ is a Set $M$ with Maps:
\[
  \mono{op}_M : \llbracket A \rrbracket
    \times M^{\llbracket B \rrbracket} \rightarrow M
\]
for each Operation $\mono{op} : A \rightarrow B$ in $\Delta$

\emph{Homomorphism} between Models $M$, $N$ is a Map $h : M
\rightarrow N$ such that:
\[
  (h \circ \mono{op}_M)(x,k) = \mono{op}_N(x,h \circ k)
\]

$\llbracket A ! \Delta \rrbracket$ is the \emph{Free Model}
(\S\ref{sec:free_model}) of $\Delta$ over $A$ with Universal Property
(\S\ref{sec:universal_property}):

For any Model $M$ of $\Delta$ and Map $f : \llbracket A \rrbracket
\rightarrow M$ there exists a Unique Homomorphism $h : \llbracket A !
\Delta \rrbracket \rightarrow M$ that agrees with $f$ on Leaves.
\cite{pretnar15}

Operation Clauses define a Model of Operations and the Return Clause
provides a Function $f$ that can be extended to a Homomorphism.
\cite{pretnar15}

\fist With General Recursion and Higher-order Results then
Domains (\S\ref{sec:order_domain}) are used instead of Sets.

Comodel: Set $W$ of possible World States and Map $\mono{op}^W : W
\times \llbracket A \rrbracket \rightarrow W \times \llbracket B
\rrbracket$ for each Operation $\mono{op} : A \rightarrow B$ in
$\Sigma$

when Operation Call $\mono{op}(v; y.c)$ escapes all Handlers, pass
current State $w \in W$ and Parameter $v$ to $\mono{op}^W$ and get
back new State and Result, assigning Result to $y$ and continue
Evaluating $c$. \cite{pretnar15}


\textbf{Operational Semantics} \cite{pretnar15}

Small-step Operational Semantics

Operation Calls do not perform Effects: they behave as ``Signals''
that propagate outwards until they reach a Handler with a matching
Clause. \cite{pretnar15}

An Operation that escapes all Handlers is treated as a Terminating
Computation (no further Reductions). \cite{pretnar15}

``Actual'' Effectful behavior simulated by an Outermost Handler.
\cite{pretnar15}



\subsubsection{Effect Theory}\label{sec:effect_theory}
\cite{plotkin-pretnar09}

$\thy{E}$

Conditional Effect Theory: collection of Conditional Equations:
\[
  \Gamma; \Delta \vdash T_1 = T_2(\varphi)
\]
given that $\Gamma; \Delta \vdash T_1$, $\Gamma; \Delta \vdash T_2$,
and $\Gamma \vdash \varphi : \mathbf{form}$

An Effect Theory $\thy{E}$ gives rise to a standard (possibly
Infinitary) Equational Theory (\S\ref{sec:equational_theory}).
\cite{plotkin-pretnar09}



\subsubsection{Effect Handler}\label{sec:effect_handler}

\cite{orchard-yoshida16}: Processes as Effect Handlers, Session Types
(\S\ref{sec:session_type}) as Effects

Homomorphism from Free Algebras
\cite{bauer-pretnar12}

\cite{plotkin-pretnar13}:

Homomorphisms from the Free Model to a Model on a given Carrier

Model of an Equational Theory: Carrier Set, Set of Handling Maps (one
for each Operation) Satisfying Equations

Computations Interpreted in the Free Model

Handling Constructs Interpreted by Induced Homomorphisms

Operations replaced by Operation Maps

\fist Cf. Exception Handlers (\S\ref{sec:exception_effect}) where
Exceptions are replaced by Handling Computations

\danger\; Note that all Families of Maps yield a Model of the Theory,
for some Families it is Undecidable given their Definitions whether
they yield a Model or not; if allowing complete freedom in the
Language (all possible Definitions allowed), not all Handlers will
have Interpretations


\asterism


An Algebraic Effect Handler that is Linear in its Continuation gives
rise to the notion of Linear Control-flow Effects
\cite{orchard-yoshida16}. Non-linear Effects such as Exceptions
(Interrupted Control-flow) and Non-determinism (Branching
Control-flow) may be captured via Session-typed
(\S\ref{sec:session_type}) Encodings that explicitly include their
Continuation. \cite{orchard-yoshida16} %FIXME



\cite{plotkin-pretnar09}:

Handling corresponds to Model of the Algebraic Theory
(\S\ref{sec:algebraic_theory}) of the Effects

Handling a Computational Effect: Homomorphically Mapping the Handled
Computation into another Computation

Well-formed-ness, Correctness (redefinition of Operations yields a
Model of the Effect Theory)

\cite{plotkin-pretnar09}:

Type Variables $X$

Value Types $\sigma$

Handler Variables $z$

Value Terms $u$

Quantifier-free Formulas $\varphi$

\emph{Handler Types}:
\begin{flalign*}
  \quad \chi &::= X \; | \; F \sigma \; | \; 1 \;
    | \; \chi_1 \times \chi_2 \; | \; \sigma \rightarrow \chi &
\end{flalign*}

\emph{Handler Terms}:
\begin{flalign*}
  \quad h ::=& \; z(v_1, v_2, \ldots) \;
    | \; \mono{op}_{v_1, v_2, \ldots}
      (X_1:A_1.h_1, X_2:A_2.h_2, \ldots) & \\
    |&\; \mono{if}\; \varphi \;\mono{then}\; h_1
      \;\mono{else}\; h_2 \; | \; \mono{return}\; u \;
    | \; \mono{let}\; x \;\mono{be}\; h \;\mono{in}\; h' & \\
    |&\; \star \;
    | \; \langle h_1, h_2 \rangle \; | \; \mono{fst}\; h \;
    | \; \mono{snd}\; h \; | \; \lambda x:\sigma.h \;
    | \; h u &
\end{flalign*}

Typing Handler Terms:
\begin{itemize}
  \item Context $\Gamma$ of Value Types
  \item Context $Z$ of Handler Variables $z : (\alpha_1, \alpha_2,
    \ldots) \rightarrow \chi$ (written $z:\chi$ if the List of Arity
    Types is Empty), according to rules:
    \begin{enumerate}
      \item $(z:(\alpha_1, \alpha_2, \ldots) \rightarrow \chi \in Z)$
        %FIXME
      \item $(\mono{op}:\beta_1, \ldots, \beta_m; A_1, \ldots, A_n \in
        \Sigma_\mathrm{eff})$
        %FIXME
      \item %FIXME
      \item %FIXME
    \end{enumerate}
\end{itemize}

Handler Signature $\Sigma_\mathrm{hand}$: Set of Handler Symbols $H$

a Handler:
\[
  H : (\sigma_1, \sigma_2, \ldots; \chi_1, \chi_2, \ldots)
    \rightarrow \chi \mathbf{handler} \in \Sigma_\mathrm{hand}
\]

Computation Types

Computation Terms

Typing Computation Terms

Typing Handling Constructs

Uniform Handler, Parametrically Uniform Handler
\cite{plotkin-pretnar09}


\cite{pretnar15}:
\[
  \mono{handler}\; \{ \mono{return}\; x
          \mapsto c_r, \mono{op}_1(x;k) \mapsto c_1, \ldots,
          \mono{op}_n(x;k) \mapsto c_n \}
\]


\asterism


Timeout Handler



\paragraph{Shallow Handler}\label{sec:shallow_handler}\hfill

only Handle the first call of an Operation

more ``elementary'': can be used to simulate Deep Handler through
Recursion \cite{pretnar15}



\paragraph{Deep Handler}\label{sec:deep_handler}\hfill

continue Handling Operations in the Continuation
(\S\ref{sec:continuation})



\paragraph{Simple Handler}\label{sec:simple_handler}\hfill
\cite{plotkin-pretnar13}

Simple Handlers define Handling Computations in terms of Polymorphic
Constructs only.

Examples: Exception Handler, Temporary-state Handler, Stream
Redirection Handler, CCS Renaming and Hiding Handlers, etc.

No Parameter-passing Handlers
(\S\ref{sec:parameter_passing_handler})are Simple

\emph{Uniformly Simple} Family of Handlers



\paragraph{Parameter-passing Handler}\hfill
\label{sec:parameter_passing_handler}
\cite{plotkin-pretnar13}

contains $\lambda$-abstraction in the Handling Terms



\subsubsection{Generic Effect}\label{sec:generic_effect}

\cite{pretnar15}:
\[
  \mono{op}\; \stackrel{\mathrm{def}}{=} \;\mono{fun} x \mapsto
  \;\mono{op}(x; y.\mono{return}\; y)
\]
Parameter $x$ passed to Operation with the Trivial Continuation



\subsubsection{Extensible Effect}\label{sec:extensible_effect}

van Laarhoven Free Monad (\S\ref{sec:vanlaarhoven_free_monad})



% ====================================================================
\section{Coeffect System}\label{sec:coeffect_system}
% ====================================================================

Context-dependent Computation (Petricek, Orchard, Mycroft)

Effect: how a Program \emph{Influences} its Environment

Coeffect: \emph{Requirement} of a Program with respect to its
Environment

(ICFP video):

Types in Contexts paired with a Coeffect:
$x : T_r A \vdash M : B$

$r$ Element of a Coeffect Preordered Semiring (???) %FIXME

Interaction

(Graded case):

$i : \text{Coeffect} \times \text{Effect} \rightarrow \text{Coeffect}$

$k : \text{Coeffect} \times \text{Effect} \rightarrow \text{Effect}$

Zappa-Szep Product (\S\ref{sec:zappa_szep})



% --------------------------------------------------------------------
\subsection{Coeffect}\label{sec:coeffect}
% --------------------------------------------------------------------

Implicit Parameters in a Programming Language like Haskell is a
Coeffect System (Orchard-Petricek14)

$\mono{codo}$ Notation



% ====================================================================
\section{Curry-Howard Correspondence}\label{sec:curry_howard}
% ====================================================================

\emph{Curry-Howard Correspondence}

Type Theory, Proof Theory, Algebra (Preorders: $\leq$ is a Reflexive
and Transitive Relation), Category Theory

Syntactic Category (\S\ref{sec:syntactic_category}) %FIXME

``Computational Trinitarianism''
\\
\begin{tabular}{| l | l | l |}
\hline
\textbf{Logic} & \textbf{Type Theory} & \textbf{Category Theory}\\ \hline \hline
Proposition & $A$ (Type) & $A \in \cat{C}_0$ \\ \hline
Proof & $a : A$ (Term) & $a:U \rightarrow A \in \cat{C}_1$ \\
\hline
\end{tabular}
\\
\cite{harper12}
\\
\begin{tabular}{| p{2cm} | p{3cm} | p{4.5cm} | p{3cm} |}
\hline
& \textbf{Logic} & \textbf{Type} & \textbf{Algebra}\\ \hline \hline
Trivial Proposition
  & \begin{center} $\overline{A \vdash \top}$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $\overline{A \leq \top}$ \end{center} \\ \hline
Bottom
  & \begin{center} $\overline{\bot \vdash A}$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $\overline{\bot \leq A}$ \end{center} \\ \hline
Reflexivity
  & \begin{center} $A \vdash A$ \end{center}
  & \begin{center} $x : A \vdash x : A$ \end{center}
  & \begin{center} $A \leq A$ \end{center} \\ \hline
Negation Elimination
  & \begin{center} $\neg A \vdash A \rightarrow \bot$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} $A \wedge \neg A = \bot$ \end{center} \\ \hline
Negation Introduction
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\underline{C \wedge A \leq \bot}$\newline
      $C \leq \overline{A}$
    \end{center} \\ \hline
Elimination Rules
  & \begin{center}
      $\overline{A \wedge B \vdash A}$,\newline\newline
      $\overline{A \wedge B \vdash B}$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\overline{A \wedge B \leq A}$,\newline\newline
      $\overline{A \wedge B \leq B}$
    \end{center} \\ \hline
Introduction Rules
  & \begin{center}
      $\overline{A \vdash A \vee B}$,\newline\newline
      $\overline{B \vdash A \vee B}$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center}
      $\overline{A \leq A \vee B}$,\newline\newline
      $\overline{B \leq A \vee B}$
    \end{center} \\ \hline
Conjunction
  & \begin{center}
    $\underline{C \vdash A \quad C \vdash B}$\newline
    $C \vdash A \wedge B$
    \end{center}
  & \begin{center}
    $\underline{x:C \vdash m:A \quad x:C \vdash n:B}$\newline
    $x:C \vdash (m,n):A \times B$
    \end{center}
  & \begin{center}
    $\underline{C \leq A \quad C \leq B}$\newline
    $C \leq A \wedge B$
    \end{center} \\ \hline
Disjunction
  & \begin{center}
    $\underline{A \vdash C \quad B \vdash C}$\newline
    $A \vee B \vdash C$
    \end{center}
  & \begin{center}
    ???
    \end{center}
  & \begin{center}
    $\underline{A \leq C \quad B \leq C}$\newline
    $A \vee B \leq C$
    \end{center} \\ \hline
Transitivity
  & \begin{center}
      $\underline{A \vdash B \quad B \vdash C}$\newline
      $A \vdash C$
    \end{center}
  & \begin{center}
    $\underline{x:A \vdash m:B \quad y:B \vdash n:C}$\newline
    $x:A \vdash [m/y]n:C$
    \end{center}
  & \begin{center}
    $\underline{A \leq B \quad B \leq C}$\newline
    $A \leq C$
    \end{center} \\ \hline
\hline
\end{tabular}
\\
\begin{tabular}{| p{2cm} | p{3cm} | p{4.5cm} | p{3cm} |}
\hline
& \textbf{Logic} & \textbf{Type} & \textbf{Algebra}\\ \hline \hline
Implication Elimination
  & \begin{center} $A, (A \rightarrow B) \vdash B$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Implication Introduction
  & \begin{center}
      $\underline{A \wedge C \vdash B}$\newline
      $C \vdash A \rightarrow B$
    \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Weakening
  & \begin{center} $\frac{\Gamma \vdash \Sigma}
    {\Gamma,A \vdash \Sigma}$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Contraction
  & \begin{center} $\frac{\Gamma,A,A \vdash \Sigma}
    {\Gamma,A \vdash \Sigma}$ \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
Exchange
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center}
  & \begin{center} ??? \end{center} \\ \hline
\hline
\end{tabular}

Proofs and Propositions form the Object Language; Derivations are used
to infer Judgements about the Object Language


\asterism


$P\type$ -- $P\prop$

$p : P$ -- ``$p$ is a Proof of Proposition $P$''

A Proof of $A \wedge B$ is a Pair of Proofs $p : A$ and $q : B$ (holds
in both Classical and Constructive Systems)

A Proof of $A \vee B$ is a Proof $p : A$ or a Proof $q : B$ with an
indication of which Formula is Proved (differs from Classical Logic)

A Proof of $A \Rightarrow B$ is a Function that Transforms a Proof $p
: A$ into a Proof $q : B$.

No Proof for the Contradictory Proposition $\bot$

$(\exists x : A).P$ where $P$ is a Witness (\S\ref{sec:type_witness})
$w : A$ with a Proof that $P$ holds of $w$, i.e. $[w/x]P$

$(\forall x : A).P$ implies that $[a/x]P$ is Valid for every $a$ in
$A$; a Function mapping any Proof of $A$ to a Proof of $P$.

Introduction Rule for $\forall$:
\[
  {
    \frac{
      \begin{matrix}
        [x : A]\\
        \vdots\\
        p : P
      \end{matrix}
    }{
      (\lambda x : A).p : (\forall x : A).P
    }
  } (\forall I)
\]

Computation Rule for $\forall$:
\[
  ((\lambda x : A).p) \rightarrow [a/x]p
\]

Introduction Rule for $\exists$:
\[
  {
    \frac{
      a : A \quad\quad p : [a/x]P
    }{
      (a,p) : (\exists x : A).P
    }
  } (\exists I)
\]

Computation Rules for $\exists$:
\[
  fst (p,q) \rightarrow p
\]\[
  snd (p,q) \rightarrow q
\]

The Formation Rule for Equality Types (\S\ref{sec:equality_type})
requires other Judgements (Type Assumptions) in addition to
Well-typing Judgements:
\[
  {
    \frac{ A \mathsf{ Type} \quad\quad a : A \quad\quad b:A }
    { I (A,a,b) \mathsf{ Type}}
  } (I F)
\]

Introduction Rule for $I$:
\[
  {
    \frac{ a : A }
    { r(a) : I(A,a,a)}
  } (II)
\]

Elimination Rule for $I$:
\[
  {
    \frac{ c : I (A, a, b) \quad\quad d : C(a,a,r(a)) }
    { J(c,d) : C(a,b,c) }
  } (I E)
\]

Computation Rule for $I$:
\[
  J (r(a), d) \rightarrow d
\]

Leibniz Law


\asterism


Formation Rules : Defines what the Types of the System are (Syntax)

Introduction \& Elimination Rules : Define which Terms are Members of
which Types; Typing Rules (\S\ref{sec:typing_rule})

Computation Rules : How Objects can be Reduced, i.e. Evaluated
(Computation)

Natural Deduction -- Typed $\lambda$-calculus
(\S\ref{sec:typed_lambda})

(Zeroth-order) Minimal Logic -- Simple Types (Simply-typed
$\lambda$-calculus \S\ref{sec:simply_typed})

(First-order) Predicate Logic -- Dependent Types (Dependent Type
Theory \S\ref{sec:dependent_type_theory})

Classical/Intuitionistic Embedding -- Continuation-passing Style
(\S\ref{sec:continuation})

Modal Logic -- Monads (\S\ref{sec:monad})

Linear Logic -- Session Types (\S\ref{sec:session_type})

Linear Temporal Logic -- Reactive Types (\S\ref{sec:reactive_type})

Subset Type $(\exists x:A).B$ (Pairs of Objects and the Proofs that
they have Property): $\{ x : A | B \}$ consisting of those $a$ in $A$
with Property $[a/x]B$, i.e. $[a/x]B$ is Inhabited.

Epistemic Modal Logic -- ``Distributed Programming''



% ====================================================================
\section{Lambda Cube}\label{sec:lambda_cube}
% ====================================================================

All Strongly Normalizing

$\lambda\kern-5pt\rightarrow$: Simply-typed $\lambda$-calculus
(\S\ref{sec:simply_typed}); Terms depending on Terms (Function Type
\S\ref{sec:function_type})--Types can appear on both sides of the
Function Constructor $\rightarrow$:
\[
  f:A \rightarrow B
\]
or:
\[
  f:(\Pi a:A)B
\]

$\lambda2$: Polymorphic (Second-order) $\lambda$-calculus
(\S\ref{sec:secondorder_lambda}, System F (\S\ref{sec:system_f});
Terms depending on Types (Polymorphism
\S\ref{sec:polymorphic_type})--Kinds appear to the left of Types as
Parameters mapping to instances of Polymorphic Functions (Terms):
\[
  f:(\Pi A:\Type) C
\]
where:
\[
  f_A : C
\]
is the Instance of $f$ for Type $A$.

$\lambda\underline{\omega}$: Higher-order $\lambda$-calculus
(\S\ref{sec:higherorder_lambda}); Types depending on Types (Type
Operators \S\ref{sec:type_operator})--Kinds (\S\ref{sec:kind}) can
appear on both sides of the Type-level Function Constructor
$\Rightarrow$:
\[
   F:\Type \Rightarrow \Type
\]
or:
\[
  F:(\Pi A:\Type) \Type
\]

$\lambda\Pi$: Dependently-typed $\lambda$-calculus
(\S\ref{sec:dependent_lambda}); Types depending on Terms (Dependent
Types \S\ref{sec:dependent_type})--Kinds can appear to the right of
Types in Dependent Types $a:A \vdash B(a)$:
\[
  B : A \rightarrow \Type
\]
or equivalently a Polymorphic Function:
\[
  B : (\Pi X:\Type) X \rightarrow A
\]
or:
\[
  B : (\Pi X:\Type) (\Pi x:X) A
\]
allowing the definition of Dependent Product Types
(\S\ref{sec:pi_type}) and Dependent Sum Types
(\S\ref{sec:sigma_type}):
\[
  f : (\Pi a:A) B(a) \quad\quad (a,b) : (\Sigma a:A) B(a)
\]
where $a:A$, $b:B(a)$, $(f x):B(a)$

\[
  f : (\Pi a:A) (\Pi X:\Type) (\Pi x:X) A
\]

$\lambda\omega$ -- System F$_\omega$ (\S\ref{sec:system_fomega}): $\lambda2$

\fist The Systems in the $\lambda$ Cube are limited to Sorts
$\{\star,\square\}$, i.e. Kinds and the Kind of Kinds; Pure Type
Systems (\S\ref{sec:pts}) for Multi-sorted Type Systems %FIXME



% ====================================================================
\section{Typed $\lambda$-calculus}\label{sec:typed_lambda}
% ====================================================================

\emph{Typed $\lambda$-Calculus} allows for Lambda Terms to be assigned
Types (\S\ref{sec:type}).

Simply-typed $\lambda$-calculus (\S\ref{sec:simply_typed}) has only
one Type Constructor (\S\ref{sec:type_constructor}), $\rightarrow$
(see Function Type \S\ref{sec:function_type}).

Untyped $\lambda$-calculus (\S\ref{sec:untyped_lambda}) may be
considered a Typed $\lambda$-calculus with only one Type.

Extension to Untyped $\lambda$-calculus may be achieved by
considering Recursive Types with Recursion in Negative Positions;
Untyped $\lambda$-calculus can be Modelled by a Solution to the
Recursion Equation $X \simeq X \rightarrow X$. \cite{wadler12}

\fist Multi-threaded $\lambda$-calculus (\S\ref{sec:mtlc})

A Denotational Semantics for Typed $\lambda$-calculus can be given by a
\emph{B\"ohm Tree} (\S\ref{sec:bohm_tree}).

$\lambda$-cube (\S\ref{sec:lambda_cube}):
\begin{itemize}
  \item $\lambda\kern-5pt\rightarrow$ -- Simply-typed
    $\lambda$-calculus (\S\ref{sec:simply_typed}); Function Types
    (\S\ref{sec:function_type})
  \item $\lambda2$ -- Second-order $\lambda$-calculus
    (\S\ref{sec:secondorder_lambda}); Polymorphic Types
    (\S\ref{sec:polymorphic_type})
  \item $\lambda\underline{\omega}$ -- Higher-order $\lambda$-calculus
    (\S\ref{sec:higherorder_lambda}); Type Operators
    (\S\ref{sec:type_operator})
  \item $\lambda\Pi$ -- Dependently-typed $\lambda$-calculus
    (\S\ref{sec:dependent_lambda}); Dependent Types
    (\S\ref{sec:dependent_type})
\end{itemize}

Linear $\lambda$-calculus (\S\ref{sec:linear_lambda})



% --------------------------------------------------------------------
\subsection{$\kappa$-calculus}\label{sec:kappa_calculus}
% --------------------------------------------------------------------

First-order fragment of Typed $\lambda$-calculus



% --------------------------------------------------------------------
\subsection{Simply-typed $\lambda$-calculus}\label{sec:simply_typed}
% --------------------------------------------------------------------

\emph{Simply-typed $\lambda$-calculus} ($\lambda^\rightarrow$) is a
Typed Interpretation of $\lambda$-calculus with one Type Constructor
(\S\ref{sec:type_constructor}) for Function Types
(\S\ref{sec:function_type}): $\rightarrow$

Strongly Normalizing, not Turing Complete: addition of $fix_\alpha$
Operator or Recursive Types (\S\ref{sec:inductive_type}) gives
Turing Completeness

``Simply-typed'' is to distinguish from $\lambda$-cube
(\S\ref{sec:lambda_cube}) Extensions and other variations such as:
\begin{itemize}
  \item Polymorphic Types (\S\ref{sec:polymorphic_type}): Second-order
    $\lambda$-calculus ($\lambda2$ \S\ref{sec:secondorder_lambda})
  \item Type Operators (\S\ref{sec:type_operator}):
    ($\lambda\underline{\omega}$ \S\ref{sec:higherorder_lambda})
  \item Dependent Types (\S\ref{sec:dependent_type}):
    Dependently-typed $\lambda$-calculus ($\lambda\Pi$
    \S\ref{sec:dependent_lambda})
  \item Conjunctive Types (\S\ref{sec:conjunctive_type}):
    $\lambda$-calculus with Conjunctive Types
    (\S\ref{sec:conjunctive_lambda})
  \item Linear Types (\S\ref{sec:linear_type}): Linear
    $\lambda$-calculus (\S\ref{sec:linear_lambda})
\end{itemize}
because Polymorphism and Dependency cannot be encoding using only
$\rightarrow$ and Type Variables (\S\ref{sec:type_variable}). Adding
Record Types (\S\ref{sec:product_type}) to Simply-typed
$\lambda$-calculus allows for Subtyping
(\S\ref{sec:subtype_polymorphism}), and the resulting System
(\S\ref{sec:conjunctive_lambda}) is no longer ``Simply-typed'' because
it allows for Terms to have more than one Type.

Dominic Orchard (youtube) -- Simple Types: ``What'', Effect Systems
(\S\ref{sec:effect_system}): ``How'', Session Types
(\S\ref{sec:session_type}): ``What \& How''

\fist An Embedding of Simply-typed $\lambda$-calculus into
Session-typed $\pi$-calculus (\S\ref{sec:sessiontyped_pi}) is given in
Toninho-Caires-Pfenning12 \cite{caires-pfenning-toninho12}; for the
analogous Embedding of Untyped $\lambda$-calculus
(\S\ref{sec:untyped_lambda}) into $\pi$-calculus see Milner92
\cite{milner92}

The following extensions are still considered ``Simply-typed''
systems:
\begin{itemize}
  \item System T (\S\ref{sec:system_t}): Products, Coproducts, Natural
    Numbers
  \item PCF (\S\ref{sec:pcf}): Full Recursion
\end{itemize}

Types are Equivalent in Simply-typed $\lambda$-calculus if and only if
they are \emph{Syntactically Equivalent}; Types are Equivalent in
Second-order Polymorphic $\lambda$-calculus
(\S\ref{sec:secondorder_lambda}) if and only if they are
\emph{$\alpha$-equivalent}; Types are Equivalent in Higher-order
Polymorphic $\lambda$-calculus (\S\ref{sec:higherorder_lambda}) if and
only if they are \emph{$\beta\eta$-equivalent} -- (Xi16)

Simply-typed $\lambda$-calculus has the same Equational Theory of
$\beta\eta$-equivalence (\S\ref{sec:beta_reduction},
\S\ref{sec:eta_conversion}) as Untyped $\lambda$-calculus, subject to
Type restrictions.

$\beta$-reduction:
\[
  (\lambda x:s.t)u =_\beta t[x := u]
\]
holds in Context $\Gamma$ when $\Gamma$, $x:\sigma \rightarrow t:\tau$
and $\Gamma \vdash u:\sigma$.

$\eta$-reduction:
\[
  \lambda x:\sigma .t x =_\eta t
\]
holds when $\Gamma \vdash t : \sigma \rightarrow \tau$ and $x$ is not
Free in $t$.

With the Function Type Constructor $\rightarrow$ and the Base Types
$B$, the Types of a Simply-typed $\lambda$-calculus are defined (with
BNF Notation):
\[
  \tau ::= \tau \rightarrow \tau \;|\; T \in B
\]

\emph{Term Constant}

That is, Expressions of Simply-typed $\lambda$-calculus are defined
as:
\[
  e ::= x \;|\; \lambda x:t.e \;|\; e e \;|\; c
\]
where $x$ is a Variable and $\tau$ is a Type, and $c$ is a Term
Constant. These Expressions are, in order:
\begin{itemize}
  \item Variable Reference
  \item Abstraction
  \item Application
  \item Constant
\end{itemize}

Abstraction corresponds to Existential Quantification in Second-order
Logic (\S\ref{sec:secondorder_logic}).



\textbf{Intrinsic Interpretation}: \emph{Church-style}

* Only Well-typed Terms have Meaning (Meaning assigned to Typing
Derivations), therefore equivalent Terms having different Annotations
may have different Meanings, cf. Reification
(\S\ref{sec:reification}):



\textbf{Extrinsic Interpretation}: \emph{Curry-style}

* Terms Interpreted as in an Untyped Language, cf. Type Erasure
(\S\ref{sec:type_erasure})



\textbf{Typing Rules} (\S\ref{sec:typing_rule})

\begin{enumerate}
\item
  \[
    {
      \frac
      {x : \tau \in \Gamma}
      {\Gamma \vdash x : \tau}
    }
  \]
\item
  \[
    {
      \frac
      {c \;\text{is a constant of Base Type}\; T}
      {\Gamma \vdash c:T}
    }
  \]
\item
  \[
    {
      \frac
      {\Gamma, x:\sigma \vdash e:\tau}
      {\Gamma \vdash (\lambda x:\sigma.e):(\sigma \rightarrow \tau)}
    }
  \]
\item
  \[
    {
      \frac
      {\Gamma \vdash e_1:\sigma \rightarrow \tau \quad
        \Gamma \vdash e_2:\sigma}
      {\Gamma \vdash e_1 e_2 : \tau}
    }
  \]
\end{enumerate}



\textbf{Operational Semantics}

\textbf{Categorical Semantics}

Simply-typed $\lambda$-calculus is the Internal Language
(\S\ref{sec:internal_logic}) of the Cartesian-closed Categories
(\S\ref{sec:cartesian_closed}).



\textbf{Proof-theoretic Semantics}

Simply-typed $\lambda$-calculus is Isomorphic by Curry-Howard
(\S\ref{sec:curry_howard}) to Minimal Logic
(\S\ref{sec:minimal_logic}):
\begin{itemize}
  \item Terms correspond to Proofs in Natural Deduction
    (\S\ref{sec:natural_deduction})
  \item (Inhabited) Types correspond to Tautologies in Minimal Logic
\end{itemize}



Minimal Logic $\leftrightarrow$ Simply-typed $\lambda$-calculus:
\[
  \supset \leftrightarrow \rightarrow
\] \[
  \wedge \leftrightarrow \times
\] \[
  \vee \leftrightarrow +
\] \[
  False \leftrightarrow \bot
\]



\emph{Type Assignment}:
\[
  \frac{
    f:A \rightarrow B \quad x:A
  }{
    f x : B
  }(\rightarrow e)
\]\[
  \frac{
    x:A \quad y:B
  }{
    \lambda x.y : A \rightarrow B
  }(\rightarrow i)
\]



\subsubsection{System T}\label{sec:system_t}

G\"odel

Proof Interpretation of Heyting Arithmetic into a Finite-type
Extension of Primitive Recursive Arithmetic
(\S\ref{sec:primitive_recursive})

All Recursive Functions in Peano Arithmetic are definable



\subsubsection{PCF}\label{sec:pcf}

\emph{Programming Computable Functions} (\emph{PCF}) is an extended
version of Simply-typed Lambda Calculus with Natural Numbers,
Conditionals, and Recursion.

Geometry of Interaction (\S\ref{sec:interaction_geometry})

Denotational Semantics (\S\ref{sec:denotational_semantics}):
\emph{Scott Model} (???)

Scott-continuous Function (\S\ref{sec:scott_continuity})



\paragraph{FPCF}\label{sec:fpcf}\hfill

Orchard-Yoshida16 \cite{orchard-yoshida16}

\emph{Effectful PCF} (\emph{FPCF})

Call-by-value PCF with an Effect System (\S\ref{sec:effect_system})

\fist Type-and-Effect System following Nielson-Nielson99
\cite{nielson-nielson99}; distinguishes Sequential Control Flow from
Branching Control Flow (Alternation)

\fist \cite{orchard-yoshida16} presents an Embedding of FPCF into a
Session Calculus (\S\ref{sec:session_calculus}) and a reverse
Embedding of Session Calculus into FPCF.

\fist Cf. GV (\S\ref{sec:good_variation}) a Linear Functional Language
with Session Types \cite{wadler12} -- FPCF is not fundamentally
Linear, but Linearity for Sessions is implemented via an Effect
Algebra and Typing.

\textbf{Syntax}

\begin{align*}
  V &::= x \mid \lambda x.M \mid \rec(\lambda f.\lambda x.M)
    \mid C_V \\
  M,N &::= V \mid M N \mid \case\; M \;\of\; 0 \mapsto N,
    (\suc\; x) \mapsto N' \mid C
\end{align*}

$V$ -- Values

$M,N$ -- Computations

$x$ -- Variables

$C$ -- Constants: can be Instantiated to give application-specific
(possibly Effectful) Operations %FIXME instantiated

$C_V$ -- Value Constants--Subset $C_V \subset C$, including
``Pure Constructors'': %FIXME clarify pure constructors
\begin{itemize}
  \item $0$ -- Zero
  \item $\suc$ -- Successor
  \item $\unit$ -- Unit
\end{itemize}

$\case$ -- Pattern Matches on Natural Number Constructors


\textbf{Effect Algebra}

$\class{F}$ -- Set of Effects $F,G,H \in \class{F}$

$\sqsubseteq$ -- Partial Order (\S\ref{sec:partial_order}) with
Structure:
\begin{itemize}
  \item $(\class{F},\bullet,I)$ -- Monoid (\S\ref{sec:monoid}) where
    $\bullet$ corresponds to Sequential Composition and $I$ is the
    Trivial Effect for Pure Computation
  \item $(\class{F},\oplus)$ -- Commutative Semigroup
    (\S\ref{sec:commutative_semigroup}) where $\oplus$ corresponds to
    Branching with Distributivity $(F \oplus G) \bullet H = (F \bullet
    H) \oplus (G \bullet H)$
  \item $(\class{F},-^*)$ -- Closure Operation for Effect Fixed-points
    with Axioms $F^* = 1 \oplus (F^* \bullet F) = 1 \oplus (F \bullet
    F^*)$
\end{itemize}
For some Systems, $\oplus$ is the Least Upper-bound with respect to
$\sqsubseteq$. %FIXME


\textbf{Types and Effects}

Type Syntax:
\[
  \sigma,\tau ::= \sigma \xrightarrow{F} \tau \mid \Nat \mid \Unit
\]
where $F$ is the Effect Annotation for the \emph{Latent Effect} of a
Function. %FIXME latent effect

$\Gamma \vdash M:\tau,F$ -- Judgement: Term $M$ has Type $\tau$ in the
Context $\Gamma$ of Free-variable Typing Assumptions and performs
Effect $F$

Typing Rules:
\[
  \frac{}{\varnothing \vdash C : C_\tau,C_F} \mathrm{Const}
\]\[
  \frac{}{\Gamma \vdash x:\tau,I} \mathrm{Var}
\]\[
  \frac{\Gamma, x:\sigma \vdash M:\tau,F}
  {\Gamma \vdash \lambda x.M:\sigma \xrightarrow{F} \tau,I}
  \mathrm{Abs}
\]\[
  \frac{\Gamma \vdash M:\sigma \xrightarrow{H} \tau,F
    \quad\quad\quad \Gamma \vdash N:\sigma,G}
  {\Gamma \vdash M N:\tau, F \bullet G \bullet H}
  \mathrm{App}
\]\[
  \frac{\Gamma \vdash M:\Nat,F \quad\quad
    \Gamma \vdash N_1:\tau,G \quad\quad
    \Gamma,x:\Nat \vdash N_2:\tau,H}
  {\Gamma \vdash \case\; M \;\of\; 0 \mapsto N_1,
    (\suc\;x) \mapsto N_2:\tau, F \bullet(G \oplus H)}
  \mathrm{Case}
\]\[
  \frac{\Gamma \vdash M:\tau,F \quad\quad\quad F \sqsubseteq G}
  {\Gamma \vdash M:\tau,G} \mathrm{Sub}
\]\[
  \frac{\Gamma, f:\tau \xrightarrow{F} \tau, x:\tau \vdash M:\tau,F}
  {\Gamma \vdash
    \rec(\lambda f.\lambda x.M):\tau \xrightarrow{F} \tau,I}
  \mathrm{Rec}
\]

$\lett$-binding (``Syntactic sugar''):
\[
  \lett\; x = M \;\inn\; N := (\lambda x.N) M
\]
with Let Rule Typing:
\[
  \frac{\Gamma \vdash M:\sigma,F \quad\quad\quad
    \Gamma,x:\sigma \vdash N:\tau,G}
  {\Gamma \vdash \lett\; x = M \;\inn\; N:\tau, F \bullet G}
  \mathrm{Let}
\]

$\beta\eta$-equality, $\equiv$:
\[
\begin{aligned}[r c r l]
  (\beta) & \quad & (\lambda x.M) V
    & \equiv M[V/x] \\
  (\rec\beta) & \quad & \rec(\lambda f.\lambda x.M)
    & \equiv \lambda x.M[\rec(\lambda f.\lambda x.M)/f] \\
  (\case\beta1) & \quad & (\case\; 0 \;\of\; 0 \mapsto M,
    (\suc\; x) \mapsto N) & \equiv M \\
  (\case\beta2) & \quad & (\case\; (\suc\; V) \;\of\; 0 \mapsto M,
    (\suc\; x) \mapsto N) & \equiv N[V/x] \\
\end{aligned}
\]

additional $\lett$ Equations:
\[
\begin{aligned}[r c r l]
  (\lett\text{-id}) & \quad & (\lett\; x = M \;\inn\; x)
    & \equiv M \\
  (\lett\text{-assoc}) & \quad & \lett\; y =
      (\lett\; x = M \;\inn\; N) \;\inn\; N'
    & \equiv \lett\; x = M \;\in\; (\lett\; y = N \;\inn\; N')
      \quad (\text{if}\; x \notin fv(N'))\\
\end{aligned}
\]


$\eta$-equality is Type-dependent and holds only when $M$ is Pure,
i.e.:
\[
  \Gamma \vdash M \equiv (\lambda x.M x):\sigma \xrightarrow{F} \tau,I
\]


\textbf{Operational Semantics}

Paramtereized Operational Semantics

$\rightarrow$ -- Reduction Relation between Effect-specific
Configurations $\mathbb{C}$

$\mathcal{C},\mathcal{D} : M \rightarrow \mathbb{C}$ -- Maps from
Terms to Configurations

($\beta$-equality as Pure Reductions) %FIXME

Subject Reduction (\S\ref{sec:subject_reduction}):
\[
  \varnothing \vdash M:\tau,F \wedge \mathcal{C}[M]
    \rightarrow \mathcal{D}[N]
  \Rightarrow \varnothing \vdash N:\tau,G \wedge G \sqsubseteq F
\]


\textbf{Parallel Composition}

Extending the Effect Algebra of FPCF with Semigroup $(F,\diamond)$ for
Parallel Computation where $I$ (Purity) is the Unit of $\diamond$ with
Typing:
\[
  \frac{\Gamma \vdash M:\Unit,F \quad\quad\quad \Gamma \vdash N:\Unit,G}
  {\Gamma \vdash M\|N:\Unit,F \diamond G}
\]
and Equality:
\[
  M\|\Unit \equiv M \quad\quad M\|N \equiv N\|M
    \quad\quad M\|(N\|P) \equiv (M\|N)\|P
\]

completed Parallel Composition Reduces by: $\unit\|\unit
\rightarrow \unit$


\textbf{Linear Control-flow Effects}

Linearity of Control Flow: equivalent to Algebraic Effect Handler
(\S\ref{sec:effect_handler}) that is Linear in its Continuation;
Non-linear Effects such as Exceptions (Interrupted Control-flow) and
Non-determinism (Branching Control-flow) may be captured via
Session-typed (\S\ref{sec:session_type}) Encodings that explicitly
include their Continuation. %FIXME


\asterism


\textbf{Session Calculus Embedding}

Session Calculus (\S\ref{sec:session_calculus}) Embedded into FPCF
with a notion of \emph{Session Effect} (\S\ref{sec:session_effect}):
Session Types and \emph{Causal} (Non-commutative) Effects have the
same structure--both give an Ordered Analysis of the Operational
Behavior of a Program.

Effect System for Sessions is Partial: some Operations may not be
defined for all Arguments, Modelling the Program-logic Behavior of
Session Types.

Prefixing style of Session Types is replaced by Monoidal Style of
Effect Systems \newline
\fist Cf. Difference List (Prefixing) vs. normal
Concatenation of Lists. %FIXME

Branching/Selection via Alternation $\oplus$

Replication via Recursion and $-^*$


\textbf{Types}

\begin{flalign*}
  \quad\quad \tau & ::= \Nat \mid \Unit \mid [S] &
\end{flalign*}


\emph{Effect Session Types} (variant of Session Types):
\begin{flalign*}
  \quad\quad S,T & ::= ![\tau].S \mid ?[\tau].S \mid *![\tau].S \mid \End
    \mid S + S \mid \mu\alpha.S \mid \alpha \mid \tilde{\odot}S &
\end{flalign*}

$+$ -- Alternation Operator: replaces Select $\oplus$ and Branch $\&$

$\tilde{\odot}S$ -- Intermediate representation for the Session Type
of Channels being Composed via $\odot$ (Balanced Composition)

assuming Equirecursive Equations on $S$, e.g. $\mu\alpha.S =
S[\mu\alpha.S/\alpha]$


\textbf{Session Effects} (\S\ref{sec:session_effect})

$\mathbf{c,d,e,\overline{c},\overline{d},\overline{e}}
\in \class{C}$ -- Channel Values (and Dual Endpoints)

Channel Values belong to Singleton Types corresponding to the Channel
Name:
\[
  \mathbf{c} : Ch\;c
\]
provides ``simple Value Dependency''. %FIXME

$\class{F} = (\class{C} \rightarrow S) \cup \{\bot\}$ -- Maps from
Channel Names $\class{C}$ to Effect Session Types with Algebra:
\begin{itemize}
  \item $(\class{F},\bullet,\varnothing)$ -- $I = \varnothing$ is the
    Empty Mapping, $\bullet$ is Point-wise Sequential Composition of
    Effect Session Types (via $\blacklozenge$ Partial Sequential
    Operator for Session Types) where:
    \[
      \forall c:S \in F \wedge c:T \in G
        \Rightarrow c:S \blacklozenge T \in (F \bullet G)
    \]
    with additional Equations for Balancing Composition triggered by
    $\tilde{\odot}$ Types %FIXME
  \item $\oplus$:
    \[
      \Delta_1 \oplus \Delta_2 =
      \begin{cases}
        \Delta_1 \cup \Delta_2 & \;\text{if}\;
          \forall c:S \in \Delta_i
          \Rightarrow c:S \in \Delta_j \vee c \notin dom(\Delta_j) \\
        \bot & \;\text{otherwise} \\
      \end{cases}
    \]
  \item $\sqsubseteq$ -- Preorder (\S\ref{sec:preorder}) where
    $\forall\Delta,c$ and $c \notin dom(\Delta)$:
    \[\begin{aligned}
        \Delta &\sqsubseteq (\Delta,c:\End) \\
        \Delta &\sqsubseteq (\Delta,c:*![S]) \\
      \end{aligned}
      \quad\quad
      \begin{aligned}
        (\Delta,c:S) &\sqsubseteq (\Delta,c:S + T) \\
        (\Delta,c:S) &\sqsubseteq (\Delta,c:T + S) \\
    \end{aligned}\]
  \item $\diamond = \odot$ -- for Parallel Effects takes the Union of
    two Mappings if they are Balanced in their Channels, otherwise
    $\bot$ %FIXME
  \item $F^*$:
    \[
      \forall c:S \in F
        \Rightarrow c:\mu\alpha.(\End + S \blacklozenge \alpha) \in F^*
    \]
\end{itemize}

\fist $\oplus$ is not the Least Upper-bound with respect to
Subeffecting $\sqsubseteq$: defining Subeffecting as Subset Inclusion
instead of the above definition is Unsound as arbitrary Session Types
could be introduced without a corresponding implementation.


\textbf{Send, Receive, Restriction}

Operations for Sending/Receiving Values and Channels, and Restricting
Channels are added to Constants $C$ of FPCF:
\begin{align*}
  send_{c,\tau} &:
    Ch\;c \rightarrow \tau \xrightarrow{\{c:![\tau]\}} \Unit \\
  rsend_{c,d,s} &:
    Ch\;c \rightarrow
      Ch\;d \xrightarrow{\{c:*![s],d:\tilde{\odot}s\}} \Unit \\
  chSend_{c,d,s} &:
    Ch\;c \rightarrow
      Ch\;d \xrightarrow{\{c:![s],d:\tilde{\odot}s\}} \Unit \\
  recv_{c,\tau} &: Ch\;c \xrightarrow{\{c:?[\tau]\}} \tau \\
  chRecv_{c,d,s,F,\tau} &:
    Ch\;c \xrightarrow{\{c:?[s]\}}
      (Ch\;d \xrightarrow{F \bullet \{d:s\}} \tau)
    \xrightarrow{F} \tau \\
  new_{c,s,F,\tau} &:
    (Ch\;c \rightarrow Ch\;\overline{c}
      \xrightarrow{F \bullet \{c:s,\overline{c}:\overline{s}\}} \tau)
    \xrightarrow{F} \tau
\end{align*}
Each is a Family of Operations Indexed by the Types shown as Subscripts
and has Latent Effects which give the Session Environment Induced by
the Operation.

$send_{c,\tau}$, $recv_{c,\tau}$ -- correspond to Session Send/Receive
Prefixes with Effect Types describing the single Action on their
Channel

$chSend_{c,d,s}$ -- second Channel Parameter $d$ is Sent over $c$
where $d$ must be Balanced with the rest of the Environment when
Composing (due to the $\tilde{\odot}$ Operator)

$rsend_{c,d,s}$ -- identical to $chSend$ but with the
$*!$ Session Type

$chRecv_{c,d,s,F,\tau}$ -- Higher-order Operation taking a Channel $c$
over which a Session Type $s$ is Received and passed to the Parameter
Function which Maps a Channel $d$ to a Value $\tau$ with the Effect $F
\bullet \{d:s\}$ and from this a Computation is Returned with $F$
Channels where $d,c \notin F$; important for the Typability of
Replicated Input

$new_{c,s,F,\tau}$ -- Higher-order Operation where the resulting
Effect is the Effect of the Paramter Function but with the Session
Types $c:s$, $\overline{c}:\overline{s}$ deleted from the Environment
(they are in Scope only for the Parameter Function) %FIXME clarify


\textbf{Operational Semantics}

$\langle M,s \rangle$ -- Configuration

$M$ -- Term

$s$ -- Store, Mapping Channel Endpoint Names $\class{C}$ to
(Unbounded) Queues of Values

$enq$, $deq$ %FIXME


allows Asynchronous Communication

Stable Reduction Relation, Synchronous Subset

Extension of $\equiv$ with $\eta$-expansion for $new$ over Pure Values
%FIXME


\textbf{Encoding Types}

For $\Gamma;\Delta \vdash P$:
\[
  \exists M.\llbracket \Gamma;\Delta \vdash P \rrbracket
    = \llbracket \Gamma \rrbracket \vdash M:\Unit,
      \llbracket \Delta \rrbracket
\]

Value Contexts are Encoded $\llbracket\Gamma\rrbracket$ with $\Unit$
and $\Nat$ Mapped to their corresponding FPCF Value Types.

Session Environments are Mapped to Effects $\class{F}$ by:
\[
  \llbracket\Delta\rrbracket
    = \llbracket c_1:S_1, \ldots, c_n:S_n \rrbracket
    = c:\llbracket S_1 \rrbracket, \ldots, c_n:\llbracket S_n \rrbracket
\]
and the following Interpretation Mapping Session Types to Effect
Session Annotations:
\[
  \begin{aligned}
    \llbracket ![\tau].S \rrbracket
      &= !\llbracket\tau\rrbracket.\llbracket S \rrbracket \\
    \llbracket ?[\tau].S \rrbracket
      &= ?\llbracket\tau\rrbracket.\llbracket S \rrbracket \\
    \llbracket\End\rrbracket &= \End
  \end{aligned}
  \quad\quad
  \begin{aligned}
    \llbracket *![\tau].S \rrbracket
      &= *!\llbracket\tau\rrbracket.\llbracket S \rrbracket \\
    \llbracket *?[\tau] \rrbracket
      &= \mu\alpha.?\llbracket\tau\rrbracket.\alpha \\
    \llbracket \mu\alpha.S \rrbracket
      &= \mu\alpha.\llbracket S \rrbracket
  \end{aligned}
\]
\begin{align*}
  \llbracket \oplus[l_1:S,l_2:T] \rrbracket
    &= ![\Nat].(\llbracket S \rrbracket + \llbracket T \rrbracket) \\
  \llbracket \&[l_1:S,l_2:T] \rrbracket
    &= ?[\Nat].(\llbracket S \rrbracket + \llbracket T \rrbracket)
\end{align*}

\fist Natural Numbers are used in the Encoding to administer
Control-flow for Branching and Selection: for Selection Type $\oplus$
corresponds to Sending a $\Nat$ to Select a Branch prior to
Alternation, and for $\&$ corresponds to Receiving a $\Nat$ then
Alternating.


\textbf{Encoding Processes}

$\llbracket\Gamma;\Delta \vdash P\rrbracket$ -- Encoding of Typed
Processes by Induction over Data Derivations

\fist Types are included only when the Encoding has a
(Non-syntactically Implied) Type-dependence; types are elided when the
Syntax has a single corresponding Typing Rule

Encoding of Linear Send and Receive into FPCF:
\begin{align*}
  \llbracket{c!\langle{V}\rangle.P}\rrbracket
    & = send\;c \llbracket{V}\rrbracket ; \llbracket{P}\rrbracket \\
  \llbracket{c?(x).P}\rrbracket
    & = \lett\; x = recv\;c \;\inn\; \llbracket{P}\rrbracket \\
  \llbracket{c?(d).P}\rrbracket
    & = \lett\; k = chRecv\; c \;\inn\;
      k\;(\lambda d.\llbracket{P}\rrbracket) \\
  \llbracket{\Delta \vdash c!\langle{d}\rangle.P}\rrbracket
    & = chSend\;c\;d ; \llbracket{P}\rrbracket
      \quad\quad (\text{if}\;c : ![S].T \in \Delta)
\end{align*}
where $M ; N$ is used for $\lett\;x = M \;\inn\; N$ when the Bound
Variable $x$ is Free in $N$ (i.e. unused, wildcard).

Encoding of Output and Replicated Output:
\begin{align*}
  \llbracket{\Delta \vdash c!\langle{d}\rangle.P}\rrbracket
    & = rsend\;c\;d ; \llbracket{P}\rrbracket \quad\quad
      (\text{if}\;c : *![S].T \in \Delta) \\
  \llbracket{*c?(d).P}\rrbracket
    & = \rec\;(\lambda f.\lambda x.\lett\;k = chRecv\;c \;\inn\;
      (k\;(\lambda d.\llbracket{P}\rrbracket)) \| f\;\unit)\;\unit
\end{align*}

\fist Note that the Syntax $c!\langle{d}\rangle.P$ uses $chSend$ when
$c$ is a Linear Send in $\Delta$, and $rsend$ if $c$ is Replicated
Output in $\Delta$.

$rsend\;c\;d ; \llbracket{P}\rrbracket$ -- Output: $rsend$ Send $d$
before Continuing with $\llbracket{P}\rrbracket$

$\rec\;(\lambda f.\lambda x.\lett\;k = chRecv\;c \;\inn\; (k\;(\lambda
d.\llbracket{P}\rrbracket)) \| f\;\unit)\;\unit$ -- Replicated Input:
repeatedly Receives a Channel on $c$ which is Bound as $d$ in the
Scope of $\llbracket{P}\rrbracket$ in Parallel (via Continuation $k$)
with the Recursive Call.

Restricted, Parallel, and Empty Proceses:
\begin{align*}
  \llbracket{P|Q}\rrbracket
    & = \llbracket{P}\rrbracket \| \llbracket{Q}\rrbracket \\
  \llbracket{\nu c.P}\rrbracket
    & = new\;(\lambda c.\lambda \overline{c}.\llbracket{P}\rrbracket) \\
  \llbracket{0}\rrbracket & = \unit
\end{align*}

Branching, Selection, Conditionals:
\[
\begin{split}
  \llbracket{c \lhd l_1.P}\rrbracket
    = send\;c\;0; \llbracket{P}\rrbracket
  \quad\quad\quad
  \llbracket{c \lhd l_2.P}\rrbracket
    = send\;c\;1; \llbracket{P}\rrbracket \\
  \begin{split}
    \llbracket{c \rhd [l_1:P,l_2:Q]}\rrbracket
      & = \lett\; x = recv\;c \;\inn\;
        (\case\; x \;\of\; 0 \mapsto \llbracket{P}\rrbracket,
        \suc\;n \mapsto \llbracket{Q}\rrbracket) \\
    \llbracket{\mono{if}\;[V=0]\;\mono{then}
        \;P\;\mono{else}\;Q}\rrbracket
      & = \case\; V \;\of\; 0 \mapsto \llbracket{P}\rrbracket,
        \suc\;n \mapsto \llbracket{Q}\rrbracket
  \end{split}
\end{split}
\]
may be generalized to any Finite Set of Labels (Isomorphic to $\Nat$).

Subeffecting %FIXME


\textbf{Value Encoding}

PCF has the same Constructors as Session Calculus (Modulo $\pred$):
\[
  \begin{split}
    \llbracket{\unit}\rrbracket = \unit \quad\quad
    \llbracket{0}\rrbracket = 0 \quad\quad
    \llbracket{v}\rrbracket = v \\
    \begin{split}
      \llbracket{\suc\;V}\rrbracket & = \suc\;\llbracket{V}\rrbracket \\
      \llbracket{\pred\;V}\rrbracket & =
        \case\;\llbracket{V}\rrbracket\;\of\;
          0 \mapsto 0, (\suc\;x) \mapsto x
    \end{split}
  \end{split}
\]
Context-preserving Embedding of Variables


\textbf{Correctness}

\emph{Top-level Contexts}

$\Rightarrow$ -- Relation of \emph{Stable Reductions} between a Term
and a Store; characterizes the equivalent of $\beta$-reductions
(\S\ref{sec:beta_reduction}) (Synchronization) in the Session
Calculus:

$(\beta\Rightarrow)$

$(\text{ch}\beta\Rightarrow)$

$(\text{new}\Rightarrow)$

$(\equiv\Rightarrow)$

$(\rightarrow)$

\textbf{Thm.} \emph{Operational Correspondence}


\textbf{Termination and Replicated Input}

Replicated Input is Encoded as a Recursive Function that becomes
Blocked once therare no more Outputs ($rsend$).

\emph{Garbage Collection Property} (???) shows this is Observationally
Equivalent to the Empty Process:
\[
  \nu c.(*c?(d).P) \cong 0
\]

Property holds for the Encoding up to Non-termination Effects %FIXME



\subparagraph{metaFPCF}\label{sec:meta_fpcf}\hfill

\cite{orchard-yoshida16}

Monadic Metalanguage - Moggi91 %FIXME

Monadic Type Constructor $T$ augmented with an Effect Annotation
\cite{wadler-thiemann03}



\subsubsection{Reflexive Domain}\label{sec:reflexive_domain}

Dana Scott %FIXME



% --------------------------------------------------------------------
\subsection{Second-order $\lambda$-calculus}
\label{sec:secondorder_lambda}
% --------------------------------------------------------------------

$\lambda2$ -- Second-order (Polymorphic) $\lambda$-calculus

Polymorphic Types (\S\ref{sec:polymorphic_type})

Quantification over Propositional Variables in Second-order Logic
corresponds to Type Abstraction in Second-order $\lambda$-calculus.
\cite{wadler14}

System F (\S\ref{sec:system_f}) is the canonical $\lambda2$-calculus


Types are Equivalent in Simply-typed $\lambda$-calculus
(\S\ref{sec:simply_typed}) if and only if they are \emph{Syntactically
  Equivalent}; Types are Equivalent in Second-order Polymorphic
$\lambda$-calculus if and only if they are \emph{$\alpha$-equivalent};
Types are Equivalent in Higher-order Polymorphic $\lambda$-calculus
(\S\ref{sec:higherorder_lambda}) if and only if they are
\emph{$\beta\eta$-equivalent} -- (Xi16)



\subsubsection{System F}\label{sec:system_f}

$\lambda2$

\emph{System F} (or \emph{Second-order $\lambda$-calculus})

(\emph{Girard-Reynolds}) \emph{Polymorphic $\lambda$-calculus})

(Impredicative) Parametric Polymorphism
(\S\ref{sec:impredicative_polymorphism}): Type-level Function
Abstraction $\Lambda$

By Curry-Howard Isomorphism, System F corresponds to the fragment of
Second-order Intuitionistic Logic using only Universal Quantification;
can describe all Functions that are Provably Total in Second-order
Logic (\S\ref{sec:secondorder_logic})

Universal Quantification over all Types (cf. Existential Type Theory
\S\ref{sec:abstract_type}) %FIXME



System F$_\omega$ ($\lambda\omega$ \S\ref{sec:system_fomega}) --
  Higher-order System F (Type Operators \S\ref{sec:type_operator})

System F$_{<:}$ (\S\ref{sec:system_fsub}) -- System F with
  Conjunctive Types (\S\ref{sec:conjunctive_type})



% --------------------------------------------------------------------
\subsection{Higher-order $\lambda$-calculus}
\label{sec:higherorder_lambda}
% --------------------------------------------------------------------

$\lambda\underline{\omega}$ -- Higher-order $\lambda$-calculus:
Simply-typed $\lambda$-calculus with Type Operators
(\S\ref{sec:type_operator})

Types depending on Types

Types are Equivalent in Simply-typed $\lambda$-calculus
(\S\ref{sec:simply_typed}) if and only if they are \emph{Syntactically
  Equivalent}; Types are Equivalent in Second-order Polymorphic
$\lambda$-calculus (\S\ref{sec:secondorder_lambda}) if and only if
they are \emph{$\alpha$-equivalent}; Types are Equivalent in
Higher-order Polymorphic $\lambda$-calculus if and only if they are
\emph{$\beta\eta$-equivalent} -- (Xi16)



\subsubsection{System F$_\omega$}\label{sec:system_fomega}

$\lambda\omega$ -- System F ($\lambda2$ \S\ref{sec:system_f}) with
Type Operators



% --------------------------------------------------------------------
\subsection{Dependently-typed $\lambda$-calculus}
\label{sec:dependent_lambda}
% --------------------------------------------------------------------

$\lambda\Pi$ -- First-order Dependently-typed $\lambda$-calculus:
correspondence with First-order Minimal Logic
(\S\ref{sec:minimal_logic})

Calculus of Constructions ($\lambda\Pi\omega$ \S\ref{sec:coc}) --
Higher-order Dependently-typed $\lambda$-calculus

$\lambda\Pi$ is the Meta-language of LF (\S\ref{sec:lf}) Logical
Framework (\S\ref{sec:logical_framework})

Objects of $\lambda\Pi$:
\begin{enumerate}
  \item (Proof) Objects
  \item Types (Propositions)
  \item Families of Types (Type Families ???)
\end{enumerate}

Well-typing (Judgement) is Decidable %FIXME judgement?

Well-typed Terms are Strongly Normalizing

Church-Rosser Property

\fist Type-inference is Undecidable %FIXME

Dependently-typed $\lambda$-calculus with a Type of all Types (the
simplest Pure Type System \S\ref{sec:pts}) is not
Strongly Normalizing due to Girard's Paradox
(\S\ref{sec:girards_paradox})



\subsubsection{Calculus of Constructions}\label{sec:coc}

$\lambda\Pi\omega$ -- Higher-order Dependently-typed
$\lambda$-calculus

Intuitionistic Type Theory (\S\ref{sec:intuitionistic_type})

Intuitionistic (\S\ref{sec:intuitionistic_logic}) Predicate Calculus
(\S\ref{sec:predicate_logic})


\textbf{Terms}

\begin{flalign*}
  \quad\quad & A,B ::= \class{T} \mid \class{P} \mid x
    \mid (A\;B) \mid (\lambda x:A.B) \mid (\forall x:A.B) &
\end{flalign*}

$\class{T}$ -- Type of all Large Types

$\class{P}$ -- Type of all Propositions (a Type of Predicate, i.e. a
Large Type $\class{P}:\class{T}$)

$x,y,\ldots$ -- Variables


\textbf{Objects}

\begin{enumerate}
  \item Proofs -- Terms whose Types are Propositions
  \item Propositions -- Small Types
  \item Predicates -- Functions that return Propositions
  \item Types of Predicates -- Large Types, e.g. $\class{P}$
  \item $\class{T}$ -- Type of Large Types
\end{enumerate}

$\star:\square$

$\Prop:\Type$


\asterism


(scratch)

$x:(A:(\Type:(\class{P}:\class{T})))$

or

$x:(A:(\class{P}:\class{T}))$

$x:(A:(\Type:(\class{U})))$

?


$\exists x:A.B$

$(\Pi C:\Type).(\Pi (\Pi x:A).(\Pi b:B).C).C$



\paragraph{Calculus of Inductive Constructions}\label{sec:cic}

nLab:

Calculus of Co-inductive Constructions

Pure Type System (\S\ref{sec:pts})

Universes (\S\ref{sec:type_universe}): Cumulative Hierarchy
(\S\ref{sec:cumulative_hierarchy}) of Predicative (???) Types of Types
and Impredicative Type of Propositions %FIXME

Intensional Dependent Type Theory



% --------------------------------------------------------------------
\subsection{$\lambda$-calculus with Conjunctive Types}
\label{sec:conjunctive_lambda}
% --------------------------------------------------------------------

Subtyping (\S\ref{sec:subtype_polymorphism})

Conjunctive Type (\S\ref{sec:conjunctive_type})



\subsubsection{System F$_{<:}$}\label{sec:system_fsub}

System F ($\lambda2$ \S\ref{sec:system_f}) with Conjunctive Types
(\S\ref{sec:conjunctive_type})



\paragraph{System F$_{<:}^\omega$}\label{sec:fsub_omega}\hfill

Higher-order Bounded Quantification



% --------------------------------------------------------------------
\subsection{Linear $\lambda$-calculus}\label{sec:linear_lambda}
% --------------------------------------------------------------------

Substructural Type System (\S\ref{sec:substructural_type})

Linear Type System (\S\ref{sec:linear_type})



\subsubsection{Good Variation}\label{sec:good_variation}
\cite{wadler12}

Gay-Vasconcelos 2010 (Semantics: Asynchronous Buffered
Communication) %FIXME

Linear Functional Language for Session Types

Session Types $\subset$ Types

\fist See \emph{Classical Processes} (CP
\S\ref{sec:classical_processes}) for a Session-typed $\pi$-calculus
Translation

Encoding CP into GV: Operational Correspondence (Lindley-Morris15)

\fist Cf. FPCF (\S\ref{sec:fpcf}) \cite{orchard-yoshida16} -- FPCF is
not fundamentally Linear, but Linearity for Sessions is implemented
via an Effect Algebra and Typing.

No Deadlock

Extensions:
\begin{itemize}
  \item $Mix$ (Girard):
\[
  \frac{P \vdash \Gamma \quad Q \vdash \Delta}
  {P | Q \vdash \Gamma, \Delta} (Mix)
\]
    No Channels in Common between $P$ and $Q$ (rather than one Channel
    in common as in $Cut$); Equivalent to Provability of the
    Proposition:
\[
  A \otimes B \multimap A \parr B
\]
    Still no Deadlock but allows Independent Concurrent Components.
  \item $BiCut$ (\cite{abramsky-gay-nagarajan96}; special case of
    $MultiCut$):
\[
  \frac{P \vdash \Gamma, x:A, y:B \quad
    Q \vdash \Delta, x:A^\bot, y:B^\bot}
  {\nu x:A.y:B.(P|Q) \vdash \Gamma, \Delta} (BiCut)
\]
    Two Channels in common between $P$ and $Q$ (rather than one
    Channel in common as in $Cut$); Equivalent to Provability of the
    Proposition:
\[
  A \parr B \multimap A \otimes B
\]
    Allows for systems where Communication forms a loop and may
    Deadlock
\end{itemize}

Systems with both $Mix$ and $BiCut$ are Compact: from either of $A
\otimes B$ and $A \parr B$ one may derive the other;
Compact Linear Systems (\S\ref{sec:compact_linear_system}),
Interaction Categories (\S\ref{sec:interaction_category})

\emph{Types}:
\begin{flalign*}
  \quad T,U,V &::= S \;|\; T \otimes U \;|\; T \multimap U
    \;|\; T \rightarrow U \;|\; Unit &
\end{flalign*}

$S$ -- (Linear) Session Type

$T \otimes U$ -- (Linear) Tensor Product

$T \multimap U$ -- (Linear) Function

$T \rightarrow U$ -- (Unlimited) Function

$Unit$ -- (Unlimited) Unit

\emph{Unlimited Types} support Weakening and Contraction,
\emph{Linear Types} do not

Unlimited Types correspond to Types written with $!$ in CP
(\S\ref{sec:classical_processes})

\emph{Session Types}:
\begin{flalign*}
  \quad\quad S &::= \;!T.S \mid ?T.S \mid \oplus\{l_i:S_i\}_{i \in I}
    \mid \&\{l_i:S_i\}_{i \in I} \mid end_! \mid end_? &
\end{flalign*}

$!T.S$ -- Output Value of Type $T$ then Behave as $S$

$?T.S$ -- Input Value of Type $T$ then Behave as $S$

$\oplus\{l_i:S_i\}_{i \in I}$ -- Select from Behaviors $S_i$ with
Label $l_i$

$\&\{l_i:S_i\}_{i \in I}$ -- Offer Choice of Behaviors $S_i$ with
Label $l_i$

$end_!$ -- Terminator for use with Output

$end_?$ -- Terminator for use with Input


Session Type Duals:
\begin{align*}
  \overline{!T.S} &= ?T.\overline{S} \\
  \overline{?T.S} &= !T.\overline{S} \\
  \overline{\oplus\{l_i:S_i\}_{i \in I}} &=
    \&\{l_i:\overline{S_i}\}_{i \in I} \\
  \overline{\&\{l_i:S_i\}_{i \in I}} &=
    \oplus\{l_i:\overline{S_i}\}_{i \in I} \\
  \overline{end_!} &= end_? \\
  \overline{end_?} &= end_!
\end{align*}

$\overline{\overline{S}} = S$

Duality on Session Types in GV leaves the Types of Sent and Received
Values unchanged, i.e.:
\begin{align*}
  \overline{!T.S} &= ?T.\overline{S} \\
  \overline{?T.S} &= !T.\overline{S}
\end{align*}


\emph{Environments} $\Phi, \Psi$ associating Values to Types

$un(\Phi)$ -- Each Type in $\Phi$ is Unlimited


\emph{Terms}:
\begin{flalign*}
  \quad\quad L,M,N ::=&\; x \mid \mono{unit} \mid \lambda x.N \mid L\;M
    \mid (M,N) \mid \mono{let}\; (x,y) = M \;\mono{in}\; N & \\
    \mid &\; \mono{send}\; M\;N \mid \mono{receive}\; M
    \mid \mono{select}\; l\;M
    \mid \case\; M \;\of\; \{l_i:x.N_i\}_{i\in I} & \\
    \mid &\; \mono{with}\; x \;\mono{connect}\; M \;\mono{to}\; N
    \mid \mono{terminate}\; M &
\end{flalign*}

Linear $\lambda$-calculus:

$x$ -- Identifier

$\mono{unit}$ -- Unit Constant

$\lambda x.N$ -- Function Abstraction

$L\;M$ -- Function Application

$(M,N)$ -- Pair Construction

$\mono{let}\; (x,y) = M \;\mono{in}\; N$

Communication on a Channel:

$\mono{send}\; M\;N$ -- Send Value $M$ on Channel $N$

$\mono{receive}\; M$ -- Receive on Channel $M$

$\mono{select}\; l\;M$ -- Select Label $l$ on Channel $M$

$\case\; M \;\of\; \{l_i:x.N_i\}_{i\in I}$ -- Offer Choice
on Channel $M$

$\mono{with}\; x \;\mono{connect}\; M \;\mono{to}\; N$ -- Connect $M$
to $N$ by Channel $x$

$\mono{terminate}\; M$ -- Terminate Input


Type Rules

Function Abstraction may produce an Unlimited Function if and only if
all of its Free Variables are of Unlimited Type.

Each Term is not required to have a Unique Type, e.g. a
$\lambda$-expression where all Free Variables have Unlimited Type may
be given either a Linear or Unlimited Function Type.

Possibly Subtyping could be added to arrange for giving each Term a
Unique Smallest Type.


\asterism


\emph{Output} -- $\mono{send}\; M\;N$: \\
Outputs the Value $M$ of Type $T$ on Channel $N$ of Session Type
$!T.S$ \\
Returns the updated Channel after which the Output has Session Type
$S$

\emph{Input} -- $\mono{receive}\; M$: \\
Inputs a Value from Channel $M$ of Session Type $?T.S$ \\
Returns a (Linear) Pair of the Input Value of Type $T$ and the updated
Channel after which the Input has Session Type $S$

\emph{New Channel} ($Connect$) -- $\mono{with}\; x \;\mono{connect}\;
M \;\mono{to}\; N$ \\
Creates a new Channel $x$ with Session Type $S$ where $x$ is used at
Type $S$ in Term $M$ and Dual Type $\overline{S}$ in Term $N$ \\
$M$ and $N$ are Evaluated Concurrently \\
Left Subterm returns exhausted Channel of Type $end_!$ %FIXME

\emph{Terminate Channel} ($Terminate$) -- $\mono{terminate}\; M$: \\
Evaluates Term $M$ which Returns a Pair of an Exhausted Channel of
Type $end_?$ and a Value of Type $T$ \\
Deallocates the Channel and Returns the Value

Constructs for $Connect$ and $Terminate$ Deallocate two ends of a
Channel between them.

Alternative designs %FIXME


\asterism


\textbf{Translation of GV into CP}

CP (\S\ref{sec:classical_processes})

Translation of Session Types:
\begin{align*}
  \llbracket !T.S \rrbracket &=
    \llbracket T \rrbracket^\bot \parr \llbracket S \rrbracket \\
  \llbracket ?T.S \rrbracket &=
    \llbracket T \rrbracket \otimes \llbracket S \rrbracket \\
  \llbracket \oplus \{l_i : S_i\}_{i \in I} \rrbracket &=
    \llbracket S_1 \rrbracket \& \cdots \& \llbracket S_n \rrbracket,
    \quad I = \{1,\ldots,n\} \\
  \llbracket \& \{l_i : S_i\}_{i \in I} \rrbracket &=
    \llbracket S_1 \rrbracket \oplus \cdots \oplus
    \llbracket S_n \rrbracket, \quad I = \{1,\ldots,n\} \\
  \llbracket end_! \rrbracket &= \bot \\
  \llbracket end_? \rrbracket &= 1
\end{align*}

\fist Note that Input/Output are translated into their Duals. This is
explained by Send and Receive in GV taking Channels as
\emph{Arguments}, while in the Interpretations in CP Channels are
\emph{Results}.
\begin{itemize}
  \item \emph{Send}: takes a Value and a Channel and Sends the Value
    on that Channel (the Channel must \emph{Input} the Value)
  \item \emph{Receive}: takes a Channel and Returns a Value (the
    Channel must \emph{Output} the Value)
\end{itemize}
Since Duality on Session Types in GV leaves Types of Sent and Received
Values unchanged, the Translation of these Operations takes the Dual
of the Sent Value, but not the Received Value, i.e.:
\begin{align*}
  \llbracket !T.S \rrbracket &=
    \llbracket T \rrbracket^\bot \parr \llbracket S \rrbracket \\
  \llbracket ?T.S \rrbracket &=
    \llbracket T \rrbracket \otimes \llbracket S \rrbracket
\end{align*}
and following the equality in Linear Logic, $A \multimap B = A^\bot
\parr B$, $\llbracket T \rrbracket^\bot \parr \llbracket S \rrbracket$
could alternatively be written $\llbracket T \rrbracket \multimap
\llbracket S \rrbracket$.

Translation Preserves Duality:
\[
  \llbracket \overline{S} \rrbracket = \llbracket S \rrbracket^\bot
\]

Translation of Types:
\begin{align*}
  \llbracket T \multimap U \rrbracket &=
    \llbracket T \rrbracket^\bot \parr \llbracket U \rrbracket \\
  \llbracket T \rightarrow U \rrbracket &=
    \;!(\llbracket T \rrbracket^\bot \parr \llbracket U \rrbracket) \\
  \llbracket T \otimes U \rrbracket &=
    \llbracket T \rrbracket \otimes \llbracket U \rrbracket \\
  \llbracket Unit \rrbracket &= \;!\top
\end{align*}

$\llbracket T \rrbracket^\bot \parr \llbracket U \rrbracket$ could
alternatively be written:
\[
  \llbracket T \rrbracket \multimap \llbracket U \rrbracket
\]

$!(\llbracket T \rrbracket^\bot \parr \llbracket U \rrbracket)$ could
alternatively be written:
\[
  !(\llbracket T \rrbracket \multimap \llbracket U \rrbracket)
\]

$!T$ could alternatively be written $1$ (Unit for $\otimes$)

This Translation follows the Call-by-value Translation of Classical
Linear Logic (\S\ref{sec:cll})

Translation of Terms:

Linear $\lambda$ Terms:
\begin{itemize}
  \item Variable Translates to an $Axiom$
  \item $Weaken$ and $Contract$ Translate to $Weaken$ and $Contract$
  \item Function Abstraction and Product Deconstruction Translate to
    Input
  \item Function Application and Product Construction Translate to
    Output
  \item Translation of Elimination Rules ($\multimap-E$,
    $\rightarrow-E$, $\times-E$) require use of $Cut$
\end{itemize}

Communication Operation Terms:
\begin{itemize}
  \item Send: Output Operation $x[y].(P|Q)$
  \item Select: Select Operation $x[in_j].P$
  \item Case: Choice Operation $\case(Q_1, \ldots, Q_n)$
  \item $end_!$ in Connect: Empty Output $y[].0$
  \item Terminate: Empty Input $x().P$
  \item Receive (Trivial): $x(y).R$ (???)
  \item Connect: $Cut$ corresponds to introducing a Channel for
    Communication between two Subterms
\end{itemize}
Each of these Communication Translations involve a $Cut$ corresponding
to Communication with given Channel.

Term $M$ of Type $T$ is Translated $\llbracket M \rrbracket_z$ where
$z$ is a Channel of Type $\llbracket T \rrbracket$ where $\llbracket M
\rrbracket_z$ Sends the ``Answer'' it Computes on $z$, as expressed by
the Theorem:

Thm. \textbf{Translation Preserves Types}

\[
  \text{If } \Phi \vdash M : T \text{ then }
  \llbracket M \rrbracket z \vdash \llbracket \Phi \rrbracket^\bot,
  z : \llbracket T \rrbracket
\]



\subsubsection{$\mathcal{L}^\parallel_0$}\label{sec:l_par_zero}

Shi-Xi13

Parallel Reduction Calculus (\S\ref{sec:parallel_reduction_calculus})
with a simple Linear Type System

\emph{Viewtypes} (\S\ref{sec:viewtype})

\fist Extension: $\mathcal{L}^\parallel_{\forall,\exists}$
(\S\ref{sec:l_par_quant}) -- Universally and Existentially Quantified
(Polymorphic and Dependent) Viewtypes and support for Programming with
Theorem Proving

$\mono{thread\_create} : (\mathbf{1} \rightarrow_l \mathbf{1})
\Rightarrow \mathbf{1}$

$\mathbf{Res}$ -- a collection of Finite Multisets of Resources

$\Pi$ -- Program Pools

$\Gamma$ -- Expression Context

$\Delta$ -- Linear Expression Context

Lem. \emph{Canonical Forms}

Lem. \emph{Substitution}

Ad-hoc Redexes, Sole Reducts (Normalization ?)

Def. \emph{Pure Redexes}

when Ad-hoc Reduction occurs, resources may be Generated as well as
Consumed

Thm. \emph{Subject Reduction on Expressions}

Thm. \emph{Progress on Expressions}

Parallel Reduction for Pools

Thm. \emph{Subject Reduction on Pools}

Thm. \emph{Progress on Pools}

absence of Race Conditions



\subsubsection{$\mathcal{L}^\parallel_{\forall,\exists}$}
\label{sec:l_par_quant}

Shi-Xi13

$\mathcal{L}^\parallel_0$ extended with Universally and Existentially
Quantified (Polymorphic and Dependent) Viewtypes
(\S\ref{sec:viewtype}) with support for Programming with Theorem
Proving (PwTP)

extension by ``\emph{Predicatization}''

Applied Type System (ATS \S\ref{sec:ats})

$\delta$ -- Base Type Constructors have $c$-sorts $(\sigma_1, \ldots,
\sigma_n) \rightarrow type$ (e.g. $\mathsf{int} : (int) \rightarrow
type$, $\mathsf{bool} : (bool) \rightarrow type$, $\mathsf{ptr} :
(addr) \rightarrow type$)

Base Viewtype Constructors have $c$-sorts $(\sigma_1, \ldots,
\sigma_n) \rightarrow viewtype$ (e.g. $\mathsf{var} : (type, addr)
\rightarrow viewtype$ where $\mathsf{var}(T,L)$ is a Viewtype for a
Pointer to the Address $L$ where a Value of Type $T$ is stored)

%            FIXME c-sort ???
general form of a $c$-type in $\mathcal{L}^\parallel_{\forall,
  \exists}$:
\[
  \forall\Sigma.\overline{B}
    \supset ((VT_1, \ldots, VT_n) \Rightarrow VT)
\]
where $\Sigma = a_1 : \sigma_1, \ldots, a_n : \sigma_n$ and
$\overline{B} = B_1, \ldots, B_n$

Guarded, Asserting Types/Viewtypes %FIXME

Programming with Theorem Proving: Sorts $prop$ (Classical
Propositions) and $view$ (Linear Propositions \S\ref{sec:view})

$prop$ is a Subsort of $view$ (every Prop is considered a View)

when assigning a Prop or a View to a Dynamic Term, the Dynamic Term
needs to be verified as being \emph{Total} (Pure and Terminating)

$@$ -- (Infix) Base View Constructor with $c$-sort $(type, addr)
\rightarrow view$; given $T$ and $L$ the View $T@L$ is assigned to a
Resource of the form $v@L$ for some Value $v$ of Type $T$, i.e. a
Value of Type $T$ is stored at Address $L$

ptrset, ptrget functions %FIXME

Recursive Views


\textbf{Multicore Programming in ATS}

$\mathsf{unplock0, uplock1, upticket} : (viewtype) \rightarrow
viewtype$

$\mathsf{tid} : (viewtype) \rightarrow viewtype$ -- $\mathsf{tid}(VT)$
a Joinable Thread with Return Type $VT$

$\mathsf{spawn} : (viewtype) \rightarrow viewtype$

Parallel $\mono{let}$-binding %FIXME



\subsubsection{MTLC$_0$}\label{sec:mtlc_0}

\begingroup

\renewcommand{\Unit}{\mathbf{1}}
\newcommand{\bool}{\mathsf{bool}}
\newcommand{\Bool}{\mathsf{Bool}}
\newcommand{\Choose}{\mathsf{Choose}}
\newcommand{\Nil}{\mathsf{Nil}}
\newcommand{\Send}{\mathsf{Send}}
\newcommand{\Recv}{\mathsf{Recv}}
\newcommand{\Service}{\mathsf{Service}}
\newcommand{\chpos}{\mathbf{chpos}}
\newcommand{\chneg}{\mathbf{chneg}}

Xi-Ren-Wu-Blair15 - \emph{Session Types in a Linearly Typed
  Multi-threaded Lambda-Calculus}

\fist ATS (Applied Type System \S\ref{sec:ats})

Multi-threaded $\lambda$-calculus (\S\ref{sec:mtlc}) with Linear Types

Threads can be created and eliminated but there are no Channels for
Communication between Threads; see MTLC$_{ch}$ (\S\ref{sec:mtlc_ch})
for extension with Synchronous Communication Channels


\textbf{Syntax}

%FIXME

$T$ -- Types

$\hat{T}$ -- \emph{Viewtypes} (\S\ref{sec:viewtype})--
\emph{Resources}

note that regular Types are a Subset of Viewtypes ??? %FIXME

$\hat{T} \otimes \hat{T}$ -- Conjunction of two Resources
(Multiplicative Conjunction in Linear Logic)

Signiature $SIG$ assigns a Viewtype to each Constant Resource $rc$ and
a Constant Type ($c$-type) of the form $(\hat{T}_1, \ldots, \hat{T}_n)
\Rightarrow \hat{T}$ to each Constant

$\rightarrow_l$ -- Type Constructor based on Linear Implication
$\multimap$ (see Interpreting Linear Logic Connectives in
MTLC$_{ch}$); applying a Function (of Viewtype) $\hat{T}_1
\rightarrow_l \hat{T}_2$ to a Value of Viewtype $\hat{T}_1$ yields a
result of Viewtype $\hat{T}_2$ and \emph{consumes} the Function itself

$\rightarrow$ -- Type Constructor; applying a Function of Type (?)
$\hat{T}_1 \rightarrow \hat{T}_2$ \emph{does not consume} the Function
itself
%FIXME

$\hat{T}_1 \parr \hat{T}_2$ -- Multiplicative Disjunction: essentially
means the Capability (Space) that ``joins'' two classified by
$\hat{T}_1$ and $\hat{T}_2$

(no corresponding constructor for $\parr$ in ATS)

$\hat{T}_1 \& \hat{T}_2$ -- Additive Conjunction: a Choice to obtain
any Capability (Space) classified by either $\hat{T}_1$ or
$\hat{T}_2$; as a Dependent Type:
\[
  \forall b : bool. \Bool(b)
    \rightarrow_l \Choose(\hat{T}_1, \hat{T}_2, b)
\]

Constant Function $\mono{thread\_create}$ and corresponding $c$-type:
\[
  \mono{thread\_create} : (\Unit \rightarrow_l \Unit) \Rightarrow \Unit
\]

$\rho(\cdot)$ -- Function computing the Multiset of Constant Resources
for a given Expression %FIXME

$R$ -- ranges over Finite Mulstisets of Resources; may be regarded as
a mapping from Resources to Natural Numbers: $R(rc) = n$ means there
are $n$ occurrences of $rc$ in $R$

$RES$ -- an abstract collection of Finite Multisets of Resources
assuming:
\begin{itemize}
  \item $\varnothing \in RES$
  \item for any $R_1$ and $R_2$, $R_2 \in RES$ if both $R_1 \in RES$
    and $R_2 \subseteq R_1$
\end{itemize}
$R$ is a \emph{Valid} Multiset of Resources when $R \in RES$ holds

\emph{Program} -- a \emph{Closed Expression} (an Expression containing
no Free Variables)

$\Pi$ -- \emph{Pool}: a collection of Programs formally defined as a
Finite Mapping from Thread IDs (represented by Natural Numbers) to
Closed Expressions (Programs) of MTLC$_0$ such that $0$ is always in
the Domain of the Mapping ($\Pi(0)$ being the Main Thread)

(relation on pools to simulate muili-threaded program execution) %FIXME


\textbf{Static Semantics}

\emph{Typing Rules}

%FIXME rules

$\Gamma$ -- Intuitionistic Expression Context

$\Delta$ -- Linear Expression Context

each Variable occurs at most once in a Context $\Gamma$ or $\Delta$

Contexts can be regarded as Finite Mappings

$(\Gamma_1, \Gamma_2)$ -- Union of $\Gamma_1$ and $\Gamma_2$ defined
when $dom(\Gamma_1) \cap dom(\Gamma_2) = \varnothing$

$(\Delta_1, \Delta_2)$ -- Union of $\Delta_1$ and $\Delta_2$ defined
when $dom(\Delta_1) \cap dom(\Delta_2) = \varnothing$

$(\Gamma;\Delta)$ -- combined Expression Context defined when
$dom(\Gamma) \cap dom(\Delta) = \varnothing$

$\Theta$ -- Substitution on Type and Viewtype Variables %FIXME

$\hat{T}[\Theta]$ -- the result of applying $\Theta$ to $\hat{T}$

$SIG \vDash rc : \hat{\delta}$ -- $rc$ is assigned the Viewtype
$\hat{\delta}$ in the Signature $SIG$

$SIG \vDash c : (\hat{T}^0_1, \ldots, \hat{T}^0_n) \Rightarrow
\hat{T}^0$ -- Judgement stating that $c$ is assigned a $c$-type of the
form $(\hat{T}_1, \ldots, \hat{T}_n) \Rightarrow \hat{T}$
%FIXME further explanation wrt substitution

\emph{Typing Judgements in MTLC$_0$}:

$(\Gamma;\Delta) \vdash e : \hat{T}$

by the Typing Rules a Closed Value \emph{cannot} contain any Resources
if the Value itself can be assigned a Non-linear Type rather than a
Viewtype:

Prop. \emph{If $(\varnothing;\varnothing) \vdash v : T$ is Derivable,
  then $\rho(v) = \varnothing$}

Lem. (\emph{Canonical Forms})

$\theta$ -- Substitution on Variables

$e[\theta]$ -- result of applying $\theta$ to Expression $e$

Lem. (\emph{Substitution}) \emph{If $(\Gamma_1;\Delta_1) \vdash \theta
  : (\Gamma_2;\Delta_2)$ and $(\Gamma_2;\Delta_2) \vdash e : \hat{T}$,
  then $(\Gamma_1;\Delta_1) \vdash e[\theta] : \hat{T}$ is Derivable
  and $\rho(e[\theta]) = \rho(e) \uplus \rho(\theta)$}

-- needed to establish Soundness of Type System


\textbf{Dynamic Semantics}

\emph{Evaluation Rules}

$E$ -- Evaluation Context (definition given)

$E[e]$ -- Expression obtained from replacing the only Hole $[]$ in $E$
with $e$

Pure Redexes and Reducts

Ad-hoc Redexes and Sole Reducts -- Resources may be \emph{generated}
as well as \emph{consumed} when Ad-hoc Reductions occur

$e_1 \rightarrow e_2$ -- $e_1$ Evaluates (or Reduces) to $e_2$ Purely
when $e$ is a Pure Redex where $e_1 = E[e]$ and $e_2 = E[e']$ such
that $e'$ is a Reduct of $e$

$\Pi_1 \rightarrow \Pi_2$ -- Evaluation on Pools (definition given)

Soundness of MTLC$_0$:

Thm. (\emph{Subject Reduction on Pools}) \emph{If $\vdash \Pi_1 :
  \hat{T}$ is Derivable and $\Pi_1 \rightarrow \Pi_2$ holds for some
  $\Pi_2$ satisfying $\rho(\Pi_2) \in RES$, then $\vdash \Pi_2 :
  \hat{T}$ is also Derivable}

Thm. (\emph{Progress Property on Pools}) \emph{If $\vdash\Pi_1 :
  \hat{T}$ is Derivable then either $\Pi_1$ is a Singleton Mapping $[0
    \mapsto v]$ for some $v$, or else $\Pi_1 \rightarrow \Pi_2$ holds
  for some $\Pi_2$ such that $\rho(\Pi_2) \in RES$}

by the above two Theorems, the Evaluation of a Well-typed Pool either
leads to a Pool that is a Singleton Mapping of the form $[0 \mapsto
  v]$ for some Value $v$, or else Evaluation never halts
(Type-soundness)

(note: in the original Xi-Ren-Wu-Blair the phrase ``or else goes on
forever'' is used instead of ``Evaluation never halts''; the latter
seems to be more clear, if it is correctly stated)



\subsubsection{MTLC$_{ch}$}\label{sec:mtlc_ch}

MTLC$_0$ extended with Synchronous Communication Channels and support
for Session Types (\S\ref{sec:session_type})

support for both Synchronous and Asynchronous Session-typed
Communication Channels, ``in practice'' %FIXME

ATS (Applied Type System \S\ref{sec:ats}) Implementation of Dyadic
Sessions

most closely related to SILL (Monadic instead of Linear) --
Pfenning-Griffith15 \emph{Polarized Substructural Session Types} --
implemented in OCaml %FIXME xref

``Dependent Session Types''

Erlang code generation

\emph{Session Types}:
\[
  S ::= \Nil \ |\ \Send(\hat{T}) :: S \ |\ \Recv(\hat{T}) :: S
\]
Session Type Duals:
\begin{align*}
  dual(\Nil)              =&\ \overline{\Nil} \\
  dual(\Send(\hat{T})::S) =&\ \Recv(\hat{T}) :: dual(S) \\
  dual(\Recv(\hat{T})::S) =&\ \Send(\hat{T}) :: dual(S)
\end{align*}

$\Nil$ -- Empty Session; a Positive Channel of Type $\Nil$ awaits a
Message to close itself; a Negative Channel of Type $\Nil$ Sends out
``such a Message'' before Closing itself %FIXME such a message ?

$\sigma$ -- Ranges over Session Types

$\mono{chneg\_create} : (\chpos(\sigma) \rightarrow_l \mathbf{1})
\Rightarrow \chneg(\sigma)$ -- Function for creating a Negative
Channel with associated $c$-type $(\chpos(\sigma) \rightarrow_l
\mathbf{1}) \Rightarrow \chneg(\sigma)$ which takes a Linear Function
of Type $\chpos(S) \rightarrow_l \mathbf{1}$, creates a Positive and
Negative Channel sharing the same Channel ID that are properly
connected, and starts a Thread for Evaluating the call that applies
the Linear Function to the Positive Channel, and then returns the
Negative Channel

Send and Receive for Positive Channels:

$send : (\chpos (\Send(\hat{\alpha}) :: \sigma), \hat{\alpha})
\Rightarrow \chpos(\sigma)$

$recv : (\chpos (\Recv(\hat{\alpha}) :: \sigma)) \Rightarrow
\chpos(\sigma) \otimes \hat{\alpha}$

correspond to $\mono{chanpos\_send}$ and $\mono{chanpos\_recv}$,
respectively

Send and Receive for Negative Channels:

$\overline{send} : (\chneg(\Recv(\hat{a}) :: \sigma), \hat{a})
\Rightarrow \chneg(\sigma)$

$\overline{recv} : (\chneg(\Send(\hat{a}) :: \sigma)) \Rightarrow
\chneg(\sigma) \otimes \hat{a}$

correspond to $\mono{channeg\_send}$ and $\mono{channeg\_recv}$,
respectively

$close : (\chpos(\Nil)) \Rightarrow \Unit$ -- Function for closing a
Positive Channel (can also be referred to as $\mono{chanpos\_close}$)

$\overline{close} : (\chneg(\Nil)) \Rightarrow \Unit$ -- Function for
closing a Negative Channel (can also be referred to as
$\mono{channeg\_close}$)

$ch_i$, $\overline{ch}_i$ -- Resource Constants for Positive and
Negative Channels, respectively, where $i$ ranges over Natural
Numbers; for each $i$, $ch_i$ and $\overline{ch}_i$ are Dual to
eachother and their Channel IDs are $i$

$ch$, $\overline{ch}$ -- ranges over $ch_i$ and $\overline{ch}_i$


\emph{Typing Rules} -- same as MTLC$_0$

$\chpos(S)$ \emph{Matches} $\chneg(S)$ for some Session Type $S$

for any Type Derivation of $\Pi : \hat{T}$ such that $\rho(\Pi) \in
RES$, the Type assigned to a Positive Channel $ch$ is always required
to Match the Type of the corresponding Negative Channel
$\overline{ch}$ of the same Channel ID

additional Rules for Evaluating Pools (definition given)

Partial (Ad-hoc) Redexes:
\begin{itemize}
  \item $close(ch)$ Matches $\overline{close}(\overline{ch})$
  \item $send(ch,v)$ Matches $\overline{send}(\overline{ch})$
  \item $recv(ch)$ Matches $\overline{recv}(\overline{ch},v)$
\end{itemize}

every Well-typed Program in MTLC$_{ch}$ is either a Value or of the
form $E[e]$ for some Evaluation Context $E$ and Expression $e$ that is
either a Redex or Partial Redex

\emph{Blocked Expressions} -- an Expression is \emph{Blocked} if it is
of the form $E[e]$ for some Partial Redex $e$

Blocked Expressions $E_1[e_1]$ and $E_2[e_2]$ Match if $e_1$ and $e_2$
are Matching Partial Redexes

a Pool containing two matching Blocked Expressions can be Reduced
by the Rules for Evaluating Pools

\emph{Deadlocked Pools} -- a Pool $\Pi$ is \emph{Deadlocked} if
$\Pi(tid)$ for $tid \in dom(\Pi)$ are all Blocked Expressions and
there are no Matching Expressions, \emph{or} if $\Pi(0)$ is a Value
and $\Pi(tid)$ for Positive $tid \in dom(\Pi)$ are all Blocked
Expressions with no Matching Expressions

Lem. (\emph{Deadlock Freedom}) \emph{For a Well-typed Pool $\Pi$ such
  that $\Pi(0)$ is either a Value containing no Channels or a Blocked
  Expression, and $\Pi(tid)$ for all Positive $tid \in dom(\Pi)$ is a
  Blocked Expression, if $\Pi$ is obtained from Evaluating an initial
  Pool containing no Channels, then thre exist two Thread IDs $tid_1$
  and $tid_2$ such that $\Pi(tid_1)$ and $\Pi(tid_2)$ are Matching
  Blocked Expressions}

note: the scenario where the Main Thread in a Pool returns a Value
containing a Channel while another Thread is waiting for input is not
considered a Deadlocked one; forms of Values that contain Channels can
be a Channel itself, a Closure-function containing a Channel in its
Environment, or a compound Value like a Tuple containing a Channel,
etc.-- any Value containing a Channel can only be assigned a (true)
Viewtype

Proof of Deadlock Freedom Lemma--

$M$ -- \emph{Channel Set} of Positive and Negative Channels

$\class{M}$ -- Finite Non-empty Collection (Multiset) of Sets $M$

$\class{M}$ is \emph{Regular} if the Sets in $\class{M}$ are pairwise
Disjoint and each pair of Channels $ch$ and $\overline{ch}$ are either
both included in the Multiset Union $\uplus(\class{M})$ or else are
both excluded from it (note $\uplus(\class{M})$ is the same as the Set
Union $\cup(\class{M})$ since the Sets in $\class{M}$ are pairwise
Disjoint)

$\class{M} \rightsquigarrow \class{M}'$ -- \emph{DF-reduction
  Relation} on Regular Collections of Channel Sets: $\class{M}$
DF-reduces to $\class{M}'$ via a Channel $ch$ if there exists Channel
Sets $M_1$ and $M_2$ in $\class{M}$ such that $ch \in M_1$ and $ch \in
M_2$ and $\class{M}' = (\class{M}\setminus\{M_1,M_2\}) \cup
\{M_{12}\}$ where $M_{12} = (M_1 \cup
M_2)\setminus\{ch,\overline{ch}\}$

$\class{M}$ is \emph{DF-normal} if there is no $\class{M}'$ such that
$\class{M} \rightsquigarrow \class{M}'$

Prop. \emph{For each $M$ in a DF-normal $\class{M}$, a Channel $ch$ is
  in $M$ if and only if $\overline{ch}$ is also in $M$}

Def. \emph{DF-reducible}: A Regular Collection of Channel Sets
$\class{M}$ is DF-reducible if either each Set in $\class{M}$ is
Empty, or else $\class{M}$ is not DF-normal and $\class{M}'$ is
DF-reducible whenever $\class{M} \rightsquigarrow \class{M}'$

a Channel Set $M$ is \emph{Self-looping} if it contains both $ch$ and
$\overline{ch}$ for some $ch$; a Collection of Channel Sets
$\class{M}$ is not DF-reducible if there exists a Self-looping Channel
Set in $\class{M}$

(note: Xi-Ren-Wu-Blair15 contains the following proposition which
seems to be vacuously true, not sure what purpose it serves):

Prop. \emph{For a Regular Collection of Channel Sets $\class{M}$, if
  $\class{M}$ is DF-reducible and $\class{M}' =
  \class{M}\setminus\{\varnothing\}$ then $\class{M}'$ is also
  DF-reducible}

(note: also this proposition seems fairly obvious or equivalent to the
previous definition of DF-reducibility):

Prop. \emph{For a Regular Collection of Channel Sets $\class{M}$, if
  $\class{M} \rightsquigarrow \class{M}'$ and $\class{M}'$ is
  DF-reducible then $\class{M}$ is also DF-reducible}

(another Prop. regarding DF-reducibility) %TODO

(Lem. regarding non-DF-reducibility) %TODO

$\rho_{CH}(e)$ -- Set of Channels contained in Expression $e$

$\class{R}_{CH}(\Pi)$ -- Collection of $\rho_{CH}(\Pi(tid))$ where
$tid$ ranges over $dom(\Pi)$

Lem. \emph{If $\class{R}_{CH}(\Pi)$ is DF-reducible and $\Pi$
  Evaluates to $\Pi$', then $\class{R}_{CH}(\Pi')$ is also
  DF-reducible}

--Proof of Deadlock Freedom Lemma


\textbf{Type System Soundness}

Thm. (\emph{Subject Reduction on Pools}) \emph{If $\vdash \Pi_1 :
  \hat{T}$ is Derivable and $\Pi_1 \rightarrow \Pi_2$ such that
  $\rho(\Pi_2) \in RES$, then $\vdash \Pi_2 : \hat{T}$ is Derivable}

Thm. (\emph{Progress Property on Pools}) \emph{If $\vdash \Pi_1 :
  \hat{T}$ is Derivable and $\rho(\Pi_1)$ is Valid, assuming that
  $\rho(v)$ contains no Channels for every Value $v$ of the Type
  $\hat{T}$, then either $\Pi_1$ is a singleton mapping $[0 \mapsto
    v]$ for some $v$, or else $\Pi_1 \rightarrow \Pi_2$ holds for some
  $\Pi_2$ such that $\rho(\Pi_2) \in RES$}


\textbf{Additional features}

Bidirectional Forwarding

User-defined Recursive Session Types

Quantification over Types-- ATS \emph{Predicative Quantification}
(Dependent Types) and \emph{Impredicative Quantification} (Parametric
Polymorphism)


\textbf{Interpreting Linear Logic Connectives}

$A \otimes B$ -- \emph{Multiplicative Conjunction}-- (from Client's
perspective) for Session Types $A$ and $B$, a Channel of Session Type
$A \otimes B$ is Interpreted as one that Inputs a Channel specified by
$A$ and then Behaves as a Channel specified by $B$:
\[
  \Send(\chneg(A)) :: B
\]
$\mono{fserv\_times}$ -- allows the construction of a Channel of the
Type $\chneg(A \otimes B)$ from two Channels of Types $\chneg(A)$ and
$\chneg(B)$
%TODO give definition

can also be Interpreted as:
\[
  \Send(\chneg(A)) :: \Send(\chneg(B)) :: \Nil
\]

$A \multimap B$ -- \emph{Multiplicative Implication}-- (from Client's
perspective) for Session Types $A$ and $B$, a Channel of Session Type
$A \multimap B$ is Interpreted as one that Outputs a Channel specified
by $A$ and then Behaves as a Channel specified by $B$:
\[
  \Recv(\chneg(A)) :: B
\]
$\mono{fserv\_implies}$ -- uses a (Linear) Function that can turn a
Negative Channel specified by $A$ into a Negative Channel specified by
$B$ to construct a Channel of Type $\chneg(A \multimap B)$
%TODO give definition

$A \oplus B$ -- \emph{Additive Disjunction}-- (from Client's
perspective) for Session Types $A$ and $B$, a Channel of Session Type
$A \oplus B$ is Interpreted as one that Inputs a Boolean Value and
then Behaves as the Channel specified by either $A$ or $B$ depending
on whether the Boolean Value was true or false, respectively:
\[
  \forall b : bool. \Send(\Bool(b)) :: \Choose(A,B,b)
\]

Positive Channel Type:
\[
  \forall b : bool. \chpos(\Send(\Bool(b)) :: \Choose(A,B,b))
\]
Negative Channel Type:
\[
  \exists b : bool. \chneg(\Send(\Bool(b)) :: \Choose(A,B,b))
\]
$\mono{fserv\_disj_l}$, $\mono{fserv_disj_r}$ -- also called ``Internal
Choice'' (the Server decides)
%TODO give definitions

$A \& B$ -- \emph{Additive Conjunction}-- (from Client's perspective)
for Session Types $A$ and $B$, a Channel of Session Type $A \& B$ is
Interpreted as one that Outputs a Boolean Value and then Behaves as a
Channel specified by either $A$ or $B$ depending on whether the
Boolean Value is true or false, respectively:
\[
  \forall b : bool. \Recv(\Bool(b)) :: \Choose(A,B,b)
\]
$\&$ not supported as a Type Constructor in ATS so it is represented
as:
\[
  \forall b:bool,
    \Bool(b) \rightarrow_l \Choose(\chneg(A), \chneg(B), b)
\]

Positive Channel Type:
\[
  \exists b : bool. \chpos(\Recv(\Bool(b)) :: \Choose(A,B,b))
\]
Negative Channel Type:
\[
  \forall b : bool. \chneg(\Recv(\Bool(b)) :: \Choose(A,B,b))
\]
$\mono{fserv\_aconj}$ -- checks the ``Tag'' Received on its first
Argument (a Positive Channel $\mono{chp}$) and then determines whether
to offer $\mono{chp}$ as a Channel specified by $A$ or $B$; also
called ``External Choice'' (the Client decides)
%TODO give definition

$!S$ -- \emph{Exponential}-- for a Session Type $S$, $!S$ is a Type
that can be assigned to a Value representing a \emph{Persistent
  Service} specified by $S$:
\[
  \Service(S)
\]
with which Channels of the Type $\chneg(S)$ can be repeatedly created

built-in Function:
\[
  service\_create :
    (\chpos(\sigma) \rightarrow \Unit) \Rightarrow \Service(\sigma)
\]
note that the argument is a Non-linear Function (can be called
repeatedly)

(at this point Xi-Ren-Wu-Blair15 presents some examples, e.g. Sieve of
Eratosthenes, Channel Queues)


\textbf{ATS Session-Typed Channels Implementation}

Implementation in ATS of Dyadic Session-typed Channels


\textbf{Erlang Implementation}

Channels implemented as a pair of Processes: one handles Read for the
Positive Channel and Write for the Negative Dual Channel, the other
handles Read for the Negative Channel and Write for the for the
Positive Dual Channel %TODO verify this is correct?


\endgroup



% --------------------------------------------------------------------
\subsection{B\"ohm Tree}\label{sec:bohm_tree}
% --------------------------------------------------------------------

A \emph{B\"ohm Tree} is a Possibly Infinite Directed Acyclic Graph
where some Vertices are Labelled by $\lambda$-terms and all Vertices
besides the Root have exactly one Parent, every Vertex has a finite
number of Children, and every Unlabelled Vertex has no Children.



% ====================================================================
\section{$\lambda\mu$-calculus}\label{sec:lambda_mu}
% ====================================================================

Classical Logic (\S\ref{sec:classical_logic})

Classical Natural Deduction (\S\ref{sec:natural_deduction})

Operators corresponding to Continuations (\S\ref{sec:continuation})

Reduction Rules:
\begin{itemize}
  \item Logical Reduction
  \item Structural Reduction
  \item Renaming
  \item $\eta$-reduction
\end{itemize}

Confluent (\S\ref{sec:rewrite_confluence}) by the above Rules

\fist Cf. Classical Pure Type Systems (\S\ref{sec:cpts})


Selinger01 \cite{selinger01}: Categorical Semantics
(\S\ref{sec:categorical_semantics}) of (Call-by-name)
$\lambda\mu$-calculus given by Control Categories
(\S\ref{sec:control_category})

$\lambda\mu$-calculus as Internal Language for the Class of Control
Categories

Call-by-name $\lambda\mu$-calculus: Internal Language for Cocontrol
Categories (\S\ref{sec:control_category})

Call-by-value $\lambda\mu$-calculus: Internal Language for Cocontrol
Categories (\S\ref{sec:cocontrol_category})

Syntactic Translations which are mutually Inverse up to Natural
Isomorphism of Types and Equivalence of Terms (cf. Filinski89
Symmetric $\lambda$-calculus) %FIXME

Demand-driven vs. Data-driven Computation; extension of DeMorgan
Duality from Formulas to Proofs %FIXME

Control Constants %FIXME

Translation between Call-by-value and Call-by-name Calculi exchanges
Object and Control Constants, Object and Control Variables, and
reverses Typing Judgements

Translations Preserve Equational Theories and Operational Semantics (a
Term and its Translation Evaluate in the same manner), and given
notions of Observation they also Preserve Observational Equivalence
%FIXME

\begin{align*}
  & \lett\;x^A = M\;\inn\;\lett\;y^B = N\;\inn\;P \\
  & \lett\;y^B = N\;\inn\;\lett\;x^A = M\;\inn\;P
\end{align*}
are not Equivalent in the presence of Side-effects in Call-by-value
Calculi (but are Equivalent in Call-by-name Calculi)

\begin{align*}
  & \lett\;x^A = \mu\alpha^A.
    (\lett\;y^B = \mu\beta^B.P\;\inn\;N)\;\inn\;M \\
  & \lett\;y^B = \mu\beta^B.
    (\lett\;x^A = \mu\alpha^A.P\;\inn\;M)\;\inn\;N
\end{align*}
are not Equivalent in Call-by-name Calculi (but are Equivalent in
Call-by-value Calculi)


\textbf{Typing Rules} (var), (const) (*) (pair) ($\pi_1$) ($\pi_2$)
(app) (abs) (name) ($\mu$) (weaken) %FIXME


\textbf{Syntax}

$\class{B}$ -- Set of Type Constants $\sigma,\tau,\ldots$

$\class{V}$ -- Set of Variables $x,y,\ldots$

$\class{N}$ -- Set of Control Variables (Names) $\alpha,\beta,\ldots$

$\class{K}$ -- Object Constants $c^A,d^B,\ldots$

$\Sigma = (\class{B},\class{K})$ -- Signature

Terms:
\[
  \quad\quad M ::= x \mid c^A \mid * \mid \langle M,N \rangle
    \mid \pi_1 M \mid \pi_2 M \mid M\;N \mid \lambda x^A.M
    \mid [\alpha]M \mid \mu\alpha^A.M
\]

$\mu\alpha^A.M$ -- $\mu$-abstraction (\S\ref{sec:mu_abstraction})

$[\alpha]M$ -- Named Term

Object Context $\Gamma$

Control Context $\Delta$

Typing Judgement $\Gamma \vdash M:A \mid \Delta$

Equation $\Gamma \vdash M = N : A \mid \Delta$ where $\Gamma \vdash M
: A \mid \Delta$ and $\Gamma \vdash N : A \mid \Delta$ are Valid
Typing Judgements


\asterism


informally when a Subterm is Evaluated it can either Return a Value to
its Environment, or it could cause the Control Flow to Jump to some
other part of the Program; a Term containing a Jump may never Return a
Value to its Environment, in which case it can be given the Type
$\bot$ (Empty Type)

$[\alpha]M$ is a prototypical Term of Type $\bot$: it does not Return
anything but passes the Value of $M$ to a Control Variable $\alpha$
instead; in this way $\alpha$ is like a Named Channel and the Value of
$M$ is Sent along the Channel; $M$ is ``Thrown'' to $\alpha$

if $\alpha$ has Type $A$ then Value of Type $A$ can be Thrown to
$\alpha$

$N = \mu\alpha^A.M$ creates a Named Channel $\alpha$ and begins to
Evaluate $M$, and in the process of Evaluating $M$, some Value gets
Thrown to $\alpha$, this Value immediately becomes the Value of the
Term $N$ and the Evaluation of $M$ is not continued; since $\alpha$ is
of Type $A$, $N$ must be of Type $A$ as well; $M$ in a
$\mu$-abstraction has Type $\bot$

Typing Judgement:
\[
  x_1:B_1, \ldots, x_n:B_n \vdash M:A \mid \alpha_1:A_1, \ldots, \alpha_m:A_m
\]
means $M$ is a Well-typed Term with at most $n$ Free Typed Object
Variables and at most $m$ Free Typed Control Variables, i.e. $M$ is a
Function of $n$ Arguments with $m + 1$ possible Result Channels: it
can Return an ordinary Value of Type $A$ or an Exceptional Value
(\S\ref{sec:exception_effect}) of Type $A_i$ on some Channel
$\alpha_i$

Statically Scoped (Calculus of Continuations), not Dynamically Scoped
(Exceptions) %FIXME


\textbf{Classical Disjunction}

one additional Type Constructor:
\begin{flalign*}
  A ::= \cdots \mid A \vee B
\end{flalign*}

two additional Term Constructors:
\begin{flalign*}
  M ::= \cdots \mid [\alpha,\beta]M \mid \mu(\alpha^A,\beta^B).M
\end{flalign*}

Typing Rules: (name'), ($\mu$')


\textbf{Call-by-name Operational Semantics}

\textbf{Call-by-name CPS Semantics}

Continuation-passing Style (CPS)

DeGroote94

Hoffman-Streicher97

Streicher-Reus98: CPS translation as the basis for an Abstract Machine
Model yielding a Stack-based Kriving Machine (???) %FIXME

Categorical Interpretation of Call-by-name Disjunctive
$\lambda\mu$-calculus in a Control Category
(\S\ref{sec:control_category})

\emph{CPS Translation}

Disjunctive $\lambda\mu$-calculus over Signature
$(\class{B},\class{K})$

Target Language: $\lambda^{R\times+}$ -- $\lambda$-calculus with Sum,
Products, and distinguished Type $R$ of Responses %FIXME responses

for each Type $A$ of $\lambda\mu$-calculus, define a pair of Types:
Continuation Type $K_A$ and Computation Type $C_A$ of Type $A$:

(definitions) %FIXME

translations of Control Operators exchange Current Continuations, i.e.
Control Variables of $\lambda\mu$-calculus are (essentially) Variables
of the Target Language that a user of the Source Language has limited
access %FIXME

\emph{Categorical Interpretation of Call-by-name $\lambda\mu$-calculus
  in a Control Category}

Target Language $\lambda^{R\times+}$ can be Interpreted directly in a
Response Category $\cat{C}$

\emph{Categorical Call-by-name Interpretation}:

(interpretation) %FIXME

\textbf{Lemma} if $\cat{P} = R^\cat{C}$ is a Category of Continuations
then the Call-by-name Categorical Interpretation of the
$\lambda\mu$-calculus in $\cat{P}$ coincides with the Interpretation
of the Call-by-name CPS Translation in $R^\cat{C}$

\textbf{Prop.} (\emph{Soundness and Completeness}): Theories Induced
on the $\lambda\mu$-calculus by the Call-by-name Categorical
Interpretation are exactly the Theories Induced by the Call-by-name
CPS Translation

Call-by-name $\lambda\mu$-calculus is an Internal Language for Control
Categories


Standard Form of Typing Judgements %FIXME

for $\lambda\mu$-signature $\Sigma$ and Call-by-name Theory
$\class{T}$, construct Syntactic Control Category
(\S\ref{sec:syntactic_control_category})
$\cat{P}^n_{\Sigma,\class{T}}$ with Objects as Types of the Language
(and Object Constructors given by corresponding Type Constructors) and
Morphisms from $A$ to $B$ named by Valid Standard Form Typing
Judgements $x:A \vdash M:B$. Two Typing Judgements $x:A \vdash M:B$
and $x:A \vdash N:B$ name the same Morphism if $(X:A \vdash M=N:B) \in
\class{T}$


\emph{Axioms of Call-by-name $\lambda\mu$-calculus} %FIXME

Mixed Substitution


\textbf{Call-by-value CPS Semantics}

Disjunctive $\lambda\mu$-calculus over Signature
$(\class{B},\class{K})$

for each Type $A$ of the $\lambda\mu$-calculus, define three Types
$V_A$, $K_A$, $C_A$ of the Target Language, the Types of Values,
Continuations and Computations of Type $A$, resp.:

(definitions) %FIXME

\emph{Categorical Interpretation of Call-by-value $\lambda\mu$-calculus
  in a Cocontrol Category}

Cocontrol Category (\S\ref{sec:cocontrol_category})

Interpret Target Language $\lambda^{R\times+}$ of the CPS Translation
in a Response Category $\cat{C}$

Cocontrol Category $\cat{P}$

(interpretation) %FIXME

\textbf{Lemma} if $\cat{P} = R^\cat{C}$ is a Category of Continuations
then the Call-by-value Categorical Interpretation of the
$\lambda\mu$-calculus in $\cat{P}^{op}$ coincides with the
Interpretation of the Call-by-value CPS Translation in $R^\cat{C}$

\textbf{Prop.} (\emph{Soundness and Completeness}): the Theories
Induced on the $\lambda\mu$-calculus by the Call-by-value Categorical
Interpretation are exactly the Theories Induced by the Call-by-value
CPS Translation

(value grammar) %FIXME

Call-by-value $\lambda\mu$-calculus is an Internal Language for
Cocontrol Categories

Syntactic Cocontrol Category
(\S\ref{sec:syntactic_cocontrol_category})
$\cat{P}^v_{\Sigma,\class{T}}$ %FIXME


\emph{Axioms of Call-by-value $\lambda\mu$-calculus}

(axioms) %FIXME




% --------------------------------------------------------------------
\subsection{$\mu$-abstraction}\label{sec:mu_abstraction}
% --------------------------------------------------------------------

$\mu\alpha^A.M$

$M$ has Type $\bot$

Continuation (\S\ref{sec:continuation}), $\callcc$

``Handler'', ``Catch'' %FIXME



% ====================================================================
\section{Logical Framework}\label{sec:logical_framework}
% ====================================================================

%FIXME

Automath, Isabelle

Dependently-typed $\lambda$-calculus (\S\ref{sec:dependent_lambda})

\begin{enumerate}
  \item Class of Object-logics (???)
  \item Meta-language (\S\ref{sec:metalanguage})
  \item Representation Mechanism for Object-Logics
\end{enumerate}

``Framework = Language + Representation''



% --------------------------------------------------------------------
\subsection{LF}\label{sec:lf}
% --------------------------------------------------------------------

LF (Edinburgh Logical Framework)

Twelf


wiki:

Meta-language -- $\lambda\Pi$ (First-order Dependently-typed
$\lambda$-calculus \S\ref{sec:dependent_lambda}): First-order Minimal
Logic (\S\ref{sec:minimal_logic})

\fist Type-inference is Undecidable %FIXME

Objects of $\lambda\Pi$:
\begin{enumerate}
  \item (Proof) Objects
  \item Types (Propositions)
  \item Families of Types (Type Families ???)
\end{enumerate}

Representation Mechanism: Judgements-as-types (cf. Intuitionistic
Type-theory \S\ref{sec:intuitionistic_type})

Judgements are Represented as the Types of their Proofs

a Logical System (\S\ref{sec:logical_system}) $\class{L}$ is
Represented by its Signature assigning Kinds and Types to a Finite Set
of Constants that Represent its Syntax, Judgements, and Rule Schemes
%FIXME

Object-logic Rules and Proofs are Represented as Primitive Proofs of
Hypothetico-general Judgements:
\[
  \Lambda x:C.J(x) \vdash K
\]

$J \vdash K$ -- Hypothetical (ordinary Function Space
\S\ref{sec:function_type})

$\Lambda x:J.K(x)$ -- General (Dependent Function Space
\S\ref{sec:dependent_function})



% ====================================================================
\section{Pure Type System}\label{sec:pts}
% ====================================================================

(Roorda00) %FIXME

PTS (or \emph{Generalized Type System})

Multi-sorted Type System

Arbitrary number of Sorts and Dependencies

Generalization of the \emph{Lambda Cube} (\S\ref{sec:lambda_cube}) to
more Sorts than Terms and Types

Not necessarily Strongly Normalizing (\S\ref{sec:normalization}), e.g.
System U (\S\ref{sec:system_u})

Dependently-typed $\lambda$-calculus (\S\ref{sec:dependent_lambda})
with a Type of all Types (\S\ref{sec:type_universe})--the simplest
Pure Type System--is not Strongly Normalizing due to Girard's Paradox
(\S\ref{sec:girards_paradox})

\emph{Barendregt-Geuvers-Klop Conjecture}: a Weakly Normalizing PTS
always has the Strong Normalization Property

Programming Languages: SAGE, Yarrow, Henk 2000


\fist ATS (Applied Type System \S\ref{sec:ats}) is a Programming
Language based on the restriction of PTS to prevent arbitrary Programs
from appearing in Types through a strict separation of \emph{Static}
(Type-level) Terms and \emph{Dynamic} (Program-level) Terms -- Xi16
\emph{Applied Type System: An Approach to Practical Programming with
  Theorem-Proving}


System of Natural Deduction (\S\ref{sec:natural_deduction}) for
Dependent Types (\S\ref{sec:dependent_type}) with only the Dependent
Product Type (\S\ref{sec:pi_type}) Formation Rule specified.

Dependent Product as the Type of $\lambda$-expressions:
\[
  \Gamma,x:A \vdash B:C
\]
Implies:
\[
  \Gamma \vdash (\lambda x:A.B):(\Pi x:A.C)
\]


\asterism


wiki:

$(S,A,R)$

$S$ -- Set of \emph{Sorts} (all Constants)

$A \hookrightarrow S \times S$ -- Set of \emph{Axioms} of the form
$c:s$ of Constants $c$ and Sorts $s$

$R \hookrightarrow S \times S \times S$ -- Set of Rules
$(s_1,s_2,s_3)$ on Sorts where Types of Sort $s_2$ may Depend on Types
of Sort $s_1$ with its Dependent Product a Type of Sort $s_3$

Rules $(s_1,s_2,s_2)$ are abbreviated
$(s_1,s_2)$

Axioms describe the Containment of Sorts, e.g. $\star:\square$ (Types
in Kinds)

Rules define the Dependencies between Sorts:
\begin{itemize}
  \item $(\star,\star)$ -- Terms may depend on Terms (Functions
    \S\ref{sec:function_type})
  \item $(\star,\square)$ -- Types may depend on Terms (Dependent
    Types \S\ref{sec:dependent_type})
  \item $(\square,\star)$ -- Terms may depend on Types (Polymorphism
    \S\ref{sec:polymorphic_type})
  \item $(\square,\square)$ -- Types may depend on Types (Type
    Operators \S\ref{sec:type_operator})
\end{itemize}

$(\lambda x:A.f(x)):(\Pi x:A.B):\star$

$(\lambda x:A.B(x)):(\Pi x:A.\star):\square$

$(\Lambda X:\star.f_X):(\Pi X:\star.C):\star$

$(\Lambda X:\star.F(X)):(\Pi X:\star.\star):\square$



% --------------------------------------------------------------------
\subsection{Classical Pure Type System}\label{sec:cpts}
% --------------------------------------------------------------------

Classical Logic (\S\ref{sec:classical_logic})

addition of Double Negation Operator

\fist Cf. $\lambda\mu$-calculus (\S\ref{sec:lambda_mu})



% --------------------------------------------------------------------
\subsection{Modal Pure Type System}\label{sec:mpts}
% --------------------------------------------------------------------

Modal Logic (\S\ref{sec:modal_logic})

Modal Type Theory (\S\ref{sec:modal_type_theory})



% --------------------------------------------------------------------
\subsection{System U}\label{sec:system_u}
% --------------------------------------------------------------------

Non-normalizing, Inconsistent

Girard's Paradox (\S\ref{sec:girards_paradox})

System U$^-$



% --------------------------------------------------------------------
\subsection{Applied Type System}\label{sec:ats}
% --------------------------------------------------------------------

\begingroup

\newcommand{\lam}{\mathsf{lam}}
\newcommand{\app}{\mathsf{app}}
\newcommand{\slam}{\mathsf{slam}}
\newcommand{\sapp}{\mathsf{sapp}}
\renewcommand{\lett}{\mathsf{let}}
\renewcommand{\inn}{\mathsf{in}}
\newcommand{\INT}{\mathsf{int}}
\newcommand{\BOOL}{\mathsf{bool}}
\newcommand{\Int}{\mathsf{Int}}
\newcommand{\Bool}{\mathsf{Bool}}
\renewcommand{\Nat}{\mathsf{Nat}}
\newcommand{\dtree}{\mathscr{D}}

Programming Language based on the restriction of PTS to prevent
arbitrary Programs from appearing in Types through a strict separation
of \emph{Static} (Type-level) Terms and \emph{Dynamic} (Program-level)
Terms -- Xi16 \emph{Applied Type System: An Approach to Practical
  Programming with Theorem-Proving}

Xi16 -- \emph{Applied Type System: An Approach to Practical
  Programming with Theorem-proving} -- Programming with Theorem
Proving (PwTP)

Zhu-Xi05 \emph{Safe Programming with Pointers through Stateful
  Views} -- ATS/SV (\S\ref{sec:ats_sv})) -- Linear Proofs/Propositions

Shi-Xi13 \emph{A Linear Type System for Multicore Programming in ATS}
-- \emph{Viewtypes} (Linear Types \S\ref{sec:viewtype}),
$\mathcal{L}^\parallel_{\forall, \exists}$ -- Parallel Reduction
Calculus with Universally and Existentially Quantified (Polymorphic
and Dependent) Viewtypes and support for Programming with Theorem
Proving

successor of Dependent ML: restricted form of Dependent Types where
\emph{Type Index Expressions} (Statics) are completely separated from
Run-time Expressions (Dynamics); see \emph{Phase Distinction}
(\S\ref{sec:phase_distinction})

Xi07 \emph{Dependent ML}: \emph{Dependent Types} as a form of Types
that correspond to Formulas in some First-order Many-sorted Logic %FIXME

\emph{Datasorts} -- like a Datatype Declaration (ML) but the Declared
``Sort'' is only for classifying \emph{Terms to be used as Indexes}
for forming \emph{Dependent Types}

handling of Nonlinear Constraints through explicit Proof Construction

compared to Theorem-proving systems such as NuPrl, Coq, in ATS Proof
Construction is solely meant for Constraint Simplification and Proofs
contain no Computational meaning; in NuPrl and Coq Proofs are
\emph{Constructive} and meant for supporting \emph{Program Extraction}

\fist Xi-Ren-Wu-Blair15 -- \emph{Session Types in a Linearly typed
  Multi-threaded Lambda-Calculus} -- embedding in ATS

$\lambda_{dyn}$ -- Untyped $\lambda$-calculus
(\S\ref{sec:untyped_lambda}): extended with Constants (incl. Constant
Constructors, Constant Functions): needed to formally assign Dynamic
(Operational) Semantics

ATS$_0$ -- ATS without PwTP

ATS$_{pf}$ -- ATS with PwTP

a \emph{Well-typed Program} in ATS can be turned into one in
$\lambda_{dyn}$ through \emph{Type-erasure} and \emph{Proof-erasure}
and still retain its Dynamic (Operational) Semantics (Curry-style
typing, cf. Church-style)

uses approach to assigning Dynamic (Operational) Semantics to terms
via \emph{Evaluation Contexts}

every \emph{View} (Linear Proof) in ATS defines a kind of Writer
Comonad (Env-comonad \S\ref{sec:comonad}) -- August Alm
\emph{(Co)monads in ATS}
\url{https://groups.google.com/d/msg/ats-lang-users/hvgOGcuBGrc/Mc9WAkblEgAJ}


\textbf{$\lambda_{dyn}$}

\emph{Dynamic Terms} -- Syntax:

\begin{flalign*}
  \quad e ::=&\ x \ |\ dcx(\vec{e}) \ |\ \langle e_1,e_2 \rangle
          \ |\ \fst(e) \ |\ \snd(e) \\
            |&\ \lam\ x.e \ |\ \app(e_1,e_2)
          \ |\ \lett\ x = e_1 \ \inn\ e_2 &
\end{flalign*}

\begin{itemize}
\item $\vec{e}$ -- a possibly empty sequence of Dynamic Terms
\item $dcx$ -- ranges over \emph{External Dynamic Constants}, including:
  \begin{itemize}
    \item $dcc$ -- \emph{Dynamic Constructors}
    \item $dcf$ -- \emph{Dynamic Functions}
  \end{itemize}
\end{itemize}

\emph{Values} -- special forms of Dynamic Terms:
\begin{flalign*}
  \quad v ::=&\ x \ |\ dcc(\vec{v}) \ |\ \langle v_1,v_2 \rangle
          \ |\ \lam\ x.e &
\end{flalign*}

\emph{Primitive Values} -- Values not Constructed by
$\langle-,-\rangle$ or $\lam$

\emph{Evaluation Contexts} -- a Dynamic Term in which a Subterm (only
in certain positions) is replaced with a \emph{Hole} $[]$:
\begin{flalign*}
  \quad E ::=&\ [] \ |\ dcx (v_1,...,v_{i-1}), E, e_{i+1},...,e_n)
          \ |\ \langle E,e \rangle \ |\ \langle v,E \rangle & \\
            |&\ \app(E,e) \ |\ \app(v,E) \ |\ \lett\ x = E \ \inn\ e &
\end{flalign*}

\emph{Redexes} (Reducible Expressions) in $\lambda_{dyn}$:
\begin{itemize}
\item $\fst (\langle v_1,v_2 \rangle)$ is a Redex and its Reduct is
  $v_1$
\item $\snd (\langle v_1,v_2 \rangle)$ is a Redex and its Reduct is
  $v_2$
\item $\app (\lam\ x.e, v)$ is a Redex and its Reduct is $e[x \mapsto
  v]$
\item $dcf (\vec{v})$ is a Redex if it is defined equal to some value
  $v$ in which case its Reduct is $v$
\item new forms of Redexes can have more than one Reduct
\end{itemize}

\emph{One-step Reduction} -- $E[e_1] \rightarrow E[e_2]$: for a
Dynamic Term $E[e_1]$ and some Redex $e_1$, $E[e_1]$ Reduces to
$E[e_2]$ in \emph{one step} if $e_2$ is a Reduct of $e_1$

$\rightarrow^*$ -- Reflexive, Transitive Closure of $\rightarrow$

\emph{Program} -- a Closed Dynamic Term

for a Program $e_0$ in $\lambda_{dyn}$, a Finite Reduction Sequence can
either lead to a Value or a Non-value

\emph{Stuck Form} -- a Non-value Term that cannot be further Reduced

\begin{itemize}
\item Stuck Programs can be Aborted with an Exception
\item the Type System can be developed to Statically (at Compile-time)
  ensure the absence of various Stuck Forms in Well-typed Programs
\end{itemize}


\textbf{ATS$_0$}

\emph{Dynamics} -- extended Untyped $\lambda$-calculus
($\lambda_{dyn}$) where Programs are constructed and Evaluated; Typed
by Static Terms

\emph{Statics} -- Simply-typed $\lambda$-calculus
($\lambda^\rightarrow$ \S\ref{sec:simply_typed}), extended with
certain Constants, where (Dynamic Term) Types are formed and reasoned
about

\emph{Sorts} -- the "Types" of Static Terms



\emph{ATS$_0$ Statics Syntax}

Sorts:
\begin{flalign*}
  \quad \sigma ::=&\ b \ |\ \sigma_1 \rightarrow \sigma_2 &
\end{flalign*}

Static Terms:
\begin{flalign*}
  \quad s ::=&\ a \ |\ scx (s_1,...,s_n)
          \ |\ \lambda a:\sigma.s \ |\ s_1(s_2) &
\end{flalign*}

Static Variable Vontext:
\begin{flalign*}
  \quad \Sigma ::=&\ \varnothing \ |\ \Sigma, a:\sigma &
\end{flalign*}

Static Substitution:
\begin{flalign*}
  \quad \Theta ::=&\ [] \ |\ \Theta[a \mapsto s] &
\end{flalign*}

$b$ -- \emph{Base Sorts}:
\begin{itemize}
\item $bool$ -- Static Booleans
\item $type$ -- (Dynamic Term) Types
\item $int$ -- Static Integers (not required for formalization of
  ATS$_0$)
\end{itemize}

$a$ -- Static Variables

$s$ -- Static Terms

$scx$ -- ranges over (built-in) Static Constants:
\begin{itemize}
\item $scc$ -- Static Constant Constructors
\item $scf$ -- Static Constant Functions
\end{itemize}

\emph{C-sort} -- $(\sigma_1,...,\sigma_n) \Rightarrow b$: can only be
assigned to Static Constants (note C-sorts are not "regular" Sorts)

for a Static Constant $scx$, a Static Term $scx (s_1,...,s_n)$ is of
Sort $b$ if $scx$ is assigned the C-sort $(\sigma_1,...,\sigma_n)
\Rightarrow b$ and each $s_i$ can be assigned Sorts $\sigma_i$ for $i
= 1,...,n$

assumed Static Constants in ATS$_0$:
\begin{flalign*}
  \quad true           :& () \Rightarrow bool & \\
  \quad false          :& () \Rightarrow bool & \\
  \quad \leq_{ty}      :& (type,type) \Rightarrow bool & \\
  \quad *              :& (type,type) \Rightarrow type & \\
  \quad \rightarrow    :& (type,type) \Rightarrow type & \\
  \quad \wedge         :& (bool,type) \Rightarrow type & \\
  \quad \supset        :& (bool,type) \Rightarrow type & \\
  \quad \forall_\sigma :& (\sigma \rightarrow type) \Rightarrow type & \\
  \quad \exists_\sigma :& (\sigma \rightarrow type) \Rightarrow type &
\end{flalign*}

\emph{Type Constructor} -- a Static Constant Constructor $scc$ with a
C-sort $(\sigma_1,...,\sigma_n) \Rightarrow type$; e.g. $*$,
$\rightarrow$, $\wedge$, $\supset$, $\forall_\sigma$, $\exists_\sigma$
above

for \emph{Proposition} $B$ and Type $T$:
\begin{itemize}
\item $B \supset T$ -- \emph{Guarded type}
  (\S\ref{sec:guarded_type}): a Value $v$ assigned a Guarded Type can
  be used if and only if $B$ is Satisfied
\item $B \wedge T$ -- \emph{Asserting Type}: if a Value $v$ of an
  Asserting Type is generated at a point in Program Evaluation, then
  the \emph{Assertion} of $B$ holds at that point
\end{itemize}

$int$ -- Sort for (Static) Integers

$\INT : int \Rightarrow type$ -- Type Constructor of the Sort $int
\Rightarrow type$

$\INT(i:int)$ -- a Singleton Type for the Integer equal to $i$

$\Int = \exists a:int.\INT(a)$ -- Type for (Dynamic) Integers

$\Nat = \exists a:int.(0 <= a) \wedge \INT(a)$ -- Type for (Dynamic)
Natural Numbers

$\BOOL : bool \Rightarrow type$ -- Type Constructor of the Sort $bool
\Rightarrow type$ such that for each Proposition $B:bool$, $\BOOL(B)$
is a Singleton Type for the Truth-value equal to $B$

$\Bool = \exists a:bool.\BOOL(a)$ -- Type for (Dynamic) Booleans

example Type of a \emph{Dynamic assertion}:
\[
  \forall a:bool.\BOOL(a) \rightarrow a \wedge ()
\]
where $()$ is the Unit Type: given a Function $f$ of this Type,
applied to a Boolean Value $v:\BOOL(B)$ for some Proposition $B:bool$,
if $f(v)$ returns then $B$ must be True


\emph{Sorting Rules}

\emph{St-Var}:
\[
  \frac{\Sigma(a) = \sigma}{\Sigma \vdash a:\sigma}
\]

\emph{St-Scx}:
\[
  \frac{\vdash scx:(\sigma_1,...,\sigma_n) \Rightarrow b \quad\quad
    \Sigma \vdash s_1:\sigma_1 \quad\quad \cdots \quad\quad
    \Sigma \vdash s_n:\sigma_n}
  {\Sigma \vdash scx(s_1,...,s_n):b}
\]

\emph{St-Lam}:
\[
  \frac{\Sigma, a:\sigma_1 \vdash s:\sigma_2}
    {\Sigma \vdash \lambda a:\sigma_1.s:\sigma_1 \rightarrow \sigma_2}
\]

\emph{St-App}:
\[
  \frac{\Sigma \vdash s_1:\sigma_1 \rightarrow \sigma_2 \quad\quad
    \Sigma \vdash s_2:\sigma_1}
  {\Sigma \vdash s_1(s_2):\sigma_2 }
\]

$\Sigma; \vec{B} \vDash B_0$ -- \emph{Constraint} where $\Sigma \vdash
B:bool$ holds for each $B$ in $\vec{B}$ and $\Sigma \vdash B_0:bool$
holds

\emph{Constraint Relation} -- determines whether each Constraint is
True or False

\emph{Regularity Rules} (7) for the Constraint Relation %FIXME

\emph{Regularity Conditions} (9) on $\leq_{ty}$ %FIXME


\emph{ATS$_0$ Dynamics Syntax}

\emph{Dynamic terms}:
\begin{flalign*}
  \quad e ::=&\ x \ |\ dcx\{\vec{s}\}(e_1,...,e_n)
          \ |\ \langle e_1,e_2 \rangle
          \ |\ \fst(e) \ |\ \snd(e) \ |\ \lam\ x.e & \\
            |&\ \app(e_1,e_2) \ |\ \supset^+(e) \ |\ \supset^-(e)
          \ |\ \slam\ a.e \ |\ \sapp(e,s) & \\
            |&\ \wedge(e) \ |\ \lett\ \wedge(x) = e_1 \inn\ e_2
          \ |\ \langle s,e \rangle
          \ |\ \lett\ \langle a,x \rangle = e_1 \inn\ e_2 &
\end{flalign*}

\emph{Dynamic Values}:
\begin{flalign*}
  \quad v ::=&\ x \ |\ dcc\{\vec{s}\}(v_1,...,v_n)
          \ |\ \langle v_1,v_2 \rangle
          \ |\ \lam\ x.e \ |\ \supset^+(e)
          \ |\ \slam\ a.e \ |\ \wedge(v) \ |\ \langle s,v \rangle &
\end{flalign*}
where $x$ ranges over Dynamic Variables, $s$ are Static Terms and
$\{\vec{s}\}$ is a possibly empty Sequence of Static Terms, $dcx$
ranges over Dynamic Constants including $dcc$ Dynamic Constant
Constructors and $dcf$ Dynamic Constant Functions

\emph{Dynamic Variable Contexts} -- assign Types to Dynamic Variables:
\begin{flalign*}
  \quad \Delta ::=& \varnothing \ |\ \Delta,x:T &
\end{flalign*}
where $T$ is a Type for Dynamic Terms (i.e. a Static Term of Sort
$type$)

\emph{Dynamic Substitution}:
\begin{flalign*}
  \quad \Theta ::=& [] \ |\ \Theta[x \mapsto e] &
\end{flalign*}


\emph{ATS$_0$ Derivations, Judgements, Proofs}

$\dtree$ -- \emph{Derivation Tree}

$J$ -- \emph{Judgement}

$\dtree :: J$ -- $\dtree$ is a \emph{Derivation} of $J$ (the
Conclusion of $\dtree$ is $J$)

$ht(\dtree)$ -- Height of Derivation Tree representing $\dtree$

$\Sigma;\vec{B};\Delta \vdash e:T$ -- \emph{Typing Judgement} of
Static Variable Context $\Sigma$, zero or more Propositions $B:bool$,
and Dynamic Variable Context $\Delta$

\emph{Typing Rules} (16) %FIXME

\emph{C-type} in ATS$_0$ -- $\forall \vec{a}:\vec{\sigma}.\vec{B}
\supset (T_1,...,T_n) \Rightarrow T$

$\vdash dcx : \forall\vec{a}:\vec{\sigma}.\vec{B} \supset
(T_1,...,T_n) \Rightarrow T$ -- $dcx$ is assumed to have C-type
following; if $dcx$ is a Constructor $dcc$ then $T$ is assumed to have
been \emph{Constructed} by some $scc$ and $dcc$ is said to be
\emph{Associated} with $scc$; e.g. List Constructors, Integer
Addition/Division Functions %FIXME show examples

\emph{Canonical Forms} -- if $\dtree ::
\varnothing;\varnothing;\varnothing \vdash v:T$ then:
\begin{enumerate}
\item if $T = T_1*T_2$ then $v$ is of the form
  $\langle{v_1,v_2}\rangle$
\item if $T = T_1 \rightarrow T_2$ then $v$ is of the form $\lam\ x.e$
\item if $T = B \wedge T_0$ then $v$ is of the form $\wedge(v_0)$
\item if $T = B \supset T_0$ then $v$ is of the form $\supset^+(e)$
\item if $T = \forall a:\sigma.T_0$ then $v$ is of the form
  $\slam\ a.e$
\item if $T = \exists a:\sigma.T_0$ then $v$ is of the form
  $\langle{T,v_0}\rangle$
\item if $T = scc(\vec{s}_1)$ then $v$ is of the form
  $dcc\{\vec{s}_2\}(\vec{v})$ for some $dcc$ associated with $scc$
\end{enumerate}


\emph{ATS$_0$ Call-by-value Dynamic Semantics}

\emph{Evaluation Contexts}:
\begin{flalign*}
  \quad E ::=&\ [] \ |\ dcx\{\vec{s}\}(\vec{v},E,\vec{e})
          \ |\ \langle{E,d}\rangle \ |\ \langle{v,E}\rangle
          \ |\ \app(E,e) \ |\ \app(v,E) & \\
            |&\ \supset^-(E) \ |\ \wedge(E)
          \ |\ \lett\ \wedge(x) = E \ \inn\ e
          \ |\ \sapp(E,s) \ |\ \langle{s,E}\rangle
          \ |\ \lett\ \langle{a,x}\rangle = E \ \inn\ e &
\end{flalign*}

\emph{Redexes and Reducts}:
\begin{itemize}
\item $\fst(\langle{v_1,v_2}\rangle)$ is a Redex with Reduct $v_1$
\item $\snd(\langle{v_1,v_2}\rangle)$ is a Redex with Reduct $v_2$
\item $\app(\lam\ x.e,v)$ is a Redex with Reduct $e[x \mapsto v]$
\item $dcf\{\vec{s}\}(\vec{v})$ is a Redex if it is defined equal to
  some Value $v$, if so then its Reduct is $v$
\item $\supset^-(\supset^+(e))$ is a Redex with Reduct $e$
\item $\sapp(\slam\ a.e,s)$ is Redex with Reduct $e[a \mapsto s]$
\item $\lett\ \wedge(x) = \wedge(v) \ \inn\ e$ is a Redex with Reduct
  $e[x \mapsto v]$
\item $\lett\ \langle{a,x}\rangle = \langle{s,v}\rangle \ \inn\ e$ is
  a Redex with Reduct $e[a \mapsto s][x \mapsto v]$
\end{itemize}

\emph{One-step Reduction}: for Dynamic Terms $e_1$, $e_2$ such that
$e_1 = E[e]$ and $e_2 = E[e']$ for some Redex $e$ and its Reduct $e'$,
$e_1$ Reduces to $e_2$ in \emph{one step}, denoted $e_1 \rightarrow
e_2$

$\rightarrow^*$ -- Transitive Closure of $\rightarrow$

\emph{Thm.} Subject Reduction in ATS$_0$:

\emph{Assume $\dtree :: \Sigma;\vec{B};\Delta \vdash e:T$ and $e
  \rightarrow e'$; then $\Sigma;\vec{B};\Delta \vdash e':T$ is also
  derivable.}


\emph{Thm.} Progress in ATS$_0$:

\emph{Assume $\dtree :: \varnothing;\varnothing;\varnothing \vdash
  e:T$; then either $e$ is a Value or $e \rightarrow e'$ holds for
  some Dynamic Term $e'$.}

\emph{Type Soundness} -- (Meta-property): by Progress and Subject
Reduction Theorems, for each \emph{Closed, Well-typed Dynamic Term}
$e$, either $e \rightarrow^* v$ holds for some Value $v$ \emph{or}
there is an \emph{Infinite Reduciton Sequence} starting from $e$: $e =
e_0 \rightarrow e_1 \rightarrow e_2 \rightarrow \cdots$; i.e. each
Well-typed Program in ATS$_0$ either reaches a Value or else runs
forever (cannot get \emph{Stuck})

$||e||$ -- \emph{Type Erasure} on Dynamic Terms: maps each Dynamic
Term in ATS$_0$ to an Untyped Dynamic Term in $\lambda_{dyn}$; to
ensure that Values in ATS$_0$ are mapped to Values in $\lambda_{dyn}$
requires the Syntactic \emph{Value-form Restriction}:
\begin{enumerate}
\item only when $e$ is a Value can $\supset^+(e)$ be formed
\item only when $e$ is a Value can $\slam\ a.e$ be formed
\end{enumerate}
and as a result $||v||$ is a Value in $\lambda_{dyn}$ for every Value
$v$ in ATS$_0$

\begin{itemize}
\item note it is possible for a Non-value Term $e$ in ATS$_0$ to have
  a Type Erasure resulting in a Value Term in $\lambda_{dyn}$
\item Type Erasure cannot alter the Dynamic Semantics of ATS$_0$
\end{itemize}


\textbf{ATS$_{pf}$}

ATS$_0$ extended with support for PwTP

Programming with Theorem Proving (PwTP): a Programming Paradigm for
\emph{Internalizing} Constraint Solving %FIXME xref constraint solving

additional Base Sort: $prop$ -- Static Terms representing Types for
\emph{Proofs}

additional Static Constants:
\begin{flalign*}
  \quad \leq_{pr}      :& (prop,prop) \Rightarrow bool & \\
  \quad *              :& (prop,prop) \Rightarrow prop & \\
  \quad *              :& (prop,type) \Rightarrow type & \\
  \quad \rightarrow    :& (prop,prop) \Rightarrow prop & \\
  \quad \rightarrow    :& (prop,type) \Rightarrow type & \\
  \quad \wedge         :& (bool,prop) \Rightarrow prop & \\
  \quad \supset        :& (bool,prop) \Rightarrow prop & \\
  \quad \forall_\sigma :& (\sigma \rightarrow prop) \Rightarrow prop & \\
  \quad \exists_\sigma :& (\sigma \rightarrow prop) \Rightarrow prop \\
\end{flalign*}
\fist note that some of these Symbols are Overloaded

Functions are allowed to be formed from:
\begin{itemize}
\item $prop \rightarrow prop$
\item $prop \rightarrow type$
\item $type \rightarrow type$
\end{itemize}
but not $type \rightarrow prop$

some Dynamic constructs from ATS$_0$ need to be ``split'' in
ATS$_{pf}$ for these different cases:
\begin{itemize}
\item $\langle{e1,e2}\rangle$ is split into:
  \begin{itemize}
    \item $\langle{e1,e2}\rangle_{pp}$ -- $prop$-$prop$ pairs
    \item $\langle{e1,e2}\rangle_{pt}$ -- $prop$-$type$ pairs
    \item $\langle{e1,e2}\rangle_{tt}$ -- $type$-$type$ pairs
  \end{itemize}
\item $\lam\ x.e$ is split into:
  \begin{itemize}
    \item $\lam_{pp}\ x.e$ -- $prop$-$prop$ functions
    \item $\lam_{pt}\ x.e$ -- $prop$-$type$ functions
    \item $\lam_{tt}\ x.e$ -- $type$-$type$ functions
  \end{itemize}
\item $app(e1,e2)$ is split into:
  \begin{itemize}
    \item $\app_{pp}(e1,e2)$ -- $prop$-$prop$ applications
    \item $\app_{pt}(e1,e2)$ -- $prop$-$type$ applications
    \item $\app_{tt}(e1,e2)$ -- $type$-$type$ applications
  \end{itemize}
\end{itemize}

\emph{Dynamic Variable Contexts} of ATS$_{pf}$:
\begin{flalign*}
  \Delta ::=&\ \varnothing \ |\ \Delta,x:T^* &
\end{flalign*}

where $T^*$ is either a $type$ or a $prop$

$\leq_{ty}$ \emph{Regularity Condition} extensions (2) %FIXME

\fist note there are no Regularity Conditions on $prop$s, as Proofs
have no \emph{Computational} meaning in ATS$_{pf}$


\emph{ATS$_{pf}$ Static Constants}:
\begin{flalign*}
    \wedge         :& (bool,bool) \Rightarrow bool & \\
    \supset        :& (bool,bool) \Rightarrow bool & \\
    \forall_\sigma :& (\sigma \rightarrow bool) \Rightarrow bool & \\
    \exists_\sigma :& (\sigma \rightarrow bool) \Rightarrow bool &
\end{flalign*}
\fist note the above Symbols corresponding to Static constants are all
Overloaded

$B$ -- a Static Term of Sort $bool$

$P$ -- a Static Term of Sort $prop$

correspondences with $prop$ Predicates/Constructors: *FIXME*

a Proof of $P$ can be constructed in ATS$_{pf}$ to ``attest to the
\emph{Validity}'' of the Boolean Term encoded by $P$


\emph{ATS$_{pf}$ Typing Rules}

\begin{enumerate}
\item \emph{P-typing Rules} -- assigns $prop$s to Dynamic Terms
  (encoding Proofs)
\item \emph{T-typing Rules} -- assigns $type$s to Dynamic Terms (to be
  Evaluated)
\end{enumerate}

the Typing Rules for ATS$_{pf}$ are the same as ATS$_0$ except:
\begin{itemize}
\item replace $T$ with $T^*$
\item the Premises of P-typing Rules are required to be P-typing Rules
  themselves
\end{itemize}


\emph{ATS$_{pf}$ Proof Erasure}

\emph{Proof Erasure} -- translation of each Dynamic Term from
ATS$_{pf}$ to a Dynamic Term in ATS$_0$ preserving the Dynamic
(Call-by-value) Semantics

for a Sort $\sigma$, the Proof-erasure $|\sigma|$ is one in which
every occurrence of $prop$ in $\sigma$ is replaced with $bool$

for a Static Variable Context $\Sigma$, the Proof-erasure $|\Sigma|$
is obtained by replacing each Declaration $a:\sigma$ with $a:|\sigma|$

for a Static Constant $scx$ of C-sort $(\sigma_1,...,\sigma_n)
\Rightarrow \sigma$, the Proof-erasure $|scx|$ is of C-sort
$(|\sigma_1|,...,|\sigma_n|) \Rightarrow |\sigma|$; *note* it is
possible that $|scx_1| = |scx_2|$ for two different Constants $scx_1$
and $scx_2$

$|-|_p$ -- maps a given Dynamic Variable Context $\Delta$ to a
sequence of Boolean Terms

$|\Delta|_p$ -- a sequence of Boolean Terms $\vec{B}$ such that each
$B$ in $\vec{B}$ is $|P|$ for some $a:P$ Declared in $\Sigma$

$|-|_t$ -- maps a given Dynamic Variable Context $\Delta$ to (another)
Dynamic Variable Context

$|\Delta|_T$ -- a Dynamic Variable Context such that each Declaration
is of the form $a:|T|$ for some $a:T$ Declared in $\Sigma$

\emph{Lemma} (Constraint Internalization):

\emph{Assume the Typing Judgement $\Sigma;\vec{B};\Delta |- e:P$ is
  derivable in ATS$_{pf}$; then the Constraint
  $|\Sigma|;|\vec{B}|;|\Delta|_p \vDash |P|$ holds}

for a C-type assigned to a Dynamic Proof Constant of the form $\forall
\Sigma.\vec{B} \supset (\vec{P}) \Rightarrow P_0$, it is assumed the
Constraint:
\[
  \varnothing;\varnothing \vDash
     \forall|\Sigma|.|\vec{B}| \supset (|\vec{P}| \supset |P_0|)
\]
holds in ATS$_0$

for a C-type $CT$ in ATS$_{pf}$ of the form $\forall \Sigma.\vec{B}
\supset (\vec{P},T_1,...,T_n) \Rightarrow T_0$, the C-type $|CT|$ in
ATS$_0$ is defined as:
\[
  \forall |\Sigma|.|\vec{B}| \supset (|\vec{P}| \supset
    ((|T_1|,...,|T_n|) \Rightarrow |T_0|))
\]

\emph{Thm.} 4.1

\emph{Assume that $\Sigma;\vec{B};\Delta \vdash e:T$ is derivable in
  ATS$_{pf}$. Then $|\Sigma|;|\vec{B}|,|\Delta|_p;|\Delta|_t \vdash
  |e|:|T|$ is derivable in ATS$_0$}

by Theorem 4.1, the Proof-erasure of a Program is Well-typed in
ATS$_0$ if it is Well-typed in ATS$_{pf}$


\emph{Relation between $prop$ and $bool$}

$prop$ may be seen as an \emph{Internalized} version of $bool$: given
a Static Term $B:bool$, its Truth-value is determined by a Constraint
Solver \emph{outside} ATS$_{pf}$; given a Static Term $P:prop$, a
Proof of $P$ can be constructed \emph{inside} ATS$_{pf}$ to attest the
\emph{Validity} of the Boolean Term \emph{encoded} by $P$

\emph{example} -- a \emph{Static Predicate}:
\begin{verbatim}
  stacst fact_b : (int,int) -> bool
  praxi fact_b_bas () : [fact_b(0,1)] unit_p
  praxi fact_b_ind {n:int}{r:int} ()
    : [0 <= n && fact_b(n,r) ->> fact_b(n+1, (n+1)*r)] unit_p
\end{verbatim}
*FIXME* $->>$ implication or typo??? \\
is equivalent to the ``$\mono{dataprop}$'':
\begin{verbatim}
  dataprop fact_p (int,int) =
    | fact_p_bas (0,1) of ()
    | {n:nat}{r:int} fact_p_ind (n+1, (n+1)*r) of fact_p(n,r)
\end{verbatim}
where $\mono{unit\_p}$ is the Unit $prop$ encoding the Truth-value
$true$

a verified implementation of Factorial Function using Static Predicate
(no explicit use of Proofs):
\begin{verbatim}
    fun f_fact_b {n:nat} (n:int n) : [r:int] (fact_b (n,r) && int r) =
      loop (0,1) where {
      prval () = $solver_assert (fact_b_bas)
      prval () = $solver_assert (fact_b_ind)
      fun loop {i:nat | i <= n} {r:int | fact_b (i,r)} (
        i:int i, r:int r
      ) : [r:int] (fact_b (n,r) && int r) =
        if i < n then loop (i+1, (i+1)*r) else r
    }
\end{verbatim}

\fist note the Constraints generated by Type-checking the above code
cannot be solved by the built-in Constraint Solver ATS (they must be
exported to be handled by an external Constraint Solver such as one
based on the Z3 Theorem Prover) %FIXME clarify

a verified implementation of Factorial Function using
$\mono{dataprop}$ (explicit use of Proofs):
\begin{verbatim}
  fun f_fact_p {n:nat} (n: int n) : [r:int] (fact_p (n,r) | int r) =
    loop (fact_p_bas() | 0(*i*), 1(*r*)) where {
    fun loop {i:nat | i <= n} {r:int} (
      pf : fact_p (i,r) | i:int i, r:int r
    ) : [r:int] (fact_p (n,r) | int r) =
      if i < n then
        loop (fact_p_ind (pf) | i+1, (i+1)*r)
      else
        (pf | r)
  }
\end{verbatim}

a \emph{Proof} in ATS$_{pf}$ can be \emph{Non-constructive} since
Proofs are not expected to have any Run-time meaning


\endgroup



\subsubsection{ATS/SV}\label{sec:ats_sv}

\begingroup

\newcommand{\addr}{\mathsf{addr}}
\newcommand{\ptr}{\mathbf{ptr}}
\newcommand{\bool}{\mathbf{bool}}
\newcommand{\intt}{\mathbf{intt}}
\renewcommand{\unit}{\mathbf{1}}

Zhu-Xi05 -- \emph{Safe Programming with Pointers through Stateful
  Views} -- (\emph{Note}: this paper was written for an earlier
version of ATS than the implementation described in \S\ref{sec:ats})

\fist cf. approaches of Floyd-Hoare Logic (\S\ref{sec:hoare_logic}),
Model Checking (\S\ref{sec:model_checking})

Views (\S\ref{sec:view})

\fist see also (Shi-Xi13) Viewtypes (\S\ref{sec:viewtype}): a pair of
a Linear Proof and a (Non-linear) Value

\fist \emph{Note}: the following assumes that every Value takes one
``Memory Unit'' to Store, e.g. ``Boxed'' Values

\emph{Stateful Views}

$T@L$ -- the (Stateful) View indicating that a Value of Type $T$ is
stored at Address $L$; \emph{this is the only form of a Primitive View
  and all other Views are built on top of such Primitive Views}

a Stateful View can be assigned to Proof Terms of Stateful Views

Proofs of Views are treated as \emph{Resources} (cf. Linear Types
\S\ref{sec:linear_type}) which can be \emph{Consumed} and
\emph{Generated}

example Functions:
\begin{flalign*}
  \quad & getVar   &:\ & \forall a:\type.\forall l:\addr
    .(a@l \ |\ \ptr(l)) \rightarrow (a@l \ |\ a) \\
  \quad & setVar   &:\ & \forall a_1:\type.\forall a_2:\type.\forall l:\addr
    .(a_1@l \ |\ a_2, \ptr(l)) \rightarrow (a_2@l \ |\ \unit) \\
  \quad & allocVar &:\ & \unit \rightarrow \exists l:\addr
    .(\top @ l \ |\ \ptr(l)) \\
  \quad & freeVar  &:\ & \forall a:\type.\forall l:\addr
    .(a@l \ |\ \ptr(l)) \rightarrow \unit
\end{flalign*}
where $\ptr(L)$ is the Singleton Type for a Pointer pointing to a
given Address $L$ and every Type is a Subtype of the Top Type $\top$

$:=$ -- $setVar$

$!$ -- $getVar$

some Proofs can be Generated and Consumed Implicitly


\textbf{ATS/SV Statics Syntax}

%FIXME: grammar

for each Sort $\sigma$, one can form the Proposition:
\[
  s_1 =_\sigma s_2
\]
if $s_1$ and $s_2$ are Static Terms of Sort $\sigma$

$a$ -- Static Variables

$l$ -- Address Constants $\mathbf{l}_0, \mathbf{l}_1, \ldots$

$b$ -- Boolean Values $true$, $false$

$i$ -- Integers $\ldots, -1, 0, 1, \ldots$

$s$ -- Static Terms

$\vec{s}$ -- a Sequence of Static Terms

$\delta(\vec{s})$ -- Primitive Types; e.g. $\top$, $\unit$, $\ptr(L)$
(Singleton ``Pointer'' Type), $\bool(P)$ (Singleton Boolean Type),
$\intt(I)$ (Singleton Integer Type)

$\Sigma \vdash s : \sigma$ -- the Static Term $s$ can be assigned the
Sort $\sigma$ under $\Sigma$ %FIXME: context, environment, assumptions?

$L$ -- Static Term of Sort $addr$

$P$ -- Static Term of Sort $bool$

$I$ -- Static Term of Sort $int$

$T$ -- Static Term of Sort $type$

Primitive Functions $c_P$, $c_I$, etc.

$L + I$ -- an Address equal to $\mathbf{l}_{n+i}$ if $L =
\mathbf{l}_n$ and $I = i$ and $0 \leq n + i$

$ST$ -- \emph{State}: a Finite Mapping from Addresses to Values with
Domain $dom(ST)$

$ST(l) = v$ -- the Value $v$ is \emph{Stored} at (Address) $l$

$ST_1 \otimes ST_2$ -- Union of $ST_1$ and $ST_2$ \emph{if} $dom(ST_1)
\cap dom(ST_2) = \varnothing$

$ST : V$ -- the State $ST$ ``meets'' the View $V$

$V$ -- \emph{Stateful Views}:
\[
  V ::= \top \ |\ T@L \ |\ \overline{\delta}(\vec{s})
    \ |\ V_1 \multimap V_2 \ |\ V_1 \otimes V_2
\]

$\overline{P}, \overline{T}, \overline{V}$ -- Sequences of
Propositions, Types and Views, resp.

$\top$ -- the \emph{Empty View}: ``met'' by the Empty State (the State
$ST$ such that $dom(ST) = \varnothing$)

$T@L$ -- \emph{Primitive View}: ``met'' by the State that maps Address
$L$ to a Value of Type $T$

$V_1 \otimes V_2$ -- ``met'' by a State $ST$ if $ST = ST_1 \otimes
ST_2$ for some $ST_1 : V_1$ and $ST_2 : V_2$

$V_1 \multimap V_2$ -- ``met'' by a State $ST$ if $ST_1 \otimes ST$
``meets'' $V_2$ for \emph{any} State $ST_1 : V_1$ such that
$dom(ST_1) \cap dom(ST) = \varnothing$

$\overline{\delta}$ -- a \emph{View Constructor}

$\vdash \overline{\delta} (\sigma_1, \ldots, \sigma_n)$ -- indicates
that Applying $\overline{\delta}$ to Static Terms $s_1 : \sigma_1,
\ldots, s_n : \sigma_n$ \emph{Generates} a View $\overline{\delta}
(s_1, \ldots, s_n)$

$c$ -- Proof Constructors with each $\overline{\delta}$ which are
assigned View of the form $\forall\Sigma, \overline{P}.(\overline{V})
\multimap \overline{\delta}(\vec{s})$ (e.g. $arrayView(T,I,L)$ and
associated Proof Constructors $ArrayNone$ and $ArraySome$) %FIXME

$(\overline{V} \ |\ T) \rightarrow CT$ -- Type for Dynamic Functions
that can be Applied to Values of Type $T$ \emph{only if} the Current
State (when the Application occurs) ``meets'' the Views $\overline{V}$
\emph{and} such an Application yields a Dynamic Term that can be
assigned the Computation Type $CT$ of the Form $\exists\Sigma',
\overline{P}'.(\overline{V}' \ |\ T')$, i.e. the Dynamic Term is
expected to Evaluate to a Value $v$ at a certain State $ST$ such that
for some Static Substitution $\Theta$ each Proposition in
$\overline{P}'[\Theta]$ is \emph{True}, $v$ is of Type $T'[\Theta]$
and $ST$ ``meets'' $V'[\Theta]$ %FIXME clarify

$T_1 \rightarrow T_2$ -- shorthand for a ``\emph{Stateless Function
  Type}'':
\[
  (\varnothing \ |\ T_1) \rightarrow \exists
    \varnothing,\varnothing.(\varnothing \ |\ T_2)
\]

$P \supset T$ -- Guarded Type (\S\ref{sec:guarded_type})

$P \wedge T$ -- Asserting Type (???) %FIXME


\emph{Constraints} (needed to define Type Equality):

$\Sigma; \overline{P} \vDash P$ -- \emph{Persistent Constraint}
(Intuitionistic Logic)

$\Sigma; \overline{P}; \overline{V} \vDash V$ -- \emph{Ephemeral
  Constraint} (Intuitionistic Linear Logic)

(Rules for Ephemeral Constraints) %FIXME


\emph{Subtyping}:

$\leq_{tp}$ -- Subtype Relation on Sort $type$

$=_{tp}$ -- Type Equality:
\[
  T_1 \leq_{tp} T_2 \wedge T_2 \leq_{tp} T_1
\]

$\Sigma; \overline{P} \vDash T_1 \leq_{tp} T_2$ -- Subtype Judgement

(\emph{Subtype Rules}) %FIXME

$(ext)$ -- Frame Rule (Separation Logic \S\ref{sec:separation_logic})

all Types are a Subtype of $\top$


Example $arrayView$:
\begin{verbatim}
  dataview arrayView (type, int, addr) =
    | {a:type, l:addr}
      ArrayNone (a,0,l)
    | {a:type, n:nat, l:addr}
      ArraySome (a,n+1,l) of (a@l, arrayView (a, n, l+1))
\end{verbatim}
where the two View Proof Constructors $ArrayNone$ and $ArraySome$ are
given the following ``Functional'' Views:
\begin{flalign*}
  \quad & ArrayNone &:
    \ & \forall a:type.\forall l:addr.() \multimap arrayView(a,0,l) \\
  \quad & ArraySome &:
    \ & \forall a:type.\forall l:addr.\forall n:nat
      .(a@l, arrayView(a,n,l+1)) \multimap arrayView(a,n+1,l)
\end{flalign*}

\fist Note in ATS2 (ATS Postiats) $\mathtt{array\_v}$ is defined as a
$\mathtt{viewdef}$:
\begin{verbatim}
  viewdef array_v (a:viewt@ype, l:addr, n:int) = @[a][n] @ l
\end{verbatim}

(example: singly-linked list)

(example: cyclic buffer)



\endgroup



% ====================================================================
\section{Dependent Type Theory}\label{sec:dependent_type_theory}
% ====================================================================

Dependent Types (\S\ref{sec:dependent_type})

Dependently-typed $\lambda$-calculus (\S\ref{sec:dependent_lambda})

By Curry-Howard Isomorphism Dependent Types correspond to Propositions
of First-order Predicate Logic (\S\ref{sec:firstorder_logic})


\textbf{Categorical Semantics} (\S\ref{sec:categorical_semantics})

Categorical Model (\S\ref{sec:categorical_model})

Comprehension Category (\S\ref{sec:comprehension_category}),
Contextual Category (\S\ref{sec:contextual_category})

Interpretation of Judgements of Dependent Type Theory in a given
Category $\cat{C}$ with Finite Limits (\S\ref{sec:finite_limit})

Codomain Fibration (\S\ref{sec:codomain_fibration}):
\[
  cod:\cat{C}^I \rightarrow \cat{C}
\]

Classifying Functor (Grothendieck Construction
\S\ref{sec:grothendieck_construction}):
\[
  \chi : \cat{C}^{op} \rightarrow \cat{Cat}
\]
sends an Object in $\cat{C}$ to the Slice Category
(\S\ref{sec:slice_category}) over it:
\[
  \chi = \Gamma \mapsto \cat{C}/\Gamma
\]
and sends a Moprhism $f : \Gamma \rightarrow \Gamma'$ to the Pullback
(\S\ref{sec:pullback})/Base Change (\S\ref{sec:base_change}) Functor:
\[
  f^* : \cat{C}/\Gamma' \rightarrow \cat{C}/\Gamma
\]


\textbf{Rules}

Rules for choices ``$[xyz]$'' associating every String ``$xyz$'' of
Symbols in Type Theory with Objects and Morphisms in $\cat{C}$: a
collection of such choices following the Rules is an Interpretation (a
choice of Categorical Semantics) of the Type Theory in the Category
$\cat{C}$.

\emph{Contexts and Type Judgements}:
\begin{enumerate}
  \item $[()] := *$ -- Empty Context $()$ is Interpreted as the
    Terminal Object $*$ of $\cat{C}$
  \item For Context $\Gamma$ with Interpretation $[\Gamma] \in
    \cat{C}_0$, a Judgement $\Gamma \vdash A\type$ is Interpreted
    as an Object in the Slice Category over $\Gamma$:
    \[
      [\Gamma \vdash A\type] \in (\cat{C}/\Gamma)_0
    \]
    giving a choice of Morphism:
    \[
      [\Gamma \vdash A\type] : [(\Gamma,x:A)] \rightarrow [\Gamma]
    \]
  \item For Judgement $\Gamma \vdash A\type$ Interpreted as $[\Gamma
    \vdash A\type]$ above, an Extended Context $(\Gamma,x:A)$ is
    Interpreted as the Domain Object $[(\Gamma,x:A)]$ of the above
    choice of Morphism
\end{enumerate}

\emph{Terms}

For Context $\Gamma$ and Judgement $\Gamma \vdash A\type$ with chosen
Interpretation $[\Gamma \vdash A\type] : [(\Gamma,x:A)] \rightarrow
[\Gamma]$, a Judgement $\Gamma \vdash a:A$ is Interpreted as a Section
(\S\ref{sec:section}) of $[\Gamma \vdash A\type]$, equivalently as a
Morphism in $\cat{C}/\Gamma$:
\[
  [\Gamma \vdash a:A]: * \rightarrow [\Gamma,x:A]
\]
giving a Commuting Triangle:
\[
  1_{[\Gamma]} = [\Gamma \vdash A\type] \circ [\Gamma \vdash a:A]
\]

\emph{Variables}

\emph{Substitution}



% --------------------------------------------------------------------
\subsection{Ornament}\label{sec:ornament}
% --------------------------------------------------------------------

\cite{mcbride13}

Algebraic Ornament (\S\ref{sec:algebraic_ornament})

Ornamental Algebra

Dependent Types: ``axis'' of Indexing for Data Structures

Datatype of Datatype Descriptions (\emph{Universe}: Martin-L\"of84)

Refinement Types (\S\ref{sec:refinement_type}): Decoration with
``Logical Data''; Ornaments ``Decorate'' with additional ``Non-logical
Data'' %FIXME



\subsubsection{Algebraic Ornament}\label{sec:algebraic_ornament}

Type Refinement (\S\ref{sec:refinement_type}) Induced by Algebras over
a Datatype's Structure



% ====================================================================
\section{Intuitionistic Type Theory}\label{sec:intuitionistic_type}
% ====================================================================

\cite{martinlof84}

\emph{Intuitionistic Type Theory} (also \emph{Constructive Type
  Theory} or \emph{Martin-L\"of Type Theory})

Calculus of Constructions (\S\ref{sec:coc})

NuPrl -- Martin-L\"of Type Theory is expressive but Type-checking
requires more Theorem Proving (Zhu-Xi05) %FIXME

Dependent Type Theory (\S\ref{sec:dependent_type_theory})

Inductive Types (\S\ref{sec:inductive_type})

Predicative (Parametric) Polymorphism
(\S\ref{sec:predicative_polymorphism})

Modelled by Locally Cartesian Closed Category
(\S\ref{sec:locally_cartesian})

Extensional Martin-L\"of Type Theory: Internal Language
(\S\ref{sec:internal_logic}) for Cartesian Closed Quasi-categories
(\S\ref{sec:quasicategory})

Formation: the Context in which the Type is defined

Introduction: rules for Construction

Elimination: rules for De-construction

Computation: ???

Four forms of Judgements:
\begin{description}
  \item [Well-formed Type]: $A$ is a Set, $A$ is a Proposition, $A$ is
    an Expectation, $A$ is a Task; Types (encodes Syntax of Formulas
    ``A is a Proposition''; note some Formulas are only Well-formed if
    certain Judgements are Derivable \cite{thompson99}):
    \[
      A \text{ type}
    \]
  \item [Equality of Types]: $A$ and $B$ are Equal Sets:
    \[
      A \equiv B \text{ type}
    \]
  \item [Well-formed Term of Type]: $a$ is an Element of $A$, $a$ is a
    Proof of $A$, $a$ is a Realization of $A$, $a$ is a Method for
    doing $A$:
    \[
      a : A
    \]
  \item [Equality of Terms]: $a$ and $b$ are Equal Elements of Set $A$:
    \[
      a \equiv b : A
    \]
\end{description}

Dependent Type (\S\ref{sec:dependent_type}):
\[
  (x:A)B
\]
Removal of Dependency by Substitution:
\[
  [x/a]B
\]
Abstracted Object:
\[
  [x]b
\]
Removal of Abstration on Object:
\[
  b[x/a]
\]
Well-formed Context of Typing Assumptions
(\S\ref{sec:typing_assumption}):
\[
  \vdash \Gamma \textsf{ Context}
\]
Context (\S\ref{sec:type_context}) Judgements:
\begin {itemize}
\item Well-formed Type $\sigma$:
  \[
    \Gamma \vdash \sigma \mathsf{ Type}
  \]
\item Well-formed Term $t$ of Type $\sigma$:
  \[
    \Gamma \vdash t : \sigma
  \]
\item Type Equivalence:
  \[
    \Gamma \vdash \sigma \equiv \tau
  \]
\item Term Equivalence:
  \[
    \Gamma \vdash t \equiv u : \sigma
  \]
\end {itemize}
\hfill\\
Type Universe:
\[
  \class{U}
\]
Dependent Type mapping Objects to Types:
\[
  \textrm{El}
\]

Definitional Equality (\S\ref{sec:proof_equality})

Structural Rules (\S\ref{sec:structural_rule})



\textbf{Identity Types} (\S\ref{sec:equality_type})
\\
Identity Type Introduction:
\[
  \frac{
    \Gamma \vdash m : A
  }{
    \Gamma \vdash refl_A(m) : Id_A(m,m)
  } (Id_A\text{-I})
\]
Identity Type Elimination:
\[
  \frac{
    \Gamma \vdash p : Id_A (m,n) \quad
    \Gamma, x:A, y:A, z : Id_A(x,y) \vdash C_{x,y,z} \text{ type}\quad
    \Gamma, x : A \vdash q : [x, x, refl_A(x)/x,y,z]C
  }{
    \Gamma \vdash refl_A(m) : Id_A(m,m)
  } (Id_A\text{-E})
\]
\textbf{Dependent Product Types} (\S\ref{sec:pi_type})
\\
Logical Implication and Universal Quantification
\\
Dependent Product Formation:
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma, x:A \vdash B \text{ type}
  }{
    \Gamma \vdash (\Pi x:A) B \text{ type}
  } (\Pi\text{-F})
\]
Dependent Product Introduction:
\[
  \frac{
    \Gamma, x : A \vdash m_x : B_x \quad
  }{
    \Gamma \vdash (\lambda x:A.m_x : B_x) : (\Pi x:A) B
  } (\Pi\text{-I})
\]
Dependent Product Elimination:
\[
  \frac{
    \Gamma \vdash m : (\Pi x:A) B \quad
    \Gamma \vdash n : A
  }{
    \Gamma \vdash m\;n : [n/x]B
  } (\Pi\text{-E})
\]
Dependent Product Computation (cf. $\beta$-reduction
\S\ref{sec:beta_reduction}):
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma , x : A \vdash m : B
  }{
    \Gamma \vdash (\lambda x : A.m)\;n \equiv [n/x]m : [n/x]B
  } (\Pi\text{-C})
\]


\textbf{Dependent Sum Types} (\S\ref{sec:sigma_type})
\\
Logical Conjunction and Existential Quantification
\\
Dependent Sum Formation:
\[
  \frac{
    \Gamma \vdash A \text{ type} \quad
    \Gamma, x : A \vdash B_x \text{ type}
  }{
    \Gamma \vdash (\Sigma x:A) B_x \text{ type}
  } (\Sigma\text{-F})
\]
Dependent Sum Introduction:
\[
  \frac{
    \Gamma \vdash m : A \quad
    \Gamma \vdash n : [m/x]B
  }{
    \Gamma \vdash (m,n) : (\Sigma x:A) B_x
  } (\Sigma\text{-I})
\]
Dependent Sum Elimination 1:
\[
  \frac{
    \Gamma \vdash m : (\Sigma x:A) B_x
  }{
    \Gamma \vdash \pi_1\;m : A
  } (\Sigma\text{-E$_1$})
\]
Dependent Sum Elimination 2:
\[
  \frac{
    \Gamma \vdash m : (\Sigma x:A) B_x
  }{
    \Gamma \vdash \pi_2\;m : B[\pi_1\;m/x]
  } (\Sigma\text{-E$_2$})
\]
\textbf{Binary Sum Types} (\S\ref{sec:sum_type})
\\
Disjunction
\\
Binary Sum Introduction 1:
\[
  \frac{
    \Gamma \vdash m : A
  }{
    \Gamma \vdash inl(m) : A + B
  } (+\text{-I}_1)
\]
Binary Sum Introduction 2:
\[
  \frac{
    \Gamma \vdash n : B
  }{
    \Gamma \vdash inr(n) : A + B
  } (+\text{-I}_2)
\]
Binary Sum Elimination:
\[
  \frac{
    \Gamma \vdash m : A + B \quad
    \Gamma, z : A + B \vdash C \text{ type} \quad
    \Gamma, x : A \vdash n : [inl(x)/z]C \quad
    \Gamma, y : B \vdash p : [inr(y)/z]C
  }{
    \Gamma \vdash case (m, x\;n, y\;p) : [m/z]C
  } (+\text{-E})
\]



Categorical Model, ``Category with Families'':

\begin{itemize}
  \item Category $\mathsf{C}$ of Contexts: Objects are Contexts,
    Morphisms are Substitutions
  \item Functor $T : \mathsf{C}^{op} \rightarrow \mathbf{Fam(Set)}$
    where $\mathbf{Fam(Set)}$ is the Category of Families
    (\S\ref{sec:family}) of Sets where Objects are Pairs $(A,B)$ of an
    Index Set $A$ and a Function $B: X \rightarrow A$ and Morphisms
    are Pairs of Functions $f: A \rightarrow A$ and $g: X \rightarrow
    X'$ such that $B' \circ g = f \circ B$, i.e. $f$ maps $B_a$ to
    $B'_{g(a)}$
\end{itemize}

The Functor $T$ assigns a Context $\Gamma$ to a Set of Types
$Ty(\Gamma)$, and for each $A : Ty(\Gamma)$ a Set of Terms
$Tm(\Gamma,A)$.

The Empty Context is the Terminal Object of $\mathsf{C}$.

Final Object for \emph{Comprehension} (or \emph{Context Extension}) % FIXME



\textbf{Alternate description}\cite{bastenhof09}

Language $L$:
\begin{enumerate}
  \item $1$ (Unity Type), $\Omega$ (Truth Value Type)
  \item Base Types $\tau_1, \tau_2, \tau_3, \ldots$
  \item Function Symbols $f, g, h, \ldots$
\end{enumerate}
The Types of a System are given by the smallest Set including $1$,
$\Omega$, and the Base Types closed under $\times$ (Product Types
\S\ref{sec:product_type}) and Unary Type Operator $P$ (Power Types
\S\ref{sec:power_type}).

Terms of Type $\Omega$ represent Formulas, e.g. $\tau_1 = \tau_2$.


\asterism


\textbf{Sum Type} (\S\ref{sec:sum_type}) (Tagged Union)

$A \cup B = \{ a_1, a_2, ..., b_1, b_2, ... \}$

$x \in A \cup B \Rightarrow x \in A \vee x \in B$

$U \subset A \cup B \Rightarrow \forall u \in U, u \in A \vee u \in B \}$


\textbf{Product Type} (\S\ref{sec:product_type}) (Pairs)

$A \times B = \{ (a_1,b_1), (a_1,b_2), ..., (a_2,b_1), (a_2,b_2), ... \}$

$(x,y) \in A \times B \Rightarrow x \in A \wedge y \in B$

$U \subset A \times B
\Rightarrow \forall (u,v) \in U, u \in A \wedge v \in B$


\textbf{Powerset} (\S\ref{sec:powerset})
(Relations \S\ref{sec:binary_relation})

$\pow(A \times B) = \{ \linebreak[1]
\{(a_1,b_1)\}, \{(a_1,b_2)\}, ...,
\{(a_2,b_1)\}, \{(a_2,b_2)\}, ...
\linebreak[1] \vdots \linebreak[1]
\{(a_1,b_1), (a_1,b_2)\}, \{(a_1,b_1), (a_1,b_3)\}, ...,
\{(a_2,b_1), (a_2,b_2)\}, \{(a_2,b_1), (a_2,b_3)\}, ...
\linebreak[1] \vdots \linebreak[1]
..., A \times B - \{(a_2,b_1), (a_2,b_3)\}, \allowbreak
A \times B - \{(a_2,b_1), (a_2,b_2)\}, \allowbreak
..., A \times B - \{(a_1,b_1), (a_1,b_3)\}, \allowbreak
A \times B - \{(a_1,b_1), (a_1,b_2)\}, \allowbreak
\linebreak[1] \vdots \linebreak[1]
..., A \times B - \{(a_2,b_2)\}, A \times B - \{(a_2,b_1)\}, \allowbreak
..., A \times B - \{(a_1,b_2)\}, A \times B - \{(a_1,b_1)\}, \allowbreak
\linebreak[1] A \times B
\}$

$A \times B \in \pow(A \times B)$

$U \in \pow(A \times B) \Rightarrow U \subseteq A \times B \allowbreak
\Rightarrow \forall (u,v) \in U, u \in A \wedge v \in B$

$\class{V} \subset \pow(A \times B)
\Rightarrow \forall U \in \class{V}, U \subseteq A \times B$


\textbf{Function Type} (\S\ref{sec:function_type})

$A \rightarrow B = B^A = \{ \linebreak[1]
\{ (a_1, b_1), (a_2, b_1), (a_3, b_1), ...\},
\{ (a_1, b_2), (a_2, b_2), (a_3, b_2), ...\},
\{ (a_1, b_3), (a_2, b_3), (a_3, b_3), ...\}, ...
\linebreak[1] \vdots \linebreak[1]
\{ (a_1, b_2), (a_2, b_1), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_2), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_1), (a_3, b_2), ...\}, ...
\linebreak[1] \vdots \linebreak[1]
\{ (a_1, b_3), (a_2, b_1), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_3), (a_3, b_1), ...\},
\{ (a_1, b_1), (a_2, b_1), (a_3, b_3), ...\},
\linebreak[1] \vdots \linebreak[1]
\}$

$B^A \subset \pow(A \times B)$

$f \in B^A
\Rightarrow f \in \pow(A \times B) \wedge f \neq A \times B \allowbreak
\Rightarrow f \subset A \times B
\Rightarrow \forall (x, f(x)) \in f, x \in A \wedge f(x) \in B$

$U \subset B^A \Rightarrow \forall u \in U, u \in \pow(A \times B)$


\textbf{Dependent Type} (\S\ref{sec:dependent_type})

$a:A \vdash B(a) = \{(a_1,B(a_1)), (a_2,B(a_2)), ...\}$

$a:A \vdash B(a) \in \class{U}^A \linebreak[1]
\Rightarrow a:A \vdash B(a) \subset A \times \class{U}$

$(x,X) \in a:A \vdash B(a) \Rightarrow x \in A \wedge X \in \class{U}$

$U \subset a:A \vdash B(a) \Rightarrow \forall (x,X) \in U, x \in A
\wedge X \in \class{U}$


\textbf{Dependent Sum Type} ($\Sigma$-type \S\ref{sec:sigma_type})

$(\Sigma a:A) B(a) = \{\{ (a_1, x_1), (a_1, x_2), ...\},
\{ (a_2, y_1), (a_2, y_2), ...\}, \cdots \}$

$(\Sigma a:A) B(a) \subset \pow \bigsqcup_{X \in \class{U}} A \times X$

$Z \in (\Sigma a:A) B(a) \Rightarrow \exists x \in A : \forall y \in
B(x), (x,y) \in P$



\textbf{Dependent Product Type} ($\Pi$-type \S\ref{sec:pi_type})

$(\Pi a:A) B(a) = \{(a_1, x), (a_2, y), (a_3, z), ...\}$

$(\Pi a:A) B(a) \subset \pow \bigsqcup_{a \in A} (\Sigma a:A) B(a)$


\asterism



% --------------------------------------------------------------------
\subsection{Constructive Type}\label{sec:constructive_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Meaning Explanation}\label{sec:meaning_explanation}
% --------------------------------------------------------------------

Martin-L\"of, a Proof-theoretic Semantics
(\S\ref{sec:proof_semantics}) for Type Theory

Realizability Model (\S\ref{sec:realizability_model}) for Type Theory

Intensional Type Theory (\S\ref{sec:intensional_type})

Extensional Type Theory (\S\ref{sec:extensional_type})

Terms $x,y,z,X,Y,Z,\ldots$

$x \Rightarrow y$: $x$ Computes (Reduces, Transitive) to $y$

Predicates:
\begin{itemize}
  \item $A \type$
  \item $a : A$
  \item $a = b : A$
\end{itemize}

Induction Recursion (\S\ref{sec:induction_recursion}): $A \type$ by
Induction (\S\ref{sec:mathematical_induction}) and two Recursive
Functions:
\begin{itemize}
  \item $|A|$ the Collection of Terms of Type $A$
  \item $=_A$ the Collection of Pairs of Equal Terms of Type $A$
\end{itemize}
(each Collection may be defined Inductively)



% --------------------------------------------------------------------
\subsection{Extensional Type Theory}\label{sec:extensional_type}
\cite{harper12}
% --------------------------------------------------------------------

\emph{Extensional Type Theory} (\emph{ETT})

Strict Equivalence

``Homotopy Set Theory'' (Homotopically Discrete)

Equality Reflection Principle



\subsubsection{Computational Type Theory}\label{sec:computational_type}

\emph{NuPRL}



% --------------------------------------------------------------------
\subsection{Intensional Type Theory}\label{sec:intensional_type}
\cite{harper12}
% --------------------------------------------------------------------

Weak Equivalence



% --------------------------------------------------------------------
\subsection{Observational Type Theory}\label{sec:observational_type}
% --------------------------------------------------------------------

``Homotopy Set Theory'' -- first-stage approximation to Homotopy Type
Theory (\S\ref{sec:hott}): Propositions of OTT correspond to
$h$-propositions (\S\ref{sec:h_proposition}) of HoTT and Types of OTT
correspond to $h$-sets (\S\ref{sec:h_set}) in HoTT.

Equality based on Setoids (\S\ref{sec:setoid})--special case of Higher
Internal Groupoids (???)

Intensional (Definitional) Equality and Type Checking are Decidable

Propositional Equality is Extensional
(\S\ref{sec:extensional_equality}), i.e. Functions are Equal if they
are Point-wise (Observationally) Equal

Propositional Equality is \emph{Substitutive}: Coercion between Types
with Observationally Equivalent Subterms.

\emph{Canonicity}: any Closed Term is Definitionally Reducible to a
Canonical Value



% ====================================================================
\section{Higher Type Theory}\label{sec:higher_type_theory}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Cubical Type Theory}\label{sec:cubical_type_theory}
% --------------------------------------------------------------------

Harper16 - Computational Higher Type Theory

\fist Computational Type Theory (\S\ref{sec:computational_type})

RedPRL

Terms: Programs

Types: Programs that express Specifications of Program Behavior

Cubical Set (\S\ref{sec:cubical_set})

Cubical Programming Language (Licata,Brunerie,Coquand,et.al):

Syntax organized ``Cubically'':
\begin{itemize}
  \item Points: ordinary Terms and Types
  \item Lines: Identifications (??? Judgemental account)
  \item Squares: Homotopies, etc.
\end{itemize}

Cartesian Cubes specified by a Dimension Context, $\Psi$, a Finite Set
of Dimension Variables $\{x,y,z,\ldots\}$


Licata14 - Cubical infinite-dimensional type theory (YouTube):

Boundaries-as-terms

Dimensions as Names (Pronouns: Scoped Reference to a particular
Binding Site, i.e. Variables, cf. Nominal Logic Names are ``things'')

$n$-dimensional Cube has $n$ Dimension Names Free


\textbf{Judgements}

$\Psi ::= \varnothing | \Psi, s \;\mathsf{dim}$



% --------------------------------------------------------------------
\section{Simplicial Type Theory}\label{sec:simplicial_type_theory}
% --------------------------------------------------------------------

\url{https://golem.ph.utexas.edu/category/2017/05/a_type_theory_for_synthetic_ca.html}



% ====================================================================
\section{Modal Type Theory}\label{sec:modal_type_theory}
% ====================================================================

Modal Logic (\S\ref{sec:modal_logic})

Type Formation Rules for Modalities (\S\ref{sec:modality})

Closure Operator Modality (???)

Idempotent Monadic or Idempotent Comonadic (???)

Modal Pure Type Systems (\S\ref{sec:mpts})



% --------------------------------------------------------------------
\subsection{Modal Type}\label{sec:modal_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Functional Reactive Programming}\label{sec:frp}
% --------------------------------------------------------------------

%FIXME possibly move this? dynamical systems? control theory?

\fist \cite{winskel-nielsen93} refers to Distributed (Concurrent)
Systems as \emph{Reactive Systems}, see Process Calculus
(\S\ref{sec:process_calculus}) and Interaction Categories
(\S\ref{sec:interaction_category})
%FIXME

(FRP)

Event-driven Programming: Inversion of Control %FIXME

Pure Functions over Signals \S\ref{sec:signal} (Time-dependent Values)

Temporal Logic (\S\ref{sec:temporal_logic}); may be Interpreted by
Kripke Structures (\S\ref{sec:kripke_structure})-- State Transition
Systems (\S\ref{sec:state_transition}) with a Labelling Function for
States (Nodes) mapping each Node to a Set of Properties that hold in
that State

Linear Temporal Logic (LTL) (\S\ref{sec:linear_temporal})

LTL Propositions \emph{as} Types \\
Proofs of LTL Formulae \emph{as} FRP Programs \cite{jeffrey12},
(Jeltsch 11)

LTL Types express Temporal Behaviors of Programs, e.g. a Program which
must be used immediately, or one which may be used at some Time in the
Future \cite{jeffrey12} %FIXME clarify used

Fan Categories (\S\ref{sec:fan_category}) \cite{jeltsch12}

Hughes Arrows (\S\ref{sec:hughes_arrow}) with Loops (???): Type Class
(\S\ref{sec:constrained_type}) for Freyd Categories
(\S\ref{sec:freyd_category}), i.e. Premonoidal Categories
(\S\ref{sec:premonoidal_category}) with a Cartesian Center (???) and a
Premonoidal Trace (\S\ref{sec:category_trace}) -- defines the Dataflow
Structure but lacks Temporal Properties \cite{jeffrey12}
%FIXME

Reactive Programs form Proofs of Constructive LTL Properties
\cite{jeffrey12}

Implications in LTL give rise to Stateless Functions on Streams (???),
``Constrains'' Modality gives rise to Causal Functions
\cite{jeffrey12} %FIXME xref

Reactive Programs form a Partially-traced Monoidal Category
(\S\ref{sec:partially_traced}) \cite{jeffrey12}

Arrows with Loops where the Type System enforces that only Decoupled
Functions can be Looped \cite{jeffrey12}

Stateless Function $\Rightarrow$, Causal Function $\unrhd$, Decoupled
Function $\rhd$: expression as LTL Operators \cite{jeffrey12}

LTL Formulae: Reactive Types (\S\ref{sec:reactive_type})

Implementation in a Dependent Type Theory
(\S\ref{sec:dependent_type}): not efficiently executable as a Polling
Pull (???) implementation and also suffers from Time Leaks in that the
entire Input History must be recorded (and can't be Garbage Collected)
\cite{jeffrey12}

Push-pull FRP: underlying I/O model is Asynchronous



\subsubsection{Reactive Type}\label{sec:reactive_type}

\cite{jeffrey12}:

correspondance with Propositions of Linear Temporal Logic (LTL)
(\S\ref{sec:linear_temporal})

Loop Combinator: Cyclic Dataflow Graphs (???), Type of a Partial Trace
(\S\ref{sec:partial_trace}) %FIXME

\emph{Reactive Type}

Elements of $Time \rightarrow Set$

\begin{flalign*}
  \quad & RSet : Set_1 & \\
  \quad & RSet = Time \rightarrow Set \\
  \quad & \langle \rangle : Set \rightarrow RSet \\
  \quad & \langle A \rangle(t) = A \\
  \quad & \llbracket \rrbracket : RSet \rightarrow Set \\
  \quad & \llbracket A \rrbracket = \forall \{t\}A(t)
\end{flalign*}

$\langle A \rangle$ -- Constant Reactive Type for each Type $A$

$\llbracket A \rrbracket$ -- Reactive Type with Elements as Signals
(\S\ref{sec:signal}) $\sigma$ such that $\sigma\{t\} : A(t)$ for all
Times $t$; generalizes the Signal Type Constructor with Isomorphism:
\[
  Signal(A) \cong \llbracket \langle A \rangle \rrbracket
\]
$\llbracket \langle \rangle \rrbracket : Set \rightarrow Set$ is a
Monad (\S\ref{sec:monad}) as an Instance of the Read-only State Monad
where State is the current Time

Example Reactive Type:
\begin{flalign*}
  \quad & Past : RSet & \\
  \quad & Past(t) = \exists \{s\}(s \leq t)
\end{flalign*}

Type Combinators can be Pointwise Lifted (Lifting Monad?
\S\ref{sec:lifting_monad}) from Types to Reactive Types, e.g. Lifted
version of the $Maybe$ Type:
\begin{flalign*}
  \quad & E : RSet \rightarrow RSet & \\
  \quad & E(A)(t) = Maybe(A(t))
\end{flalign*}

Category of Reactive Types $\cat{RSet}$:
\begin{itemize}
  \item Objects: Reactive Types
  \item Morphisms: Elements of $\llbracket A \Rightarrow B \rrbracket$
  \item Identity and Composition: inherited Pointwise from $\cat{Set}$
\end{itemize}
The Cartesian-closed (\S\ref{sec:cartesian_closed}) Structure of
$\cat{Set}$ Lifts to $\cat{RSet}$ and $\langle \rangle$ gives rise to
a Functor from $\cat{Set}$ to $\cat{RSet}$.

Temporal Propositions \S\ref{sec:temporal_logic} (Propositions with
one Time Parameter) \emph{as} Reactive Types

Modalities (\S\ref{sec:modality}) of Linear-time Temporal Logic (LTL)
(\S\ref{sec:linear_temporal}) \emph{as} Reactive Type Combinators

Primitive Modalities:
\begin{itemize}
  \item $\ocircle \phi$ -- Next
  \item $\phi \;\until\; \psi$ -- Until
\end{itemize}

Derived Modalities:
\begin{itemize}
  \item $\lozenge \phi$ -- Future
  \item $\square \phi$ -- Globally: $\phi$ True at all Future Times
  \item $\phi \;\untileq\; \psi$ -- Non-strict Until
  \item $\phi \rhd \psi$ -- Constrains
  \item $\phi \unrhd \psi$ -- Non-strict Constrains
  \item $\phi \rightsquigarrow \psi$ -- Choice: Constructively defines
    a Choice Function, Classically collapses to $\Rightarrow$
\end{itemize}

Duals of $\ocircle$, $\untileq$, $\lozenge$, $\square$:
\begin{itemize}
  \item $\ominus \phi$ -- Yesterday: $\phi$ True at Time $s$ when True
    at Time $s - 1$
  \item $\phi \;\sinceeq\; \psi$ -- Non-strict Since
  \item $\minlozenge \phi$ -- Once: True when $\phi$ is True at some
    Past Time
  \item $\boxminus \phi$ -- Historically: True whenever $\phi$ is True
    at all Past Times
\end{itemize}

$\Rightarrow$, $\rhd$, and $\unrhd$ define Function Spaces:
\begin{itemize}
  \item $A \Rightarrow B$ -- \emph{Stateless Functions}: Output Value
    at Time $t$ depends only on Input Value at Time $t$; Implications
    in LTL
  \item $A \unrhd B$ -- \emph{Causal Functions}: Output Value at Time
    $t$ depends on History of Inputs (respect Equality up to the
    current Time); ``Constrains'' Modality
  \item $A \rhd B$ -- \emph{Decoupled Functions}: Output Value at Time
    $t$ depends on History of Inputs but cannot depend on Input Value
    at Time $t$
\end{itemize}

Derivations in Classical Logic:
\begin{align*}
  \lozenge A &= T \;\until\; A \\
  \square A &= \neg(\lozenge\neg A) \\
  A \; \untileq\; B &= A \;\until\; (A \wedge B) \\
  A \rhd B &= \neg(A \;\until\; \neg B) \\
  A \unrhd B &= A \neg(A \;\untileq\; \neg B) \\ %FIXME is this right?
  A \rightsquigarrow B &= \neg((A \wedge \neg B) \;\untileq\; T)
\end{align*}


\textbf{Combinators}

Signal Functions (\S\ref{sec:signal_function}) $f,g$:

$f \ggg g$, $f \&\&\& g$, and $loop f$ allow Dataflow Networks to be
built which can be visualized in any Traced Monoidal Category
(\S\ref{sec:traced_monoidal})

Example $clickMonitor$:
\begin{flalign*}
  \quad & clickMonitor : \llbracket \langle MouseButtonState \rangle
    \unrhd \langle MouseEvent \rangle \rrbracket & \\
  \quad & clickMonitor = arr (\cdot = up) \ggg edge \ggg tag(mouseClick)
\end{flalign*}

$\ggg$ and $\&\&\&$ respect Decoupling:
\begin{itemize}
  \item if $f:\llbracket A \rhd B \rrbracket$ and $g : \llbracket B
    \unrhd C \rrbracket$ then $f \ggg g : \llbracket A \rhd C
    \rrbracket$
  \item if $f:\llbracket A \unrhd B \rrbracket$ and $g : \llbracket B
    \rhd C \rrbracket$ then $f \ggg g : \llbracket A \rhd C
    \rrbracket$
  \item if $f:\llbracket A \rhd B \rrbracket$ and $g : \llbracket B
    \rhd C \rrbracket$ then $f \&\&\& g : \llbracket A \rhd B \wedge C
    \rrbracket$
\end{itemize}


\textbf{FRP Primitives}

$constant : \forall\{A,B\}\llbracket \square B
  \Rightarrow A \rhd B \rrbracket$

$localTime : \forall\{A\} \llbracket A \rhd
  \langle Time \rangle \rrbracket$

$initially : \forall\{A\} \llbracket A
  \Rightarrow A \unrhd A \rrbracket$

$decouple : \forall\{A\} \llbracket \ominus A
  \Rightarrow A \rhd \ominus A \rrbracket$

\emph{Nested Signals} via the $\square$ Modality indicates a
\emph{Stream} of Future Values, e.g. $\llbracket \square\square A
\rrbracket$ is Inhabited by Signals of Signals of Type $A$.

$decouple$ Primitive used to introduce minimal Decoupling, i.e. acts
as an Identity with a $1$ Unit delay.


\textbf{Feedback Loops}

\[
  \llbracket ((A \wedge B) \unrhd (A \wedge C))
    \Rightarrow B \unrhd C \rrbracket
\]
required to Satisfy the Equations of a Traced Premonoidal Category
(\S\ref{sec:traced_premonoidal})

Instance of the Type Class of Arrows (\S\ref{sec:hughes_arrow}) with
Loops

Consequence of the existence of Loops is that every Type is Inhabited,
e.g. defining:
\begin{flalign*}
  \quad & f : \llbracket (F \wedge T) \unrhd (F \wedge F) \rrbracket & \\
  \quad & f = arr[\lambda(x,y).(x,x)]
\end{flalign*}
and Tracing (???) $f$ gives a Function $T \unrhd F$ which can be used
to Inhabit the Empty Type. When this is not desired it can be avoided
by only giving Fixed Points to Decoupled Functions leading to a Type
for $loop$:
\begin{flalign*}
  \quad & loop : \forall\{A,B,C\} \llbracket ((A \wedge B)
    \rhd (A \wedge C)) \Rightarrow B \rhd C \rrbracket & \\
  \quad & loop f = (ifix(f \ggg fst) \&\&\& id) \ggg f \ggg snd
\end{flalign*}
where $ifix$ is the Function for Indexed Fixed Points.

Decoupled Functions form Contraction Maps
(\S\ref{sec:contraction_map}) in an Ultrametric Space
(\S\ref{sec:ultrametric_space}) of Functions and so have Fixed Points.

Because $loop$ can only be Applied to Decoupled Functions and not
Functions in general it does not form a Trace
(\S\ref{sec:category_trace}) and instead forms a Partial Trace
(\S\ref{sec:partial_trace}).


\asterism


Comonad Structure of $\square$:
\begin{flalign*}
  \quad & extend : \forall\{A,B\} \llbracket A \Rightarrow B \rrbracket
    \rightarrow \llbracket \square A
    \Rightarrow \square B \rrbracket & \\
  \quad & extract : \forall\{A\} \llbracket \square A
    \Rightarrow A \rrbracket \\
  \quad & duplicate : \forall\{A\} \llbracket \square A
    \Rightarrow \square\square A \rrbracket
\end{flalign*}

Applicative Structure of $\square$:
\begin{flalign*}
  \quad & [\cdot] : \forall\{A\} \llbracket A \rrbracket
    \rightarrow \llbracket \square A \rrbracket & \\
  \quad & (\cdot \langle * \rangle \cdot) : \forall\{A,B\}
    \llbracket \square (A \Rightarrow B) \Rightarrow \square A
    \Rightarrow \square B \rrbracket
\end{flalign*}

Comonad and Applicative Structure of $\square$ show that $\square$ is
a Model of $S4$ (Alethic) Modal Logic (\S\ref{sec:alethic_logic})

$\ocircle$, $\ominus$: Applicative Functors
(\S\ref{sec:applicative_functor})

$\lozenge$, $\minlozenge$: Applicative Monads
(\S\ref{sec:applicative_monad})

$\boxminus$: Applicative Comonad (\S\ref{sec:applicative_comonad})

Kleisli Category (\S\ref{sec:kleisli_category}) $\boxminus \cat{RSet}$:
\begin{itemize}
  \item Objects: Reactive Types
  \item Morphisms: Elements of $\llbracket \boxminus A \Rightarrow B
    \rrbracket$
  \item Identity and Composition: usual for Kleisli Construction
\end{itemize}

Enriched Categorical (\S\ref{sec:enriched_category}) Structure of
$\unrhd$ (with Hom-objects given by $\unrhd$): $arr$, $id$, $before$,
$after$, $\$$, $\ggg$

$\unrhd \cat{RSet}$:
\begin{itemize}
  \item Objects: Reactive Types
  \item Morphisms: Elements of $\llbracket A \unrhd B
    \rrbracket$
  \item Identity and Composition: as given by Enriched Category
    Structure of $\unrhd$
\end{itemize}

\begin{itemize}
  \item $\cat{Set}$: Morphisms are Witnesses of Implication with no
    place in Time
  \item $\cat{RSet}$: Morphisms are Witnesses of Implication whose
    Hypothesis is True at some Time $t$
  \item $\unrhd \cat{RSet}$: Morphisms are Witnesses of Implication
    whose Hypothesis is True over an Interval $[s,t]$
  \item $\boxminus \cat{RSet}$: Morphisms are Witnesses of Implication
    whose Hypothesis is True over an Interval $(-\infty,t]$
\end{itemize}
leads to (Embedding \S\ref{sec:category_embedding}) Functors:
\[
  \cat{Set} \hookrightarrow \cat{RSet} \hookrightarrow
    \unrhd\cat{RSet} \hookrightarrow \boxminus\cat{RSet}
\]
All have Finite Products inherited from $\cat{Set}$

All but $\unrhd\cat{RSet}$ are Cartesian Closed
(\S\ref{sec:cartesian_closed}): in $\cat{RSet}$, $\sinceeq$
(with its Arguments flipped) is Left-adjoint to $\unrhd$ so
$\cat{RSet}$ has a Closed Structure for $\unrhd$ even if
$\unrhd\cat{RSet}$ does not.


$\cat{RSet}$ inherits Coproducts from $\cat{Set}$

$\unrhd\cat{RSet}$ has Weak Coproducts

$\boxminus\cat{RSet}$ does not have Coproducts

\fist Note that the Embedding of $\unrhd\cat{RSet} \hookrightarrow
\boxminus\cat{RSet}$ requires the existence of a Least Element of Time
$-\infty$.

$\mathsf{C}$ -- Chop Modality on Paths; Interval Temporal Logic
(\S\ref{sec:interval_temporal})


\asterism


\textbf{Implementation}

Implementation uses Interval Types (\S\ref{sec:interval_type}) instead
of Reactive Types (\S\ref{sec:reactive_type}); Interval Temporal Logic
(\S\ref{sec:interval_temporal}) admits the Chop Modality $\mathsf{C}$
on Paths and may give a Cartesian Closed structure to $\unrhd$

For a Causal Function Space $A \unrhd B$ the State (???) of a Causal
Function is Modelled as a \emph{Process} of Type:
\[
  (A @ s \multimap B @ u)
\]
that has ``Received'' Input up to Time $s$ and ``Produced'' Output up
to Time $u$; initial State of a Causal Function at Time $t$ is a
Process where $s = t = u$. A Process can Terminate when $u = \infty$,
i.e. when it has ``Produced'' all its Output (even if $s \prec
\infty$).

Resumption Model of Concurrency (???)

(??? cf. Processes \S\ref{sec:process} in Process Calculus?)



\subsubsection{Interval Type}\label{sec:interval_type}

\cite{jeffrey12}:

\emph{Time Intervals}: Segments of Signals

$Time^\infty$ -- Type of Time Bounds, Extends $Time$ with $\infty$

$[s \prec t)$ -- \emph{Time Interval}

$i \sim j$ -- \emph{Concatenable Intervals}: $i = [s \prec t)$ and $j
    = [t \prec u)$

$i \frown j \because i \sim j$ -- \emph{Concatenation} of $i = [s
        \prec t)$ and $j = [t \prec u)$ is $[s \prec u)$



\emph{Interval Types}

\emph{Monotone Interval Type}

$MSet$

Non-monotone Semantics

Monotone Semantics



\subsubsection{Signal}\label{sec:signal}

\emph{Signal} (or \emph{Behavior})

$a$-valued Behavior: $Time \rightarrow a$

\cite{jeffrey12}:

gives rise to an Event Stream (\S\ref{sec:frp_event})

\begin{flalign*}
  \quad & Signal : Set \rightarrow Set & \\
  \quad & Signal(A) = Time \rightarrow A
\end{flalign*}

$Time$ forms a Decidable Total Order:
\begin{flalign*}
  \quad & Time : Set & \\
  \quad & \leq : Time \rightarrow Time \rightarrow Set \\
  \quad & + : Time \rightarrow \nats \rightarrow Time \\
  \quad & - : Time \rightarrow Time \rightarrow \nats
\end{flalign*}

assuming a Discrete Time Model: Termination Property of $fix$

Dense Time FRP: $\epsilon$-decoupled Functions for some $0 <
\epsilon$; \emph{Zeno Processes} perform Output which is successively
smaller; \emph{Zeno Event Signals}

Isomorphism with Reactive Type (\S\ref{sec:reactive_type})
Constructors:
\[
  Signal(A) \cong \llbracket \langle A \rangle \rrbracket
\]

$\llbracket \langle \rangle \rrbracket : Set \rightarrow Set$ is a
Monad (\S\ref{sec:monad}) as an Instance of the Read-only State Monad
where State is the current Time

Signals of Signals give rise to Signals

Continuous Behaviors

Discrete Behaviors: \emph{Events} (\S\ref{sec:frp_event})



\paragraph{Signal Function}\label{sec:signal_function}\hfill

or \emph{Reactive Function}

\cite{jeffrey12}:

Functions from Signals to Signals

Functions required to be Causal Functions $A \unrhd B$:
\begin{flalign*}
  \quad & SF : Set \rightarrow Set \rightarrow Set & \\
  \quad & SF(A,B) = (f : Signal(A) \rightarrow
    Signal(B)) \times (Causal (f))
\end{flalign*}

Causal Functions respect Equivalence up to the current Time

$SF(A,B)$ encoded in LTL over the past:
\[
  SF(A,B) \cong \llbracket \boxminus\langle A \rangle
    \Rightarrow \langle B \rangle \rrbracket
\]
gives a Semantics for Signal Functions in $\boxminus\cat{RSet}$ and
$\boxminus\cat{RSet}$ is compatible with Hughes Arrows
(\S\ref{sec:hughes_arrow}) as any Category with Finite Products is
trivially a Freyd Category (\S\ref{sec:freyd_category})

$SF$ modified with $era$ Parameter (Jeltsch 09):
\begin{flalign*}
  \quad & SF' : Set \rightarrow Set \rightarrow Time
    \rightarrow Set & \\
  \quad & SF' (A,B,s) = (f : Signal(A) \rightarrow
    Signal(B)) \times (Causal_s(f))
\end{flalign*}
$SF'(A,B,s)$ encoded in LTL:
\[
  SF'(A,B) \cong \langle A \rangle \unrhd \langle B \rangle
\]
has a Semantics in $\unrhd\cat{RSet}$ which also satisfies the
requirements of Arrows.

Decoupled Functions are a Subset of Signal Functions:
\begin{flalign*}
  \quad & SF'' : Set \rightarrow Set \rightarrow Time
    \rightarrow Set & \\
  \quad & SF'' (A,B,s) = (f : Signal(A) \rightarrow
    Signal(B)) \times (Decoupled_s(f))
\end{flalign*}
$SF'(A,B,s)$ encoded in LTL:
\[
  SF''(A,B) \cong \langle A \rangle \rhd \langle A \rangle
\]

\fist Note that $\rhd\cat{RSet}$ is not a Category as it has
Composition but not Identities (Identity Function is only Decoupled on
Singleton Types), cf. Contraction Maps in a Complete Metric Space:
Identities are Non-expanding but not Contracting
%FIXME xref


\textbf{Combinators}

Signal Functions $f,g$:

$f \ggg g$, $f \&\&\& g$, and $loop f$ allow Dataflow Networks to be
built which can be visualized in any Traced Monoidal Category
(\S\ref{sec:traced_monoidal})



\subsubsection{Event}\label{sec:frp_event}

Event-driven Programming: Inversion of Control %FIXME

\cite{jeffrey12}:

Discrete Behaviors

Signal gives rise to an \emph{Event Stream}


Semantics given by Signals of Type $E A$ where:
\begin{flalign*}
  \quad & E : RSet \rightarrow RSet & \\
  \quad & E(A)(t) = Maybe(A(t))
\end{flalign*}
A Signal of Type $E A$ at Time $t$ is either $Nothing$ (no Event has
arrived) or $Just(a)$ (an Event of $a$ of Type $A(t)$ has arrived).

Example:
\[
  mouseClick : \llbracket E \langle MouseEvent \rangle \rrbracket
\]


\textbf{Event Primitives}

$never : \forall\{A,B\} \llbracket A \rhd E B \rrbracket$

$now : \forall\{A,B\} \llbracket B \Rightarrow A \rhd E B \rrbracket$

$later : \forall\{A,B\} \llbracket \lozenge B
  \Rightarrow A \rhd E B \rrbracket$

$tag : \forall\{A,B\} \llbracket \square B \Rightarrow
  E A \unrhd E B \rrbracket$

$edge : \llbracket [Bool] \unrhd E T \rrbracket$ -- converts Signals
  into Events

$hold : \forall\{A\} \llbracket A \Rightarrow E A
  \rhd \minlozenge A \rrbracket$ -- converts Events into Signals


\textbf{Switching}

starting and stopping Signal Functions based on Events

Switching Combinators:

$switch : \forall\{A,B,C\} \llbracket (A \unrhd (B \wedge E C))
  \Rightarrow \square(C \Rightarrow (A \unrhd B))
  \Rightarrow (A \unrhd B) \rrbracket$ -- only React to the first
  Switching Event

$rswitch : \forall\{A,B\} \llbracket (A \unrhd B)
  \Rightarrow (A \wedge E(A \unrhd B)) \unrhd B \rrbracket$ -- React
  on every Switching Event

Example Function which Returns True after an Event has occurred:
\[
  switch(constant[False] \&\&\& id)[\lambda x.constant[True]]
\]



% ====================================================================
\section{Homotopy Type Theory}\label{sec:hott}
% ====================================================================

Homotopy Theory (\S\ref{sec:homotopy})

- Function Extensionality
- Univalence Axiom (\S\ref{sec:univalence_axiom})

- Values (Points), Paths, Homotopies

- Internal Language of Higher Categories
(\S\ref{sec:higher_category}).

Homotopy Types Model $\infty$-groupoids
(\S\ref{sec:infinity_groupoid})

\url{https://golem.ph.utexas.edu/category/2017/05/a_type_theory_for_synthetic_ca.html}:
the Rule of Identity-elimination in Martin-Lof Identity Types
automatically generates the structure of an $\infty$-groupoid--
Homotopy Type Theory can be viewed as a ``Synthetic Theory of
$\infty$-groupoids''

Categorical Semantics (\S\ref{sec:categorical_semantics})

nLab:

Observational Type Theory (\S\ref{sec:observational_type}) is a
first-step approximation to Homotopy Type Theory: Propositions of OTT
correspond to $h$-propositions (\S\ref{sec:h_proposition}) of HoTT and
Types of OTT correspond to $h$-sets (\S\ref{sec:h_set}) of HoTT.

Homotopy Levels (\S\ref{sec:homotopy_level}), Homotopy Type
(\S\ref{sec:homotopy_type}):

$h$-level 1: $h$-proposition (\S\ref{sec:h_proposition})

$h$-level 2, Homotopy $0$-type (\S\ref{sec:homotopy_0type}): $h$-set
(\S\ref{sec:h_set})

$h$-level 3, Homotopy $1$-type (\S\ref{sec:homotopy_1type}):
$h$-groupoid (\S\ref{sec:h_groupoid})


Nuyts15:

\begin{itemize}
  \item Elements of a Type correspond to Objects of ``the''
    $\infty$-Groupoid
  \item Judgemental Equality corresponds to ``being the same''
  \item Identity Types correspond to Hom-groupoids
  \item Proofs of Equality correspond to Isomorphisms
\end{itemize}

generalized Homotopy Hypothesis: Isomorphism of any kind of Structures
is the same as Propositional Equality



% --------------------------------------------------------------------
\subsection{$h$-proposition}\label{sec:h_proposition}
% --------------------------------------------------------------------

$h$-level 1

nLab:

(or \emph{Mere Proposition}: Types which have at most one Element,
i.e. $Prop := \Sigma(A : Type) \Pi(x, y : A) x = y$)

Internalization of notion of Proposition (\S\ref{sec:proposition}),
i.e. Semantically corresponding to $(-1)$-truncated Objects
(\S\ref{sec:truncated_object})

Propositions of Observational Type Theory
(\S\ref{sec:observational_type}) correspond to $h$-propositions of HoTT



% --------------------------------------------------------------------
\subsection{$h$-set}\label{sec:h_set}
% --------------------------------------------------------------------

Types in Observational Type Theory (\S\ref{sec:observational_type})
correspond to $h$-sets of HoTT



% --------------------------------------------------------------------
\subsection{$h$-groupoid}\label{sec:h_groupoid}
% --------------------------------------------------------------------

Groupoid (\S\ref{sec:groupoid})



% --------------------------------------------------------------------
\subsection{Higher Inductive Type}\label{sec:higher_inductive_type}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection{Inference Rules}\label{sec:homotopy_rules}
% --------------------------------------------------------------------

Inference Rules (\S\ref{sec:type_inference}) have the form:
\[
  \frac{J_1 \quad \cdots \quad J_k} {J} Name
\]
where $J_i$ are provided as derived hypothetical (metatheoretical)
Judgements and $J$ is the conclusion.

A Tree constructed from Inference Rules forms a Derivation
(\S\ref{sec:typing_derivation}) of a Judgement.



\textbf{Context Rules}

The following Rules of Inference allow for the determination of a
Well-formed Context:
\begin{enumerate}
\item
\[
  {
    \frac{}{(.)ctx}
  } ctx-EMP
\]
\item
\[
  {
    \frac
    {x_1:A_1, \ldots, x_{n-1}:A_{n-1} \vdash A_n : \class{U}_i}
    {(x_1:A_1,\ldots,x_n:A_n) ctx}
  } ctx-EXT
\]
\end{enumerate}



\textbf{Structural Rules}

Given a Context, derive Typing Judgements
(\S\ref{sec:typing_judgement}) listed in the Context:
\[
  {
    \frac
    {(x_1:A_1, \ldots, x_n:A_n)ctx}
    {x_1:A_1, \ldots, x_n:A_n \vdash x_i:A_i}
  } Vble
\]

Substitution for Typing Judgements:
\[
  {
    \frac
    {\Gamma \vdash a : A \;\;\;\;\;\;\;
    \Gamma,x:A,\Delta \vdash b : B}
    {\Gamma,[a/x]\Delta \vdash [a/x]b : [a/x]B}
  } Subst_1
\]

Weakening for Typing Judgements:
\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i \;\;\;\;\;\;\;
    \Gamma,\Delta \vdash b : B}
    {\Gamma,x:A,\Delta \vdash b:B}
  } Wkg_1
\]

Substitution for Judgemental Equality:
\[
  {
    \frac
    {\Gamma \vdash a : A \;\;\;\;\;\;\;
    \Gamma,x:A,\Delta \vdash b \equiv c : B}
    {\Gamma,[a/x]\Delta \vdash [a/x]b \equiv [a/x]c : [a/x]B}
  } Subst_2
\]

Weakening for Judgemental Equality:
\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i \;\;\;\;\;\;\;
    \Gamma,\Delta \vdash b \equiv c : B}
    {\Gamma, x:A, \Delta \vdash b \equiv c : B}
  } Wkg_2
\]



\textbf{Universe Rules}

\[
  {
    \frac
    {(\Gamma) ctx}
    {\Gamma \vdash \class{U}_i : \class{U}_{i+1}}
  } \class{U}-INTRO
\]

\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i}
    {\Gamma \vdash A : \class{U}_{i+1}}
  } \class{U}-CUMUL
\]



\textbf{Dependent Function Type Rules}

\[
  {
    \frac
    {\Gamma \vdash A : \class{U}_i \;\;\;\;\;\;\;
    \Gamma,x:A \vdash B : \class{U}_i}
    {\Gamma \vdash \prod_{(x:A)} B : \class{U}_i}
  } \Pi-FORM
\]\[
  {
    \frac
    {}
    {}
  } \Pi-INTRO
\]\[
  {
    \frac
    {}
    {}
  } \Pi-ELIM
\]\[
  {
    \frac
    {}
    {}
  } \Pi-COMP
\]\[
  {
    \frac
    {}
    {}
  } \Pi-UNIQ
\]



% --------------------------------------------------------------------
\subsection{Univalence Axiom}\label{sec:univalence_axiom}
% --------------------------------------------------------------------

``Identity is Equivalent to Equivalence''

``Equivalent Types are Identical''
\[
  (A = B) \simeq (A \simeq B)
\]
where $A = B$ is notation for the Type $Id_U(A,B)$ where $U$ is the
Universe containing $A$ and $B$.



% --------------------------------------------------------------------
\subsection{Opetopic Type Theory}\label{sec:opetopic_typetheory}
% --------------------------------------------------------------------

Internal Language of $\infty$-categories
(\S\ref{sec:infinity_category})



% --------------------------------------------------------------------
\subsection{Directed Homotopy Type Theory}\label{sec:directed_hott}
% --------------------------------------------------------------------

Nuyts15 \emph{Towards a Directed Homotopy Type Theory}

a special case of Mode Theory (\S\ref{sec:mode_theory}) in Dependent
Type Theory



% ====================================================================
\section{Mode Theory}\label{sec:mode_theory}
% ====================================================================

Licata-Shulman-Riley2017 \emph{A Fibrational Framework for
  Substructural and Modal Logics}

Framework for Substructural (\S\ref{sec:substructural_type}) and Modal
(\S\ref{sec:modal_type_theory}) Type Theories

\fist Directed Homotopy Type Theory (\S\ref{sec:directed_hott}) --
a special case of Mode Theory in Dependent Type Theory

\emph{Structurality over Structurality}

Semantically the Logic corresponds to a Functor between
$2$-dimensional Cartesian Multicatories
(\S\ref{sec:cartesian_multicategory}), a \emph{Fibration} in various
senses

first layer: Simple Type Theory of \emph{Modes} (collection of Base
Types $p,q,r$) and \emph{Context Descriptors} (or \emph{Mode
  Morphisms}: Terms $\alpha$ built from Variables and Constants)

next layer: ``main'' Logic where each Proposition (Type) is assigned a
\emph{Mode}

Substructural features are provided by adding Structural Properties on
the Context Descriptor $\alpha$

Modal Logics will generally involve a Mode Theory with more than one
Mode

a Mode Theory specifying a Context Descriptor and Structural
Properties is analyzed as a $2$-dimensional Cartesian Multicategory

basic Sequent:
\[
  x_1:A_1,\ldots,x_n:A_n \vdash_\alpha C
\]
where if $A_i$ has Mode $p_i$ and $C$ has Mode $q$ then
$x_1:p_1,\ldots,x_n:p_n \vdash \alpha:q$

$\Gamma = x_1:A_1,\ldots,x_n:A_n$ -- ordinary Structural/Cartesian
Context

Substructural or Modal aspects are enforced by the Term $\alpha$,
constraining how the resources from $\Gamma$ can be used

in Linear/Ordered/Bunched Logic the Context $\Gamma$ is usually a
Multiset/List/Tree

$\Gamma \vdash_\alpha A$ -- ``$\Gamma$ Proves $A$ along/over/using
$\alpha$''



% ====================================================================
\section{Metaprogramming}\label{sec:metaprogramming}
% ====================================================================

% --------------------------------------------------------------------
\subsection{Reflection}\label{sec:type_reflection}
% --------------------------------------------------------------------

Type Introspection (???) + Manipulation

Monadic Reflection (\S\ref{sec:monadic_reflection})
