%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Database Theory}\label{part:database_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ====================================================================
\section{Data Structure}\label{sec:data_structure}
% ====================================================================

%FIXME possibly move this section?

potentially Infinite Data Structures: Abstracted as $F$-coalgebras
(\S\ref{sec:f_coalgebra})

(also Data Structure as Folds of Church Encodings)
%??? FIXME

(Milewski - Understanding F-Algebras)

As Recursive Functions are defined as Fixed Points of regular
Functions, (Nested) Data Structures can be defined as Fixed Points of
regular Type Constructors.

Functors as Type Constructors give rise to Nested Data Structures that
allow Recursive Evaluation (generalized Folding).



% --------------------------------------------------------------------
\subsection{Ordered Tree}\label{sec:ordered_tree}
% --------------------------------------------------------------------

\subsubsection{Trie}\label{sec:trie}

\subsubsection{Prefix Tree}\label{sec:prefix_tree}

\subsubsection{Suffix Tree}\label{sec:suffix_tree}



% --------------------------------------------------------------------
\subsection{Fingertree}\label{sec:fingertree}
% --------------------------------------------------------------------



% ====================================================================
\section{Relational Model}\label{sec:relational_model}
% ====================================================================

\emph{Relational Calculus}

%FIXME:

2016 - Gibbons - \emph{Comprehending Ringads} -- ``Ringad Comprehensions
represent a convenient notation for expressing \emph{Database Queries}.''



% --------------------------------------------------------------------
\subsection{Relation}\label{sec:database_relation}
% --------------------------------------------------------------------

(wiki):

A \emph{Relation} is a Heading (\S\ref{sec:heading}) paired with a Body
(\S\ref{sec:body}).

A Relation is a Set of Tuples $(d_1, d_2, \ldots, d_n)$ where each Element $d_j
\in D_j$ is a Member of a Data Domain $D_j$. Unlike a Set Theoretic Relation
(\S\ref{sec:relation}), there is no ordering to the Elements of the Tuples of a
Relation-- each element is called an \emph{Attribute Value} and an
\emph{Attribute} is a Name paired with a Data Domain (sometimes called a
\emph{Type} or \emph{Data Type} \S\ref{sec:datatype}), so that a Tuple is a
\emph{Set of Attribute Values} in which no two distinct Elements have the same
Attribute Name, i.e. a Tuple in this case is a Function mapping Names to
Values.

A Relation can be seen as an instantiation of a \emph{Relation Schema}
(\S\ref{sec:relation_schema}) if it has the Heading of the Schema and Satisfies
the applicable Constraints.

in SQL, Relations are represented by \emph{Tables} where each Row represents a
single Tuple and the Values of each Attribute form a Column



\subsubsection{Attribute}\label{sec:database_attribute}

Attribute Value

Data Domain (Data Type \S\ref{sec:datatype})

Tuples



\subsubsection{Heading}\label{sec:heading}

a Set of Attributes in which no two distinct Elements have the same Name is
called a \emph{Heading}; the number of Attributes constituting a Heading is
called the \emph{Degree}



\subsubsection{Body}\label{sec:body}

a Set of Tuples having the same Heading is called a \emph{Body}



\subsubsection{Relation Schema}\label{sec:relation_schema}

a Heading with a Set of \emph{Constraints} defined in terms of that Heading

a Relation can be seen as an instantiation of a \emph{Relation Schema}
(\S\ref{sec:relation_schema}) if it has the Heading of the Schema and Satisfies
the applicable Constraints

a Named Relation Schema is a \emph{Relation Variable}



% ====================================================================
\section{Database Schema}\label{sec:database_schema}
% ====================================================================

% ====================================================================
\section{Formal Concept Analysis}\label{sec:fca}
% ====================================================================

%FIXME this is an information science topic

\url{http://www.upriss.org.uk/fca/fca.html}

\emph{Concept Hierarchy} (or \emph{Formal Ontology})

\url{https://golem.ph.utexas.edu/category/2014/02/galois_correspondences_and_enr.html}
(4th post in a series)



% --------------------------------------------------------------------
\subsection{Formal Context}\label{sec:formal_context}
% --------------------------------------------------------------------

\emph{Formal Context}:
\[
  K = (G,M,I)
\]

$G$ -- \emph{Objects}

$M$ -- \emph{Attributes}

$I \subseteq G \times M$ -- \emph{Incidence}



% --------------------------------------------------------------------
\subsection{Formal Concept}\label{sec:formal_concept}
% --------------------------------------------------------------------

a \emph{Formal Concept} is a pair $(A,B)$ where:
\begin{itemize}
  \item $A \subseteq G$ -- a Set of Objects
  \item $B \subseteq M$ -- a Set of Attributes
  \item $A' = B$ -- where $A' = \{ m \in M \ |\ \forall g \in A, gIm \}$
  \item $B' = A$ -- where $B' = \{ g \in G \ |\ \forall m \in B, gIm \}$
\end{itemize}
that is:
\begin{itemize}
  \item every Object in $A$ has every Attribute in $B$
  \item for every Object in $G$ that is \emph{not} in $A$, there is
    \emph{some} Attribute in $B$ that the Object \emph{does not} have
  \item for every Attribute in $M$ that is \emph{not} in $B$, there is
    \emph{some} Object in $A$ that \emph{does not} have that Attribute
\end{itemize}
