%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Database Theory}\label{part:database_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ====================================================================
\section{Data Structure}\label{sec:data_structure}
% ====================================================================

%FIXME possibly move this section?

potentially Infinite Data Structures: Abstracted as $F$-coalgebras
(\S\ref{sec:f_coalgebra})

(also Data Structure as Folds of Church Encodings)
%??? FIXME

(Milewski - Understanding F-Algebras)

As Recursive Functions are defined as Fixed Points of regular
Functions, (Nested) Data Structures can be defined as Fixed Points of
regular Type Constructors.

Functors as Type Constructors give rise to Nested Data Structures that
allow Recursive Evaluation (generalized Folding).



% --------------------------------------------------------------------
\subsection{Ordered Tree}\label{sec:ordered_tree}
% --------------------------------------------------------------------

\subsubsection{Trie}\label{sec:trie}

\subsubsection{Prefix Tree}\label{sec:prefix_tree}

\subsubsection{Suffix Tree}\label{sec:suffix_tree}



% --------------------------------------------------------------------
\subsection{Fingertree}\label{sec:fingertree}
% --------------------------------------------------------------------



% ====================================================================
\section{Relational Model}\label{sec:relational_model}
% ====================================================================

\emph{Relational Calculus}



% ====================================================================
\section{Database Schema}\label{sec:database_schema}
% ====================================================================

% ====================================================================
\section{Formal Concept Analysis}\label{sec:fca}
% ====================================================================

%FIXME this is an information science topic

\url{http://www.upriss.org.uk/fca/fca.html}

\emph{Concept Hierarchy} (or \emph{Formal Ontology})

\url{https://golem.ph.utexas.edu/category/2014/02/galois_correspondences_and_enr.html}
(4th post in a series)



% --------------------------------------------------------------------
\subsection{Formal Context}\label{sec:formal_context}
% --------------------------------------------------------------------

\emph{Formal Context}:
\[
  K = (G,M,I)
\]

$G$ -- \emph{Objects}

$M$ -- \emph{Attributes}

$I \subseteq G \times M$ -- \emph{Incidence}



% --------------------------------------------------------------------
\subsection{Formal Concept}\label{sec:formal_concept}
% --------------------------------------------------------------------

a \emph{Formal Concept} is a pair $(A,B)$ where:
\begin{itemize}
  \item $A \subseteq G$ -- a Set of Objects
  \item $B \subseteq M$ -- a Set of Attributes
  \item $A' = B$ -- where $A' = \{ m \in M \ |\ \forall g \in A, gIm \}$
  \item $B' = A$ -- where $B' = \{ g \in G \ |\ \forall m \in B, gIm \}$
\end{itemize}
that is:
\begin{itemize}
  \item every Object in $A$ has every Attribute in $B$
  \item for every Object in $G$ that is \emph{not} in $A$, there is
    \emph{some} Attribute in $B$ that the Object \emph{does not} have
  \item for every Attribute in $M$ that is \emph{not} in $B$, there is
    \emph{some} Object in $A$ that \emph{does not} have that Attribute
\end{itemize}
