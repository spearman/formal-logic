%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Database Theory}\label{part:database_theory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ==============================================================================
\section{Data}\label{sec:data}
% ==============================================================================

\emph{Sample Data} (\emph{Statistical Sample} \S\ref{sec:sample})

when viewed ``in context'', Data conveys \emph{Information}
(\S\ref{sec:information})

\fist cf. Datatype (Type Theory \S\ref{sec:datatype}), Statistical Data Type
(\S\ref{sec:statistical_data_type})



% ------------------------------------------------------------------------------
\subsection{Data Item}\label{sec:data_item}
% ------------------------------------------------------------------------------

cf. ``\emph{Data Point}'' (Statistical Sample \S\ref{sec:sample})



% ------------------------------------------------------------------------------
\subsection{Data Collection}\label{sec:data_collection}
% ------------------------------------------------------------------------------

cf. \emph{Data Generating Process} (\S\ref{sec:data_generating_process}),
\emph{Sampling} (\S\ref{sec:sampling})



% ------------------------------------------------------------------------------
\subsection{Dataset}\label{sec:dataset}
% ------------------------------------------------------------------------------

cf. \emph{Sample Data} (\emph{Statistical Sample} \S\ref{sec:sample})

\fist Statistical Transformations (\S\ref{sec:dataset_transformation}) of
Datasets

Datasets in Machine Learning Algorithms (\S\ref{sec:learning_algorithm}):
\begin{itemize}
  \item Training Dataset (\S\ref{sec:training_dataset})
  \item Validation Dataset (\S\ref{sec:validation_dataset})
  \item Test Dataset (\S\ref{sec:test_dataset})
\end{itemize}



% ==============================================================================
\section{Data Structure}\label{sec:data_structure}
% ==============================================================================

%FIXME possibly move this section?

potentially Infinite Data Structures: Abstracted as $F$-coalgebras
(\S\ref{sec:f_coalgebra})

(also Data Structure as Folds of Church Encodings)
%??? FIXME

(Milewski - Understanding F-Algebras)

As Recursive Functions are defined as Fixed Points of regular
Functions, (Nested) Data Structures can be defined as Fixed Points of
regular Type Constructors.

Functors as Type Constructors give rise to Nested Data Structures that
allow Recursive Evaluation (generalized Folding).



% -----------------------------------------------------------------------------
\subsection{Ordered Tree}\label{sec:ordered_tree}
% -----------------------------------------------------------------------------

\subsubsection{Trie}\label{sec:trie}

\subsubsection{Prefix Tree}\label{sec:prefix_tree}

\subsubsection{Suffix Tree}\label{sec:suffix_tree}



% -----------------------------------------------------------------------------
\subsection{Fingertree}\label{sec:fingertree}
% -----------------------------------------------------------------------------



% ==============================================================================
\section{Data Transformation}\label{sec:data_transformation}
% ==============================================================================

\fist cf. Statistical Data Transformation (\S\ref{sec:dataset_transformation})



% -----------------------------------------------------------------------------
\subsection{Bidirectional Transformation}
\label{sec:bidirectional_transformation}
% -----------------------------------------------------------------------------

\subsubsection{Bidirectional Model Tranformation}
\label{sec:bidirectional_model_transformation}

\subsubsection{Optic}\label{sec:optic}

%FIXME: move to category theory ???

\url{https://golem.ph.utexas.edu/category/2020/01/profunctor_optics_the_categori.html}

compositional representation of \emph{Bidirectional Data Accessors}

originally called \emph{Accessors} or \emph{Generalized Functional References}

\emph{Profunctor Encoding} -- \emph{Profunctor Optics}
(\S\ref{sec:profunctor_optics})

\emph{van Laarhoven Encoding} -- Haskell $\mathtt{lens}$ library

%FIXME: move to profunctor subsection ?

\url{https://ncatlab.org/nlab/show/optic+%28in+computer+science%29}

\url{http://oleg.fi/gists/posts/2017-04-18-glassery.html}

\url{https://golem.ph.utexas.edu/category/2020/01/profunctor_optics_the_categori.html}

compositional representation of \emph{Bidirectional Data Accessors}

\emph{Lens} (\S\ref{sec:lens}) -- Products; \emph{Note}: not the same as
``Lenses'' (Anamorphism or \emph{Co-iteration} \S\ref{sec:anamorphism}) in
Recursion Theory

\emph{view}, \emph{update}

``Generalized Functional References''

\emph{Prism} -- Tagged Unions; Lenses in the \emph{Opposite} Category

\emph{match}, \emph{build}

\emph{Traversal} -- Containers

\emph{extract}

\emph{Setter}

\emph{Grate}

2018 - Riley - \emph{Categories of Optics}

$\mathbf{Optic} : \mathbf{SymmMonCat} \rightarrow \mathbf{SymmMonCat}$

for a Symmetric Monoidal Category $(\cat{C}, \otimes, I)$, given two Pairs of
Objects of $\cat{C}$, $(S, S')$ and $(A, A')$, an \emph{Optic}
$p : (S, S') \nrightarrow (A, A')$ is an Element of the Set:
\[
  \mathbf{Optic}_\cat{C} ((S, S'), (A, A')) \defeq
    \int^{M\in\cat{C}} \cat{C}(S, M \otimes A) \times \cat{C}(M \otimes A', S')
\]

(Coend Calculus \S\ref{sec:coend})

\asterism

\url{https://www.youtube.com/watch?v=1NHBexWYgkU}

an Optic is given by a choice of a Residual Object $M \in \cat{C}$, a Forward
Map $f$ and a Backward Map $b$

when $\cat{C}$ is Cartesian,
$\mathbf{Optic}(\cat{C}) \simeq \mathbf{Lens}(\cat{C})$



\paragraph{Parametric Optics}\label{sec:parametric_optics}\hfill

\url{https://www.youtube.com/watch?v=1NHBexWYgkU} -- common structure behind
Neural Networks, Loss Functions, and Optimizers

nlab: Para Construction (\S\ref{sec:para_construction}) $Para(Optic(C))$
recovers the Category of Neural Networks (Capucci et al. 2020)



\paragraph{Lens}\label{sec:lens}\hfill

2007 - Foster et al. - \emph{Combinators for bidirectional tree transformations:
A linguistic approach to the view-update problem}

2012 - Johnson et al. - \emph{Lenses, fibrations, and universal translations}

nlab: ``well-behaved'' Lenses are equivalently Co-algebras of the Co-state
Co-monad (O'Connor 2010, 2011)

\fist cf. System T (\S\ref{sec:system_t}) -- Proof Interpretation of Heyting
Arithmetic (\S\ref{sec:heyting_arithmetic}) into a Finite-type Extension of
Primitive Recursive Arithmetic (\S\ref{sec:primitive_recursive}); the
Interpretation of Intuitionistic Implication is the first example of a ``Lense''
from Programming: a Proof of $\varphi \rightarrow \psi$ is a \emph{Lens} from
Proofs of $\varphi$ to Proofs of $\psi$
(\url{https://julesh.com/2018/08/16/lenses-for-philosophers/})

\fist cf. van Laarhoven Free Monad (\S\ref{sec:vanlaarhoven_free_monad}) -- van
Laarhoven Function: $(X \rightarrow F X) \rightarrow F Y$ equivalent to Store
Comonad

Lenses in Compositional Game Theory (Ghani, Hedges 2018)



\subparagraph{Asymmetric Lens}\label{sec:asymmetric_lens}\hfill

\subparagraph{Symmetric Lens}\label{sec:symmetric_lens}\hfill

2019 - Fong, Johnson - \emph{Functorial Backpropagation and Symmetric Lenses} -
\url{https://www.youtube.com/watch?v=s0WTRHe-4ZI} -- ``Lenses are Learners'';
\fist Backpropagation (\S\ref{sec:backpropagation})



\subparagraph{Parametric Lens}\label{sec:parametric_lens}\hfill

%FIXME: type of symmetric lens ?

nlab: Para Construction (\S\ref{sec:para_construction}) $Para(Optic(C))$
recovers the Category of Neural Networks (Capucci et al. 2020)

2021 - Gavranovic, et al. - \emph{Categorical Foundations of Gradient-based
Learning}

a Parametric Lens is a ``\emph{Process}'' with three kinds of ``Interfaces'':
Inputs, Outputs, and Parameters, and on each Interface, information flows both
ways, i.e. ``computations'' are bi-directional



\subparagraph{Bare Lens}\label{sec:bare_lens}\hfill

or \emph{Set-based Lens}



\subparagraph{Constant Complement Lens}
\label{sec:constant_complement_lens}\hfill



% ==============================================================================
\section{Data Analysis}\label{sec:data_analysis}
% ==============================================================================

% -----------------------------------------------------------------------------
\subsection{Descriptive Analytics}\label{sec:descriptive_analytics}
% -----------------------------------------------------------------------------

\fist Unsupervised Learning (Cluster Analysis \S\ref{sec:cluster_analysis})



% -----------------------------------------------------------------------------
\subsection{Predictive Analytics}\label{sec:predictive_analytics}
% -----------------------------------------------------------------------------

Predictive Inference (\S\ref{sec:predictive_inference}), Predictive Modeling
(\S\ref{sec:predictive_modeling})

\fist Supervised Learning (Statistical Classification
\S\ref{sec:statistical_classification}, Regression Analysis
\S\ref{sec:regression_analysis})

Time-series Models (\S\ref{sec:time_series_analysis})

cf. Scenario Analysis (\S\ref{sec:scenario_analysis}): based on
\emph{hypothetical} Data, not historical Data



% -----------------------------------------------------------------------------
\subsection{Prescriptive Analytics}\label{sec:prescriptive_analytics}
% -----------------------------------------------------------------------------

- \url{http://www.argmin.net/2018/01/29/taxonomy/} -- Reinforcement Learning
(\S\ref{sec:reinforcement_learning}) as Prescriptive Analytics

\fist Optimal Control (\S\ref{sec:optimal_control})



% ==============================================================================
\section{Relational Algebra}\label{sec:relational_algebra}
% ==============================================================================

\emph{Domain Relational Calculus}



% -----------------------------------------------------------------------------
\subsection{Projection}\label{sec:relational_projection}
% -----------------------------------------------------------------------------



% ==============================================================================
\section{Relational Model}\label{sec:relational_model}
% ==============================================================================

\emph{Relational Calculus}

%FIXME:

2016 - Gibbons - \emph{Comprehending Ringads} -- ``Ringad Comprehensions
represent a convenient notation for expressing \emph{Database Queries}.''



% -----------------------------------------------------------------------------
\subsection{Relation}\label{sec:database_relation}
% -----------------------------------------------------------------------------

(wiki):

A \emph{Relation} is a Heading (\S\ref{sec:heading}) paired with a Body
(\S\ref{sec:body}).

A Relation is a Set of Tuples $(d_1, d_2, \ldots, d_n)$ where each Element $d_j
\in D_j$ is a Member of a Data Domain $D_j$. Unlike a Set Theoretic Relation
(\S\ref{sec:relation}), there is no ordering to the Elements of the Tuples of a
Relation-- each element is called an \emph{Attribute Value} and an
\emph{Attribute} is a Name paired with a Data Domain (sometimes called a
\emph{Type} or \emph{Data Type} \S\ref{sec:datatype}), so that a Tuple is a
\emph{Set of Attribute Values} in which no two distinct Elements have the same
Attribute Name, i.e. a Tuple in this case is a Function mapping Names to
Values.

A Relation can be seen as an instantiation of a \emph{Relation Schema}
(\S\ref{sec:relation_schema}) if it has the Heading of the Schema and Satisfies
the applicable Constraints.

in SQL, Relations are represented by \emph{Tables} where each Row represents a
single Tuple and the Values of each Attribute form a Column



\subsubsection{Attribute}\label{sec:database_attribute}

Attribute Value

Data Domain (Data Type \S\ref{sec:datatype})

Tuples



\subsubsection{Heading}\label{sec:heading}

a Set of Attributes in which no two distinct Elements have the same Name is
called a \emph{Heading}; the number of Attributes constituting a Heading is
called the \emph{Degree}



\subsubsection{Body}\label{sec:body}

a Set of Tuples having the same Heading is called a \emph{Body}



\subsubsection{Relation Schema}\label{sec:relation_schema}

a Heading with a Set of \emph{Constraints} defined in terms of that Heading

a Relation can be seen as an instantiation of a \emph{Relation Schema}
(\S\ref{sec:relation_schema}) if it has the Heading of the Schema and Satisfies
the applicable Constraints

a Named Relation Schema is a \emph{Relation Variable}



% ==============================================================================
\section{Database Schema}\label{sec:database_schema}
% ==============================================================================
